"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[22597],{603905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(667294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(a),k=o,m=h["".concat(l,".").concat(k)]||h[k]||d[k]||i;return a?n.createElement(m,r(r({ref:t},p),{},{components:a})):n.createElement(m,r({ref:t},p))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=k;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},729142:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(487462),o=(a(667294),a(603905));const i={},r="WebSockets",s={unversionedId:"networking/protocols/websockets",id:"networking/protocols/websockets",title:"WebSockets",description:"WebSocketis a computer communications protocol, providing full-duplex communication channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011, and the WebSocket API in Web IDL is being standardized by the W3C.",source:"@site/docs/networking/protocols/websockets.md",sourceDirName:"networking/protocols",slug:"/networking/protocols/websockets",permalink:"/networking/protocols/websockets",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/networking/protocols/websockets.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Weave",permalink:"/networking/protocols/weave"},next:{title:"ZeroMQ: Distributed Messaging",permalink:"/networking/protocols/zeromq-distributed-messaging"}},l={},c=[{value:"Will WebSocket survive HTTP/2?",id:"will-websocket-survive-http2",level:2},{value:"Takeaways",id:"takeaways",level:2},{value:"socketio / socket.io",id:"socketio--socketio",level:2},{value:"Websocket vs socketio",id:"websocket-vs-socketio",level:2},{value:"Django Channels",id:"django-channels",level:2}],p={toc:c},h="wrapper";function d(e){let{components:t,...a}=e;return(0,o.kt)(h,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"websockets"},"WebSockets"),(0,o.kt)("p",null,"WebSocketis a computer ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Communications_protocol"},"communications protocol"),", providing ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Full-duplex"},"full-duplex")," communication channels over a single ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Transmission_Control_Protocol"},"TCP")," connection. The WebSocket protocol was standardized by the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force"},"IETF")," as ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Request_for_Comments"},"RFC")," 6455 in 2011, and the WebSocket ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Application_programming_interface"},"API")," in ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Web_IDL"},"Web IDL")," is being standardized by the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/World_Wide_Web_Consortium"},"W3C"),".\nWebSocket is distinct from HTTP. Both protocols are located at layer 7 in the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/OSI_model"},"OSI model")," and depend on TCP at layer 4. Although they are different, ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc6455"},"RFC 6455"),' states that WebSocket "is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries," thus making it compatible with the HTTP protocol. To achieve compatibility, the ',(0,o.kt)("strong",{parentName:"p"},"WebSocket ",(0,o.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Handshaking"},"handshake")," uses the ",(0,o.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header"},"HTTP Upgrade header")," to change from the HTTP protocol to the WebSocket protocol."),"\nThe WebSocket protocol enables interaction between a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Web_browser"},"web browser"),"(or other client application) and a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Web_server"},"web server")," with lower overhead than half-duplex alternatives such as HTTP polling, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open. In this way, a two-way ongoing conversation can take place between the client and the server. The communications are done over TCP ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Port_(computer_networking)"},"port")," number 80 (or 443 in the case of ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Transport_Layer_Security"},"TLS"),"-encrypted connections), which is of benefit for those environments which block non-web Internet connections using a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Firewall_(computing)"},"firewall"),". Similar two-way browser-server communications have been achieved in non-standardized ways using stopgap technologies such as ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Comet_(programming)"},"Comet"),".\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/WebSocket"},"https://en.wikipedia.org/wiki/WebSocket"),"\nWebsockets are full bidirectional connection between hosts (once user is connected to the server, both client and server can initiate the request) (Also have sticky session, i.e. if one request from user gets to a server than all the further messages will be transfered via same server)\nWebSockets are typically used to make web applications more interactive. They can be helpful when implementing social feeds, online chats, news updates, or location-based apps.\nThe WebSocket protocol is a rather low-level protocol. It defines how a stream of bytes is transformed into frames. A frame may contain a text or a binary message. Because the message itself does not provide any additional information on how to route or process it, It is difficult to implement more complex applications without writing additional code. Fortunately, the WebSocket specification allows using of sub-protocols that operate on a higher, application level. One of them, supported by the Spring Framework, is STOMP.\n",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=2Nt-ZrNP22A"},"WebSockets Crash Course")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=1BfCnjr_Vjg&ab_channel=Fireship"},"WebSockets in 100 Seconds & Beyond with Socket.io")),(0,o.kt)("h2",{id:"will-websocket-survive-http2"},"Will WebSocket survive HTTP/2?"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null},"HTTP/2"),(0,o.kt)("th",{parentName:"tr",align:null},"WebSocket"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Headers"),(0,o.kt)("td",{parentName:"tr",align:null},"Compressed (HPACK)"),(0,o.kt)("td",{parentName:"tr",align:null},"None")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Binary"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"Binary or Textual")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Multiplexing"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Prioritization"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"No")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Compression"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Direction"),(0,o.kt)("td",{parentName:"tr",align:null},"Client/Server + Server Push"),(0,o.kt)("td",{parentName:"tr",align:null},"Bidirectional")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Full-duplex"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes")))),(0,o.kt)("p",null,"As we have seen above, HTTP/2 introduces ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Push_technology?oldformat=true"},"Server Push"),' which enables the server to proactively send resources to the client cache. It does not, however, allow for pushing data down to the client application itself. Server pushes are only processed by the browser and do not pop up to the application code, meaning there is no API for the application to get notifications for those events.\nThis is where Server-Sent Events (SSE) becomes very useful. SSE is a mechanism that allows the server to asynchronously push the data to the client once the client-server connection is established. The server can then decide to send data whenever a new "chunk" of data is available. It can be considered as a one-way publish-subscribe model. It also offers a standard JavaScript client API named EventSource implemented in most modern browser as part of HTML5 standard by ',(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/eventsource/"},"W3C"),". Note that browsers that do not support ",(0,o.kt)("a",{parentName:"p",href:"http://caniuse.com/#feat=eventsource"},"EventSource API")," can be easily polyfilled.\nSince SSE is based on HTTP, it has a natural fit with HTTP/2 and can be combined to get the best of both: HTTP/2 handling an efficient transport layer based on multiplexed streams and SSE providing the API up to the applications to enable push.\nNow that we have understood what multiplexing is all about, we have to remember that SSE is HTTP based. It means that with HTTP/2, not only can several SSE streams be interleaved onto a single TCP connection, but also several SSE streams (server to client push) with several client requests (client to server). Thanks to HTTP/2 and SSE, we now have a pure HTTP bidirectional connection with a simple API to let application code register to server pushes. Lack of bidirectional capabilities have often been perceived as a major drawback when comparing SSE to WebSocket. Thanks to HTTP/2 is it no longer the case. This opens up the opportunity to skip WebSockets and stick to a HTTP based signaling.\nTo provide some answers to the initial question:Will WebSocket survive HTTP/2?"),(0,o.kt)("p",null,"It certainly will, mainly because it is already well adopted and, in very specific use cases, it has an advantage as it has been built from the ground up for bidirectional capabilities with less overhead (headers). Let's say that you need to exchange a high throughput of messages from both ends, with almost as much data flow upstream than downstream (e.g Massively Multiplayer Online Game that needs to keep all their players in sync). WebSocket will probably remain a better choice.\nIf you consider a use case like displaying real-time market news, market data, chat application, etc, relying on HTTP/2 + SSE will provide you an efficient bidirectional communication channel and keep the huge advantage of staying in the HTTP world:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"WebSocket can often be a source of pain when considering compatibility with existing web infrastructure as it upgrades an HTTP connection to a completely different protocol that has nothing to do with HTTP."),(0,o.kt)("li",{parentName:"ul"},"Scale and security: Web components (Firewalls, Intrusion Detection, Load Balancers) are built, maintained and configured with HTTP in mind, an environment that large/critical applications will prefer in terms of resiliency, security and scalability.")),(0,o.kt)("h2",{id:"takeaways"},"Takeaways"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"HTTP/2 is not a full replacement of HTTP."),(0,o.kt)("li",{parentName:"ul"},"Hacks such as Domain sharding, resource inlining and image spriting will be counter-productive in an HTTP/2 world."),(0,o.kt)("li",{parentName:"ul"},"HTTP/2 is not a replacement for push technologies such as WebSocket or SSE."),(0,o.kt)("li",{parentName:"ul"},"HTTP/2 Push server can only be processed by browsers, not by applications."),(0,o.kt)("li",{parentName:"ul"},"Combining HTTP/2 and SSE provides efficient HTTP-based bidirectional communication.\nWebSocket will probably remain used but SSE and its EventSource API combined with the power of HTTP/2 will provide the same result in most use cases, just simpler.\n",(0,o.kt)("a",{parentName:"li",href:"https://www.infoq.com/articles/websocket-and-http2-coexist"},"https://www.infoq.com/articles/websocket-and-http2-coexist"),(0,o.kt)("a",{parentName:"li",href:"https://sookocheff.com/post/networking/how-do-websockets-work"},"https://sookocheff.com/post/networking/how-do-websockets-work"))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://ably.com/topic/websockets"},"https://ably.com/topic/websockets")),(0,o.kt)("h2",{id:"socketio--socketio"},"socketio / socket.io"),(0,o.kt)("p",null,"Bidirectional and low-latency communication for every platform"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/socketio/socket.io"},"https://github.com/socketio/socket.io")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://socket.io"},"https://socket.io")),(0,o.kt)("h2",{id:"websocket-vs-socketio"},"Websocket vs socketio"),(0,o.kt)("p",null,"Socketio advantages are that it simplifies the usage of WebSockets, and probably more importantly it provides fail-overs to other protocols in the event that WebSockets are not supported on the browser or server.\n",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/10112178/differences-between-socket-io-and-websockets"},"https://stackoverflow.com/questions/10112178/differences-between-socket-io-and-websockets")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://davidwalsh.name/websocket"},"https://davidwalsh.name/websocket")),(0,o.kt)("h2",{id:"django-channels"},"Django Channels"))}d.isMDXComponent=!0}}]);