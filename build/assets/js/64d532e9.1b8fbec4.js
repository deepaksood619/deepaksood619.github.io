"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4858],{603905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(667294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),g=o,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||a;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},822495:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(487462),o=(r(667294),r(603905));const a={},i="Tasks",s={unversionedId:"devops/kubernetes/tasks",id:"devops/kubernetes/tasks",title:"Tasks",description:"Monitoring, Logging and Debugging",source:"@site/docs/devops/kubernetes/tasks.md",sourceDirName:"devops/kubernetes",slug:"/devops/kubernetes/tasks",permalink:"/devops/kubernetes/tasks",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/devops/kubernetes/tasks.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Storage",permalink:"/devops/kubernetes/storage"},next:{title:"Tools",permalink:"/devops/kubernetes/tools"}},l={},p=[{value:"Monitoring, Logging and Debugging",id:"monitoring-logging-and-debugging",level:2},{value:"Auditing",id:"auditing",level:2},{value:"Administer a Cluster",id:"administer-a-cluster",level:2},{value:"Horizontal Pod Autoscaler (HPA)",id:"horizontal-pod-autoscaler-hpa",level:2},{value:"PLEG - Pod Lifecycle Event Generator",id:"pleg---pod-lifecycle-event-generator",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...a}=e;return(0,o.kt)(u,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"tasks"},"Tasks"),(0,o.kt)("h2",{id:"monitoring-logging-and-debugging"},"Monitoring, Logging and Debugging"),(0,o.kt)("h2",{id:"auditing"},"Auditing"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/debug-application-cluster/audit"},"https://kubernetes.io/docs/tasks/debug-application-cluster/audit")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.cncf.io/blog/2019/12/03/kubernetes-audit-making-log-auditing-a-viable-practice-again"},"https://www.cncf.io/blog/2019/12/03/kubernetes-audit-making-log-auditing-a-viable-practice-again")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.cncf.io/webinars/k8s-audit-logging-deep-dive"},"https://www.cncf.io/webinars/k8s-audit-logging-deep-dive")),(0,o.kt)("h2",{id:"administer-a-cluster"},"Administer a Cluster"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/administer-cluster/kms-provider"},"https://kubernetes.io/docs/tasks/administer-cluster/kms-provider")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data"},"https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data")),(0,o.kt)("h2",{id:"horizontal-pod-autoscaler-hpa"},"Horizontal Pod Autoscaler (HPA)"),(0,o.kt)("p",null,"The Horizontal Pod Autoscaler automatically scales the number of pods in a replication controller, deployment, replica set or stateful set based on observed CPU utilization (or, with",(0,o.kt)("a",{parentName:"p",href:"https://git.k8s.io/community/contributors/design-proposals/instrumentation/custom-metrics-api"},"custom metrics")," support, on some other application-provided metrics). Note that Horizontal Pod Autoscaling does not apply to objects that can't be scaled, for example, DaemonSets."),(0,o.kt)("p",null,"The Horizontal Pod Autoscaler is implemented as a Kubernetes API resource and a controller. The resource determines the behavior of the controller. The controller periodically adjusts the number of replicas in a replication controller or deployment to match the observed average CPU utilization to the target specified by user."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:r(611328).Z,width:"822",height:"742"})),(0,o.kt)("p",null,"The Horizontal Pod Autoscaler is implemented as a control loop, with a period controlled by the controller manager's--horizontal-pod-autoscaler-sync-periodflag (with a default value of 15 seconds)."),(0,o.kt)("p",null,"When managing the scale of a group of replicas using the Horizontal Pod Autoscaler, it is possible that the number of replicas keeps fluctuating frequently due to the dynamic nature of the metrics evaluated. This is sometimes referred to as ",(0,o.kt)("em",{parentName:"p"},"thrashing"),"."),(0,o.kt)("p",null,"desiredReplicas = ceil","[currentReplicas * ( currentMetricValue / desiredMetricValue )]"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale"},"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale")),(0,o.kt)("h2",{id:"pleg---pod-lifecycle-event-generator"},"PLEG - Pod Lifecycle Event Generator"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://developers.redhat.com/blog/2019/11/13/pod-lifecycle-event-generator-understanding-the-pleg-is-not-healthy-issue-in-kubernetes"},"https://developers.redhat.com/blog/2019/11/13/pod-lifecycle-event-generator-understanding-the-pleg-is-not-healthy-issue-in-kubernetes")))}d.isMDXComponent=!0},611328:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/DevOps-Kubernetes-Tasks-image1-98dbee72b84f7e251d4d6dfac82a3d55.jpg"}}]);