"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[26349],{603905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var a=r(667294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=l(r),h=n,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||s;return r?a.createElement(m,i(i({ref:t},u),{},{components:r})):a.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,i=new Array(s);i[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[p]="string"==typeof e?e:n,i[1]=o;for(var l=2;l<s;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},63094:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=r(487462),n=(r(667294),r(603905));const s={},i="Skip Lists",o={unversionedId:"data-structures/linear-data-structure/skip-lists",id:"data-structures/linear-data-structure/skip-lists",title:"Skip Lists",description:"In computer science, a**skip list** is a data structure that allows fast searchwithin an ordered sequence of elements. Fast search is made possible by maintaining a linked hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one (see the picture below on the right). Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for. Via the linked hierarchy, these two elements link to elements of the next sparsest subsequence, where searching is continued until finally we are searching in the full sequence. The elements that are skipped over may be chosen probabilisticallyor deterministically, with the former being more common.",source:"@site/docs/data-structures/linear-data-structure/skip-lists.md",sourceDirName:"data-structures/linear-data-structure",slug:"/data-structures/linear-data-structure/skip-lists",permalink:"/data-structures/linear-data-structure/skip-lists",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/linear-data-structure/skip-lists.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sets",permalink:"/data-structures/linear-data-structure/sets"},next:{title:"Stack LIFO",permalink:"/data-structures/linear-data-structure/stack-lifo"}},c={},l=[],u={toc:l},p="wrapper";function d(e){let{components:t,...s}=e;return(0,n.kt)(p,(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"skip-lists"},"Skip Lists"),(0,n.kt)("p",null,"In ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_science"},"computer science"),", a",(0,n.kt)("strong",{parentName:"p"},"skip list")," is a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_structure"},"data structure")," that allows fast searchwithin an ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ordered_sequence"},"ordered sequence")," of elements. Fast search is made possible by maintaining a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linked_list"},"linked")," hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one (see the picture below on the right). Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for. Via the linked hierarchy, these two elements link to elements of the next sparsest subsequence, where searching is continued until finally we are searching in the full sequence. The elements that are skipped over may be chosen probabilisticallyor deterministically, with the former being more common.\n",(0,n.kt)("img",{alt:"image",src:r(292288).Z,width:"1224",height:"1584"})),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"image",src:r(878770).Z,width:"1224",height:"1584"})),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"image",src:r(670471).Z,width:"1224",height:"1584"})))}d.isMDXComponent=!0},292288:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/Skip-Lists-image1-6061e84631a1317dc84ab88aca77a1bb.jpg"},878770:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/Skip-Lists-image2-76a81f385e4028479ef2f190f60100ed.jpg"},670471:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/Skip-Lists-image3-10b18d3786cc5902b21fa66ec372747f.jpg"}}]);