"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[37082],{603905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var n=a(667294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),h=r,k=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return a?n.createElement(k,s(s({ref:t},p),{},{components:a})):n.createElement(k,s({ref:t},p))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},846275:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(487462),r=(a(667294),a(603905));const i={},s="Services, LoadBalancing and Networking",o={unversionedId:"devops/kubernetes/services-loadbalancing-and-networking/readme",id:"devops/kubernetes/services-loadbalancing-and-networking/readme",title:"Services, LoadBalancing and Networking",description:"1. Services",source:"@site/docs/devops/kubernetes/services-loadbalancing-and-networking/readme.md",sourceDirName:"devops/kubernetes/services-loadbalancing-and-networking",slug:"/devops/kubernetes/services-loadbalancing-and-networking/",permalink:"/devops/kubernetes/services-loadbalancing-and-networking/",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/devops/kubernetes/services-loadbalancing-and-networking/readme.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"RBAC",permalink:"/devops/kubernetes/reference/rbac"},next:{title:"Ingress",permalink:"/devops/kubernetes/services-loadbalancing-and-networking/ingress"}},l={},c=[{value:"Kubernetes Networking",id:"kubernetes-networking",level:2},{value:"Pod Network Architecture",id:"pod-network-architecture",level:2},{value:"Kubernetes Network Architecture",id:"kubernetes-network-architecture",level:2},{value:"Netfilter",id:"netfilter",level:2},{value:"Kubernetes Service Discovery",id:"kubernetes-service-discovery",level:2},{value:"Service registration",id:"service-registration",level:2},{value:"Service Discovery",id:"service-discovery",level:2},{value:"Summary",id:"summary",level:2},{value:"Others",id:"others",level:2},{value:"Source ip preservation in loadbalancer",id:"source-ip-preservation-in-loadbalancer",level:2},{value:"Kube-proxy",id:"kube-proxy",level:2},{value:"ip tables",id:"ip-tables",level:2},{value:"References",id:"references",level:2},{value:"CNI",id:"cni",level:2},{value:"Calico",id:"calico",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"services-loadbalancing-and-networking"},"Services, LoadBalancing and Networking"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Services")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"DNS for Services and Pods")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Connecting Applications with Services")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Ingress")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Network Policies")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Adding entries to Pod /etc/hosts with HostAliases"))),(0,r.kt)("h2",{id:"kubernetes-networking"},"Kubernetes Networking"),(0,r.kt)("p",null,"Pods - share a network stack"),(0,r.kt)("p",null,"it means that all the containers in a pod can reach each other on localhost."),(0,r.kt)("h2",{id:"pod-network-architecture"},"Pod Network Architecture"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(504808).Z,width:"1100",height:"877"})),(0,r.kt)("h2",{id:"kubernetes-network-architecture"},"Kubernetes Network Architecture"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(463296).Z,width:"1100",height:"877"})),(0,r.kt)("p",null,"cbr - custom bridge"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(318097).Z,width:"1100",height:"859"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(465493).Z,width:"1192",height:"944"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(384366).Z,width:"1201",height:"897"})),(0,r.kt)("h2",{id:"netfilter"},"Netfilter"),(0,r.kt)("p",null,"Netfilter is a rules-based packet processing engine. It runs in kernel space and gets a look at every packet at various points in its life cycle. It matches packets against rules and when it finds a rule that matches it takes the specified action. Among the many actions it can take is redirecting the packet to another destination. That's right, netfilter is a kernel space proxy."),(0,r.kt)("h2",{id:"kubernetes-service-discovery"},"Kubernetes Service Discovery"),(0,r.kt)("p",null,"There's two major operations that relate to service discovery:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"service registration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"service discovery"))),(0,r.kt)("h2",{id:"service-registration"},"Service registration"),(0,r.kt)("p",null,"Service registrationis the process of registering a service in aservice registryso that other services can discover it."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(433764).Z,width:"1280",height:"558"})),(0,r.kt)("p",null,"Kubernetes uses DNS for theservice registry."),(0,r.kt)("p",null,'To enable this, every Kubernetes cluster operates a well-knowninternal DNS servicethat runs as a set of Pods in thekube-systemNamespace. We usually call this the "cluster DNS".'),(0,r.kt)("p",null,"Every Kubernetes Service isautomatically registeredwith the cluster DNS."),(0,r.kt)("p",null,"The registration process looks like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You POST a new Service definition to the API Server")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The request is authenticated, authorized, and subjected to admission policies")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Service is allocated aClusterIP(virtual IP address) and persisted to the cluster store")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Service configuration is disseminated across the cluster (more on this later)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The cluster's DNS service notices the new Service and creates the necessaryDNS A records"))),(0,r.kt)("p",null,"Step 5 is the secret sauce in this process. Thecluster DNSservice is based on ",(0,r.kt)("a",{parentName:"p",href:"https://coredns.io/"},"CoreDNS")," and runs as aKubernetes-native application. This means that it knows it's running on Kubernetes and implements acontrollerthat watches the API Server for new Service objects. Any time it sees a new Service object, it creates the DNS records that allow the Service name to be resolved to its ClusterIP. This means that Services don't have to care about the process of registering with DNS, the CoreDNS controller watches for new Service objects and makes the DNS magic happen."),(0,r.kt)("p",null,"It's important to understand that the name registered with DNS is the value ofmetadata.nameand that the ClusterIP is dynamically assigned by Kubernetes."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(664817).Z,width:"1280",height:"383"})),(0,r.kt)("p",null,"Once a Service is registered with the cluster's DNS it can bediscoveredby other Pods running on the cluster..."),(0,r.kt)("h2",{id:"service-discovery"},"Service Discovery"),(0,r.kt)("p",null,"Forservice discoveryto work, every Pod needs to know know the location of the cluster DNS and use it. To make this work, every container in every Pod has its/etc/resolv.conffile configured to use the cluster DNS."),(0,r.kt)("p",null,"Every Kubernetes node runs a system service calledkube-proxy. This is a Pod-based Kubernetes native app that implements acontrollerthatwatches the API Serverfor new Service objects and creates localiptables, orIPVS, rules that tell the Node to trap on packets destined for theservice networkand forward them to individual Pod IPs."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Interestingly, kube-proxy is not a proxy in the normal sense of the term. All it does is create and manage iptables/IPVS rules. The name comes from the fact it used to run with a userspace proxy.")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"When a newServiceis created it is allocated a virtual IP address called aClusterIP. This is automatically registered against the name of the Service in the cluster's internal DNS and relevant Endpoints objects (or Endpoints slices) are created to hold the list of healthy Pods with that the Service will load-balance to."),(0,r.kt)("p",null,"At the same time, all Nodes in the cluster are configured with the iptables/IPVS rules that listen for traffic to this ClusterIP and redirect it to real Pod IPs. The is summarised in the image below, though the ordering of some events might be slightly different.."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(660025).Z,width:"1280",height:"350"})),(0,r.kt)("p",null,"When a Pod needs to connect to another Pod, it does this via a Service. It sends a query to the cluster DNS to resolve the name of the Service to its ClusterIP and then send traffic to the ClusterIP. This ClusterIP is on a special network called theService network.However, there are no routes to theService network, so the Pod sends traffic to its default gateway. This gets forwarded to an interface on the Node the Pod is running, and eventually the default gateway of the Node. As part of this operation, the Node's kernel traps on the address and rewrites the destination IP field in the packet header so that it now goes to the IP of a healthy Pod."),(0,r.kt)("p",null,"This is summarised in the image below."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(113853).Z,width:"1280",height:"525"})),(0,r.kt)("p",null,"Last but not least... all Pods are on the same flat overlay network and routes exist to this network and the rest is simple."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery"},"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery")),(0,r.kt)("h2",{id:"others"},"Others"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kubernetes performsIP address management(",(0,r.kt)("strong",{parentName:"li"},"IPAM"),") to keep track of used and free IP addresses on the Pod network.")),(0,r.kt)("h2",{id:"source-ip-preservation-in-loadbalancer"},"Source ip preservation in loadbalancer"),(0,r.kt)("p",null,'kubectl patch svc flask-republisher -n testing -p \'{"spec":{"externalTrafficPolicy":"Local"}}\''),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tutorials/services/source-ip"},"https://kubernetes.io/docs/tutorials/services/source-ip")),(0,r.kt)("h2",{id:"kube-proxy"},"Kube-proxy"),(0,r.kt)("p",null,"Kube-proxy is a go application which can work in three modes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"userspace"))),(0,r.kt)("p",null,"In this mode, Kube-proxy installs iptables rules which capture traffic to a Service's ClusterIP and redirects that traffic to Kube-proxy's listening port. Kube-proxy then chooses a backend Pod and forwards the request to it."),(0,r.kt)("p",null,"kube-proxy serves as an OSI layer 4 load balancer in this model. Since Kube-proxy runs in the userspace, packages need to be copied back and forth between kernelspace and userspace, adding extra latency in the proxy process. The advantage is that Kube-proxy can retry other Pod if the first Pod is not available."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(289855).Z,width:"1102",height:"621"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"iptables"))),(0,r.kt)("p",null,"To avoid the additional copies between kernelspace and userspace, Kube-proxy can work on iptables mode. Kube-proxy creates an iptables rule for each of the backend Pods in the Service. After catching the traffic sent to the ClusterIP, iptables forwards that traffic directly to one of the backend Pod using DNAT. In this mode, Kube-proxy no longer serves as the OSI layer 4 proxy. It only creates corresponding iptables rules. Without switching between kernelspace and userspace, the proxy process is more efficient."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(979929).Z,width:"1100",height:"824"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ipvs"))),(0,r.kt)("p",null,"This model is similar to iptables because both ipvs and iptables are base on netfilter hook in kernelspace. Ipvs uses hash tables to store rules, meaning it's faster than iptables, especially in a large cluster where there're thousands of services. In addition, ipvs supports more load balancing algorithms."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(532563).Z,width:"1101",height:"774"})),(0,r.kt)("h2",{id:"ip-tables"},"ip tables"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.google.com/drawings/d/1MtWL8qRTs6PlnJrW4dh8135_S9e2SaawT410bJuoBPk/edit"},"https://docs.google.com/drawings/d/1MtWL8qRTs6PlnJrW4dh8135_S9e2SaawT410bJuoBPk/edit")),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727"},"https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/google-cloud/understanding-kubernetes-networking-services-f0cb48e4cc82"},"https://medium.com/google-cloud/understanding-kubernetes-networking-services-f0cb48e4cc82")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/google-cloud/understanding-kubernetes-networking-ingress-1bc341c84078"},"https://medium.com/google-cloud/understanding-kubernetes-networking-ingress-1bc341c84078")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model"},"https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=0Omvgd7Hg1I"},"https://www.youtube.com/watch?v=0Omvgd7Hg1I")),(0,r.kt)("h2",{id:"cni"},"CNI"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/containernetworking/cni"},"Container Network Interface"),"(CNI) is an API specification that is focused around the creation and connection of container workloads."),(0,r.kt)("p",null,"CNI has two main commands: add and delete. Configuration is passed in as JSON data."),(0,r.kt)("p",null,"When the CNI plugin is added, a virtual ethernet device pair is created and then connected between the Pod network namespace and the Host network namespace. Once IPs and routes are created and assigned, the information is returned to the Kubernetes API server."),(0,r.kt)("p",null,"An important feature that was added in later versions is the ability to chain CNI plugins."),(0,r.kt)("h2",{id:"calico"},"Calico"),(0,r.kt)("p",null,"Calico is an open source networking and network security solution for containers, virtual machines, and native host-based workloads. Calico supports a broad range of platforms including Kubernetes, OpenShift, Docker EE, OpenStack, and bare metal services."),(0,r.kt)("p",null,"Calico combines flexible networking capabilities with run-anywhere security enforcement to provide a solution with native Linux kernel performance and true cloud-native scalability. Calico provides developers and cluster operators with a consistent experience and set of capabilities whether running in public cloud or on-prem, on a single node or across a multi-thousand node cluster."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.projectcalico.org/v3.11/introduction"},"https://docs.projectcalico.org/v3.11/introduction")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/projectcalico/calico"},"https://github.com/projectcalico/calico")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.projectcalico.org"},"https://www.projectcalico.org")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://eksworkshop.com/beginner/120_network-policies/calico"},"https://eksworkshop.com/beginner/120_network-policies/calico")),(0,r.kt)("p",null,"Calico with Canal"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/canal"},"https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/canal")),(0,r.kt)("p",null,"Weave Works"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.weave.works/docs/net/latest/kubernetes/kube-addon"},"https://www.weave.works/docs/net/latest/kubernetes/kube-addon")),(0,r.kt)("p",null,"Flannel"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/coreos/flannel"},"https://github.com/coreos/flannel")),(0,r.kt)("p",null,"Romana"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"http://romana.io/how/romana_basics"},"http://romana.io/how/romana_basics")),(0,r.kt)("p",null,"Kube Router"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.kube-router.io"},"https://www.kube-router.io")),(0,r.kt)("p",null,"Kopeio"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/kopeio/networking"},"https://github.com/kopeio/networking")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Which of the plugins allow vxlans?")),(0,r.kt)("p",null,"Canal, Project Calico, Flannel, Kopeio-networking, Weave Net"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Which are layer 2 plugins?")),(0,r.kt)("p",null,"Canal, Flannel, Kopeio-networking, Weave Net"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Which are layer 3?")),(0,r.kt)("p",null,"Project Calico, Romana, Kube Router"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Which allow network policies?")),(0,r.kt)("p",null,"Project Calico, Canal, Kube Router, Romana Weave Net"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Which can encrypt all TCP and UDP traffic?")),(0,r.kt)("p",null,"Project Calico, Kopeio, Weave Net"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/containernetworking/cni"},"https://github.com/containernetworking/cni")))}u.isMDXComponent=!0},504808:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image1-675569b35557506999b6b612195783d7.jpg"},289855:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image10-10b3a9af5c4febc86d62211c36178eb2.jpg"},979929:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image11-41da263b5da1df742dc29e8de0861dee.jpg"},532563:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image12-e560b70f3b79adc83c76660d12f4ab99.jpg"},463296:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image2-35c32a6e75cbfd743c96f6221c06f0ac.jpg"},318097:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image3-93fe5aaf65e98c4560c4ed9f27ad43af.jpg"},465493:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image4-4c9e2cc5768e326044c329d5b0d8afdf.jpg"},384366:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image5-aa19cb0ad0e702259151128604a50f17.jpg"},433764:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image6-1f75cad10bc2200e52cc95de60911bbb.jpg"},664817:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image7-a3645bffe86c526f4d764c4971aeb82e.jpg"},660025:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image8-cc8159382139542c224c3ae90e9aec2c.jpg"},113853:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DevOps-Kubernetes-Services-LoadBalancing-and-Networking-image9-8f4a72e6de95be352b442694cd30ecbf.jpg"}}]);