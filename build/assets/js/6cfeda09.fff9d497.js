"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[13174],{603905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(667294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),f=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=f(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=f(r),d=a,m=p["".concat(l,".").concat(d)]||p[d]||c[d]||i;return r?n.createElement(m,o(o({ref:t},u),{},{components:r})):n.createElement(m,o({ref:t},u))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var f=2;f<i;f++)o[f]=r[f];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},820274:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>f});var n=r(487462),a=(r(667294),r(603905));const i={},o="Suffix Tree",s={unversionedId:"data-structures/trie/suffix-tree",id:"data-structures/trie/suffix-tree",title:"Suffix Tree",description:"In computer science, a suffix tree (also called PAT tree or, in an earlier form, position tree) is a compressed trie containing all the suffixes) of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.",source:"@site/docs/data-structures/trie/suffix-tree.md",sourceDirName:"data-structures/trie",slug:"/data-structures/trie/suffix-tree",permalink:"/data-structures/trie/suffix-tree",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/trie/suffix-tree.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Suffix Array",permalink:"/data-structures/trie/suffix-array"},next:{title:"Ternary Search Tries (TST)",permalink:"/data-structures/trie/ternary-search-tries-tst"}},l={},f=[{value:"Generalized Suffix Tree",id:"generalized-suffix-tree",level:2},{value:"How to build a Suffix Tree for a given text?",id:"how-to-build-a-suffix-tree-for-a-given-text",level:2},{value:"Suffix Tree and Its Construction",id:"suffix-tree-and-its-construction",level:2},{value:"Advanced",id:"advanced",level:2}],u={toc:f},p="wrapper";function c(e){let{components:t,...i}=e;return(0,a.kt)(p,(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"suffix-tree"},"Suffix Tree"),(0,a.kt)("p",null,"In ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_science"},"computer science"),", a suffix tree (also called PAT tree or, in an earlier form, position tree) is a compressed ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Trie"},"trie")," containing all the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Suffix_(computer_science)"},"suffixes")," of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations."),(0,a.kt)("p",null,"The construction of such a tree for the string S takes time and space linear in the length of S. Once constructed, several operations can be performed quickly, for instance locating a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Substring"},"substring")," in S, locating a substring if a certain number of mistakes are allowed, locating matches for a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Regular_expression"},"regular expression")," pattern etc. Suffix trees also provide one of the first linear-time solutions for the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Longest_common_substring_problem"},"longest common substring problem"),". These speedups come at a cost: storing a string's suffix tree typically requires significantly more space than storing the string itself."),(0,a.kt)("p",null,"The suffix tree for the string S of length n is defined as a tree such that:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The tree has exactly n leaves numbered from 1 to n."),(0,a.kt)("li",{parentName:"ul"},"Except for the root, every ",(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology"},"internal node")," has at least two children."),(0,a.kt)("li",{parentName:"ul"},"Each edge is labelled with a non-empty substring of S."),(0,a.kt)("li",{parentName:"ul"},"No two edges starting out of a node can have string-labels beginning with the same character."),(0,a.kt)("li",{parentName:"ul"},"The string obtained by concatenating all the string-labels found on the path from the root to leaf i spells out suffix S ","[i..n]",", for i from 1 to n.")),(0,a.kt)("p",null,"Since such a tree does not exist for all strings, S is padded with a terminal symbol not seen in the string (usually denoted $). This ensures that no suffix is a prefix of another, and that there will be n leaf nodes, one for each of the n suffixes of S. Since all internal non-root nodes are branching, there can be at most ",(0,a.kt)("em",{parentName:"p"},"n"),"\u2212 1 such nodes, and ",(0,a.kt)("em",{parentName:"p"},"n"),"+(",(0,a.kt)("em",{parentName:"p"},"n"),"\u22121)+1=2",(0,a.kt)("em",{parentName:"p"},"n")," nodes in total (",(0,a.kt)("em",{parentName:"p"},"n")," leaves, ",(0,a.kt)("em",{parentName:"p"},"n"),"\u22121 internal non-root nodes, 1 root)."),(0,a.kt)("h2",{id:"generalized-suffix-tree"},"Generalized Suffix Tree"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Generalized_suffix_tree"},"generalized suffix tree")," is a suffix tree made for a set of words instead of a single word. It represents all suffixes from this set of words. Each word must be terminated by a different termination symbol or word."),(0,a.kt)("h2",{id:"how-to-build-a-suffix-tree-for-a-given-text"},"How to build a Suffix Tree for a given text?"),(0,a.kt)("p",null,"As discussed above, ",(0,a.kt)("strong",{parentName:"p"},"Suffix Tree is compressed trie of all suffixes"),", so following are very abstract steps to build a suffix tree from given text."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Generate all suffixes of given text."),(0,a.kt)("li",{parentName:"ul"},"Consider all suffixes as individual words and build a compressed trie.")),(0,a.kt)("p",null,'Let us consider an example text "banana0" where \'0\' is string termination character. Following are all suffixes of "banana0"'),(0,a.kt)("p",null,"banana0\nanana0\nnana0\nana0\nna0\na0\n0"),(0,a.kt)("p",null,"If we consider all of the above suffixes as individual words and build a trie, we get following."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image",src:r(361371).Z,width:"664",height:"603"})),(0,a.kt)("p",null,'If we join chains of single nodes, we get the following compressed trie, which is the Suffix Tree for given text "banana0"'),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image",src:r(593199).Z,width:"663",height:"363"})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image",src:r(606774).Z,width:"1315",height:"1016"})),(0,a.kt)("h2",{id:"suffix-tree-and-its-construction"},"Suffix Tree and Its Construction"),(0,a.kt)("p",null,"Suffix Tree were first introduced to solve SubString Problem -"),(0,a.kt)("p",null,"The substring problem: Pre-process text T so that the computation string matching problem is solved in time proportional to m, the length of pattern P."),(0,a.kt)("p",null,"Use Case - Performing intensive queries on a big database, which is represented by T. Once the su\ufb03x tree for T is built each query is proportional to O(m) time."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problems")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"SME - String Matching Existence problem - Given a pattern P and a text T, determine whether there is an occurance of P in T."),(0,a.kt)("li",{parentName:"ul"},"SMC - String Matching Computation problem - Given a pattern P and a text T, determine all the occurance of P in T")),(0,a.kt)("h2",{id:"advanced"},"Advanced"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Ukkonen's Linear Time Algorithm",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Implicit's Suffix Tree")))),(0,a.kt)("p",null,"An implicit su\ufb03x tree for a string S is a tree obtained from T(S$) by performing the following operations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Remove all the terminal symbols $."),(0,a.kt)("li",{parentName:"ol"},"From the resulting tree, remove all edges without label."),(0,a.kt)("li",{parentName:"ol"},"Finally, from the resulting tree, remove all nodes that do not have at least two children.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Suffix Links"),(0,a.kt)("li",{parentName:"ul"},"Extension Algorithm"),(0,a.kt)("li",{parentName:"ul"},"Edge Label Compression"),(0,a.kt)("li",{parentName:"ul"},"Phase Algorithm")))}c.isMDXComponent=!0},361371:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Suffix-Tree-image1-9376cff99223b6eb0665639cbe99f51d.jpg"},593199:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Suffix-Tree-image2-5235062143012efa7fcf6075343bc607.jpg"},606774:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Suffix-Tree-image3-2d87f15e922a9959df2894348d9980fa.jpg"}}]);