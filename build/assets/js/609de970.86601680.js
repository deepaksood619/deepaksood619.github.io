"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[52753],{603905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>d});var i=r(667294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,i,o=function(e,t){if(null==e)return{};var r,i,o={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=i.createContext({}),l=function(e){var t=i.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},c=function(e){var t=l(e.components);return i.createElement(p.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var r=e.components,o=e.mdxType,n=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=l(r),m=o,d=h["".concat(p,".").concat(m)]||h[m]||u[m]||n;return r?i.createElement(d,a(a({ref:t},c),{},{components:r})):i.createElement(d,a({ref:t},c))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=r.length,a=new Array(n);a[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[h]="string"==typeof e?e:o,a[1]=s;for(var l=2;l<n;l++)a[l]=r[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,r)}m.displayName="MDXCreateElement"},190824:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>u,frontMatter:()=>n,metadata:()=>s,toc:()=>l});var i=r(487462),o=(r(667294),r(603905));const n={},a="Concurrency Problems",s={unversionedId:"computer-science/operating-system/concurrency-problems",id:"computer-science/operating-system/concurrency-problems",title:"Concurrency Problems",description:"Problems",source:"@site/docs/computer-science/operating-system/concurrency-problems.md",sourceDirName:"computer-science/operating-system",slug:"/computer-science/operating-system/concurrency-problems",permalink:"/computer-science/operating-system/concurrency-problems",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/operating-system/concurrency-problems.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concurrency Models - Async",permalink:"/computer-science/operating-system/concurrency-models-async"},next:{title:"Concurrency / Threading",permalink:"/computer-science/operating-system/concurrency-threading"}},p={},l=[{value:"Problems",id:"problems",level:2},{value:"Producer Consumer Problem",id:"producer-consumer-problem",level:2},{value:"Reader-Writer Problem",id:"reader-writer-problem",level:2},{value:"Sleeping Barber Problem",id:"sleeping-barber-problem",level:2},{value:"Dining Philosophers Problem",id:"dining-philosophers-problem",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Solutions",id:"solutions",level:2},{value:"References",id:"references",level:2}],c={toc:l},h="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(h,(0,i.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"concurrency-problems"},"Concurrency Problems"),(0,o.kt)("h2",{id:"problems"},"Problems"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Deadlock")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Deadlock"},"deadlock"),", which occurs when many processes are waiting for a shared resource (critical section) which is being held by some other process. In this case, the processes just keep waiting and execute no further"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Distributed Deadlock"),(0,o.kt)("li",{parentName:"ul"},"Resource Starvation")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Resource_starvation"},"starvation"),", which occurs when a process is waiting to enter the critical section, but other processes monopolize the critical section, and the first process is forced to wait indefinitely;"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Priority Inversion")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Priority_inversion"},"priority inversion"),", which occurs when a high-priority process is in the critical section, and it is interrupted by a medium-priority process. This violation of priority rules can happen under certain circumstances and may lead to serious consequences in real-time systems"),(0,o.kt)("p",null,"Happened in Mars Pathfinder in 1997"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Busy Waiting")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Busy_waiting"},"busy waiting"),", which occurs when a process frequently polls to determine if it has access to a critical section. This frequent polling robs processing time from other processes."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Livelock")),(0,o.kt)("p",null,"Alivelockis similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing. Its a special case of resource starvation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Race Condition")),(0,o.kt)("p",null,"Since threads have a shared memory space, they can have access to shared variables. A race condition occurs when multiple threads try to change the same variable simultaneously. The thread scheduler can arbitrarily swap between threads, so we have no way of knowing the order in which the threads will try to change the data. This can result in incorrect behavior in either of the threads, particularly if the threads decide to do something based on the value of the variable. To prevent this from happening, a mutual exclusion (or mutex)lockcan be placed around the piece of the code that modifies the variable so that only one thread can write to the variable at a time."),(0,o.kt)("h2",{id:"producer-consumer-problem"},"Producer Consumer Problem"),(0,o.kt)("p",null,"Also known as Bounded-buffer problem is a classic example of a multi-process synchronizationproblem.\nThe problem describes two processes, the producer and the consumer, who share a common, fixed-size ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Buffer_(computer_science)"},"buffer")," used as a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Queue_(data_structure)"},"queue"),".\nThe producer's job is to generate data, put it into the buffer, and start again. At the same time, the consumer is consuming the data (i.e., removing it from the buffer), one piece at a time.\nThe problem is to make sure that the producer won't try to add data into the buffer if it's full and that the consumer won't try to remove data from an empty buffer.\nThe solution for the producer is to either go to sleep or discard data if the buffer is full. The next time the consumer removes an item from the buffer, it notifies the producer, who starts to fill the buffer again. In the same way, the consumer can go to sleep if it finds the buffer empty. The next time the producer puts data into the buffer, it wakes up the sleeping consumer. The solution can be reached by means of ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inter-process_communication"},"inter-process communication"),", typically using ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Semaphore_(programming)"},"semaphores"),". An inadequate solution could result in a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Deadlock"},"deadlock")," where both processes are waiting to be awakened. The problem can also be generalized to have multiple producers and consumers."),(0,o.kt)("h2",{id:"reader-writer-problem"},"Reader-Writer Problem"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_science"},"computer science"),", the",(0,o.kt)("strong",{parentName:"p"},"readers-writers problems"),"are examples of a common computing problem in ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Concurrency_(computer_science)"},"concurrency"),". There are at least three variations of the problems, which deal with situations in which many ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Thread_(computer_science)"},"threads")," try to access the same shared resource at one time. Some threads may read and some may write, with the constraint that no process may access the shared resource for either reading or writing while another process is in the act of writing to it. (In particular, it ",(0,o.kt)("em",{parentName:"p"},"is"),"allowed for two or more readers to access the share at the same time.) A ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Readers-writer_lock"},"readers-writer lock")," is a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_structure"},"data structure")," that solves one or more of the readers-writers problems."),(0,o.kt)("h2",{id:"sleeping-barber-problem"},"Sleeping Barber Problem"),(0,o.kt)("p",null,"The",(0,o.kt)("strong",{parentName:"p"},"sleeping barber problem"),"is a classic inter-process communication and ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Synchronization"},"synchronization")," problem between multiple ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Operating_system"},"operating system"),(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Process_(computing)"},"processes"),"."),(0,o.kt)("h2",{id:"dining-philosophers-problem"},"Dining Philosophers Problem"),(0,o.kt)("p",null,"The",(0,o.kt)("strong",{parentName:"p"},"dining philosophers problem"),"is an example problem often used in ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Concurrency_(computer_science)"},"concurrent")," algorithm design to illustrate ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Synchronization_(computer_science)"},"synchronization")," issues and techniques for resolving them."),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Five silent ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Philosopher"},"philosophers")," sit at a round table with bowls of ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Spaghetti"},"spaghetti"),". Forks are placed between each pair of adjacent philosophers."),(0,o.kt)("p",null,"Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks."),(0,o.kt)("p",null,"Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed."),(0,o.kt)("p",null,"The problem is how to design a discipline of behavior (a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Concurrency_(computer_science)"},"concurrent"),(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Algorithm"},"algorithm"),") such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think."),(0,o.kt)("h2",{id:"solutions"},"Solutions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Resource hierarchy solution"),(0,o.kt)("li",{parentName:"ul"},"Arbitrator solution (waiter / mutex)"),(0,o.kt)("li",{parentName:"ul"},"Chandy/Misra solution")),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem"},"https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem"},"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Sleeping_barber_problem"},"https://en.wikipedia.org/wiki/Sleeping_barber_problem")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cigarette_smokers_problem"},"https://en.wikipedia.org/wiki/Cigarette_smokers_problem")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dining_philosophers_problem"},"https://en.wikipedia.org/wiki/Dining_philosophers_problem")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/operating-system-dining-philosopher-problem-using-semaphores"},"https://www.geeksforgeeks.org/operating-system-dining-philosopher-problem-using-semaphores")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/dining-philosophers-solution-using-monitors"},"https://www.geeksforgeeks.org/dining-philosophers-solution-using-monitors")))}u.isMDXComponent=!0}}]);