"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53509],{603905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>p});var a=r(667294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var o=a.createContext({}),u=function(e){var t=a.useContext(o),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},c=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(r),m=n,p=d["".concat(o,".").concat(m)]||d[m]||h[m]||i;return r?a.createElement(p,l(l({ref:t},c),{},{components:r})):a.createElement(p,l({ref:t},c))}));function p(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:n,l[1]=s;for(var u=2;u<i;u++)l[u]=r[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},616626:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=r(487462),n=(r(667294),r(603905));const i={},l="Problems",s={unversionedId:"data-structures/hierarchical-data-structure/problems",id:"data-structures/hierarchical-data-structure/problems",title:"Problems",description:"Tree Traversals",source:"@site/docs/data-structures/hierarchical-data-structure/problems.md",sourceDirName:"data-structures/hierarchical-data-structure",slug:"/data-structures/hierarchical-data-structure/problems",permalink:"/data-structures/hierarchical-data-structure/problems",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/hierarchical-data-structure/problems.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Left Leaning Red-Black BSTs (LLRB tree)",permalink:"/data-structures/hierarchical-data-structure/left-leaning-red-black-bsts-llrb-tree"},next:{title:"Segment Tree",permalink:"/data-structures/hierarchical-data-structure/segment-tree"}},o={},u=[{value:"Tree Traversals",id:"tree-traversals",level:2},{value:"Interview Problems",id:"interview-problems",level:2}],c={toc:u},d="wrapper";function h(e){let{components:t,...r}=e;return(0,n.kt)(d,(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"problems"},"Problems"),(0,n.kt)("h2",{id:"tree-traversals"},"Tree Traversals"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Preorder"),(0,n.kt)("li",{parentName:"ol"},"Inorder"),(0,n.kt)("li",{parentName:"ol"},"Postorder"),(0,n.kt)("li",{parentName:"ol"},"Level order traversals")),(0,n.kt)("h2",{id:"interview-problems"},"Interview Problems"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Validate BST"),(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Do an inorder traversal of the BST. The output result must be a sorted array")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Another classic solution is to keep track of the minimum and maximum values a node can take. And at each node we will check whether its value is between the min and max values it's allowed to take. The root can take any value between negative infinity and positive infinity. At any node, its left child should be smaller than or equal than its own value, and similarly the right child should be larger than or equal to. So during recursion, we send the current value as the new max to our left child and send the min as it is without changing. And to the right child, we send the current value as the new min and send the max without changing.")))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Level Order Traversal"))),(0,n.kt)("p",null,"Use queue for pushing items in each level and printing before new items are pushed. Also can have a counter for pushing to queue before the queue had been emptied."),(0,n.kt)("ol",{start:3},(0,n.kt)("li",{parentName:"ol"},"Trim a BST")),(0,n.kt)("p",null,"We can do this by performing a post-order traversal of the tree. We first process the left children, then right children, and finally the node itself. So we form the new tree bottom up, starting from the leaves towards the root. As a result while processing the node itself, both its left and right subtrees are valid trimmed binary search trees (may be NULL as well)."),(0,n.kt)("p",null,"At each node we'll return a reference based on its value, which will then be assigned to its parent's left or right child pointer, depending on whether the current node is left or right child of the parent. If current node's value is between min and max (min<=node<=max) then there's no action need to be taken, so we return the reference to the node itself. If current node's value is less than min, then we return the reference to its right subtree, and discard the left subtree. Because if a node's value is less than min, then its left children are definitely less than min since this is a binary search tree. But its right children may or may not be less than min we can't be sure, so we return the reference to it. Since we're performing bottom-up post-order traversal, its right subtree is already a trimmed valid binary search tree (possibly NULL), and left subtree is definitely NULL because those nodes were surely less than min and they were eliminated during the post-order traversal. Remember that in post-order traversal we first process all the children of a node, and then finally the node itself."),(0,n.kt)("p",null,"Similar situation occurs when node's value is greater than max, we now return the reference to its left subtree. Because if a node's value is greater than max, then its right children are definitely greater than max. But its left children may or may not be greater than max. So we discard the right subtree and return the reference to the already valid left subtree."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"def trimBST(tree, minVal, maxVal):\n\n    if not tree:\n        return\n\n    tree.left=trimBST(tree.left, minVal, maxVal)\n    tree.right=trimBST(tree.right, minVal, maxVal)\n\n    if minVal<=tree.val<=maxVal:\n        return tree\n\n    if tree.val<minVal:\n        return tree.right\n\n    if tree.val>maxVal:\nreturn tree.left\n")))}h.isMDXComponent=!0}}]);