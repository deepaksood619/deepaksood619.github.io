"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[50379],{603905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>p});var n=t(667294);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=n.createContext({}),c=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},u=function(e){var a=c(e.components);return n.createElement(l.Provider,{value:a},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(t),h=o,p=m["".concat(l,".").concat(h)]||m[h]||d[h]||r;return t?n.createElement(p,s(s({ref:a},u),{},{components:t})):n.createElement(p,s({ref:a},u))}));function p(e,a){var t=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=h;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i[m]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=t[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},461302:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var n=t(487462),o=(t(667294),t(603905));const r={},s="Configurations / Optimizations / Best Practices",i={unversionedId:"databases/sql-databases/aws-aurora/configurations-optimizations-best-practices",id:"databases/sql-databases/aws-aurora/configurations-optimizations-best-practices",title:"Configurations / Optimizations / Best Practices",description:"Database Configuration",source:"@site/docs/databases/sql-databases/aws-aurora/configurations-optimizations-best-practices.md",sourceDirName:"databases/sql-databases/aws-aurora",slug:"/databases/sql-databases/aws-aurora/configurations-optimizations-best-practices",permalink:"/databases/sql-databases/aws-aurora/configurations-optimizations-best-practices",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/sql-databases/aws-aurora/configurations-optimizations-best-practices.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Aurora Documentation",permalink:"/databases/sql-databases/aws-aurora/aurora-documentation"},next:{title:"AWS Aurora",permalink:"/databases/sql-databases/aws-aurora/intro"}},l={},c=[{value:"Database Configuration",id:"database-configuration",level:3},{value:"Key Performance Indicators",id:"key-performance-indicators",level:3},{value:"Classifying Parameters",id:"classifying-parameters",level:3},{value:"Others",id:"others",level:2},{value:"Recommendations and impact",id:"recommendations-and-impact",level:2},{value:"autocommit",id:"autocommit",level:3},{value:"max_connections",id:"max_connections",level:3},{value:"max_allowed_packet",id:"max_allowed_packet",level:3},{value:"group_concat_max_len",id:"group_concat_max_len",level:3},{value:"innodb_ft_result_cache_limit",id:"innodb_ft_result_cache_limit",level:3},{value:"max_heap_table_size",id:"max_heap_table_size",level:3},{value:"performance_schema",id:"performance_schema",level:3},{value:"binlog_cache_size",id:"binlog_cache_size",level:3},{value:"bulk_insert_buffer_size",id:"bulk_insert_buffer_size",level:3},{value:"innodb_buffer_pool_size",id:"innodb_buffer_pool_size",level:3},{value:"innodb_sort_buffer_size",id:"innodb_sort_buffer_size",level:3},{value:"join_buffer_size",id:"join_buffer_size",level:3},{value:"key_buffer_size",id:"key_buffer_size",level:3},{value:"myisam_sort_buffer_size",id:"myisam_sort_buffer_size",level:3},{value:"Query Cache",id:"query-cache",level:3},{value:"Removed in MySQL 8.0",id:"removed-in-mysql-80",level:3},{value:"query_cache_size",id:"query_cache_size",level:3},{value:"query_cache_type",id:"query_cache_type",level:3},{value:"read_buffer_size",id:"read_buffer_size",level:3},{value:"read_rnd_buffer_size",id:"read_rnd_buffer_size",level:3},{value:"table_open_cache",id:"table_open_cache",level:3},{value:"table_definition_cache",id:"table_definition_cache",level:3},{value:"tmp_table_size",id:"tmp_table_size",level:3},{value:"Instance Types",id:"instance-types",level:3},{value:"Amazon Aurora Serverless",id:"amazon-aurora-serverless",level:2},{value:"Serverless V2",id:"serverless-v2",level:3},{value:"Important points",id:"important-points",level:2},{value:"Optimizations",id:"optimizations",level:2},{value:"DB instance RAM recommendations",id:"db-instance-ram-recommendations",level:2},{value:"Wait Events",id:"wait-events",level:2},{value:"Aurora IO Costs/Optimization",id:"aurora-io-costsoptimization",level:2},{value:"RDS Proxy",id:"rds-proxy",level:3}],u={toc:c},m="wrapper";function d(e){let{components:a,...t}=e;return(0,o.kt)(m,(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"configurations--optimizations--best-practices"},"Configurations / Optimizations / Best Practices"),(0,o.kt)("h3",{id:"database-configuration"},"Database Configuration"),(0,o.kt)("p",null,"There are two types of Aurora MySQL parameter groups: DB parameter groups and DB cluster parameter groups. Some parameters affect the configuration for an entire DB cluster, like binary log format, time zone, and character set defaults. Others limit their scope to a single DB instance."),(0,o.kt)("h3",{id:"key-performance-indicators"},"Key Performance Indicators"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"CPU utilization"),(0,o.kt)("li",{parentName:"ul"},"Number of database connections"),(0,o.kt)("li",{parentName:"ul"},"Memory utilization"),(0,o.kt)("li",{parentName:"ul"},"Cache hit rates"),(0,o.kt)("li",{parentName:"ul"},"Query throughput"),(0,o.kt)("li",{parentName:"ul"},"Latency")),(0,o.kt)("h3",{id:"classifying-parameters"},"Classifying Parameters"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Parameters that control the database's behavior and functionality but have no impact on resource utilization and instance stability")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Parameters that might affect performance by managing how resources, such as caching and internal memory-based buffers, are allocated in the instance"))),(0,o.kt)("h2",{id:"others"},"Others"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"innodb_additional_mem_pool_size"),(0,o.kt)("li",{parentName:"ul"},"innodb_log_buffer_size"),(0,o.kt)("li",{parentName:"ul"},"long_query_time"),(0,o.kt)("li",{parentName:"ul"},"server_audit_events"),(0,o.kt)("li",{parentName:"ul"},"server_audit_excl_users"),(0,o.kt)("li",{parentName:"ul"},"server_audit_incl_users")),(0,o.kt)("h2",{id:"recommendations-and-impact"},"Recommendations and impact"),(0,o.kt)("h3",{id:"autocommit"},"autocommit"),(0,o.kt)("p",null,"Recommended setting: Use the default value (1 or ON) to ensure that each SQL statement is automatically committed as you run it, unless it's part of a transaction opened by the user.\nImpact:A value of OFF might encourage incorrect usage patterns such as transactions that are held open longer than required, not closed, or committed at all. This can affect the performance and stability of the database."),(0,o.kt)("h3",{id:"max_connections"},"max_connections"),(0,o.kt)("p",null,"Recommended setting: Default (variable value). When using a custom value, configure only as many connections as the application actively uses to perform work.\nImpact:Configuring a too-high connection limit can contribute to higher memory use even if connections are not actively used. It can also cause high database connection spikes that affect the databases' performance and stability.\nThis variable parameter is automatically populated based on your instance's memory allocation and size using the following formula, so use the default value first:\nGREATEST({log(DBInstanceClassMemory/805306368,2)",(0,o.kt)("em",{parentName:"p"},"45},{log(DBInstanceClassMemory/8187281408,2)"),"1000})\nFor example, for an Aurora MySQL db.r4.large instance with 15.25 GiB of memory, it is set to 1,000:"),(0,o.kt)("p",null,"DBInstanceClassMemory = 16374562816 bytes\nmax_connections = GREATEST({log(16374562816/805306368,2)",(0,o.kt)("em",{parentName:"p"},"45},{log(16374562816/8187281408,2)"),"1000})\nmax_connections = GREATEST(195.56,1000) = 1000\nIf you are encountering connection errors and getting excessiveToo many connectionsin your error logs, you can set this parameter to a fixed value instead of the variable setting.\nWhen you're considering settingmax_connectionsto a fixed value if your application requires a higher number of connections, consider using a connection pool or proxy between the application and the database. You can also do this if connections can't be predicted or controlled reliably.\nWhen you manually configure a value for this parameter that exceeds the recommended number of connections, ",(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/cloudwatch/"},"Amazon CloudWatch")," metrics for DB connections show a red line where the threshold is exceeded. This is the formula that CloudWatch uses:"),(0,o.kt)("p",null,"Threshold value for max_connections = {DBInstanceClassMemory/12582880}\nFor example, for a db.r4.large instance whose memory size is 15.25 GiB (15.25 x 1024 x 1024 x 1024 = 16374562816 bytes), the warning threshold is approximately 1,300 connections. You can still use the maximum number of configured connections, provided that there are enough resources on the instance."),(0,o.kt)("h3",{id:"max_allowed_packet"},"max_allowed_packet"),(0,o.kt)("p",null,"Recommended setting: Default (4,194,304 bytes). Use a custom value only if required by your database workload. Tune this parameter when you are dealing with queries returning large elements, like long strings or BLOBs.\nImpact:Setting a large value here doesn't affect the initial size of the message buffers. Instead, it allows them to grow up to the defined size if required by your queries. A large parameter value coupled with a large number of concurrent eligible queries can increase the risk of out-of-memory conditions.\nThe following example error is shown when setting this parameter too small:"),(0,o.kt)("p",null,"ERROR 1153 (08S01) at line 3: Got a packet bigger than 'max_allowed_packet' bytes"),(0,o.kt)("h3",{id:"group_concat_max_len"},"group_concat_max_len"),(0,o.kt)("p",null,"Recommended setting: Default (1,024 bytes). Use a custom value only if your workload requires it. You need to tune this parameter only when you want to alter the return of theGROUP_CONCAT()statement and allow the engine to return longer column values. This value should be used in parallel withmax_allowed_packet, as this determines the maximum size of a response.\nImpact:Some of the symptoms of setting this parameter too high are high memory use and out-of-memory conditions. Setting it too low causes queries to fail."),(0,o.kt)("h3",{id:"innodb_ft_result_cache_limit"},"innodb_ft_result_cache_limit"),(0,o.kt)("p",null,"Recommended setting: Default (2,000,000,000 bytes). Use a custom value depending on your workload.\nImpact:As the value is already close to 1.9 GiB, increasing it beyond its default can result in out-of-memory conditions."),(0,o.kt)("h3",{id:"max_heap_table_size"},"max_heap_table_size"),(0,o.kt)("p",null,"Recommended setting: Default (16,777,216 bytes). Limits the maximum size of tables created in memory as defined by a user. Altering this value only has effect on newly created tables, and doesn't affect existing ones.\nImpact:Setting this parameter too high causes high memory utilization or out-of-memory conditions if in-memory tables grow."),(0,o.kt)("h3",{id:"performance_schema"},"performance_schema"),(0,o.kt)("p",null,"Recommended setting: Disable for t2 instances due to its high memory utilization.\nImpact:In Aurora MySQL 5.6, Performance Schema memory is preallocated heuristically. This preallocation is based on other configuration parameters such asmax_connections, table_open_cache, andtable_definition_cache. In Aurora MySQL 5.7, Performance Schema memory is allocated on-demand. The Performance Schema typically consumes around 1 to 3 GB of memory depending on the instance class, workload, and database configuration. If a DB instance is running low on memory, enabling Performance Schema can lead to out-of-memory conditions."),(0,o.kt)("h3",{id:"binlog_cache_size"},"binlog_cache_size"),(0,o.kt)("p",null,"Recommended setting: Default (32,768 bytes). This parameter controls the amount of memory that the binary log cache can use. By increasing it, you can improve performance on systems with large transactions by using buffers to avoid excessive disk writes. This cache is allocated on a per connection basis.\nImpact:Limit this value in environments with a large number of DB connections to avoid causing an out-of-memory condition."),(0,o.kt)("h3",{id:"bulk_insert_buffer_size"},"bulk_insert_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Leave as is, because it doesn't apply to Aurora MySQL."),(0,o.kt)("h3",{id:"innodb_buffer_pool_size"},"innodb_buffer_pool_size"),(0,o.kt)("p",null,"Recommended setting: Default (variable value), as it is preconfigured in Aurora to 75 percent of instance memory size. You can see buffer pool use in the output of SHOW ENGINE INNODB STATUS.\nImpact:A larger buffer pool improves overall performance by allowing less disk I/O when accessing the same table data repeatedly. The actual amount of allocated memory might be slightly higher than the actual configured value due to InnoDB engine overhead."),(0,o.kt)("h3",{id:"innodb_sort_buffer_size"},"innodb_sort_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Default (1,048,576 bytes)\nImpact:Higher-than-default values can increase the overall memory pressure on systems with a large number of concurrent queries"),(0,o.kt)("h3",{id:"join_buffer_size"},"join_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Default (262,144 bytes). This value is preallocated for various types of operations (such as joins) and a single query may allocate multiple instances of this buffer. If you want to improve the performance of your joins, we recommend that you add indexes to such tables.\nImpact:Changing this parameter can cause severe memory pressure in environments with a large number of concurrent queries. Increasing this value doesn't provide faster JOIN query performance, even when you add indexes."),(0,o.kt)("h3",{id:"key_buffer_size"},"key_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Leave as the default value (16,777,216 bytes), because it is not relevant to Aurora and affects only MyISAM table performance.\nImpact:No impact on Aurora's performance."),(0,o.kt)("h3",{id:"myisam_sort_buffer_size"},"myisam_sort_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Leave as the default value (8,388,608 bytes). It's not applicable for Aurora because it has no effect on InnoDB.\nImpact:No impact on Aurora's performance."),(0,o.kt)("h3",{id:"query-cache"},"Query Cache"),(0,o.kt)("p",null,"Aurora has two query-cache related metrics"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Buffer cache hit ratio : The percentage of requests that are served by the Buffer cache."),(0,o.kt)("li",{parentName:"ul"},"Resultset cache hit ratio : The percentage of requests that are served by the Resultset cache.")),(0,o.kt)("p",null,"\"Resultset Cache Hit Ratio\" is related to the query cache, which is a feature that enables caching the read queries' results (that's why called result set cache hit). So, if the engine started to execute a new read query, it will check the cached results before executing the query itself and if it found that this same query has been executed before and that its result wasn't invalidated yet, then it will serve the result of the new query from the cache. This is generally useful & shows up high in number when the workload contains a lot of similar select queries that has the similar values and conditions."),(0,o.kt)("p",null,'On the other hand, "Buffer Cache Hit Ratio" is more related to the innodb page caching hit ratio (& not the query result cache), and this should increase with increasing all types of read queries, as this process is called by bufferpool warm up which will cause the engine to load all the needed pages from the storage to the memory for faster access to the data. However, with increased amount of writes to the writer, this will make the readers to invalidate there in memory pages then load these pages again from the storage when needed. The "ratio" here depends on the percentage of hitting the in memory pages which should be very high ex: more than 99%.\nQuery cache is generally considered with low connections, similar type of queries over & over again (based on few observations on mysql/aurora, query cache might be actually bad for performance if you have high no. of connections & lots of adhoc style, changing queries).- It is rarely good to enable the Query Cache'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"- Guarded by a single mutext\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Most workloads is best left with the Query Cache disabled:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"query_cache_type = 0"))),(0,o.kt)("li",{parentName:"ul"},"If you think your workload benefits from the Query Cache, test it",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The more writes, the less benefit"),(0,o.kt)("li",{parentName:"ul"},"The more data fitting into the buffer pool, the less benefit"),(0,o.kt)("li",{parentName:"ul"},"The more complex queries and the larger scans, the more benefit"))),(0,o.kt)("li",{parentName:"ul"},"Often other caching solutions are a better option")),(0,o.kt)("h3",{id:"removed-in-mysql-80"},"Removed in MySQL 8.0"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Aurora.Monitoring.html"},"http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Aurora.Monitoring.html")),(0,o.kt)("h3",{id:"query_cache_size"},"query_cache_size"),(0,o.kt)("p",null,"Recommended setting: Default (variable value). The parameter is pretuned in Aurora, and the value is much larger than MySQL default. Aurora's query cache doesn't suffer from scalability issues (as the query cache does in MySQL). It's an acceptable practice to modify it for high-throughput, demanding workloads.\nImpact:Query performance is affected when accessing queries through this cache. You can see query cache use in the output of a SHOW STATUS command under the \"QCache\" section."),(0,o.kt)("h3",{id:"query_cache_type"},"query_cache_type"),(0,o.kt)("p",null,"Recommended setting: Enabled. By default, the query cache is enabled in Aurora and is recommended to keep it enabled for its performance gains and low overhead. However, it's fine to disable the query cache if you know that your workload doesn't benefit from it. An example is a write-heavy workload with limited to no read queries.\nImpact:Disabling query caching in Aurora might affect database performance if your workload reuses queries, like repeatable SQL statements. You can see query cache use in the output of a SHOW STATUS command under the \"Qcache\" section."),(0,o.kt)("h3",{id:"read_buffer_size"},"read_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Default (262,144 bytes).\nImpact:Large values cause higher overall memory pressure and provoke out-of-memory issues. Don't increase the setting unless you can prove that the higher value benefits performance without compromising stability."),(0,o.kt)("h3",{id:"read_rnd_buffer_size"},"read_rnd_buffer_size"),(0,o.kt)("p",null,"Recommended setting: Default (524,288 bytes). There's no need to increase the setting for Aurora, due to the performance characteristics of the underlying storage cluster.\nImpact:Large values might cause out-of-memory issues."),(0,o.kt)("h3",{id:"table_open_cache"},"table_open_cache"),(0,o.kt)("p",null,"Recommended setting: Leave as is, unless your workload requires accessing a very large number of tables simultaneously. The table cache is a major memory consumer, and the default value in Aurora is significantly higher than the MySQL defaults. This parameter is automatically adjusted based on instance size.\nImpact:A database with a large number of tables (in the hundreds of thousands) requires a larger setting, because not all tables fit in memory. Setting this value too high might contribute to out of memory conditions. This setting also indirectly contributes to Performance Schema memory usage, if the Performance Schema is enabled."),(0,o.kt)("h3",{id:"table_definition_cache"},"table_definition_cache"),(0,o.kt)("p",null,"Recommended settings: Defaults. This setting is pretuned in Aurora to be significantly larger than in MySQL, and it's automatically adjusted based on instance size and class. If your workload requires it and your database requires a very large number of tables to be opened concurrently, increasing this value might speed up opening tables operations. This parameter is used in conjunction with table_open_cache.\nImpact:This setting also indirectly contributes to Performance Schema memory usage, if the Performance Schema is enabled. Watch out for higher-than-default settings as they might provoke out-of-memory issues."),(0,o.kt)("h3",{id:"tmp_table_size"},"tmp_table_size"),(0,o.kt)("p",null,"Recommended settings: Default (16,777,216 bytes). Together withmax_heap_table_size, this parameter limits the size for in-memory tables used for query processing. When the temporary table size limit is exceeded, tables are then swapped to disk.\nImpact:Very large values (hundreds of megabytes or more) are notorious for causing memory issues and out-of-memory errors. This parameter doesn't affect tables created with the MEMORY engine.\n",(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/blogs/database/best-practices-for-amazon-aurora-mysql-database-configuration"},"https://aws.amazon.com/blogs/database/best-practices-for-amazon-aurora-mysql-database-configuration")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Reference.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Reference.html")),(0,o.kt)("h3",{id:"instance-types"},"Instance Types"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"db.r6g instances")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"db.r5 instances"))),(0,o.kt)("h2",{id:"amazon-aurora-serverless"},"Amazon Aurora Serverless"),(0,o.kt)("p",null,"Amazon Aurora Serverless is an on-demand, autoscaling configuration for Amazon Aurora. AnAurora Serverless DB clusteris a DB cluster that automatically starts up, shuts down, and scales up or down its compute capacity based on your application's needs. Aurora Serverless provides a relatively simple, cost-effective option for infrequent, intermittent, or unpredictable workloads. It can provide this because it automatically starts up, scales compute capacity to match your application's usage, and shuts down when it's not in use.\nA non-Serverless DB cluster for Aurora is called aprovisioned DB cluster. Aurora Serverless clusters and provisioned clusters both have the same kind of high-capacity, distributed, and highly available storage volume."),(0,o.kt)("h3",{id:"serverless-v2"},"Serverless V2"),(0,o.kt)("p",null,"Amazon Aurora Serverless v2, currently in preview, scales instantly from hundreds to hundreds-of-thousands of transactions in a fraction of a second. As it scales, it adjusts capacity in fine-grained increments to provide just the right amount of database resources that the application needs. There is no database capacity for you to manage, you pay only for the capacity your application consumes, and you can save up to 90% of your database cost compared to the cost of provisioning capacity for peak load.\nAurora Serverless v2 (Preview) supports all manner of database workloads, from development and test environments, websites, and applications that have infrequent, intermittent, or unpredictable workloads to the most demanding, business critical applications that require high scale and high availability. It supports the full breadth of Aurora features, including Global Database, Multi-AZ deployments, and read replicas. Aurora Serverless v2 (Preview) is currently available in preview for Aurora with MySQL compatibility only.\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html")),(0,o.kt)("h2",{id:"important-points"},"Important points"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You can't give an Aurora Serverless DB cluster a public IP address. You can access an Aurora Serverless DB cluster only from within a virtual private cloud (VPC) based on the Amazon VPC service.\n",(0,o.kt)("a",{parentName:"li",href:"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html"))),(0,o.kt)("h2",{id:"optimizations"},"Optimizations"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/blogs/database/planning-and-optimizing-amazon-aurora-with-mysql-compatibility-for-consolidated-workloads"},"https://aws.amazon.com/blogs/database/planning-and-optimizing-amazon-aurora-with-mysql-compatibility-for-consolidated-workloads")),(0,o.kt)("h2",{id:"db-instance-ram-recommendations"},"DB instance RAM recommendations"),(0,o.kt)("p",null,"An Amazon RDS performance best practice is to allocate enough RAM so that yourworking setresides almost completely in memory. The working set is the data and indexes that are frequently in use on your instance. The more you use the DB instance, the more the working set will grow.\nTo tell if your working set is almost all in memory, check the ReadIOPS metric (using Amazon CloudWatch) while the DB instance is under load. The value of ReadIOPS should be small and stable. If scaling up the DB instance class - to a class with more RAM - results in a dramatic drop in ReadIOPS, your working set was not almost completely in memory. Continue to scale up until ReadIOPS no longer drops dramatically after a scaling operation, or ReadIOPS is reduced to a very small amount. For information on monitoring a DB instance's metrics, see ",(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/MonitoringOverview.html#USER_Monitoring"},"Viewing DB instance metrics"),"."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_BestPractices.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_BestPractices.html")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/premiumsupport/knowledge-center/rds-instance-high-cpu"},"https://aws.amazon.com/premiumsupport/knowledge-center/rds-instance-high-cpu")),(0,o.kt)("h2",{id:"wait-events"},"Wait Events"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Tuning.wait-events.html"},"https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Tuning.wait-events.html"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/premiumsupport/knowledge-center/aurora-mysql-synch-wait-events"},"https://aws.amazon.com/premiumsupport/knowledge-center/aurora-mysql-synch-wait-events")),(0,o.kt)("h2",{id:"aurora-io-costsoptimization"},"Aurora IO Costs/Optimization"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=dpLRAlEX7Lo"},"Amazon Aurora I/O Cost Optimization Methodology | Amazon Web Services")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select * from sys.user_summary_by_file_io;\n\ninnodb_flush_log_at_trx_commit\n\ninnodb_flush_log_at_timeout\n")),(0,o.kt)("h3",{id:"rds-proxy"},"RDS Proxy"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/rds/proxy"},"https://aws.amazon.com/rds/proxy")))}d.isMDXComponent=!0}}]);