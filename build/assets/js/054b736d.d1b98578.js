"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[87683],{603905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>h});var o=r(667294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,o,a=function(e,t){if(null==e)return{};var r,o,a={},n=Object.keys(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},c=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var r=e.components,a=e.mdxType,n=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=d(r),m=a,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||n;return r?o.createElement(h,s(s({ref:t},c),{},{components:r})):o.createElement(h,s({ref:t},c))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=r.length,s=new Array(n);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var d=2;d<n;d++)s[d]=r[d];return o.createElement.apply(null,s)}return o.createElement.apply(null,r)}m.displayName="MDXCreateElement"},497466:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>n,metadata:()=>i,toc:()=>d});var o=r(487462),a=(r(667294),r(603905));const n={},s="Intro",i={unversionedId:"databases/sql-databases/memsql/intro",id:"databases/sql-databases/memsql/intro",title:"Intro",description:"MemSQL is a distributed in-memory relational database designed for both transactional and analytical workloads.",source:"@site/docs/databases/sql-databases/memsql/intro.md",sourceDirName:"databases/sql-databases/memsql",slug:"/databases/sql-databases/memsql/intro",permalink:"/databases/sql-databases/memsql/intro",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/sql-databases/memsql/intro.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MemSQL",permalink:"/databases/sql-databases/memsql/"},next:{title:"MySQL",permalink:"/databases/sql-databases/mysql/"}},l={},d=[{value:"History",id:"history",level:2},{value:"Checkpoints",id:"checkpoints",level:2},{value:"Concurrency Control",id:"concurrency-control",level:2},{value:"Data Model",id:"data-model",level:2},{value:"Indexes",id:"indexes",level:2},{value:"Isolation Levels",id:"isolation-levels",level:2},{value:"Joins",id:"joins",level:2},{value:"Logging",id:"logging",level:2},{value:"Query Compilation",id:"query-compilation",level:2},{value:"Query Execution",id:"query-execution",level:2},{value:"Query Interface",id:"query-interface",level:2},{value:"Storage Architecture",id:"storage-architecture",level:2},{value:"Storage Model",id:"storage-model",level:2},{value:"Stored Procedures",id:"stored-procedures",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Views",id:"views",level:2}],c={toc:d},p="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,o.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"intro"},"Intro"),(0,a.kt)("p",null,"MemSQL is a distributed in-memory relational database designed for both transactional and analytical workloads."),(0,a.kt)("h2",{id:"history"},"History"),(0,a.kt)("p",null,"MemSQL was a Y-combinator graduate start-up founded in 2011."),(0,a.kt)("h2",{id:"checkpoints"},"Checkpoints"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?checkpoints=non-blocking"},"Non-Blocking"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?checkpoints=consistent"},"Consistent"),"\nMemSQL uses multi-version concurrency control and it's natural to create a consistent(non-fuzzy) snapshot without the need to block ongoing transactions."),(0,a.kt)("h2",{id:"concurrency-control"},"Concurrency Control"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?concurrency-control=multi-version-concurrency-control-mvcc"},"Multi-version Concurrency Control (MVCC)"),"\nMemSQL uses multi-version concurrency control. Reads are not blocked, writes acquire row-level locks."),(0,a.kt)("h2",{id:"data-model"},"Data Model"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?data-model=relational"},"Relational"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?data-model=keyvalue"},"Key/Value"),"\nMemSQL is a distributed relational database. It also supports two-column key/value store."),(0,a.kt)("h2",{id:"indexes"},"Indexes"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?indexes=skip-list"},"Skip List"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?indexes=hash-table"},"Hash Table"),"\nSkip list is the default index type in MemSQL. Skip list is lock free and thus leads extremely fast insert performance, and O(lg(n)) expected lookup/insert/delete performance. Unlike B+ tree, skip list is singly linked, thus reserve scan leads to twice as costly as forward scan. Skip list involves more pointer chasing than B+ tree which could potentially lead to more cache misses. In MemSQL, heuristics are applied to organize nearby nodes on the same physical page to mitigate penalties caused by pointer chasing. Lock-free hash table is also supported in MemSQL to perform fast exact-match queries."),(0,a.kt)("h2",{id:"isolation-levels"},"Isolation Levels"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?isolation-levels=read-committed"},"Read Committed"),"\nMemSQL supports read committed isolation level."),(0,a.kt)("h2",{id:"joins"},"Joins"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?joins=nested-loop-join"},"Nested Loop Join"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?joins=hash-join"},"Hash Join"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?joins=sort-merge-join"},"Sort-Merge Join"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?joins=broadcast-join"},"Broadcast Join"),"\nNested loop join, index-nested loop join, merge join and hash join are supported in MemSQL. Joins between two Columnstore tables are often executed as sort merge join. For distributed join queries, if two tables are joined with identical shard key, the join will be performed locally; otherwise dataset is broadcast to other nodes via the network."),(0,a.kt)("h2",{id:"logging"},"Logging"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?logging=physical-logging"},"Physical Logging"),"\nMemSQL implements write-ahead-logging which records only committed transactions. It uses a transaction buffer pool as back-pressure mechanism so that a worker thread doesn't generate indefinite amount of logs. Replication is implemented based on log recovery."),(0,a.kt)("h2",{id:"query-compilation"},"Query Compilation"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?query-compilation=code-generation"},"Code Generation"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?query-compilation=jit-compilation"},"JIT Compilation"),"\nInstead of the traditional interpreter based execution model, MemSQL 5 comes with a new code generation architecture, which compiles a SQL query to LLVM to machine code. When the MemSQL server encounters a SQL query, it parses SQL into AST and extracts parameters from the query, which is then transformed into a MemSQL-specific intermediate representation inMemSQL Plan Language(MPL). MemSQL then flattens MPL AST into a more compact format asMemSQL Bytecode(MBC). Plans in MBC format is then transformed into LLVM Bitcode, which LLVM uses to generate machine code. Such code generation architecture enables many low-level optimizations and avoids much less unnecessary work compared to interpreter-based execution. Compiled plans are also cached on disk for future use."),(0,a.kt)("h2",{id:"query-execution"},"Query Execution"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?query-execution=tuple-at-a-time-model"},"Tuple-at-a-Time Model"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?query-execution=vectorized-model"},"Vectorized Model"),"\nMemSQL uses Tuple-at-a-Time Model for rowstore query execution, uses Vectorized Model for columnstore."),(0,a.kt)("h2",{id:"query-interface"},"Query Interface"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?query-interface=sql"},"SQL"),"\nMemSQL supports a subset of MySQL syntax, plus extensions for distributed SQL, geospatial and JSON queries. MySQL wire protocol is supported."),(0,a.kt)("h2",{id:"storage-architecture"},"Storage Architecture"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?storage-architecture=disk-oriented"},"Disk-oriented"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?storage-architecture=in-memory"},"In-Memory"),"\nIn MemSQL, rowstore is completely in-memory and columnstore is disk-backed."),(0,a.kt)("h2",{id:"storage-model"},"Storage Model"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?storage-model=decomposition-storage-model-columnar"},"Decomposition Storage Model (Columnar)"),(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?storage-model=n-ary-storage-model-rowrecord"},"N-ary Storage Model (Row/Record)"),"\nIn MemSQL, row segments in rowstore are stored in N-ary storage model in-memory. Column segments in columnstore are stored in decomposition storage model. Clustered columnar indexes are created for columnstore and compression is applied."),(0,a.kt)("h2",{id:"stored-procedures"},"Stored Procedures"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?stored-procedures=not-supported"},"Not Supported"),"\nStored procedure is not supported."),(0,a.kt)("h2",{id:"system-architecture"},"System Architecture"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?system-architecture=shared-nothing"},"Shared-Nothing"),"\nMemSQL has a two-tier, clustered architecture. The nodes in upper tier areaggregators, which are cluster-aware query routers. One special node calledMaster Aggregatoris responsible for clustering monitoring. The nodes in lower tier areleaves, which store and process partitioned shards. The aggregator sends extended SQL to leaves to perform distributed query execution."),(0,a.kt)("h2",{id:"views"},"Views"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/browse?views=virtual-views"},"Virtual Views"),"\nViews in MemSQL is not materialzed and cannot be written into.\n",(0,a.kt)("a",{parentName:"p",href:"https://dbdb.io/db/memsql"},"https://dbdb.io/db/memsql")))}u.isMDXComponent=!0}}]);