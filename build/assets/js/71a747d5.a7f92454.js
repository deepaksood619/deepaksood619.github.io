"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[82619],{603905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(667294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||s;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,a[1]=i;for(var c=2;c<s;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},581317:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=n(487462),o=(n(667294),n(603905));const s={},a="Reference",i={unversionedId:"devops/kubernetes/reference/readme",id:"devops/kubernetes/reference/readme",title:"Reference",description:"Admission Controllers",source:"@site/docs/devops/kubernetes/reference/readme.md",sourceDirName:"devops/kubernetes/reference",slug:"/devops/kubernetes/reference/",permalink:"/devops/kubernetes/reference/",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/devops/kubernetes/reference/readme.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Outline Documentation",permalink:"/devops/kubernetes/outline-documentation"},next:{title:"RBAC",permalink:"/devops/kubernetes/reference/rbac"}},l={},c=[{value:"Admission Controllers",id:"admission-controllers",level:2},{value:"Dynamic Admission Control",id:"dynamic-admission-control",level:2},{value:"Admission Webhooks",id:"admission-webhooks",level:2},{value:"Quality of Service",id:"quality-of-service",level:2}],u={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reference"},"Reference"),(0,o.kt)("h2",{id:"admission-controllers"},"Admission Controllers"),(0,o.kt)("p",null,"An admission controller is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object, but after the request is authenticated and authorized. The controllers consist of the",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do"},"list")," below, are compiled into thekube-apiserverbinary, and may only be configured by the cluster administrator. In that list, there are two special controllers: MutatingAdmissionWebhook and ValidatingAdmissionWebhook. These execute the mutating and validating (respectively)",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks"},"admission control webhooks")," which are configured in the API."),(0,o.kt)("p",null,'Admission controllers may be "validating", "mutating", or both. Mutating controllers may modify the objects they admit; validating controllers may not.'),(0,o.kt)("p",null,"The admission control process proceeds in two phases. In the first phase, mutating admission controllers are run. In the second phase, validating admission controllers are run. Note again that some of the controllers are both."),(0,o.kt)("p",null,"If any of the controllers in either phase reject the request, the entire request is rejected immediately and an error is returned to the end-user."),(0,o.kt)("p",null,"Finally, in addition to sometimes mutating the object in question, admission controllers may sometimes have side effects, that is, mutate related resources as part of request processing. Incrementing quota usage is the canonical example of why this is necessary. Any such side-effect needs a corresponding reclamation or reconciliation process, as a given admission controller does not know for sure that a given request will pass all of the other admission controllers."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers"},"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers")),(0,o.kt)("h2",{id:"dynamic-admission-control"},"Dynamic Admission Control"),(0,o.kt)("h2",{id:"admission-webhooks"},"Admission Webhooks"),(0,o.kt)("p",null,"Admission webhooks are HTTP callbacks that receive admission requests and do something with them. You can define two types of admission webhooks, ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook"},"validating admission Webhook")," and ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook"},"mutating admission webhook"),". Mutating admission Webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults. After all object modifications are complete, and after the incoming object is validated by the API server, validating admission webhooks are invoked and can reject requests to enforce custom policies."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers"},"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers")),(0,o.kt)("h2",{id:"quality-of-service"},"Quality of Service"),(0,o.kt)("p",null,"CPU requests are made in CPU units, each unit being a millicore / millicpu, using mille - the Latin word for thousand. Thus a request for .7 of a CPU would be 700 millicore."),(0,o.kt)("p",null,"One CPU, in Kubernetes, is equivalent to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"1 AWS vCPU"),(0,o.kt)("li",{parentName:"ul"},"1 GCP Core"),(0,o.kt)("li",{parentName:"ul"},"1 Azure vCore"),(0,o.kt)("li",{parentName:"ul"},"1 Hyperthread on a bare-metal Intel processor with Hyperthreading.")),(0,o.kt)("p",null,"When Kubernetes creates a Pod it assigns one of these QoS classes to the Pod:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Guaranteed",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Every Container in the Pod must have a memory limit and a memory request, and they must be the same."),(0,o.kt)("li",{parentName:"ul"},"Every Container in the Pod must have a CPU limit and a CPU request, and they must be the same.")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},'resources:\nlimits:\nmemory: "200Mi"\ncpu: "700m"\nrequests:\nmemory: "200Mi"\ncpu: "700m"')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Burstable",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The Pod does not meet the criteria for QoS class Guaranteed."),(0,o.kt)("li",{parentName:"ul"},"At least one Container in the Pod has a memory or CPU request")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},'resources:\nlimits:\nmemory: "200Mi"\nrequests:\nmemory: "100Mi"')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"BestEffort",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"For a Pod to be given a QoS class of BestEffort, the Containers in the Pod must not have any memory or CPU limits or requests.")))),(0,o.kt)("p",null,"You can useephemeral-storagefor managing local ephemeral storage. Each Container of a Pod can specify one or more of the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"spec.containers[].resources.limits.ephemeral-storage"),(0,o.kt)("li",{parentName:"ul"},"spec.containers[].resources.requests.ephemeral-storage")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod"},"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers"},"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.replex.io/blog/everything-you-need-to-know-about-kubernetes-quality-of-service-qos-classes"},"https://www.replex.io/blog/everything-you-need-to-know-about-kubernetes-quality-of-service-qos-classes")))}m.isMDXComponent=!0}}]);