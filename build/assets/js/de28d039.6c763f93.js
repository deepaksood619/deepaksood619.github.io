"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[57396],{603905:(e,t,i)=>{i.d(t,{Zo:()=>m,kt:()=>f});var n=i(667294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var c=n.createContext({}),p=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},m=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),h=p(i),u=a,f=h["".concat(c,".").concat(u)]||h[u]||l[u]||r;return i?n.createElement(f,o(o({ref:t},m),{},{components:i})):n.createElement(f,o({ref:t},m))}));function f(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=i.length,o=new Array(r);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=i[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},54907:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=i(487462),a=(i(667294),i(603905));const r={},o="Finite-State Machine",s={unversionedId:"algorithms/algorithmic-complexity/finite-state-machine",id:"algorithms/algorithmic-complexity/finite-state-machine",title:"Finite-State Machine",description:"DFA - Deterministic Finite Automata",source:"@site/docs/algorithms/algorithmic-complexity/finite-state-machine.md",sourceDirName:"algorithms/algorithmic-complexity",slug:"/algorithms/algorithmic-complexity/finite-state-machine",permalink:"/algorithms/algorithmic-complexity/finite-state-machine",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/algorithms/algorithmic-complexity/finite-state-machine.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Computational Complexity Theory",permalink:"/algorithms/algorithmic-complexity/computational-complexity-theory"},next:{title:"Halting Problem",permalink:"/algorithms/algorithmic-complexity/halting-problem"}},c={},p=[],m={toc:p},h="wrapper";function l(e){let{components:t,...r}=e;return(0,a.kt)(h,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"finite-state-machine"},"Finite-State Machine"),(0,a.kt)("p",null,"DFA - Deterministic Finite Automata"),(0,a.kt)("p",null,"NFA - Non-deterministic Finite Automata"),(0,a.kt)("p",null,"Use ",(0,a.kt)("em",{parentName:"p"},"e (epsilon)")," transition to get to next state"),(0,a.kt)("p",null,"Afinite-state machine(FSM) orfinite-state automaton(FSA, plural:automata), finite automaton, or simply astate machine, is a mathematical ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Model_of_computation"},"model of computation"),". It is an ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Abstract_machine"},"abstract machine")," that can be in exactly one of a finite number of ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/State_(computer_science)"},"states")," at any given time. The FSM can change from one state to another in response to some external ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Input_(computer_science)"},"inputs"),"; the change from one state to another is called atransition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types --",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Deterministic_finite_automaton"},"deterministic finite state machines")," and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton"},"non-deterministic finite state machines"),".A deterministic finite-state machine can be constructed equivalent to any non-deterministic one."),(0,a.kt)("p",null,"The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Simple examples are ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Vending_machine"},"vending machines"),", which dispense products when the proper combination of coins is deposited, ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elevator"},"elevators"),", whose sequence of stops is determined by the floors requested by riders, ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Traffic_light"},"traffic lights"),", which change sequence when cars are waiting, and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Combination_lock"},"combination locks"),", which require the input of a sequence of numbers in the proper order."),(0,a.kt)("p",null,"The finite state machine has less computational power than some other models of computation such as the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Turing_machine"},"Turing machine"),".The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM's ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_memory"},"memory")," is limited by the number of states it has. FSMs are studied in the more general field of ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Automata_theory"},"automata theory"),"."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image",src:i(601012).Z,width:"300",height:"225"})),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine"},"https://en.wikipedia.org/wiki/Finite-state_machine")))}l.isMDXComponent=!0},601012:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/Finite-State-Machine-image1-e55f922784601709fabde7f8f9418a36.jpg"}}]);