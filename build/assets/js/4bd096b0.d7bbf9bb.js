"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[43573],{603905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(667294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=o,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||r;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},730248:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(487462),o=(n(667294),n(603905));const r={},i="Mocking",s={unversionedId:"computer-science/testing/mocking",id:"computer-science/testing/mocking",title:"Mocking",description:"The Abstract Pattern of the Problem",source:"@site/docs/computer-science/testing/mocking.md",sourceDirName:"computer-science/testing",slug:"/computer-science/testing/mocking",permalink:"/computer-science/testing/mocking",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/testing/mocking.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Load / Performance Testing/QA Tools",permalink:"/computer-science/testing/load-performance-testing-qa-tools"},next:{title:"Postman",permalink:"/computer-science/testing/postman"}},l={},c=[{value:"The Abstract Pattern of the Problem",id:"the-abstract-pattern-of-the-problem",level:2},{value:"Problem 1: A dependencies side-effect",id:"problem-1-a-dependencies-side-effect",level:3},{value:"Problem 2: A dependencies return value",id:"problem-2-a-dependencies-return-value",level:3},{value:"Problem 3: A dependency throws an Exception",id:"problem-3-a-dependency-throws-an-exception",level:3},{value:"The Problem - Simple Examples",id:"the-problem---simple-examples",level:2},{value:"Examples for External Dependencies",id:"examples-for-external-dependencies",level:2},{value:"The solution: Patching",id:"the-solution-patching",level:2},{value:"Direct replacement: Don&#39;t do this",id:"direct-replacement-dont-do-this",level:2},{value:"Mock and MagicMock",id:"mock-and-magicmock",level:2},{value:"spec, autospec &amp; spec_set",id:"spec-autospec--spec_set",level:2},{value:"pytests monkeypatch",id:"pytests-monkeypatch",level:2},{value:"External Packages",id:"external-packages",level:2},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Temporary files: Are Mocks a Code Smell?",id:"temporary-files-are-mocks-a-code-smell",level:2},{value:"Dependency Injection: Randomness",id:"dependency-injection-randomness",level:2},{value:"Terminology",id:"terminology",level:2},{value:"A note about Architecture",id:"a-note-about-architecture",level:2},{value:"What else is there?",id:"what-else-is-there",level:2},{value:"Tools",id:"tools",level:2},{value:"Mock Server",id:"mock-server",level:2}],p={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mocking"},"Mocking"),(0,o.kt)("h2",{id:"the-abstract-pattern-of-the-problem"},"The Abstract Pattern of the Problem"),(0,o.kt)("p",null,"A dependency of the function we want to test can have an effect in three different ways: By side-effects, return values or exceptions."),(0,o.kt)("h3",{id:"problem-1-a-dependencies-side-effect"},"Problem 1: A dependencies side-effect"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def a_function():\n... # Application code to be tested\na_dependency()\n... # Application code to be tested\n")),(0,o.kt)("h3",{id:"problem-2-a-dependencies-return-value"},"Problem 2: A dependencies return value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def a_function():\n... # Application code to be tested\nfoo = a_dependency()\n... # Application code to be tested; it might use foo\n")),(0,o.kt)("h3",{id:"problem-3-a-dependency-throws-an-exception"},"Problem 3: A dependency throws an Exception"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def a_function():\n... # Application code to be tested\ntry:\n    foo = a_dependency()\nexcept:\n... # Application code to be tested\n... # this might depend on the type of Exception\n... # Application code to be tested\n")),(0,o.kt)("h2",{id:"the-problem---simple-examples"},"The Problem - Simple Examples"),(0,o.kt)("p",null,"Example 1: We want to add a user to a database. You can see thatdbdoes not return anything, but we change the state of our system. And we want to be sure that we don't actually change our production system when the unit tests are running!\nExample 2: Generate a file name based on the current date. You can see that the dependencydatetimereturns a value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import datetime\n\ndef generate_filename():\n    return f"{datetime.datetime.now():%Y-%m-%d}.jpg"\n')),(0,o.kt)("p",null,"Similarly, you could imagine a function which returns the weather in an English sentence and uses an API to get the actual weather (",(0,o.kt)("a",{parentName:"p",href:"https://gist.github.com/MartinThoma/5c7224ceae47e74645e0145d26dc03ec"},"example"),").\nExample 3: In my project ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/MartinThoma/edapy"},"edapy")," I looked at metadata from PDF files. I use the dependency PdfFileReader and have the file itself as an dependency. As the PDF file could be broken, PyPDF2 might throw an exception. So you can imagine code like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import PyPDF2.utils\nfrom PyPDF2 import PdfFileReader\n\ndef get_pdf_info(pdf_path):\n    info = {}\n    try:\n        pdf_toread = PdfFileReader(fp, strict=False)\n    except PyPDF2.utils.PdfReadError:\n        info["is_errornous"] = True\n        return info\n    # a lot more\nreturn info\n')),(0,o.kt)("p",null,"When you want to test such functions, you have the problem that the expected output is not only dependent on the function itself, but also on something external. In the cases above, the system time, an external service, and the file system."),(0,o.kt)("h2",{id:"examples-for-external-dependencies"},"Examples for External Dependencies"),(0,o.kt)("p",null,"There are lots of external dependencies your tests might have:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Date or time"),(0,o.kt)("li",{parentName:"ul"},"Internet: A web service you need to use"),(0,o.kt)("li",{parentName:"ul"},"File System: A file you need to create / read / edit / delete"),(0,o.kt)("li",{parentName:"ul"},"Database: Data you select / insert / update/ delete"),(0,o.kt)("li",{parentName:"ul"},"Randomness: Your code might make use ofrandomornp.random")),(0,o.kt)("p",null,"Just like the example above, they make isolated unit testing hard or even impossible."),(0,o.kt)("h2",{id:"the-solution-patching"},"The solution: Patching"),(0,o.kt)("p",null,"The overall strategy to test this is always the same: Replace the external dependency that is causing headaches by something in your control. The act of replacing the dependency is called ",(0,o.kt)("strong",{parentName:"p"},"patching"),", the replacement is called a ",(0,o.kt)("strong",{parentName:"p"},"mock"),". Depending on what exactly the mock does, you might also hear this being called a ",(0,o.kt)("strong",{parentName:"p"},"Test Double, Test Stub, Test Spy or a Fake Object"),". In practice in Python, the distinction does not matter.\nLet's make a tiny example how to use patch!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from external_dependency import dark_magic\n\ndef is_credit_card_fraud(transaction):\n    fraud_probability = dark_magic(transaction)\n    if fraud_probability > 0.99:\n        return True\n    else:\n        return False\n\ndef dark_magic(transaction):\n    raise ValueError()\n")),(0,o.kt)("p",null,"No matter which transaction you would use, the function is_credit_card_fraud would throw a ValueError.\nThis is how you patch that dependency away with a decorator@patch:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from unittest.mock import patch, MagicMock\n\ndef the_mock(input):\n    return 0.999\n\n@patch("fraud_example.dark_magic", the_mock)\ndef test_is_credit_card_fraud():\n    import fraud_example\n\n    transaction = {"amount_usd": "9999.99", "overnight_shipping": True}\n    is_fraud = fraud_example.is_credit_card_fraud(transaction)\n    assert is_fraud == True\n\n')),(0,o.kt)("p",null,"And this is how you patch the dependency fraud_example.dark_magic away with a context handler ( with ... ):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def test_is_credit_card_fraud_context_handler():\n    import fraud_example\n\n    transaction = {"amount_usd": "9999.99", "overnight_shipping": True}\n    with patch("fraud_example.dark_magic", the_mock):\n        is_fraud = fraud_example.is_credit_card_fraud(transaction)\nassert is_fraud == True\n')),(0,o.kt)("p",null,'When you now execute pytest, the test will succeed. You will always get 0.999 as a return value ofdark_magic\ud83c\udf89\nA part that might be surprising in this example is the first parameter of thepatchdecorator: It\'s"fraud_example.dark_magic"and NOT"external_dependency.dark_magic"! The target of your replacement is always what was loaded within the file you want to test, not where it was loaded from.'),(0,o.kt)("h2",{id:"direct-replacement-dont-do-this"},"Direct replacement: Don't do this"),(0,o.kt)("p",null,"The following is an example which does not usepatchand seems to work, but it has a big flaw. If you directly replacedatetime.datetimeinstead of patching it, it will be overwritten in all other contexts after that as well! \u26a0\ufe0f"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Core Library modules\nimport datetime\nfrom unittest import mock\n\n# First party modules\nfrom mock_example import generate_filename\n\nclass NewDate(datetime.datetime):\n    @classmethod\n    def now(cls):\n        return cls(1990, 4, 28)\n\ndef test_generate_filename():\n    datetime.datetime = NewDate\nassert generate_filename() == "1990-04-28.jpg"\n')),(0,o.kt)("h2",{id:"mock-and-magicmock"},"Mock and MagicMock"),(0,o.kt)("p",null,"You now know how to replace a dependency, hence it is time to talk about what to replace it with. This is whereunittest.mock.Mockandunittest.mock.MagicMockcome into play."),(0,o.kt)("p",null,'Everything you do with Mock will return a Mock. Call a function? Get a Mock as a return value. Access an attribute? Get a Mock as a value.\nPython has so called "magic" methods. I like the term "dunder" methods better - it just means all methods which start and end with adoubleunderscore. Examples are ',(0,o.kt)("inlineCode",{parentName:"p"},"__iter__")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"__contains__"),". MagicMock has those defined, Mock doesn't. I would use MagicMock everywhere, except if the mocked object doesn't define any of the magic functions."),(0,o.kt)("p",null,"A core feature of mock classes is that they allow you to not only remove a dependency which is hard to test, but also to assert on the way the mock was interacted with. Typical methods are ",(0,o.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called"},"assert_called"),"(), ",(0,o.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called_with"},"assert_called_with"),"(), ",(0,o.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_not_called"},"assert_not_called"),"()."),(0,o.kt)("h2",{id:"spec-autospec--spec_set"},"spec, autospec & spec_set"),(0,o.kt)("p",null,"A part that is really bad aboutMagicMockis that you can do anything with it - including accessing non-existing attributes, calling non-existing methods or calling existing methods with the wrong count of parameters. The mock object is missing aspecification. If you don't like that, useautospec=Truewhen patching the object:"),(0,o.kt)("p",null,"patch.object(Foo, 'foo', autospec=True)\nOr you can create a Mock like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import datetime\nfrom unittest.mock import Mock\n\na = Mock(spec=datetime) # Not Ok!\na.foo\n\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/moose/.pyenv/versions/3.8.1/lib/python3.8/unittest/mock.py\", line 635, in __getattr__\nraise AttributeError(\"Mock object has no attribute %r\" % name)\nAttributeError: Mock object has no attribute 'foo' # That is ok:\na.datetime\n<Mock name='mock.datetime' id='139883597784544'>\n")),(0,o.kt)("p",null,"The next parameter of ",(0,o.kt)("strong",{parentName:"p"},"patch")," is ",(0,o.kt)("strong",{parentName:"p"},"autospec"),". Where spec looks at the mocked object, autospecalso looks at the attributes of that object (and their attributes and those attributes, ...)."),(0,o.kt)("p",null,"Finally, there is ",(0,o.kt)("strong",{parentName:"p"},"spec_set"),". That one prevents you from setting attributes that don't exist."),(0,o.kt)("p",null,"Usually, I would useautospec=Trueandspec_set=Trueeverywhere. Code which uses introspection might be an example where you don't want that."),(0,o.kt)("h2",{id:"pytests-monkeypatch"},"pytests monkeypatch"),(0,o.kt)("p",null,"monkeypatch is a fixture from pytest. I will explain what a fixture is in the next article. For now, just accept it as a parameter you can give to your tests without specifying it and pytest will take care of it. You don't even need to import anything."),(0,o.kt)("p",null,"For the credit card fraud example, it looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def test_is_credit_card_fraud_monkeypatch(monkeypatch):\n    monkeypatch.setattr("fraud_example.dark_magic", the_mock)\n    import fraud_example\n\n    transaction = {"amount_usd": "9999.99", "overnight_shipping": True}\n    is_fraud = fraud_example.is_credit_card_fraud(transaction)\n    assert is_fraud == True\n')),(0,o.kt)("p",null,"The question when you should use ",(0,o.kt)("inlineCode",{parentName:"p"},"unittest.mock.patch")," and - if necessary -unittest.mock.Mockor pytestsmonkeypatchboils pretty much down to personal taste nowadays. The core Pythons patch / Mock only exist since Python 3.3 which, I guess, is a big part of the reason whymonkeypatchexists in the first place."),(0,o.kt)("h2",{id:"external-packages"},"External Packages"),(0,o.kt)("p",null,"There are a couple of packages designed for simplifying the patching and giving better mocks for well-known dependencies.\nFor example, you can use ",(0,o.kt)("a",{parentName:"p",href:"https://pypi.org/project/freezegun/"},"freezegun")," for mocking the system time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import freezegun\nfrom mock_example import generate_filenamedef test_generate_filename():\n\nwith freeze_time("1990-04-28"):\n    assert generate_filename() == "1990-04-28"\n')),(0,o.kt)("p",null,"For boto3 / botocore (Cloud-stuff), there is ",(0,o.kt)("a",{parentName:"p",href:"https://pypi.org/project/moto/"},"moto"),".\nFor ",(0,o.kt)("a",{parentName:"p",href:"https://pypi.org/project/requests/"},"requests"),", there is ",(0,o.kt)("a",{parentName:"p",href:"https://pypi.org/project/responses/"},"responses"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import requests\n\ndef get_ip():\n    resp = requests.get("http://ip.jsontest.com/")\n    return resp.json()\n\nif __name__ == "__main__":\n    print(get_ip())\n\nfrom requests_example import get_ip\nimport responses\n\n@responses.activate\ndef test_get_ip():\n    responses.add(\n        responses.GET,\n        "http://ip.jsontest.com/",\n        json={"ip": "123.456.789.0"},\n        status=404,\n    )\nassert get_ip() == {"ip": "123.456.789.0"}\n')),(0,o.kt)("h2",{id:"dependency-injection"},"Dependency Injection"),(0,o.kt)("p",null,"If the above sounded complicated, there is a simpler alternative: Dependency Injection. Essentially adding the external state explicitly as a parameter which makes it easy to adjust in tests. For example, the code from above could be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import datetime\n\ndef generate_filename(now=None):\n    if now is None:\n        now = datetime.datetime.now()\n    return f"{now:%Y-%m-%d}.jpg"\n')),(0,o.kt)("p",null,"Now testing is trivial:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import datetime\nfrom mock_example import generate_filename\ndef test_generate_filename():\n    now = datetime.datetime(1990, 4, 28)\n    assert generate_filename(now) == "1990-04-28.jpg"\n')),(0,o.kt)("p",null,"In some cases it feels very natural to apply such a pattern, in others it doesn't. Do this only when it feels natural. For example, it's very unlikely that I would ever pass a module as a parameter although it's possible. That would just feel very weird."),(0,o.kt)("h2",{id:"temporary-files-are-mocks-a-code-smell"},"Temporary files: Are Mocks a Code Smell?"),(0,o.kt)("p",null,"It depends very much on the details, but I like to mock as little as possible. Simply for the reason that not mocking means that you test more of your system. Strictly speaking you can't call the test aunit testanymore if you test more than one unit. It would be an integration test then - but that is also essential, right? You wouldn't be happy with BMW selling you a motor, some seats and a steering wheel and claiming \"all units work\". They need work together. Extensive mocks might prevent you from testing how things work together."),(0,o.kt)("p",null,"In an ideal world, you would have both: Unit tests which are very controlled and in case of failure make it easy to narrow down the source of the error. And integration / end-to-end tests which show that the complete system works."),(0,o.kt)("p",null,"There are also people who think that the need to mock is an indicator for a need to refactor (",(0,o.kt)("a",{parentName:"p",href:"https://github.com/pytest-dev/pytest/issues/4576#issuecomment-449865322"},"discussion"),"). Harry Percival gave the talk ",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=rk-f3B-eMkI"},"Stop Using Mocks (for a while)")," at PyCon 2020 and pointed out that testing code which is using mocks tends to be brittle as it is tightly coupled to implementation details."),(0,o.kt)("p",null,"A good example where I usually don't mock anything are file system interactions. If possible, I write the file just like it would be in the real application. When the test is finished, the test needs to clean up as well. I use the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/tempfile.html"},"tempfile")," module for that."),(0,o.kt)("h2",{id:"dependency-injection-randomness"},"Dependency Injection: Randomness"),(0,o.kt)("p",null,"Just like adding a time parameter for functions which use by default the current time might make your code way easier to test, adding arandom_stateparameter or aseedparameter to functions which use randomness helps."),(0,o.kt)("p",null,"Here are some ways to seed random number generators:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import random\nrandom.seed(0)\nrandom.random()\n# 0.8444218515250481\n\nimport numpy as np\nnp.random.seed(0)\nnp.random.random()\n# 0.5488135039273248\n\nrandom_state = np.random.RandomState(seed=0)\nrandom_state.random()\n# 0.5488135039273248\n")),(0,o.kt)("p",null,"Setting a random state / seed is also very helpful for debugging. If you haven't heard of the Heisenbug or the Higgs-Bugson, you missed some ",(0,o.kt)("a",{parentName:"p",href:"https://blog.codinghorror.com/new-programming-jargon/"},"programming jargon"),". And if your interested in research, reproducibility matters."),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Patching vs Mocking:")," Patching a function is adjusting it's functionality. In the context of unit testing we patch a dependency away; so we replace the dependency. Mocking is imitating. Usually we patch a function to use a mock we control instead of a dependency we don't control."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Monkey patching vs Mocking:")," Within a development context, mocking is pretty clearly about unit testing (",(0,o.kt)("a",{parentName:"li",href:"https://stackoverflow.com/a/2666006/562769"},"example"),"). However, monkey patching has several applications besides unit testing. For example, you can patch third party code during runtime if there is a small functionality missing or a part of the code is broken. You just extend the code. Monkey patching is used in the PyCharm debugger"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Monkey patching vs pytest.monkeypatch:")," The first one is a general concept, the second one is a concrete function within pytest which applies monkey patching for unit tests."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"unittest.mock.patch vs pytest.monkeypatch:")," This is personal preference. I prefer to stick with built-ins whenever the third-party option does not have big advantages. In this case, I even think that the core Python unittest.mock.patch is cleaner. For this reason I didn't explain pytest.monkeypatch so far. If you like to see the differences, there is a nice ",(0,o.kt)("a",{parentName:"li",href:"https://krzysztofzuraw.com/blog/2016/mocks-monkeypatching-in-python.html"},"blog post")," about it.")),(0,o.kt)("h2",{id:"a-note-about-architecture"},"A note about Architecture"),(0,o.kt)("p",null,"To keep your code clean, it is often a good idea to wrap third party dependencies. For example, you could have one module with deals with I/O. Or a module which deals with API requests. Then you have a couple of modules which might require a lot of mocking or where unit tests are pointless because the interesting part is the integration with the third party. The rest of your code stays easy to test, keeps the language you defined and cares about the objects you know. This is called the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Adapter_pattern"},"Adapter pattern"),"."),(0,o.kt)("h2",{id:"what-else-is-there"},"What else is there?"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Other types of Mocks, such as ",(0,o.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.PropertyMock"},"PropertyMock")," or"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://pypi.org/project/pytest-mock/"},"pytest-mock")," which provides the mocker fixture; I'm not really sure though if this is mainly a left-over from the time before Python 3.3 or if it actually makes things easier."),(0,o.kt)("li",{parentName:"ul"},"The 3rd party package ",(0,o.kt)("a",{parentName:"li",href:"https://pypi.org/project/mock/"},"mock"),", which should not be installed with Python 3.3+ as it was put in the standard library.")),(0,o.kt)("h2",{id:"tools"},"Tools"),(0,o.kt)("h2",{id:"mock-server"},"Mock Server"),(0,o.kt)("p",null,"For any system you integrate with via HTTP or HTTPS MockServer can be used as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("a",{parentName:"li",href:"https://www.mock-server.com/mock_server/getting_started.html"},"mock")," configured to return specific responses for different requests"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("a",{parentName:"li",href:"https://www.mock-server.com/proxy/getting_started.html"},"proxy")," recording and optionally modifying requests and responses"),(0,o.kt)("li",{parentName:"ul"},"both a ",(0,o.kt)("a",{parentName:"li",href:"https://www.mock-server.com/proxy/getting_started.html"},"proxy")," for some requests and a ",(0,o.kt)("a",{parentName:"li",href:"https://www.mock-server.com/mock_server/getting_started.html"},"mock")," for other requests at the same time\n",(0,o.kt)("a",{parentName:"li",href:"https://www.mock-server.com"},"https://www.mock-server.com"))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/mock-server/mockserver"},"https://github.com/mock-server/mockserver"),"\nIf you want to learn more about the default mocks, have a look at the awesome article by Yeray Diaz:",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/@yeraydiazdiaz/what-the-mock-cheatsheet-mocking-in-python-6a71db997832"},"What the mock? --- A cheatsheet for mocking in Python"),".\n",(0,o.kt)("a",{parentName:"p",href:"https://levelup.gitconnected.com/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed"},"https://levelup.gitconnected.com/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://martinfowler.com/articles/mocksArentStubs.html"},"https://martinfowler.com/articles/mocksArentStubs.html"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/@yeraydiazdiaz/what-the-mock-cheatsheet-mocking-in-python-6a71db997832"},"https://medium.com/@yeraydiazdiaz/what-the-mock-cheatsheet-mocking-in-python-6a71db997832")))}m.isMDXComponent=!0}}]);