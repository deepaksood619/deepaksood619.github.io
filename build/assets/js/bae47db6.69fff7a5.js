"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[22775],{603905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var i=a(667294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=i.createContext({}),p=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=p(a),d=n,u=h["".concat(l,".").concat(d)]||h[d]||m[d]||r;return a?i.createElement(u,s(s({ref:t},c),{},{components:a})):i.createElement(u,s({ref:t},c))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[h]="string"==typeof e?e:n,s[1]=o;for(var p=2;p<r;p++)s[p]=a[p];return i.createElement.apply(null,s)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},983520:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var i=a(487462),n=(a(667294),a(603905));const r={},s="Journaling File System",o={unversionedId:"computer-science/operating-system/journaling-file-system",id:"computer-science/operating-system/journaling-file-system",title:"Journaling File System",description:'Ajournaling file systemis a file system that keeps track of changes not yet committed to the file system\'s main part by recording the intentions of such changes in a data structure known as a "journal)", which is usually a circular log. In the event of a system crash or power failure, such file systems can be brought back online more quickly with a lower likelihood of becoming corrupted.',source:"@site/docs/computer-science/operating-system/journaling-file-system.md",sourceDirName:"computer-science/operating-system",slug:"/computer-science/operating-system/journaling-file-system",permalink:"/computer-science/operating-system/journaling-file-system",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/operating-system/journaling-file-system.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Intro",permalink:"/computer-science/operating-system/intro"},next:{title:"Memory Allocation",permalink:"/computer-science/operating-system/memory-allocation"}},l={},p=[{value:"Rationale",id:"rationale",level:2},{value:"Techniques",id:"techniques",level:2},{value:"Physical journals",id:"physical-journals",level:2},{value:"Logical journals",id:"logical-journals",level:2},{value:"Write hazards",id:"write-hazards",level:2},{value:"Alternatives",id:"alternatives",level:2},{value:"Soft updates",id:"soft-updates",level:2},{value:"Log-structured file systems",id:"log-structured-file-systems",level:2},{value:"Copy-on-write file systems",id:"copy-on-write-file-systems",level:2},{value:"ZFS",id:"zfs",level:2},{value:"ZFSis a combined file system and logical volume manager designed by Sun Microsystems. ZFS is scalable, and includes extensive protection against data corruption, support for high storage capacities, efficient data compression, integration of the concepts of filesystem and volume management, snapshots and copy-on-write clones, continuous integrity checking and automatic repair, RAID-Z, native NFSv4ACLs, and can be very precisely configured. The two main implementations, by Oracle and by the OpenZFS project, are extremely similar, making ZFS widely available within Unix-like systems",id:"zfsis-a-combined-file-system-and-logical-volume-manager-designed-by-sun-microsystems-zfs-is-scalable-and-includes-extensive-protection-against-data-corruption-support-for-high-storage-capacities-efficient-data-compression-integration-of-the-concepts-of-filesystem-and-volume-management-snapshots-and-copy-on-write-clones-continuous-integrity-checking-and-automatic-repair-raid-z-native-nfsv4acls-and-can-be-very-precisely-configured-the-two-main-implementations-by-oracle-and-by-the-openzfs-project-are-extremely-similar-making-zfs-widely-available-within-unix-like-systems",level:2},{value:"Btrfs",id:"btrfs",level:2},{value:"ext4",id:"ext4",level:2},{value:"Features",id:"features",level:2}],c={toc:p},h="wrapper";function m(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"journaling-file-system"},"Journaling File System"),(0,n.kt)("p",null,"Ajournaling file systemis a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/File_system"},"file system")," that keeps track of changes not yet committed to the file system's main part by recording the intentions of such changes in a data structure known as a \"",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Journal_(computing)"},"journal"),'", which is usually a ',(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Circular_log"},"circular log"),". In the event of a system crash or power failure, such file systems can be brought back online more quickly with a lower likelihood of becoming corrupted.\nDepending on the actual implementation, a journaling file system may only keep track of stored ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Metadata"},"metadata"),", resulting in improved performance at the expense of increased possibility for data corruption. Alternatively, a journaling file system may track both stored data and related metadata, while some implementations allow selectable behavior in this regard."),(0,n.kt)("h2",{id:"rationale"},"Rationale"),(0,n.kt)("p",null,"Updating file systems to reflect changes to files and directories usually requires many separate write operations. This makes it possible for an interruption (like a power failure or system ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Crash_(computing)"},"crash"),") between writes to leave data structures in an invalid intermediate state.\nFor example, deleting a file on a Unix file system involves three steps:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Removing its directory entry.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Releasing the ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inode"},"inode")," to the pool of free inodes.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Returning all disk blocks to the pool of free disk blocks.\nIf a crash occurs after step 1 and before step 2, there will be an orphaned inode and hence a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Storage_leak"},"storage leak"),"; if a crash occurs between steps 2 and 3, then the blocks previously used by the file cannot be used for new files, effectively decreasing the storage capacity of the file system. Re-arranging the steps does not help, either. If step 3 preceded step 1, a crash between them could allow the file's blocks to be reused for a new file, meaning the partially deleted file would contain part of the contents of another file, and modifications to either file would show up in both. On the other hand, if step 2 preceded step 1, a crash between them would cause the file to be inaccessible, despite appearing to exist.\nDetecting and recovering from such inconsistencies normally requires a complete ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms#walk"},"walk")," of its data structures, for example by a tool such as ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fsck"},"fsck"),"(the file system checker).This must typically be done before the file system is next mounted for read-write access. If the file system is large and if there is relatively little I/O bandwidth, this can take a long time and result in longer downtimes if it blocks the rest of the system from coming back online.\nTo prevent this, a journaled file system allocates a special area - the journal - in which it records the changes it will make ahead of time. After a crash, recovery simply involves reading the journal from the file system and replaying changes from this journal until the file system is consistent again. The changes are thus said to be ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Atomicity_(database_systems)"},"atomic"),"(not divisible) in that they either succeed (succeeded originally or are replayed completely during recovery), or are not replayed at all (are skipped because they had not yet been completely written to the journal before the crash occurred)."))),(0,n.kt)("h2",{id:"techniques"},"Techniques"),(0,n.kt)("p",null,"Some file systems allow the journal to grow, shrink and be re-allocated just as a regular file, while others put the journal in a contiguous area or a hidden file that is guaranteed not to move or change size while the file system is mounted. Some file systems may also allowexternal journalson a separate device, such as a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Solid-state_drive"},"solid-state drive")," or battery-backed non-volatile RAM. Changes to the journal may themselves be journaled for additional redundancy, or the journal may be distributed across multiple physical volumes to protect against device failure.\nThe internal format of the journal must guard against crashes while the journal itself is being written to. Many journal implementations (such as the JBD2 layer in ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ext4"},"ext4"),") bracket every change logged with a checksum, on the understanding that a crash would leave a partially written change with a missing (or mismatched) checksum that can simply be ignored when replaying the journal at next remount."),(0,n.kt)("h2",{id:"physical-journals"},"Physical journals"),(0,n.kt)("p",null,"Aphysical journallogs an advance copy of every block that will later be written to the main file system. If there is a crash when the main file system is being written to, the write can simply be replayed to completion when the file system is next mounted. If there is a crash when the write is being logged to the journal, the partial write will have a missing or mismatched checksum and can be ignored at next mount.\nPhysical journals impose a significant performance penalty because every changed block must be committedtwiceto storage, but may be acceptable when absolute fault protection is required."),(0,n.kt)("h2",{id:"logical-journals"},"Logical journals"),(0,n.kt)("p",null,"Alogical journalstores only changes to file ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Metadata"},"metadata")," in the journal, and trades fault tolerance for substantially better write performance. A file system with a logical journal still recovers quickly after a crash, but may allow unjournaled file data and journaled metadata to fall out of sync with each other, causing data corruption.\nFor example, appending to a file may involve three separate writes to:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The file's ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inode"},"inode"),", to note in the file's metadata that its size has increased.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The free space map, to mark out an allocation of space for the to-be-appended data.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The newly allocated space, to actually write the appended data.\nIn a metadata-only journal, step 3 would not be logged. If step 3 was not done, but steps 1 and 2 are replayed during recovery, the file will be appended with garbage."))),(0,n.kt)("h2",{id:"write-hazards"},"Write hazards"),(0,n.kt)("p",null,"The write cache in most operating systems sorts its writes (using the ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elevator_algorithm"},"elevator algorithm")," or some similar scheme) to maximize throughput. To avoid an out-of-order write hazard with a metadata-only journal, writes for file data must be sorted so that they are committed to storage before their associated metadata. This can be tricky to implement because it requires coordination within the operating system kernel between the file system driver and write cache. An out-of-order write hazard can also occur if a device cannot write blocks immediately to its underlying storage, that is, it cannot flush its write-cache to disk due to deferred write being enabled.\nTo complicate matters, many mass storage devices have their own write caches, in which they may aggressively reorder writes for better performance. (This is particularly common on magnetic hard drives, which have large seek latencies that can be minimized with elevator sorting.) Some journaling file systems conservatively assume such write-reordering always takes place, and sacrifice performance for correctness by forcing the device to flush its cache at certain points in the journal (called barriers in ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ext3"},"ext3")," and ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ext4"},"ext4"),")."),(0,n.kt)("h2",{id:"alternatives"},"Alternatives"),(0,n.kt)("h2",{id:"soft-updates"},"Soft updates"),(0,n.kt)("p",null,"Some ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unix_File_System"},"UFS")," implementations avoid journaling and instead implement ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Soft_updates"},"soft updates"),": they order their writes in such a way that the on-disk file system is never inconsistent, or that the only inconsistency that can be created in the event of a crash is a storage leak. To recover from these leaks, the free space map is reconciled against a full walk of the file system at next mount. This ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"},"garbage collection")," is usually done in the background."),(0,n.kt)("h2",{id:"log-structured-file-systems"},"Log-structured file systems"),(0,n.kt)("p",null,"In ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Log-structured_file_system"},"log-structured file systems"),", the write-twice penalty does not apply because the journal itselfisthe file system: it occupies the entire storage device and is structured so that it can be traversed as would a normal file system."),(0,n.kt)("h2",{id:"copy-on-write-file-systems"},"Copy-on-write file systems"),(0,n.kt)("p",null,"Full ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Copy-on-write"},"copy-on-write")," file systems (such as ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/ZFS"},"ZFS")," and ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Btrfs"},"Btrfs"),") avoid in-place changes to file data by writing out the data in newly allocated blocks, followed by updated metadata that would point to the new data and disown the old, followed by metadata pointing to that, and so on up to the superblock, or the root of the file system hierarchy. This has the same correctness-preserving properties as a journal, without the write-twice overhead.\n",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Journaling_file_system"},"https://en.wikipedia.org/wiki/Journaling_file_system")),(0,n.kt)("h2",{id:"zfs"},"ZFS"),(0,n.kt)("h2",{id:"zfsis-a-combined-file-system-and-logical-volume-manager-designed-by-sun-microsystems-zfs-is-scalable-and-includes-extensive-protection-against-data-corruption-support-for-high-storage-capacities-efficient-data-compression-integration-of-the-concepts-of-filesystem-and-volume-management-snapshots-and-copy-on-write-clones-continuous-integrity-checking-and-automatic-repair-raid-z-native-nfsv4acls-and-can-be-very-precisely-configured-the-two-main-implementations-by-oracle-and-by-the-openzfs-project-are-extremely-similar-making-zfs-widely-available-within-unix-like-systems"},"ZFSis a combined ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/File_system"},"file system")," and ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Logical_volume_management"},"logical volume manager")," designed by ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Sun_Microsystems"},"Sun Microsystems"),". ZFS is scalable, and includes extensive protection against ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Data_corruption"},"data corruption"),", support for high storage capacities, efficient data compression, integration of the concepts of filesystem and ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Volume_(computing)"},"volume management"),", ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Snapshot_(computer_storage)"},"snapshots")," and ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Copy-on-write"},"copy-on-write")," clones, continuous integrity checking and automatic repair, ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/ZFS#RAID-Z"},"RAID-Z"),", native ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/NFSv4"},"NFSv4"),(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Access_control_lists"},"ACLs"),", and can be very precisely configured. The two main implementations, by ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Oracle_Corporation"},"Oracle")," and by the ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/OpenZFS"},"OpenZFS")," project, are extremely similar, making ZFS widely available within ",(0,n.kt)("a",{parentName:"h2",href:"https://en.wikipedia.org/wiki/Unix-like"},"Unix-like")," systems"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/ZFS"},"https://en.wikipedia.org/wiki/ZFS")),(0,n.kt)("h2",{id:"btrfs"},"Btrfs"),(0,n.kt)("p",null,"Btrfs, an abbreviation for ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/B-tree"},"b-tree"),(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/File_system"},"file system"),', (pronounced as "butter fuss","better F S","butter F S","b-tree F S", or simply by spelling it out) is a file system based on the ',(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Copy-on-write#In_computer_storage"},"copy-on-write"),"(COW) principle, initially designed at ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Oracle_Corporation"},"Oracle Corporation")," for use in ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linux"},"Linux"),". The development of Btrfs began in 2007, and since November 2013 the file system's on-disk format has been declared stable in the Linux kernel.\nBtrfs is intended to address the lack of ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pool_(computer_science)"},"pooling"),", ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Snapshot_(computer_storage)"},"snapshots"),", ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Checksum"},"checksums"),", and integral multi-device spanning in ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linux_file_systems"},"Linux file systems"),'.Chris Mason, the principal Btrfs author, has stated that its goal was "to let Linux scale for the storage that will be available. Scaling is not just about addressing the storage but also means being able to administer and to manage it with a clean interface that lets people see what\'s being used and makes it more reliable".\n',(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Btrfs"},"https://en.wikipedia.org/wiki/Btrfs")),(0,n.kt)("h2",{id:"ext4"},"ext4"),(0,n.kt)("p",null,"The ",(0,n.kt)("strong",{parentName:"p"},"ext4 journaling file system")," or ",(0,n.kt)("strong",{parentName:"p"},"fourth extended filesystem")," is a ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Journaling_file_system"},"journaling file system")," for ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linux"},"Linux"),", developed as the successor to ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ext3"},"ext3"),"."),(0,n.kt)("h2",{id:"features"},"Features"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Large file system"),(0,n.kt)("li",{parentName:"ul"},"Extents"),(0,n.kt)("li",{parentName:"ul"},"Backward compatibility"),(0,n.kt)("li",{parentName:"ul"},"Persistent pre-allocation"),(0,n.kt)("li",{parentName:"ul"},"Delayed allocation"),(0,n.kt)("li",{parentName:"ul"},"Unlimited number of subdirectories"),(0,n.kt)("li",{parentName:"ul"},"Journal checksums"),(0,n.kt)("li",{parentName:"ul"},"Metadata checksumming"),(0,n.kt)("li",{parentName:"ul"},"Faster file-system checking"),(0,n.kt)("li",{parentName:"ul"},"Multiblock allocator"),(0,n.kt)("li",{parentName:"ul"},"Improved timestamps"),(0,n.kt)("li",{parentName:"ul"},"Project quotas"),(0,n.kt)("li",{parentName:"ul"},"Transparent encryption"),(0,n.kt)("li",{parentName:"ul"},"Lazy initialization"),(0,n.kt)("li",{parentName:"ul"},"Write barriers")))}m.isMDXComponent=!0}}]);