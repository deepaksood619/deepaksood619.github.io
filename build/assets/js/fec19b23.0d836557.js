"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[32890],{603905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var i=a(667294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},s=Object.keys(e);for(i=0;i<s.length;i++)a=s[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)a=s[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var h=i.createContext({}),l=function(e){var t=i.useContext(h),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=l(e.components);return i.createElement(h.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,h=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=l(a),d=n,m=p["".concat(h,".").concat(d)]||p[d]||u[d]||s;return a?i.createElement(m,o(o({ref:t},c),{},{components:a})):i.createElement(m,o({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,o=new Array(s);o[0]=d;var r={};for(var h in t)hasOwnProperty.call(t,h)&&(r[h]=t[h]);r.originalType=e,r[p]="string"==typeof e?e:n,o[1]=r;for(var l=2;l<s;l++)o[l]=a[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},724404:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var i=a(487462),n=(a(667294),a(603905));const s={},o="Hashing",r={unversionedId:"data-structures/hashtable/hashing",id:"data-structures/hashtable/hashing",title:"Hashing",description:"Hash Function",source:"@site/docs/data-structures/hashtable/hashing.md",sourceDirName:"data-structures/hashtable",slug:"/data-structures/hashtable/hashing",permalink:"/data-structures/hashtable/hashing",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/hashtable/hashing.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hashing Techniques",permalink:"/data-structures/hashtable/hashing-techniques"},next:{title:"HyperLogLog",permalink:"/data-structures/hashtable/hyperloglog"}},h={},l=[{value:"Hash Function",id:"hash-function",level:2},{value:"Consistent Hashing",id:"consistent-hashing",level:2},{value:"Modular based hashing",id:"modular-based-hashing",level:2},{value:"Applications",id:"applications",level:2},{value:"How to choose n = # of buckets (When using modulus to hash values to buckets)",id:"how-to-choose-n---of-buckets-when-using-modulus-to-hash-values-to-buckets",level:2},{value:"The load of a hash table",id:"the-load-of-a-hash-table",level:2},{value:"alpha = # of objects in hash table / # of buckets of hash table",id:"alpha---of-objects-in-hash-table---of-buckets-of-hash-table",level:2},{value:"Solution to pathological data set",id:"solution-to-pathological-data-set",level:2},{value:"Universal Hashing",id:"universal-hashing",level:2},{value:"Perfect Hash Function",id:"perfect-hash-function",level:2},{value:"Hashing Integer Data Types",id:"hashing-integer-data-types",level:2},{value:"Hashing Variable Length Data",id:"hashing-variable-length-data",level:2},{value:"2-choice Hashing",id:"2-choice-hashing",level:2},{value:"2-left Hashing",id:"2-left-hashing",level:2},{value:"Hash Table Implementations",id:"hash-table-implementations",level:2},{value:"Locality Sensitive Hashing (LSH)",id:"locality-sensitive-hashing-lsh",level:2},{value:"Further Reading",id:"further-reading",level:2}],c={toc:l},p="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"hashing"},"Hashing"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial"},"https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial")),(0,n.kt)("h2",{id:"hash-function"},"Hash Function"),(0,n.kt)("p",null,"A ",(0,n.kt)("strong",{parentName:"p"},"hash function")," is any ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Function_(mathematics)"},"function")," that can be used to map ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_(computing)"},"data")," of arbitrary size to data of fixed size. The values returned by a hash function are called",(0,n.kt)("em",{parentName:"p"},"hash values"),",",(0,n.kt)("em",{parentName:"p"},"hash codes"),",",(0,n.kt)("em",{parentName:"p"},"digests"),", or simply ",(0,n.kt)("em",{parentName:"p"},"hashes"),". The values are used to index a fixed-size table called a",(0,n.kt)("em",{parentName:"p"},"hash table"),". Use of a hash function to index a hash table is called ",(0,n.kt)("em",{parentName:"p"},"hashing")," or ",(0,n.kt)("em",{parentName:"p"},"scatter storage addressing"),"."),(0,n.kt)("h2",{id:"consistent-hashing"},"Consistent Hashing"),(0,n.kt)("p",null,"Consistent Hashing is a special kind of hashing such that when a hash table is resized, only K/n keys need to be remapped on average, where K is the number of the keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and slots are defined by a modular operation.\n",(0,n.kt)("a",{parentName:"p",href:"https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf"},"https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.toptal.com/big-data/consistent-hashing"},"https://www.toptal.com/big-data/consistent-hashing")),(0,n.kt)("h2",{id:"modular-based-hashing"},"Modular based hashing"),(0,n.kt)("h2",{id:"applications"},"Applications"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Associative arrays:")," Hash tables are commonly used to implement many types of in-memory tables. They are used to implement associative arrays (arrays whose indices are arbitrary strings or other complicated objects)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Database indexing:")," Hash tables may also be used as disk-based data structures and database indices (such as in dbm)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Caches:")," Hash tables can be used to implement caches i.e. auxiliary data tables that are used to speed up the access to data, which is primarily stored in slower media."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Object representation:")," Several dynamic languages, such as Perl, Python, JavaScript, and Ruby use hash tables to implement objects."),(0,n.kt)("li",{parentName:"ul"},"Hash Functions are used in various algorithms to make their computing faster"),(0,n.kt)("li",{parentName:"ul"},"De-Duplication",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Remove duplicates",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Report unique visitors to web site"),(0,n.kt)("li",{parentName:"ul"},"avoid duplicates in search results"),(0,n.kt)("li",{parentName:"ul"},"Do not crawl same page twice"))))),(0,n.kt)("li",{parentName:"ul"},"Symbol tables in compilers"),(0,n.kt)("li",{parentName:"ul"},"Blocking network traffic"),(0,n.kt)("li",{parentName:"ul"},"Search algorithms (e.g. game tree exploration)",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"use hash table to avoid exploring any configuration (e.g. arrangement of chess pieces) more than once")))),(0,n.kt)("h2",{id:"how-to-choose-n---of-buckets-when-using-modulus-to-hash-values-to-buckets"},"How to choose n = # of buckets (When using modulus to hash values to buckets)"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Choose n to be prime (should be few factors, within constant factor of # of objects in table)")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"not too close to a power of 2")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"not too close to a power of 10"))),(0,n.kt)("h2",{id:"the-load-of-a-hash-table"},"The load of a hash table"),(0,n.kt)("h2",{id:"alpha---of-objects-in-hash-table---of-buckets-of-hash-table"},"alpha = # of objects in hash table / # of buckets of hash table"),(0,n.kt)("p",null,"Question - which hash table implementation strategy is feasible for load factors larger than 1 (Answer - Only chaining, because # of objects are greater than # of buckets, so only using linked list for collision can be used)\nTherefore load factor for a hash table must be << 1, for constant time operations, since if chaining is used, than we have to use exhaustive search for getting values whose key hash to same place\nSo if load factor increases, we increase the number of buckets.\nA super hash function, that can handle all types of data ",(0,n.kt)("strong",{parentName:"p"},"does not exists")," (for every hash function there exists a pathological data set)"),(0,n.kt)("h2",{id:"solution-to-pathological-data-set"},"Solution to pathological data set"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use a cryptographic hash function (e.g. SHA-2)")),(0,n.kt)("p",null,"This works because it's infeasible to reverse engineer a pathological data set"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use randomization")),(0,n.kt)("p",null,'Deisgn a family of hash function, and choose randomly. Such that, for all data sets S, "almost all" functions spread out "pretty evenly"'),(0,n.kt)("h2",{id:"universal-hashing"},"Universal Hashing"),(0,n.kt)("h2",{id:"perfect-hash-function"},"Perfect Hash Function"),(0,n.kt)("p",null,"A hash function that maps each item into a unique slot is referred to as a perfect hash function."),(0,n.kt)("h2",{id:"hashing-integer-data-types"},"Hashing Integer Data Types"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Identity Hash Function")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Trivial Hash Function")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Folding Method"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The folding method for constructing the hash functions begins by dividing the item into equal-size pieces (the last piece may not be of equal size)"),(0,n.kt)("li",{parentName:"ul"},"These pieces are then added together to give the resulting hash value.- ",(0,n.kt)("strong",{parentName:"li"},"Mid-square method")),(0,n.kt)("li",{parentName:"ul"},"We first square the item, and then extract some portion of the resulting digits."),(0,n.kt)("li",{parentName:"ul"},"For example, if the item were 44, we would first compute 44^2^ = 1936"),(0,n.kt)("li",{parentName:"ul"},"By extracting the middle two digits, 93, and performing the remainder step, we get 93 % 11 = 5- ",(0,n.kt)("strong",{parentName:"li"},"Division hashing")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Algebraic coding")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Unique permuatation hashing")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Multiplicative hashing")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Fibonacci hashing")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Zobrist hashing"))),(0,n.kt)("h2",{id:"hashing-variable-length-data"},"Hashing Variable Length Data"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Middle and ends")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Character folding")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Word length folding")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Radix conversion hashing")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Rolling hash"))),(0,n.kt)("h2",{id:"2-choice-hashing"},"2-choice Hashing"),(0,n.kt)("p",null,"Explain the 2-choice hashing algorithm for exact-match hash tables."),(0,n.kt)("p",null,"In the 2-choice hashing algorithm, we use two independent hash functions to compute two separate indices into the hash table. Then, we look at both indices and find whichever one has lower occupancy.We insert a new element at this index. To lookup an element, we again hash the element using both hash functons to find 2 indices, and compare the element against the elements stored at each of the 2 indices.\nOn what metric is the 2-choice algorithm better than the standard hashing algorithm? Why?"),(0,n.kt)("p",null,"The 2-choice algorithm is better on the metric of likelihood of overflowing the hash tables given a certain number of inserts into the hash table (equivalently, given a certain occupancy ratio). This is because the 2-choice algorithm explicitly favors the hash table location that has lower occupancy, which means that it is less likely to overflow an already full location in the hash table. The standard hashing algorithm, on the other hand, pays no attention to how occupied a location is.\n",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/2-choice_hashing"},"https://en.wikipedia.org/wiki/2-choice_hashing")),(0,n.kt)("h2",{id:"2-left-hashing"},"2-left Hashing"),(0,n.kt)("p",null,"A ",(0,n.kt)("a",{parentName:"p",href:"https://xlinux.nist.gov/dads/HTML/dictionary.html"},"dictionary")," implemented with two ",(0,n.kt)("a",{parentName:"p",href:"https://xlinux.nist.gov/dads/HTML/hashtab.html"},"hash tables")," of equal size, T1and T2, and two different ",(0,n.kt)("a",{parentName:"p",href:"https://xlinux.nist.gov/dads/HTML/hash.html"},"hash functions"),", h1and h2. A new ",(0,n.kt)("a",{parentName:"p",href:"https://xlinux.nist.gov/dads/HTML/key.html"},"key")," is put in table 2 only if there are fewer (colliding) keys at T2 ","[h2(key)]"," than at T1 ","[h1(key)]",", otherwise it is put in table 1. With n keys and two tables of size n/2, the most collisions is 0.69... log2ln n +",(0,n.kt)("a",{parentName:"p",href:"https://xlinux.nist.gov/dads/HTML/bigOnotation.html"},"O"),"(1) with high probability."),(0,n.kt)("h2",{id:"hash-table-implementations"},"Hash Table Implementations"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Using Array"),(0,n.kt)("li",{parentName:"ul"},"Alternatively, we can implement the hash table with a binary search tree. We can then guarantee an 0(log n) lookup time, since we can keep the tree balanced. Additionally, we may use less space, since a large array no longer needs to be allocated in the very beginning.")),(0,n.kt)("h2",{id:"locality-sensitive-hashing-lsh"},"Locality Sensitive Hashing (LSH)"),(0,n.kt)("p",null,'In computer science, locality-sensitive hashing(LSH) is an algorithmic technique that hashes similar input items into the same "buckets" with high probability.(The number of buckets are much smaller than the universe of possible input items.)Since similar items end up in the same buckets, this technique can be used for ',(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cluster_analysis"},"data clustering")," and ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Nearest_neighbor_search"},"nearest neighbor search"),". It differs from ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hash_function"},"conventional hashing techniques")," in that hash collisions are maximized, not minimized. Alternatively, the technique can be seen as a way to ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dimension_reduction"},"reduce the dimensionality")," of high-dimensional data; high-dimensional input items can be reduced to low-dimensional versions while preserving relative distances between items.\nHashing-based approximate ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Nearest_neighbor_search"},"nearest neighbor search")," algorithms generally use one of two main categories of hashing methods: either data-independent methods, such as locality-sensitive hashing (LSH); or data-dependent methods, such as ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Locality-preserving_hashing"},"Locality-preserving hashing"),"(LPH).\n",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Locality-sensitive_hashing"},"https://en.wikipedia.org/wiki/Locality-sensitive_hashing")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134"},"https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134")),(0,n.kt)("h2",{id:"further-reading"},"Further Reading"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Birthday Paradox"),(0,n.kt)("li",{parentName:"ul"},"Pigeonhole Principle\n",(0,n.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Hash_function"},"https://en.wikipedia.org/wiki/Hash_function"))))}u.isMDXComponent=!0}}]);