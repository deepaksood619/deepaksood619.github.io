"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[55650],{603905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(667294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,k=d["".concat(l,".").concat(u)]||d[u]||m[u]||r;return n?a.createElement(k,s(s({ref:t},p),{},{components:n})):a.createElement(k,s({ref:t},p))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},61545:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=n(487462),o=(n(667294),n(603905));const r={},s="Optimizing Locking Operations",i={unversionedId:"databases/sql-databases/mysql/optimizing-locking-operations",id:"databases/sql-databases/mysql/optimizing-locking-operations",title:"Optimizing Locking Operations",description:"- 8.11 Optimizing Locking Operations",source:"@site/docs/databases/sql-databases/mysql/optimizing-locking-operations.md",sourceDirName:"databases/sql-databases/mysql",slug:"/databases/sql-databases/mysql/optimizing-locking-operations",permalink:"/databases/sql-databases/mysql/optimizing-locking-operations",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/sql-databases/mysql/optimizing-locking-operations.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MySQL Triggers",permalink:"/databases/sql-databases/mysql/mysql-triggers"},next:{title:"Others",permalink:"/databases/sql-databases/mysql/others"}},l={},c=[{value:"Gap Locking",id:"gap-locking",level:2}],p={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"optimizing-locking-operations"},"Optimizing Locking Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"8.11 Optimizing Locking Operations"),(0,o.kt)("li",{parentName:"ul"},"8.11.2 Table Locking Issues"),(0,o.kt)("li",{parentName:"ul"},"8.11.3 Concurrent Inserts"),(0,o.kt)("li",{parentName:"ul"},"8.11.4 Metadata Locking"),(0,o.kt)("li",{parentName:"ul"},"8.11.5 External Locking")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Internal locking")," is performed within the MySQL server itself to manage contention for table contents by multiple threads. This type of locking is internal because it is performed entirely by the server and involves no other programs."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"External locking")," occurs when the server and other programs lock ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html"},"MyISAM")," table files to coordinate among themselves which program can access the tables at which time.\n8.11.1 Internal Locking Methods"),(0,o.kt)("p",null,"MySQL uses ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_row_lock"},(0,o.kt)("strong",{parentName:"a"},"row-level locking"))," forInnoDBtables to support simultaneous write access by multiple sessions, making them suitable for multi-user, highly concurrent, and OLTP applications."),(0,o.kt)("p",null,"To avoid ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock"},"deadlocks")," when performing multiple concurrent write operations on a singleInnoDBtable, acquire necessary locks at the start of the transaction by issuing aSELECT ... FOR UPDATEstatement for each group of rows expected to be modified, even if the data change statements come later in the transaction. If transactions modify or lock more than one table, issue the applicable statements in the same order within each transaction. Deadlocks affect performance rather than representing a serious error, becauseInnoDBautomatically ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock_detection"},"detects")," deadlock conditions and rolls back one of the affected transactions."),(0,o.kt)("p",null,"On high concurrency systems, ",(0,o.kt)("strong",{parentName:"p"},"deadlock detection can cause a slowdown when numerous threads wait for the same lock.")," At times, it may be ",(0,o.kt)("strong",{parentName:"p"},"more efficient to disable deadlock detection and rely on the ",(0,o.kt)("a",{parentName:"strong",href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout"},"innodb_lock_wait_timeout")," setting for transaction rollback")," when a deadlock occurs. Deadlock detection can be disabled using the ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect"},"innodb_deadlock_detect")," configuration option."),(0,o.kt)("p",null,"Advantages of row-level locking:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Fewer lock conflicts when different sessions access different rows."),(0,o.kt)("li",{parentName:"ul"},"Fewer changes for rollbacks."),(0,o.kt)("li",{parentName:"ul"},"Possible to lock a single row for a long time.")),(0,o.kt)("p",null,"MySQL uses ",(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_table_lock"},(0,o.kt)("strong",{parentName:"a"},"table-level locking"))," for MyISAM, MEMORY, and MERGE tables"),(0,o.kt)("h2",{id:"gap-locking"},"Gap Locking"),(0,o.kt)("p",null,"A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record."),(0,o.kt)("p",null,"A lock on a gap between index records, or a lock on the gap before the first or after the last index record. For example, SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; prevents other transactions from inserting a value of 15 into the column t.c1, whether or not there was already any such value in the column, because the gaps between all existing values in the range are locked. Contrast with record lock and next-key lock."),(0,o.kt)("p",null,"Gap locks are part of the tradeoff between performance and concurrency, and are used in some transaction isolation levels and not others."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap_lock"},"Gap Lock")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/32498437/deadlock-in-mysql-due-to-insert-by-multiple-threads"},"Deadlock in MySQL due to Insert by multiple threads")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"http://thushw.blogspot.com/2010/11/mysql-deadlocks-with-concurrent-inserts.html"},"mysql deadlocks with concurrent inserts")),(0,o.kt)("p",null,"It is possible to cause deadlocks in mysql (Innodb) on concurrent insert statements, without there being any transactions in progress. Deadlocks are possible even when the inserts don't collide on any key."),(0,o.kt)("p",null,"The deadlocks occur due to gap locking done by mysql. There are several reasons for gap locking, and in this particular case, it has to do with preserving a unique key constraint on an index. The situation presents itself to us this way: There is a unique key constraint on a column and we are doing an insert. Mysql has to make sure that the lock it takes is sufficient to prevent another concurrent insert from adding a record with the same key, thus breaking the unique key constraint."),(0,o.kt)("p",null,'Mysql innodb engine performs row locking on inserts. If column A has a unique key constraint, and we are adding the value "bbb" for column A in an insert statement, mysql needs to lock any gap in the index between the two current records where "bbb" will be inserted at.'),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html"},"Innodb locks set")))}m.isMDXComponent=!0}}]);