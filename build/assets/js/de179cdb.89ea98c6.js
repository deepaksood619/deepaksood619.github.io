"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[92074],{603905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(667294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=n.createContext({}),h=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=h(e.components);return n.createElement(o.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,l=e.originalType,o=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=h(a),p=s,m=d["".concat(o,".").concat(p)]||d[p]||c[p]||l;return a?n.createElement(m,i(i({ref:t},u),{},{components:a})):n.createElement(m,i({ref:t},u))}));function m(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var l=a.length,i=new Array(l);i[0]=p;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r[d]="string"==typeof e?e:s,i[1]=r;for(var h=2;h<l;h++)i[h]=a[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},449653:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>h});var n=a(487462),s=(a(667294),a(603905));const l={},i="Hash Tables",r={unversionedId:"data-structures/hashtable/hash-tables",id:"data-structures/hashtable/hash-tables",title:"Hash Tables",description:"hash tables, a data structure that achieves constant-time performance for core symbol table operations, provided that search keys are standard data types or simply defined.",source:"@site/docs/data-structures/hashtable/hash-tables.md",sourceDirName:"data-structures/hashtable",slug:"/data-structures/hashtable/hash-tables",permalink:"/data-structures/hashtable/hash-tables",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/hashtable/hash-tables.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hash Functions",permalink:"/data-structures/hashtable/hash-functions"},next:{title:"Hashing Techniques",permalink:"/data-structures/hashtable/hashing-techniques"}},o={},h=[{value:"Issues",id:"issues",level:2},{value:"Classic space-time tradeoff",id:"classic-space-time-tradeoff",level:2},{value:"Computing the hash function",id:"computing-the-hash-function",level:2},{value:"NOTE: Always try to use all the data for calculating hash (try to involve all the bits for computing the hash function)",id:"note-always-try-to-use-all-the-data-for-calculating-hash-try-to-involve-all-the-bits-for-computing-the-hash-function",level:2},{value:"Modular Hashing",id:"modular-hashing",level:2},{value:"Uniform hashing assumption",id:"uniform-hashing-assumption",level:2},{value:"Collisions - Two distinct keys hashing to same index",id:"collisions---two-distinct-keys-hashing-to-same-index",level:2},{value:"Collision Resolution methods",id:"collision-resolution-methods",level:2},{value:"Problems",id:"problems",level:2},{value:"Optimization",id:"optimization",level:2},{value:"Hash Table Context",id:"hash-table-context",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Integer - return value",id:"integer---return-value",level:2},{value:"Double - convert 64 bit to 32 bit by XOR(^) MSB 32 bot LSB 32",id:"double---convert-64-bit-to-32-bit-by-xor-msb-32-bot-lsb-32",level:2},{value:"Boolean - return fixed numbers",id:"boolean---return-fixed-numbers",level:2},{value:"Strings - Use Horner&#39;s method to hash string and cache the hash value in an instance variable for better performance, since strings are immutable",id:"strings---use-horners-method-to-hash-string-and-cache-the-hash-value-in-an-instance-variable-for-better-performance-since-strings-are-immutable",level:2},{value:"User-defined types - Include all method variables in the hash code evaluation. Use hashCode implementation for each data type with some small prime number and multiply by 31",id:"user-defined-types---include-all-method-variables-in-the-hash-code-evaluation-use-hashcode-implementation-for-each-data-type-with-some-small-prime-number-and-multiply-by-31",level:2}],u={toc:h},d="wrapper";function c(e){let{components:t,...l}=e;return(0,s.kt)(d,(0,n.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"hash-tables"},"Hash Tables"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"hash tables, a data structure that achieves constant-time performance for core symbol table operations, provided that search keys are standard data types or simply defined."),"\nHash tables utilize hashing to form a data structure.\nHash tables use an associative method to store data by using what is known as a key-value lookup system. All that means is that, in a hash table, keys are mapped to unique values.\nThis system of organizing data results in a very fast way to find data efficiently. This is because since each key is mapped to a unique value -- once we know a key then we can find the associated value instantly.\nHash tables are extremely fast, having a time complexity that is in the order of O(1).\nA function that takes a key and reduces it to an integer (array index) to be mapped to an array."),(0,s.kt)("h2",{id:"issues"},"Issues"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Computing the hash function"),(0,s.kt)("li",{parentName:"ul"},"Equality test"),(0,s.kt)("li",{parentName:"ul"},"Collision resolution: Algorithm and data structure to handle two keys that hash to the same array index")),(0,s.kt)("h2",{id:"classic-space-time-tradeoff"},"Classic space-time tradeoff"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"No space limitation: trivial has function with key as index"),(0,s.kt)("li",{parentName:"ul"},"No time limitation: trivial collision resolution with sequential search")),(0,s.kt)("h2",{id:"computing-the-hash-function"},"Computing the hash function"),(0,s.kt)("p",null,"Scramble the keys uniformly to produce a table index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Efficiently computable"),(0,s.kt)("li",{parentName:"ul"},"Each table index equally likely for each key")),(0,s.kt)("h2",{id:"note-always-try-to-use-all-the-data-for-calculating-hash-try-to-involve-all-the-bits-for-computing-the-hash-function"},"NOTE: Always try to use all the data for calculating hash (try to involve all the bits for computing the hash function)"),(0,s.kt)("h2",{id:"modular-hashing"},"Modular Hashing"),(0,s.kt)("p",null,"Hash code - An int between -2^31 and 2^31 - 1"),(0,s.kt)("p",null,"Hash function - An int between 0 to M-1 (for use as array index)"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"First convert from negative to positive and then use modulus to get it to the size.")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"image",src:a(919344).Z,width:"950",height:"176"})),(0,s.kt)("h2",{id:"uniform-hashing-assumption"},"Uniform hashing assumption"),(0,s.kt)("p",null,"Each key is equally likely to hash to an integer between 0 to M - 1."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Bins and balls Model: Throw balls uniformly at random into M bins")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Birthday problem: Expect two balls in the same bin after ~ sqrt(pie M / 2) tosses.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Coupon collector problem: Expect every bin has >= 1 ball after ~ M ln M tosses.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Load balancing: After M tosses, expect most loaded bin has theta(log M / log log M) balls."))),(0,s.kt)("h2",{id:"collisions---two-distinct-keys-hashing-to-same-index"},"Collisions - Two distinct keys hashing to same index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Birthday problem: can't avoid collisions unless you have a ridiculous (quadratic) amount of memory."),(0,s.kt)("li",{parentName:"ul"},"Coupon collector + load balancing: collisions are evenly distributed")),(0,s.kt)("h2",{id:"collision-resolution-methods"},"Collision Resolution methods"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("strong",{parentName:"li"},"Separate Chaining symbol table"))),(0,s.kt)("p",null,"Use linked list for storing the values that hash to the same value.\n",(0,s.kt)("img",{alt:"image",src:a(572489).Z,width:"832",height:"774"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Easier to implement delete"),(0,s.kt)("li",{parentName:"ul"},"Performance degrades gracefully"),(0,s.kt)("li",{parentName:"ul"},"Clustering less sensitive to poorly-designed hash function")),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("strong",{parentName:"li"},"Linear Probing (Open addressing)"))),(0,s.kt)("p",null,"When a new key collides, find next empty slot, and put it there\n",(0,s.kt)("img",{alt:"image",src:a(513017).Z,width:"1054",height:"638"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Less wasted space"),(0,s.kt)("li",{parentName:"ul"},"Better cache performance")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"image",src:a(105155).Z,width:"1020",height:"642"}),"\n",(0,s.kt)("img",{alt:"image",src:a(7157).Z,width:"1036",height:"812"})),(0,s.kt)("h2",{id:"problems"},"Problems"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Clustering"),(0,s.kt)("li",{parentName:"ul"},"Hash functions are often publically available (like java) so if some client has implemented back-end in java, then an adversary can send some data that can make the Hashing perform poorly and can make the system crash")),(0,s.kt)("h2",{id:"optimization"},"Optimization"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Create a bigger hash table when older hash table gets full and rehash all old values to new hash table")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Can use Consistent Hashing Functions -"))),(0,s.kt)("p",null,"Consistent Hashing is a special kind of hashing such that when a hash table is resized, only K/n keys need to be remapped on average, where K is the number of the keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and slots are defined by a modular operation."),(0,s.kt)("h2",{id:"hash-table-context"},"Hash Table Context"),(0,s.kt)("p",null,'One-way hash function - "Hard" to find a key that will hash to a desired value (or two keys that hash to same value)'),(0,s.kt)("p",null,"Ex - MD4, MD5, SHA-0, SHA-1, SHA-2, WHIRLPOOL, RIPEMD-160"),(0,s.kt)("p",null,"Applications - Digital fingerprint, message digest, storing passwords.\nHash tables vs. balanced search trees"),(0,s.kt)("p",null,"Hash tables."),(0,s.kt)("p",null,"\u30fbSimpler to code."),(0,s.kt)("p",null,"\u30fbNo effective alternative for unordered keys."),(0,s.kt)("p",null,"\u30fbFaster for simple keys (a few arithmetic ops versus log ",(0,s.kt)("em",{parentName:"p"},"N")," compares)."),(0,s.kt)("p",null,"\u30fbBetter system support in Java for strings (e.g., cached hash code).\nBalanced search trees."),(0,s.kt)("p",null,"\u30fbStronger performance guarantee."),(0,s.kt)("p",null,"\u30fbSupport for ordered ST operations."),(0,s.kt)("p",null,"\u30fbEasier to implement compareTo() correctly than equals() and hashCode().\nJava system includes both."),(0,s.kt)("p",null,"\u30fbRed-black BSTs: java.util.TreeMap, java.util.TreeSet."),(0,s.kt)("p",null,"\u30fbHash tables: java.util.HashMap, java.util.IdentityHashMap."),(0,s.kt)("h2",{id:"implementation"},"Implementation"),(0,s.kt)("p",null,"All java classes inherit a method hashCode(), which returns a 32 bit int"),(0,s.kt)("h2",{id:"integer---return-value"},"Integer - return value"),(0,s.kt)("h2",{id:"double---convert-64-bit-to-32-bit-by-xor-msb-32-bot-lsb-32"},"Double - convert 64 bit to 32 bit by XOR(^) MSB 32 bot LSB 32"),(0,s.kt)("h2",{id:"boolean---return-fixed-numbers"},"Boolean - return fixed numbers"),(0,s.kt)("h2",{id:"strings---use-horners-method-to-hash-string-and-cache-the-hash-value-in-an-instance-variable-for-better-performance-since-strings-are-immutable"},"Strings - Use Horner's method to hash string and cache the hash value in an instance variable for better performance, since strings are immutable"),(0,s.kt)("h2",{id:"user-defined-types---include-all-method-variables-in-the-hash-code-evaluation-use-hashcode-implementation-for-each-data-type-with-some-small-prime-number-and-multiply-by-31"},"User-defined types - Include all method variables in the hash code evaluation. Use hashCode implementation for each data type with some small prime number and multiply by 31"),(0,s.kt)("p",null,"\u30fbCombine each significant field using the 31",(0,s.kt)("em",{parentName:"p"},"x")," + ",(0,s.kt)("em",{parentName:"p"},"y")," rule."),(0,s.kt)("p",null,"\u30fbIf field is a primitive type, use wrapper type hashCode()."),(0,s.kt)("p",null,"\u30fbIf field is null, return 0."),(0,s.kt)("p",null,"\u30fbIf field is a reference type, use hashCode()."),(0,s.kt)("p",null,"\u30fbIf field is an array, apply to each entry. or use Arrays.deepHashCode()\n",(0,s.kt)("a",{parentName:"p",href:"http://blog.chapagain.com.np/hash-table-implementation-in-python-data-structures-algorithms"},"http://blog.chapagain.com.np/hash-table-implementation-in-python-data-structures-algorithms")))}c.isMDXComponent=!0},919344:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image1-544e3ac2328790d0ca1200275d58a5b9.jpg"},572489:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image2-a50ded56993991503458c634a371b7a7.jpg"},513017:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image3-04f78e7b11af27d954aa68e6b7ebf1c9.jpg"},105155:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image4-0df0a747062b3b81233ac4ce4e7b4fe2.jpg"},7157:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image5-a5a3f499bb6e4ca2d93fc6741d31e236.jpg"}}]);