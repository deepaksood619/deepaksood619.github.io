"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[86434],{603905:(e,a,t)=>{t.d(a,{Zo:()=>c,kt:()=>g});var n=t(667294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=n.createContext({}),d=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},c=function(e){var a=d(e.components);return n.createElement(l.Provider,{value:a},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=d(t),m=r,g=u["".concat(l,".").concat(m)]||u[m]||p[m]||s;return t?n.createElement(g,i(i({ref:a},c),{},{components:t})):n.createElement(g,i({ref:a},c))}));function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,i=new Array(s);i[0]=m;var o={};for(var l in a)hasOwnProperty.call(a,l)&&(o[l]=a[l]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<s;d++)i[d]=t[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},992171:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var n=t(487462),r=(t(667294),t(603905));const s={},i="Data Model",o={unversionedId:"databases/nosql-databases/cassandra/data-model",id:"databases/nosql-databases/cassandra/data-model",title:"Data Model",description:"- Partition Key",source:"@site/docs/databases/nosql-databases/cassandra/data-model.md",sourceDirName:"databases/nosql-databases/cassandra",slug:"/databases/nosql-databases/cassandra/data-model",permalink:"/databases/nosql-databases/cassandra/data-model",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/nosql-databases/cassandra/data-model.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CQL (Cassandra Query Language)",permalink:"/databases/nosql-databases/cassandra/cql-cassandra-query-language"},next:{title:"Design",permalink:"/databases/nosql-databases/cassandra/design"}},l={},d=[{value:"Querying Clustering Columns",id:"querying-clustering-columns",level:2},{value:"Bucketing",id:"bucketing",level:2},{value:"Others",id:"others",level:2}],c={toc:d},u="wrapper";function p(e){let{components:a,...s}=e;return(0,r.kt)(u,(0,n.Z)({},c,s,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-model"},"Data Model"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Partition Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Clustering Key")))),(0,r.kt)("h2",{id:"querying-clustering-columns"},"Querying Clustering Columns"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You must first provide a partition key"),(0,r.kt)("li",{parentName:"ul"},"Clustering columns can follow thereafter"),(0,r.kt)("li",{parentName:"ul"},"You can perform either equality (",(0,r.kt)("inlineCode",{parentName:"li"},"="),") or range queries (",(0,r.kt)("inlineCode",{parentName:"li"},"<, >"),") on clustering columns"),(0,r.kt)("li",{parentName:"ul"},"All equality comparisions must come before inequality comparisions"),(0,r.kt)("li",{parentName:"ul"},"Since data is sorted on disk, range searches are a binary search followed by a linear read")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:t(694207).Z,width:"1440",height:"1080"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:t(613206).Z,width:"1440",height:"1080"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:t(515939).Z,width:"1440",height:"1080"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:t(839050).Z,width:"1440",height:"1080"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:t(589327).Z,width:"1440",height:"1080"})),(0,r.kt)("h2",{id:"bucketing"},"Bucketing"),(0,r.kt)("p",null,"Bucketing is a strategy that lets us control how much data is stored in each partition as well as spread writes out to the entire cluster.\nTo break up this big partition, we'll leverage our first form of bucketing. We'll break our partitions into smaller ones based on time window. The ideal size is going to keep partitions under 100MB. For example, one partition per sensor per day would be a good choice if we're storing 50-75MB of data per day. We could just as easily use week (starting from some epoch), or month and year as long as the partitions stay under 100MB. Whatever the choice, leaving a little headroom for growth is a good idea.\nA variation on this technique is to use a different table per time window. For instance, using a table per month means you'd have twelve tables per year\nThis strategy has a primary benefit of being useful for archiving and quickly dropping old data. For instance, at the beginning of each month, we could archive last month's data to HDFS or S3 in parquet format, taking advantage of cheap storage for analytics purposes. When we don't need the data in Cassandra anymore, we can simply drop the table. You can probably see there's a bit of extra maintenance around creating and removing tables, so this method is really only useful if archiving is a requirement. There are other methods to archive data as well, so this style of bucketing may be unnecessary.\nThe second technique uses multiple partitions at any given time to fan out inserts to the entire cluster. The nice part about this strategy is we can use a single partition for low volume, and many partitions for high volume.\n",(0,r.kt)("a",{parentName:"p",href:"https://thelastpickle.com/blog/2017/08/02/time-series-data-modeling-massive-scale.html"},"https://thelastpickle.com/blog/2017/08/02/time-series-data-modeling-massive-scale.html")),(0,r.kt)("h2",{id:"others"},"Others"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://shermandigital.com/blog/designing-a-cassandra-data-model"},"https://shermandigital.com/blog/designing-a-cassandra-data-model")))}p.isMDXComponent=!0},694207:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Cassandra_Data-Model-image1-2de8dcc133b0fc3b12e2962bd0b2129c.jpg"},613206:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Cassandra_Data-Model-image2-1fde3796c49b08f55d0a294c4b519918.jpg"},515939:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Cassandra_Data-Model-image3-0ca2ebd223c13be323c5928853f9ec54.jpg"},839050:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Cassandra_Data-Model-image4-d6ae4dbe2da1a28697ba085dd17a46a7.jpg"},589327:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Cassandra_Data-Model-image5-39848e79ae4c0d3507c1a04255a14d70.jpg"}}]);