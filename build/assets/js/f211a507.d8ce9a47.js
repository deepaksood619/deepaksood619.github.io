"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[45977],{603905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(667294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),o=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=o(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},k=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=o(n),k=a,d=c["".concat(p,".").concat(k)]||c[k]||m[k]||l;return n?r.createElement(d,s(s({ref:t},u),{},{components:n})):r.createElement(d,s({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,s=new Array(l);s[0]=k;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var o=2;o<l;o++)s[o]=n[o];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}k.displayName="MDXCreateElement"},227708:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>o});var r=n(487462),a=(n(667294),n(603905));const l={},s="STL Containers",i={unversionedId:"languages/c++/stl-containers",id:"languages/c++/stl-containers",title:"STL Containers",description:"1. Sequences",source:"@site/docs/languages/c++/stl-containers.md",sourceDirName:"languages/c++",slug:"/languages/c++/stl-containers",permalink:"/languages/c++/stl-containers",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/languages/c++/stl-containers.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"printf",permalink:"/languages/c++/printf"},next:{title:"STL Iterators Algorithms",permalink:"/languages/c++/stl-iterators-algorithms"}},p={},o=[{value:"C++ Vector",id:"c-vector",level:2},{value:"C++ Lists",id:"c-lists",level:2},{value:"C++ Double-ended Queues",id:"c-double-ended-queues",level:2},{value:"C++ Priority Queues",id:"c-priority-queues",level:2},{value:"C++ Queues",id:"c-queues",level:2},{value:"C++ Stacks",id:"c-stacks",level:2},{value:"C++ Sets",id:"c-sets",level:2},{value:"C++ Multisets",id:"c-multisets",level:2},{value:"C++ Maps",id:"c-maps",level:2},{value:"C++ Multimaps",id:"c-multimaps",level:2},{value:"C++ Bitsets",id:"c-bitsets",level:2}],u={toc:o},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"stl-containers"},"STL Containers"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Sequences",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"C++ Vectors"),(0,a.kt)("li",{parentName:"ul"},"C++ Lists"),(0,a.kt)("li",{parentName:"ul"},"C++ Double-Ended Queues"))),(0,a.kt)("li",{parentName:"ol"},"Container Adapters",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"C++ Stacks"),(0,a.kt)("li",{parentName:"ul"},"C++ Queues"),(0,a.kt)("li",{parentName:"ul"},"C++ Priority Queues"))),(0,a.kt)("li",{parentName:"ol"},"Associative Containers",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"C++ Bitsets"),(0,a.kt)("li",{parentName:"ul"},"C++ Maps"),(0,a.kt)("li",{parentName:"ul"},"C++ Multimaps"),(0,a.kt)("li",{parentName:"ul"},"C++ Sets"),(0,a.kt)("li",{parentName:"ul"},"C++ Multisets")))),(0,a.kt)("h2",{id:"c-vector"},"C++ Vector"),(0,a.kt)("p",null,"Vectors are sequence containers representing arrays that can change in size."),(0,a.kt)("p",null,"Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size can change dynamically, with their storage being handled automatically by the container."),(0,a.kt)("p",null,"Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the container."),(0,a.kt)("p",null,"Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/vector::capacity"},"capacity")," greater than the storage strictly needed to contain its elements (i.e., its ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/vector::size"},"size"),"). Libraries can implement different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only happen at logarithmically growing intervals of ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/vector::size"},"size")," so that the insertion of individual elements at the end of the vector can be provided withamortized constant timecomplexity (see ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/vector::push_back"},"push_back"),")."),(0,a.kt)("p",null,"Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way."),(0,a.kt)("p",null,"Compared to the other dynamic sequence containers (",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/deque"},"deques"),", ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/list"},"lists")," and ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/forward_list"},"forward_lists"),"), vectors are very efficient accessing its elements (just like arrays) and relatively efficient adding or removing elements from its ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/vector::end"},"end"),". For operations that involve inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent iterators and references than ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/list"},"lists")," and ",(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/forward_list"},"forward_lists"),"."),(0,a.kt)("p",null,"Vector constructors\nVector operators\nassign\nat\nback\nbegin\ncapacity\nclear\nempty\nend\nerase\nfront\ninsert\nmax_size\npop_back\npush_back\nrbegin\nrend\nreserve\nresize\nsize\nswap"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/reference/vector/vector"},"http://www.cplusplus.com/reference/vector/vector")),(0,a.kt)("h2",{id:"c-lists"},"C++ Lists"),(0,a.kt)("p",null,"List constructors\nList operators\nContainer constructors & destructors\nassign\nback\nbegin\nclear\nempty\nend\nerase\nfront\ninsert\nmax_size\nmerge\npop_back\npop_front\npush_back\npush_front\nrbegin\nremove\nremove_if\nrend\nresize\nreverse\nsize\nsort\nsplice\nswap\nunique"),(0,a.kt)("h2",{id:"c-double-ended-queues"},"C++ Double-ended Queues"),(0,a.kt)("p",null,"Container constructors\nContainer operators\nContainer [] operator\nContainer constructors & destructors\nassign\nat\nback\nbegin\nclear\nempty\nend\nerase\nfront\ninsert\nmax_size\npop_back\npop_front\npush_back\npush_front\nrbegin\nrend\nresize\nsize\nswap"),(0,a.kt)("h2",{id:"c-priority-queues"},"C++ Priority Queues"),(0,a.kt)("p",null,"Priority queue constructors\nempty\npop\npush\nsize\ntop"),(0,a.kt)("h2",{id:"c-queues"},"C++ Queues"),(0,a.kt)("p",null,"Queue constructor\nback\nempty\nfront\npop\npush\nsize"),(0,a.kt)("h2",{id:"c-stacks"},"C++ Stacks"),(0,a.kt)("p",null,"Stack constructors\nempty\npop\npush\nsize\ntop"),(0,a.kt)("h2",{id:"c-sets"},"C++ Sets"),(0,a.kt)("p",null,"Sets are a part of the C++ STL. Sets are containers that store unique elements following a specific order. Here are some of the frequently used member functions of sets:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c++"},"Declaration\n    set<int>s; //Creates a set of integers\n\nSize\n    int length=s.size(); //Gives the size of the set\n\nInsert\n    s.insert(x); //Inserts an integer x into the set s\n\nErasing an element\n    s.erase(val); //Erases an integer val from the set s\n\nFinding an element\n    set<int>::iterator itr=s.find(val); //Gives the iterator to the element val if it is found otherwise returns s.end()\nEx: set<int>::iterator itr=s.find(100); //If 100 is not present then it==s.end()\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/set-in-cpp-stl"},"https://www.geeksforgeeks.org/set-in-cpp-stl")),(0,a.kt)("p",null,"Set constructors & destructors"),(0,a.kt)("p",null,"Set operators"),(0,a.kt)("p",null,"begin"),(0,a.kt)("p",null,"clear"),(0,a.kt)("p",null,"count"),(0,a.kt)("p",null,"empty"),(0,a.kt)("p",null,"end"),(0,a.kt)("p",null,"equal_range"),(0,a.kt)("p",null,"erase"),(0,a.kt)("p",null,"find"),(0,a.kt)("p",null,"insert"),(0,a.kt)("p",null,"key_comp"),(0,a.kt)("p",null,"lower_bound"),(0,a.kt)("p",null,"max_size"),(0,a.kt)("p",null,"rbegin"),(0,a.kt)("p",null,"rend"),(0,a.kt)("p",null,"size"),(0,a.kt)("p",null,"swap"),(0,a.kt)("p",null,"upper_bound"),(0,a.kt)("p",null,"value_comp"),(0,a.kt)("h2",{id:"c-multisets"},"C++ Multisets"),(0,a.kt)("p",null,"Container constructors & destructors"),(0,a.kt)("p",null,"Container operators"),(0,a.kt)("p",null,"begin"),(0,a.kt)("p",null,"clear"),(0,a.kt)("p",null,"count"),(0,a.kt)("p",null,"empty"),(0,a.kt)("p",null,"end"),(0,a.kt)("p",null,"equal_range"),(0,a.kt)("p",null,"erase"),(0,a.kt)("p",null,"find"),(0,a.kt)("p",null,"insert"),(0,a.kt)("p",null,"key_comp"),(0,a.kt)("p",null,"lower_bound"),(0,a.kt)("p",null,"max_size"),(0,a.kt)("p",null,"rbegin"),(0,a.kt)("p",null,"rend"),(0,a.kt)("p",null,"swap"),(0,a.kt)("p",null,"upper_bound"),(0,a.kt)("p",null,"value_comp"),(0,a.kt)("h2",{id:"c-maps"},"C++ Maps"),(0,a.kt)("p",null,"Maps are a part of the C++ STL.Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.The mainly used member functions of maps are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Map Template:\n",(0,a.kt)("inlineCode",{parentName:"p"},"std::map <key_type, data_type>"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Declaration:\n",(0,a.kt)("inlineCode",{parentName:"p"},"map<string,int>m; //Creates a map m where key_type is of type string and data_type is of type int."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Size:\n",(0,a.kt)("inlineCode",{parentName:"p"},"int length=m.size(); //Gives the size of the map."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Insert:\n",(0,a.kt)("inlineCode",{parentName:"p"},'m.insert(make_pair("hello",9)); //Here the pair is inserted into the map where the key is "hello" and the value associated with it is 9.'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Erasing an element:\n",(0,a.kt)("inlineCode",{parentName:"p"},"m.erase(val); //Erases the pair from the map where the key_type is val."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Finding an element:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-c++"},'map<string,int>::iterator itr=m.find(val); //Gives the iterator to the element val if it is found otherwise returns m.end()\nEx: map<string,int>::iterator itr=m.find("Maps"); //If Maps is not present as the key value then itr==m.end().\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},'Accessing the value stored in the key:\nTo get the value stored of the key "MAPS" we can do m ','["MAPS"]'," or we can get the iterator using the find function and then by itr->second we can access the value.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Updating an element"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c++"},"map<string,int>::iterator find_itr = students.find(name);\nif (find_itr == students.end()) {\n    students.insert(make_pair(name, marks));\n} else {\n    find_itr->second = find_itr->second + marks;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl"},"https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl")),(0,a.kt)("p",null,"Map Constructors & Destructors"),(0,a.kt)("p",null,"Map operators"),(0,a.kt)("p",null,"begin"),(0,a.kt)("p",null,"clear"),(0,a.kt)("p",null,"count"),(0,a.kt)("p",null,"empty"),(0,a.kt)("p",null,"end"),(0,a.kt)("p",null,"equal_range"),(0,a.kt)("p",null,"erase"),(0,a.kt)("p",null,"find"),(0,a.kt)("p",null,"insert"),(0,a.kt)("p",null,"key_comp"),(0,a.kt)("p",null,"lower_bound"),(0,a.kt)("p",null,"max_size"),(0,a.kt)("p",null,"rbegin"),(0,a.kt)("p",null,"rend"),(0,a.kt)("p",null,"size"),(0,a.kt)("p",null,"swap"),(0,a.kt)("p",null,"upper_bound"),(0,a.kt)("p",null,"value_comp"),(0,a.kt)("h2",{id:"c-multimaps"},"C++ Multimaps"),(0,a.kt)("p",null,"Multimap constructors & destructors"),(0,a.kt)("p",null,"Multimap operators"),(0,a.kt)("p",null,"begin"),(0,a.kt)("p",null,"clear"),(0,a.kt)("p",null,"count"),(0,a.kt)("p",null,"empty"),(0,a.kt)("p",null,"end"),(0,a.kt)("p",null,"find"),(0,a.kt)("p",null,"equal_range"),(0,a.kt)("p",null,"erase"),(0,a.kt)("p",null,"insert"),(0,a.kt)("p",null,"key_comp"),(0,a.kt)("p",null,"lower_bound"),(0,a.kt)("p",null,"max_size"),(0,a.kt)("p",null,"rbegin"),(0,a.kt)("p",null,"rend"),(0,a.kt)("p",null,"size"),(0,a.kt)("p",null,"swap"),(0,a.kt)("p",null,"upper_bound"),(0,a.kt)("p",null,"value_comp"),(0,a.kt)("h2",{id:"c-bitsets"},"C++ Bitsets"),(0,a.kt)("p",null,"Bitset Operators"),(0,a.kt)("p",null,"Bitset Constructors"),(0,a.kt)("p",null,"any"),(0,a.kt)("p",null,"count"),(0,a.kt)("p",null,"flip"),(0,a.kt)("p",null,"none"),(0,a.kt)("p",null,"reset"),(0,a.kt)("p",null,"set"),(0,a.kt)("p",null,"size"),(0,a.kt)("p",null,"test"),(0,a.kt)("p",null,"to_string"),(0,a.kt)("p",null,"to_ulong"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.cppreference.com/Cpp_STL_ReferenceManual.pdf"},"https://www.cppreference.com/Cpp_STL_ReferenceManual.pdf")))}m.isMDXComponent=!0}}]);