"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[82522],{603905:(t,e,n)=>{n.d(e,{Zo:()=>s,kt:()=>k});var a=n(667294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var p=a.createContext({}),m=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},s=function(t){var e=m(t.components);return a.createElement(p.Provider,{value:e},t.children)},c="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,o=t.originalType,p=t.parentName,s=l(t,["components","mdxType","originalType","parentName"]),c=m(n),d=i,k=c["".concat(p,".").concat(d)]||c[d]||u[d]||o;return n?a.createElement(k,r(r({ref:e},s),{},{components:n})):a.createElement(k,r({ref:e},s))}));function k(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var p in e)hasOwnProperty.call(e,p)&&(l[p]=e[p]);l.originalType=t,l[c]="string"==typeof t?t:i,r[1]=l;for(var m=2;m<o;m++)r[m]=n[m];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},878939:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var a=n(487462),i=(n(667294),n(603905));const o={},r="Union-Find Algorithm",l={unversionedId:"algorithms/general/union-find-algorithm",id:"algorithms/general/union-find-algorithm",title:"Union-Find Algorithm",description:"A union-find algorithm is an algorithm that performs two operations on a disjoint-set data structure -",source:"@site/docs/algorithms/general/union-find-algorithm.md",sourceDirName:"algorithms/general",slug:"/algorithms/general/union-find-algorithm",permalink:"/algorithms/general/union-find-algorithm",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/algorithms/general/union-find-algorithm.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Types of algorithms",permalink:"/algorithms/general/types-of-algorithms"},next:{title:"Graph Theory",permalink:"/algorithms/graphtheory/"}},p={},m=[{value:"Connected Components - Maximal set of objects that are mutually connected",id:"connected-components---maximal-set-of-objects-that-are-mutually-connected",level:2},{value:"Quick-find (Eager approach)",id:"quick-find-eager-approach",level:2},{value:"Quick-union (lazy approach)",id:"quick-union-lazy-approach",level:2},{value:"Optimizations",id:"optimizations",level:2},{value:"Complexity",id:"complexity",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"function <em>Find</em>(x)",id:"function-findx",level:2},{value:"function <em>Union</em>(x, y)",id:"function-unionx-y",level:2},{value:"Applications",id:"applications",level:2},{value:"Union-Find vs DFS",id:"union-find-vs-dfs",level:2},{value:"Static graph - DFS",id:"static-graph---dfs",level:2},{value:"Dynamic graph - Union-find",id:"dynamic-graph---union-find",level:2}],s={toc:m},c="wrapper";function u(t){let{components:e,...n}=t;return(0,i.kt)(c,(0,a.Z)({},s,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"union-find-algorithm"},"Union-Find Algorithm"),(0,i.kt)("p",null,"A union-find algorithm is an algorithm that performs two operations on a disjoint-set data structure -"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Find - Determine which subset a particular element is in.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Union - Join two subsets into a single subset."))),(0,i.kt)("p",null,"Used for ",(0,i.kt)("strong",{parentName:"p"},"dynamic connectivity")),(0,i.kt)("p",null,"Given a set on N objects -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Union Command - connect two objects")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Find/connected query command - is there a path connecting two objects"))),(0,i.kt)("p",null,'We assume "is connected to" is an equivalence relation:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reflexive: p is connected to p (Connected to itself)"),(0,i.kt)("li",{parentName:"ul"},"Symmetric: if p is connected to q, then q is connected to p"),(0,i.kt)("li",{parentName:"ul"},"Transitive: if p is connected to q and q is connected to r, then p is connected to r.")),(0,i.kt)("h2",{id:"connected-components---maximal-set-of-objects-that-are-mutually-connected"},"Connected Components - Maximal set of objects that are mutually connected"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Find query: Check if two objects are in the same component")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Union Command: Replace components containing two objects with their union."))),(0,i.kt)("h2",{id:"quick-find-eager-approach"},"Quick-find (Eager approach)"),(0,i.kt)("p",null,"Setting all the id to parent in Union step"),(0,i.kt)("h2",{id:"quick-union-lazy-approach"},"Quick-union (lazy approach)"),(0,i.kt)("p",null,"Only setting the last component's id to parent, Creating a tree like DS whose root represents the parent. Int root(int i) is used for finding the parent and checking if two elements are connected"),(0,i.kt)("h2",{id:"optimizations"},"Optimizations"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Weighted Quick Union (Union by rank / Union by height)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Modify quick-union to avoid tall trees"),(0,i.kt)("li",{parentName:"ul"},"Keep track of size of each tree"),(0,i.kt)("li",{parentName:"ul"},"Balance by joining root of smaller tree to root of larger tree"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Path Compression"))),(0,i.kt)("p",null,"Just after computing the root of p, set the id of each examined node to point to that root."),(0,i.kt)("h2",{id:"complexity"},"Complexity"),(0,i.kt)("p",null,"Without any optimizations, Union and Find will take O(n)"),(0,i.kt)("p",null,"With both optimizations i.e. Union by Rank and Path Compression, the time complexity is O(\u03b1(V)) where \u03b1 is inverse Ackermann function. This value is < 5 for any value of n that can be written in this physical universe, so disjoint set operations take place in essentially constant time"),(0,i.kt)("p",null,"Any sequence of M union-find ops on N objects makes <= c(N+M lg* N) array acccesses."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"N"),(0,i.kt)("th",{parentName:"tr",align:null},"lg* N"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"16"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"65536"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2^65536"),(0,i.kt)("td",{parentName:"tr",align:null},"5")))),(0,i.kt)("p",null,"Here lg* N is called Iterate log function (It's the number of times you have to take the log event to get 1)."),(0,i.kt)("p",null,"Analysis can be improved to N + M \u03b1 (M, N)"),(0,i.kt)("p",null,"Here \u03b1 is called Ackermann function."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Algorithm"),(0,i.kt)("th",{parentName:"tr",align:null},"worst-case time"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Quick-find"),(0,i.kt)("td",{parentName:"tr",align:null},"M N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Weighted QU"),(0,i.kt)("td",{parentName:"tr",align:null},"N + M log N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"QU + path compression"),(0,i.kt)("td",{parentName:"tr",align:null},"N + M log N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Weighted QU + path compression"),(0,i.kt)("td",{parentName:"tr",align:null},"N + M lg* N")))),(0,i.kt)("p",null,"M union-find operations on a set of N objects"),(0,i.kt)("h2",{id:"code-snippets"},"Code Snippets"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Find")),(0,i.kt)("h2",{id:"function-findx"},"function ",(0,i.kt)("em",{parentName:"h2"},"Find"),"(x)"),(0,i.kt)("p",null,"if x.parent != x\nx.parent := ",(0,i.kt)("em",{parentName:"p"},"Find"),"(x.parent)\nreturn x.parent"),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Union")),(0,i.kt)("h2",{id:"function-unionx-y"},"function ",(0,i.kt)("em",{parentName:"h2"},"Union"),"(x, y)"),(0,i.kt)("p",null,"xRoot := ",(0,i.kt)("em",{parentName:"p"},"Find"),"(x)\nyRoot := ",(0,i.kt)("em",{parentName:"p"},"Find"),"(y)"),(0,i.kt)("p",null,"// x and y are already in the same set\nif xRoot == yRoot\nreturn"),(0,i.kt)("p",null,"// x and y are not in same set, so we merge them\nif xRoot.rank < yRoot.rank\nxRoot.parent := yRoot\nelse if xRoot.rank > yRoot.rank\nyRoot.parent := xRoot\nelse\n//Arbitrarily make one root the new parent\nyRoot.parent := xRoot\nxRoot.rank := xRoot.rank + 1"),(0,i.kt)("h2",{id:"applications"},"Applications"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Check whether a graph contains a cycle or not")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Percolation")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Dynamic Connectivity")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Connected Components")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Least common ancestor")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Equivalence of finite state automata")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Kruskal's minimum spanning tree"))),(0,i.kt)("h2",{id:"union-find-vs-dfs"},"Union-Find vs DFS"),(0,i.kt)("p",null,"The union-find algorithm is best suited for situations where the equivalence relationship is changing, i.e., there are \"Union\" operations which need to be performed on your set of partitions. Given a fixed undirected graph, you don't have the equivalence relationships changing at all - the edges are all fixed. OTOH, if you have a graph with new edges being added, DFS won't cut it. While DFS is asymptotically faster than union-find, in practice, the likely deciding factor would be the actual problem that you are trying to solve."),(0,i.kt)("h2",{id:"static-graph---dfs"},"Static graph - DFS"),(0,i.kt)("h2",{id:"dynamic-graph---union-find"},"Dynamic graph - Union-find"))}u.isMDXComponent=!0}}]);