"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[96642],{603905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var o=a(667294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,o,r=function(e,t){if(null==e)return{};var a,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)a=s[o],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)a=s[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(a),h=r,u=d["".concat(c,".").concat(h)]||d[h]||m[h]||s;return a?o.createElement(u,n(n({ref:t},p),{},{components:a})):o.createElement(u,n({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,n=new Array(s);n[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:r,n[1]=i;for(var l=2;l<s;l++)n[l]=a[l];return o.createElement.apply(null,n)}return o.createElement.apply(null,a)}h.displayName="MDXCreateElement"},898578:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>n,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=a(487462),r=(a(667294),a(603905));const s={},n="Clocks",i={unversionedId:"computer-science/distributed-system/clocks",id:"computer-science/distributed-system/clocks",title:"Clocks",description:"Atomic Broadcast",source:"@site/docs/computer-science/distributed-system/clocks.md",sourceDirName:"computer-science/distributed-system",slug:"/computer-science/distributed-system/clocks",permalink:"/computer-science/distributed-system/clocks",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/distributed-system/clocks.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CAP Theorem",permalink:"/computer-science/distributed-system/cap-theorem"},next:{title:"Consensus Protocols",permalink:"/computer-science/distributed-system/consensus-protocols"}},c={},l=[{value:"Atomic Broadcast",id:"atomic-broadcast",level:2},{value:"Total Order and Partial Order, Causal ordering",id:"total-order-and-partial-order-causal-ordering",level:2},{value:"Lamport Timestamps",id:"lamport-timestamps",level:2},{value:"Logical Clock",id:"logical-clock",level:2},{value:"Interval Tree Clocks: A Logical Clock for Dynamic Systems",id:"interval-tree-clocks-a-logical-clock-for-dynamic-systems",level:2},{value:"Leap Second",id:"leap-second",level:2}],p={toc:l},d="wrapper";function m(e){let{components:t,...s}=e;return(0,r.kt)(d,(0,o.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"clocks"},"Clocks"),(0,r.kt)("h2",{id:"atomic-broadcast"},"Atomic Broadcast"),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"https://en.m.wikipedia.org/wiki/Fault-tolerant"},"fault-tolerant"),(0,r.kt)("a",{parentName:"p",href:"https://en.m.wikipedia.org/wiki/Distributed_systems"},"distributed computing"),", anatomic broadcastortotal order broadcastis a ",(0,r.kt)("a",{parentName:"p",href:"https://en.m.wikipedia.org/wiki/Broadcasting_(networking)"},"broadcast"),' where all correct processes in a system of multiple processes receive the same set of messages in the same order; that is, the same sequence of messages.The broadcast is termed "',(0,r.kt)("a",{parentName:"p",href:"https://en.m.wikipedia.org/wiki/Atomic_(computer_science)"},"atomic"),'" because it either eventually completes correctly at all participants, or all participants abort without side effects. Atomic broadcasts are an important distributed computing primitive.'),(0,r.kt)("h2",{id:"total-order-and-partial-order-causal-ordering"},"Total Order and Partial Order, Causal ordering"),(0,r.kt)("p",null,"When events in a system follow a total order, then every event in that system has a specific order in which it occurred. In other words, when we know exactly wheneachof the events occurred, we know the total order of all the events in a system.\nIn apartial order, we can't be sure of the exact order ofallthe events in the system. Instead, all we can be sure about is the order of events that are reliant upon one another.\nIn a distributed system, we mostly deal with partially ordered events, simply because individual nodes can be sure about how to order local events, but they can't always be sure about how to order events that are happening on a different node. A node in our distributed system will send messages out to other nodes, who can't necessarily be sure of when they occurred. Similarly a node in our system will receive its own set of incoming messages, and it can't be sure of what time those messages were sent, either!\nSo how do we reconcile this lack of knowledge throughout our system? Well, it involves some reframing of how we think about time...and whether we even need it at all (?!).\nThe answer to this mystery is",(0,r.kt)("strong",{parentName:"p"},"causal ordering"),", which helps us order events not based on thetimethat they occurred, but rather, based on cause and effect. Causal ordering reframes how we think about events. If we can just figure out which events causeotherevents, we can come up with a loose ordering of how those events occurred.\n",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/baseds/ordering-distributed-events-29c1dd9d1eff"},"https://medium.com/baseds/ordering-distributed-events-29c1dd9d1eff")),(0,r.kt)("h2",{id:"lamport-timestamps"},"Lamport Timestamps"),(0,r.kt)("p",null,"The algorithm of",(0,r.kt)("strong",{parentName:"p"},"Lamport timestamps")," is a simple algorithm used to determine the order of events in a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Distributed_computer_system"},"distributed computer system"),". As different nodes or processes will typically not be perfectly synchronized, this algorithm is used to provide a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Partially_ordered_set"},"partial ordering")," of events with minimal overhead, and conceptually provide a starting point for the more advanced ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Vector_clock"},"vector clock")," method. They are named after their creator, ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Leslie_Lamport"},"Leslie Lamport"),".\nLamport's solution is to shift our thinking. He presents a novel idea: we don't actually need to think about causality in the context of total ordering to start. Instead, he says that we can start with a partial ordering of events, and then just deal with figuring out which events happened before other events. Once we figure out a partial ordering, we can turn it into a consistent total ordering.\nLamport's logical clocks allow us to shift from happened ",(0,r.kt)("strong",{parentName:"p"},"when")," to happened ",(0,r.kt)("strong",{parentName:"p"},"before")),(0,r.kt)("p",null,"we need to shift from thinking about ",(0,r.kt)("strong",{parentName:"p"},"when")," an event happened to what the event happened ",(0,r.kt)("strong",{parentName:"p"},"before"),"\nThe idea of one event happening before another is central to Lamport's paper. He uses the\u2192shorthand notation to indicate the",(0,r.kt)("strong",{parentName:"p"},"happens before")," relationship, or the fact that one event happened before another. For example, if we know that one event, a, happened before another event, b, then we can say thata\u2192b, orahappened beforeb.\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lamport_timestamps"},"https://en.wikipedia.org/wiki/Lamport_timestamps")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/baseds/logical-time-and-lamport-clocks-part-1-d0317e407112"},"https://medium.com/baseds/logical-time-and-lamport-clocks-part-1-d0317e407112")),(0,r.kt)("h2",{id:"logical-clock"},"Logical Clock"),(0,r.kt)("p",null,"Alogical clockis a mechanism for capturing chronological and causal relationships in a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Distributed_system"},"distributed system"),". Distributed systems may have no physically synchronous global clock, so a logical clock allows global ordering on events from different processes in such systems.\nIn logical clock systems each process has two data structures: ",(0,r.kt)("em",{parentName:"p"},"logical local time")," and ",(0,r.kt)("em",{parentName:"p"},"logical global time"),". Logical local time is used by the process to mark its own events, and logical global time is the local information about global time. A special protocol is used to update logical local time after each local event, and logical global time when processes exchange data."),(0,r.kt)("p",null,"Lamport suggests using something different from the typical physical clock that we all think of. Instead of using each process's physical clock to track the order of events, we can instead use acounter. The counter can start with an initial time (like 0), and we can treat that counter as the processes own local clock.\nLamport continues with this idea by proposing that, not only will every process within a distributed system have its own counter clock, but eacheventthat is recorded on a process should also have avalueon that process's local clock. Furthermore, the value of each of these events on the clock must mirror any happened before relationships. For example, if eventa\u2192 b, then the clock time for when eventaoccurred must be less than the clock time for whenever eventboccurred; in other words, clock(a) < clock(b)."),(0,r.kt)("p",null,"By using basic counters instead of physical clocks, Lamport simplifies clocks into something a little easier to deal with. These counter clocks are called logical clocks. Alogical clockis quite different from a physical clock in that there is no central notion of time, and the clock is just a counter that increments based on events in the system."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:a(535850).Z,width:"1035",height:"1431"})),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Logical_clock"},"https://en.wikipedia.org/wiki/Logical_clock")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/baseds/ticking-clocks-in-a-distributed-system-ef2aa4df07a3"},"https://medium.com/baseds/ticking-clocks-in-a-distributed-system-ef2aa4df07a3")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://medium.com/baseds/logical-time-and-lamport-clocks-part-2-272c097dcdda"},"https://medium.com/baseds/logical-time-and-lamport-clocks-part-2-272c097dcdda")),(0,r.kt)("h2",{id:"interval-tree-clocks-a-logical-clock-for-dynamic-systems"},"Interval Tree Clocks: A Logical Clock for Dynamic Systems"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/catwell/itc.lua"},"https://github.com/catwell/itc.lua")),(0,r.kt)("h2",{id:"leap-second"},"Leap Second"),(0,r.kt)("p",null,"Before we dive into the details of our NTP service, we need to look at a phenomenon called a leap second. Because of the Earth's rotation irregularities, we occasionally need to add or remove a second from time, or a ",(0,r.kt)("a",{parentName:"p",href:"https://caps.gsfc.nasa.gov/simpson/time/leapseconds.html"},"leap second"),'. For humans, adding or removing a second creates an almost unnoticeable hiccup when watching a clock. Servers, however, can miss a ton of transactions or events or experience a serious software malfunction when they expect time to go forward continuously. One of the most popular approaches for addressing that is to "',(0,r.kt)("a",{parentName:"p",href:"https://docs.ntpsec.org/latest/leapsmear.html"},'smear" the leap second'),", which means to change the time in very small increments across multiple hours."))}m.isMDXComponent=!0},535850:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/Clocks-image1-1f5895f1d48b2263b723f61292bcc705.jpg"}}]);