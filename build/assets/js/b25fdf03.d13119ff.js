"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[87877],{603905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>m});var r=a(667294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,o=function(e,t){if(null==e)return{};var a,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var d=r.createContext({}),c=function(e){var t=r.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},l=function(e){var t=c(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var a=e.components,o=e.mdxType,s=e.originalType,d=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=c(a),h=o,m=u["".concat(d,".").concat(h)]||u[h]||p[h]||s;return a?r.createElement(m,n(n({ref:t},l),{},{components:a})):r.createElement(m,n({ref:t},l))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=a.length,n=new Array(s);n[0]=h;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:o,n[1]=i;for(var c=2;c<s;c++)n[c]=a[c];return r.createElement.apply(null,n)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},815923:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>n,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=a(487462),o=(a(667294),a(603905));const s={},n="Architecture",i={unversionedId:"databases/sql-databases/aws-redshift/architecture",id:"databases/sql-databases/aws-redshift/architecture",title:"Architecture",description:"image",source:"@site/docs/databases/sql-databases/aws-redshift/architecture.md",sourceDirName:"databases/sql-databases/aws-redshift",slug:"/databases/sql-databases/aws-redshift/architecture",permalink:"/databases/sql-databases/aws-redshift/architecture",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/sql-databases/aws-redshift/architecture.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Redshift",permalink:"/databases/sql-databases/aws-redshift/"},next:{title:"Deep dive / Best practices",permalink:"/databases/sql-databases/aws-redshift/deep-dive-best-practices"}},d={},c=[],l={toc:c},u="wrapper";function p(e){let{components:t,...s}=e;return(0,o.kt)(u,(0,r.Z)({},l,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(511199).Z,width:"616",height:"431"}),"\nRedshift is meant to work in a Cluster formation. A typical Redshift Cluster has two or more",(0,o.kt)("strong",{parentName:"p"},"Compute Nodes")," which are coordinated through a",(0,o.kt)("strong",{parentName:"p"},"Leader Node"),".All client applications communicate with the cluster only with the Leader Node."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Leader Node"))),(0,o.kt)("p",null,"The Leader Node in an Amazon Redshift Cluster manages all external and internal communication. It is responsible for preparing query execution plans whenever a query is submitted to the cluster. Once the query execution plan is ready, the Leader Node distributes query execution code on the compute nodes and assigns slices of data to each to compute node for computation of results.\nLeader Node distributes query load to compute node only when the query involves accessing data stored on the compute nodes. Otherwise, the query is executed on the Leader Node itself. There are several functions in Redshift architecture which are always executed on the Leader Node. You can read ",(0,o.kt)("a",{parentName:"p",href:"http://docs.aws.amazon.com/redshift/latest/dg/c_sql-functions-leader-node.html"},"SQL Functions Supported on the Leader Node")," for more information on these functions.\n2. ",(0,o.kt)("strong",{parentName:"p"},"Compute Nodes")),(0,o.kt)("p",null,"Compute Nodes are responsible for the actual execution of queries and have data stored with them. They execute queries and return intermediate results to the Leader Node which further aggregates the results.\nThere are two types of Compute Nodes available in Redshift architecture:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Dense Storage (DS) --Dense Storage nodes allow you to create large data warehouses using Hard Disk Drives (HDDs) for a low price point."),(0,o.kt)("li",{parentName:"ul"},"Dense Compute (DC) --Dense Compute nodes allow you to create high-performance data warehouses using Solid-State Drives (SSDs).\nA more detailed explanation of how responsibilities are divided among Leader and Compute Nodes are depicted in the diagram below:")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(924170).Z,width:"638",height:"644"}),"\n3. ",(0,o.kt)("strong",{parentName:"p"},"Node slices")),(0,o.kt)("p",null,"A compute node consist of slices. Each Slice has a portion of Compute Node's memory and disk assigned to it where it performs Query Operations. The Leader Node is responsible for assigning a Query code and data to a slice for execution. Slices once assigned query load work in parallel to generate query results.\nData is distributed among the Slices on the basis of ",(0,o.kt)("a",{parentName:"p",href:"https://hevodata.com/blog/redshift-distribution-keys/"},"Distribution Style and Distribution Key")," of a particular table. An even distribution of data enables Redshift to assign workload evenly to slices and maximizes the benefit of parallel processing.\nNumber of Slices per Compute Node is decided on the basis of the type of node. You can find more information onClusters and Nodes.\n4. ",(0,o.kt)("strong",{parentName:"p"},"Massively parallel processing (MPP)")),(0,o.kt)("p",null,"Amazon Redshift architecture allows it to use Massively parallel processing (MPP) for fast processing even for the most complex queries and a huge amount of data set. Multiple compute nodes execute the same query code on portions of data to maximize parallel processing.\n5. ",(0,o.kt)("strong",{parentName:"p"},"Columnar Data Storage")),(0,o.kt)("p",null,"Data in Amazon Redshift data warehouse is stored in a columnar fashion which drastically reduces the I/O on disks. Columnar storage reduces the number of disk I/O requests and minimizes the amount of data loaded into the memory to execute a query. Reduction in I/O speeds up query execution and loading less data means Redshift can perform more in-memory processing.\nRedshift uses Sort Keys to sort columns and filter out chunks of data while executing queries. You can read more about Sort Keys in our post on ",(0,o.kt)("a",{parentName:"p",href:"https://hevodata.com/blog/redshift-sort-keys-choosing-best-sort-style/"},"Choosing the best Sort Keys"),"\n6. ",(0,o.kt)("strong",{parentName:"p"},"Data Compression")),(0,o.kt)("p",null,"Data compression is one of the important factors in ensuring query performance. It reduces storage footprint and enables loading of large amounts of data in the memory fast. Owing to Columnar storage, Redshift can use adaptive compression encoding depending on the column data type. Read more about using compression encodings in ",(0,o.kt)("a",{parentName:"p",href:"http://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html"},"Compression Encodings in Redshift"),".\n7. ",(0,o.kt)("strong",{parentName:"p"},"Query Optimizer")),(0,o.kt)("p",null,"Redshift's Query Optimizer generate query plans that are MPP-aware and takes advantage of Columnar Data Storage. Query Optimizer uses analyzed information about tables to generate efficient query plans for execution. Read more about ",(0,o.kt)("a",{parentName:"p",href:"https://hevodata.com/blog/redshift-vacuum-and-analyze/"},"Analyze")," to know how to make the best of Query Optimizer.\n",(0,o.kt)("a",{parentName:"p",href:"https://hevodata.com/blog/redshift-architecture"},"https://hevodata.com/blog/redshift-architecture")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/redshift/latest/dg/c_high_level_system_architecture.html"},"https://docs.aws.amazon.com/redshift/latest/dg/c_high_level_system_architecture.html")))}p.isMDXComponent=!0},511199:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/AWS-Redshift_Architecture-image1-979bdbec623486b8a6e9c66b60971006.jpg"},924170:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/AWS-Redshift_Architecture-image2-d28334c3715ee21f8c15d07a6fadcd51.jpg"}}]);