"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[30152],{603905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var r=a(667294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),m=i,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||n;return a?r.createElement(h,s(s({ref:t},c),{},{components:a})):r.createElement(h,s({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,s=new Array(n);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<n;p++)s[p]=a[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},920537:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>n,metadata:()=>o,toc:()=>p});var r=a(487462),i=(a(667294),a(603905));const n={},s="Kd-trees",o={unversionedId:"data-structures/hierarchical-data-structure/kd-trees",id:"data-structures/hierarchical-data-structure/kd-trees",title:"Kd-trees",description:"In computer science, a***k*-d tree**(short for*k-dimensional tree*) is a space-partitioningdata structure for organizing points) in ak-dimensional space.*k*-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g.range searches and nearest neighbor searches).k-d trees are a special case of binary space partitioning trees.",source:"@site/docs/data-structures/hierarchical-data-structure/kd-trees.md",sourceDirName:"data-structures/hierarchical-data-structure",slug:"/data-structures/hierarchical-data-structure/kd-trees",permalink:"/data-structures/hierarchical-data-structure/kd-trees",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/data-structures/hierarchical-data-structure/kd-trees.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"k-ary heap / d-ary heap / d-way heap",permalink:"/data-structures/hierarchical-data-structure/k-ary-heap-d-ary-heap-d-way-heap"},next:{title:"Left Leaning Red-Black BSTs (LLRB tree)",permalink:"/data-structures/hierarchical-data-structure/left-leaning-red-black-bsts-llrb-tree"}},l={},p=[{value:"Operations",id:"operations",level:2},{value:"Applications of 2d trees",id:"applications-of-2d-trees",level:2},{value:"Flocking Boids Algorithm",id:"flocking-boids-algorithm",level:2},{value:"Appel&#39;s algorithm for N-body simulation",id:"appels-algorithm-for-n-body-simulation",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"kd-trees"},"Kd-trees"),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_science"},"computer science"),", a",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"k"),"-d tree"),"(short for",(0,i.kt)("em",{parentName:"p"},"k-dimensional ",(0,i.kt)("a",{parentName:"em",href:"https://en.wikipedia.org/wiki/Tree_data_structure"},"tree")),") is a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Space_partitioning"},"space-partitioning"),(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_structure"},"data structure")," for organizing ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Point_(geometry)"},"points")," in a",(0,i.kt)("em",{parentName:"p"},"k"),"-dimensional ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euclidean_space"},"space"),".",(0,i.kt)("em",{parentName:"p"},"k"),"-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g.",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Range_search"},"range searches")," and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Nearest_neighbor_search"},"nearest neighbor searches"),").",(0,i.kt)("em",{parentName:"p"},"k"),"-d trees are a special case of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Binary_space_partitioning"},"binary space partitioning")," trees.\nA non-leaf node in K-D tree divides the space into two parts, called as half-spaces."),(0,i.kt)("p",null,"Points to the left of this space are represented by the left subtree of that node and points to the right of the space are represented by the right subtree.\nExtension of BSTs that allow us to do efficient processing of sets of points in space.\n",(0,i.kt)("img",{alt:"image",src:a(646283).Z,width:"1172",height:"832"})),(0,i.kt)("p",null,"Problem with Grid implementation - ",(0,i.kt)("strong",{parentName:"p"},"Clustering")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Lists are too long, even though average length is short.\n",(0,i.kt)("img",{alt:"image",src:a(265453).Z,width:"1099",height:"726"}),(0,i.kt)("img",{alt:"image",src:a(105325).Z,width:"1206",height:"910"}))),(0,i.kt)("h2",{id:"operations"},"Operations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Range search in a 2d tree")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Nearest neighbor search in a 2d tree\n",(0,i.kt)("img",{alt:"image",src:a(569147).Z,width:"1194",height:"884"})))),(0,i.kt)("h2",{id:"applications-of-2d-trees"},"Applications of 2d trees"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Classifying astronomical objects"),(0,i.kt)("li",{parentName:"ul"},"Computer animation"),(0,i.kt)("li",{parentName:"ul"},"Speeding up neural networks"),(0,i.kt)("li",{parentName:"ul"},"Mining data"),(0,i.kt)("li",{parentName:"ul"},"Image retrieval")),(0,i.kt)("h2",{id:"flocking-boids-algorithm"},"Flocking Boids Algorithm"),(0,i.kt)("p",null,"Boids: Three simple rules lead to complex emergent flocking behavior in birds:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Collision avoidance: point away from k nearest boids"),(0,i.kt)("li",{parentName:"ul"},"Flock centering: point towards the center of mass of k nearest boids"),(0,i.kt)("li",{parentName:"ul"},"Velocity matching: update velocity to the average of k nearest boids")),(0,i.kt)("h2",{id:"appels-algorithm-for-n-body-simulation"},"Appel's algorithm for N-body simulation"),(0,i.kt)("p",null,"Key idea: suppose particle is far, far away from cluster of particles:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Treat cluster of particles as a single aggregate particle"),(0,i.kt)("li",{parentName:"ul"},"Compute force between particle and center of mass of aggregate")),(0,i.kt)("p",null,"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Build 3-d tree with N particles as nodes"),(0,i.kt)("li",{parentName:"ul"},"Store center-of-mass of subtree in each node"),(0,i.kt)("li",{parentName:"ul"},"To compute total force acting on a particle, traverse tree, but stop as soon as distance from particle to subdivision is sufficiently large")),(0,i.kt)("p",null,"Running time per step is N log N"))}d.isMDXComponent=!0},646283:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Kd-trees-image1-b23e1a0f6bb979580a726659e0d34a96.jpg"},265453:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Kd-trees-image2-bde7448e2751145bc5885275848f1b2d.jpg"},105325:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Kd-trees-image3-1f7c6ee1ba722f44ec5182e8d2d224e5.jpg"},569147:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Kd-trees-image4-040266caf8a076852fe3bbb72b01caf3.jpg"}}]);