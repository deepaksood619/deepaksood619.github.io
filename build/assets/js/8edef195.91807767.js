"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[75335],{603905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>m});var o=a(667294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=o.createContext({}),u=function(e){var t=o.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},l=function(e){var t=u(e.components);return o.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=u(a),d=n,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||r;return a?o.createElement(m,i(i({ref:t},l),{},{components:a})):o.createElement(m,i({ref:t},l))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:n,i[1]=s;for(var u=2;u<r;u++)i[u]=a[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}d.displayName="MDXCreateElement"},449057:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var o=a(487462),n=(a(667294),a(603905));const r={},i="OAuth",s={unversionedId:"computer-science/security/authentication/oauth",id:"computer-science/security/authentication/oauth",title:"OAuth",description:"- OAuth is an open standard for access delegation",source:"@site/docs/computer-science/security/authentication/oauth.md",sourceDirName:"computer-science/security/authentication",slug:"/computer-science/security/authentication/oauth",permalink:"/computer-science/security/authentication/oauth",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/security/authentication/oauth.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JWT",permalink:"/computer-science/security/authentication/jwt"},next:{title:"OpenID",permalink:"/computer-science/security/authentication/openid"}},c={},u=[{value:"Workflow of OAuth 2.0",id:"workflow-of-oauth-20",level:2},{value:"4 Grant Types",id:"4-grant-types",level:2},{value:"Authorization Code Grant",id:"authorization-code-grant",level:2},{value:"Implicit Grant",id:"implicit-grant",level:2},{value:"Resource Owner Password (Password Grant)",id:"resource-owner-password-password-grant",level:2},{value:"Client Credential",id:"client-credential",level:2},{value:"OAuth",id:"oauth-1",level:2},{value:"Sliding-sessions",id:"sliding-sessions",level:2},{value:"OAuth vs OpenID Connect (OIDC)",id:"oauth-vs-openid-connect-oidc",level:2},{value:"Map of OAuth 2.0 Specs",id:"map-of-oauth-20-specs",level:2},{value:"PKCE - Proof-Key for Code Exchange (pronounced - pixie)",id:"pkce---proof-key-for-code-exchange-pronounced---pixie",level:2},{value:"OAuth 2.1",id:"oauth-21",level:2},{value:"Others",id:"others",level:2}],l={toc:u},h="wrapper";function p(e){let{components:t,...r}=e;return(0,n.kt)(h,(0,o.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"oauth"},"OAuth"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"OAuth is an open standard for access delegation"),(0,n.kt)("li",{parentName:"ul"},'OAuth provides to clients a "secure delegated access" to server resources on behalf of a resource owner'),(0,n.kt)("li",{parentName:"ul"},"OAuth2 is more of a framework than a defined protocol\n",(0,n.kt)("a",{parentName:"li",href:"https://oauth.net/2/"},"OAuth 2.0")," is a protocol that allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials.\nAccording to ",(0,n.kt)("a",{parentName:"li",href:"http://oauth.net/about/"},"OAuth's website")," the protocol is not unlike a valet key.")),(0,n.kt)("p",null,"Many luxury cars today come with a valet key. It is a special key you give the parking attendant and unlike your regular key, will not allow the car to drive more than a mile or two. Some valet keys will not open the trunk, while others will block access to your onboard cell phone address book. Regardless of what restrictions the valet key imposes, the idea is very clever. You give someone limited access to your car with a special key, while using your regular key to unlock everything.\n",(0,n.kt)("img",{alt:"image",src:a(174495).Z,width:"768",height:"431"})),(0,n.kt)("h2",{id:"workflow-of-oauth-20"},"Workflow of OAuth 2.0"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"image",src:a(816583).Z,width:"1101",height:"566"}),"\nThroughout this workflow OAuth 2.0 serves as an authorization framework, the actual authentication of user occurs through OpenID Connect, through the use of ID tokens that are passed along with the access token."),(0,n.kt)("h2",{id:"4-grant-types"},"4 Grant Types"),(0,n.kt)("p",null,"Define how an application can retrieve tokens from your OAuth server and are used in different use cases."),(0,n.kt)("h2",{id:"authorization-code-grant"},"Authorization Code Grant"),(0,n.kt)("p",null,"The Authorization Code flow is the most powerful and most secure by default. When the application redirects the user to the Identity Provider to authenticate, the IdP passes back a short-lived, one-time use authorization code. The application uses the authorization code to retrieve the Access Token.\nThe important part is twofold: First, by the time the user sees the authorization code, it's already been consumed and therefore can't be used again. Second, the Access Token is kept by the application in the backend. Assuming the application is built securely, a malicious user has to find another way to attack it.\nUnfortunately, this doesn't work for client side applications such as many Javascript apps or most mobile apps as the application itself can be attacked or decompiled for sensitive information. Therefore, we need a different approach."),(0,n.kt)("h2",{id:"implicit-grant"},"Implicit Grant"),(0,n.kt)("p",null,"The Implicit flow is designed specifically for mobile apps or client side Javascript apps where embedded credentials could be compromised. The mechanics are simple in that the application redirects the user to the Identity Provider to authenticate, the IdP passes back token(s), and the application uses it according to the scopes it has.\nSince it's quite likely that the user could interact with the token(s), it's important that our use cases reflect that. If we have a banking app, allowing the send_wire_transfers_to_russia scope may be a bad idea unless we have additional factors baked into our authentication process to validate that the right user is using it. The next time you lose your phone, you'll appreciate that.\nAs a result, this is often used for OpenID Connect scenarios where a user wants to provide trusted profile information to a third party but not necessarily access or permissions to other systems. Since the underlying concepts are the same and the implementation looks very similar, it's most of the benefit for the same effort."),(0,n.kt)("h2",{id:"resource-owner-password-password-grant"},"Resource Owner Password (Password Grant)"),(0,n.kt)("p",null,"Compared to the previous grant types, Resource Owner Password makes me nervous. With both the Authorization Code and Implicit flows, the application redirects the user to the Identity Provider to submit their username and password. As a result, the application never sees their credentials. With the Resource Owner Password flow, the application itself accepts the credentials and submits them on behalf of the user.\nIf the application is malicious or even just poorly developed, it could store those credentials and compromise the user's information. Therefore, you should only use this if you're building applications for your users to interact with your legacy systems. For example, a bank may implement this for an internal employee portal.\nBut remember: Fundamentally, you're training users to put their credentials into applications they may not trust which is a bad habit at best and a security risk at all times."),(0,n.kt)("h2",{id:"client-credential"},"Client Credential"),(0,n.kt)("p",null,"The Client Credential grant type is designed exclusively for backend server to server operations. Think of it as a server's username and password. Conceptually, it's not far from how your application connects to other backend systems such as your database or Twilio. The benefit is that your OAuth provider can return configuration information or other details within the token itself.\nFinally, since there's not a user involved, it doesn't support OpenID Connect.\n",(0,n.kt)("a",{parentName:"p",href:"https://auth0.com/docs/protocols/oauth2"},"https://auth0.com/docs/protocols/oauth2")),(0,n.kt)("p",null,"Youtube - ",(0,n.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=CPbvxxslDTU"},"OAuth 2.0: An Overview")),(0,n.kt)("p",null,"Youtube - ",(0,n.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=bzGKgC3N7SY"},"What is OAuth2? How does OAuth2 work? | Tech Primers")),(0,n.kt)("h2",{id:"oauth-1"},"OAuth"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Authorization Code"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Only valid for one-time use, since its only usage is to exchange it for an access token"),(0,n.kt)("li",{parentName:"ul"},"Expires very quickly (according to this ",(0,n.kt)("a",{parentName:"li",href:"https://www.oauth.com/oauth2-servers/authorization/the-authorization-response/"},"article"),", the OAuth protocol's recommended maximum is 10 minutes, and many services' authorization codes expire even earlier)- ",(0,n.kt)("strong",{parentName:"li"},"Access Token")),(0,n.kt)("li",{parentName:"ul"},"Can be obtained using the authorization code"),(0,n.kt)("li",{parentName:"ul"},"Put in the headers of any API requests to Google on behalf of the user"),(0,n.kt)("li",{parentName:"ul"},"Expires after one hour (the expiration time may vary if you're using something besides Google)"),(0,n.kt)("li",{parentName:"ul"},"carry the necessary information to access a resource directly. In other words, when a client passes an access token to a server managing a resource, that server can use the information contained in the token to decide whether the client is authorized or not. Access tokens usually have an expiration date and are short-lived.- ",(0,n.kt)("strong",{parentName:"li"},"Refresh Token")),(0,n.kt)("li",{parentName:"ul"},"allows you to get new access tokens"),(0,n.kt)("li",{parentName:"ul"},"carry the information necessary to get a new access token. In other words, whenever an access token is required to access a specific resource, a client may use a refresh token to get a new access token issued by the authentication server. Common use cases include getting new access tokens after old ones have expired, or getting access to a new resource for the first time. Refresh tokens can also expire but are rather long-lived. Refresh tokens are usually subject to strict storage requirements to ensure they are not leaked. They can also be ",(0,n.kt)("strong",{parentName:"li"},"blacklisted")," by the authorization server.")))),(0,n.kt)("h2",{id:"sliding-sessions"},"Sliding-sessions"),(0,n.kt)("p",null,"Sliding-sessions are sessions that expire after aperiod of inactivity. As you can imagine, this is easily implemented using access tokens and refresh tokens. When a user performs an action, a new access token is issued. If the user uses an expired access token, the session is considered inactive and a new access token is required. Whether this token can be obtained with a refresh token or a new authentication round is required is defined by the requirements of the development team."),(0,n.kt)("h2",{id:"oauth-vs-openid-connect-oidc"},"OAuth vs OpenID Connect (OIDC)"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/"},"OAuth 2.0 Framework")," describes overarching patterns for granting authorization but does not define how to actually perform authentication. The application using OAuth constructs a specific request for permissions to a third party system - usually called an Identity Provider (IdP) - which handles the authentication process and returns an Access Token representing success. The IdP may require additional factors such as SMS or email but that is entirely outside the scope of OAuth. Finally, the contents and structure of that Access Token are undefined by default. This ambiguity guarantees that Identity Providers will build incompatible systems.\nLuckily, ",(0,n.kt)("a",{parentName:"p",href:"https://openid.net/connect/"},"OpenID Connect")," or OIDC brings some sanity to the madness. It is an OAuth extension which adds and strictly defines an ID Token for returning user information. Now when we log in with our Identity Provider, it can return specific fields that our applications can expect and handle. The important thing to remember is that OIDC is just a special, simplified case of OAuth, not a replacement. It uses the same terminology and concepts.\n",(0,n.kt)("a",{parentName:"p",href:"https://blog.runscope.com/posts/understanding-oauth-2-and-openid-connect"},"https://blog.runscope.com/posts/understanding-oauth-2-and-openid-connect")),(0,n.kt)("h2",{id:"map-of-oauth-20-specs"},"Map of OAuth 2.0 Specs"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs"},"https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc6749"},"https://tools.ietf.org/html/rfc6749"),"\n",(0,n.kt)("img",{alt:"image",src:a(611699).Z,width:"1101",height:"559"})),(0,n.kt)("h2",{id:"pkce---proof-key-for-code-exchange-pronounced---pixie"},"PKCE - Proof-Key for Code Exchange (pronounced - pixie)"),(0,n.kt)("h2",{id:"oauth-21"},"OAuth 2.1"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Authorization Code + PKCE"),(0,n.kt)("li",{parentName:"ul"},"Client Credentials"),(0,n.kt)("li",{parentName:"ul"},"Tokens in HTTP Header"),(0,n.kt)("li",{parentName:"ul"},"Tokens in POST Form Body- RFC6749 - OAuth 2.0 Core"),(0,n.kt)("li",{parentName:"ul"},"RFC6750 - Bearer Token Usage"),(0,n.kt)("li",{parentName:"ul"},"RFC7636 - PKCE"),(0,n.kt)("li",{parentName:"ul"},"Native app and brower-based app BCPs (Best Current Practices)"),(0,n.kt)("li",{parentName:"ul"},"Security BCP",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Must support PKCE for all client types"),(0,n.kt)("li",{parentName:"ul"},"No password grant"),(0,n.kt)("li",{parentName:"ul"},"No implicit flow"),(0,n.kt)("li",{parentName:"ul"},"Exact string matching for redirect URIs"),(0,n.kt)("li",{parentName:"ul"},"No access tokens in query strings"),(0,n.kt)("li",{parentName:"ul"},"Refresh tokens must be sender-contrained or one-time use\n",(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=g_aVPdwBTfw"},"https://www.youtube.com/watch?v=g_aVPdwBTfw"))))),(0,n.kt)("h2",{id:"others"},"Others"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://developer.okta.com/docs/concepts/api-access-management"},"https://developer.okta.com/docs/concepts/api-access-management")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=996OiexHze0"},"https://www.youtube.com/watch?v=996OiexHze0")))}p.isMDXComponent=!0},174495:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/Authentication_OAuth-image1-3cf9089eefefed05fd1b7ef28219a18f.jpg"},816583:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/Authentication_OAuth-image2-d9adf0b352256e10e5f3f090d5562285.jpg"},611699:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/Authentication_OAuth-image3-f84fd41e6def7af831bf0d38df062028.jpg"}}]);