"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[54767],{603905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var s=a(667294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,s)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,s,n=function(e,t){if(null==e)return{};var a,s,n={},i=Object.keys(e);for(s=0;s<i.length;s++)a=i[s],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)a=i[s],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=s.createContext({}),d=function(e){var t=s.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=d(e.components);return s.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},h=s.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=d(a),h=n,u=p["".concat(l,".").concat(h)]||p[h]||m[h]||i;return a?s.createElement(u,r(r({ref:t},c),{},{components:a})):s.createElement(u,r({ref:t},c))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:n,r[1]=o;for(var d=2;d<i;d++)r[d]=a[d];return s.createElement.apply(null,r)}return s.createElement.apply(null,a)}h.displayName="MDXCreateElement"},961710:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=a(487462),n=(a(667294),a(603905));const i={},r="Redis Concepts",o={unversionedId:"databases/nosql-databases/redis/redis-concepts",id:"databases/nosql-databases/redis/redis-concepts",title:"Redis Concepts",description:"Redis keys",source:"@site/docs/databases/nosql-databases/redis/redis-concepts.md",sourceDirName:"databases/nosql-databases/redis",slug:"/databases/nosql-databases/redis/redis-concepts",permalink:"/databases/nosql-databases/redis/redis-concepts",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/nosql-databases/redis/redis-concepts.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Others",permalink:"/databases/nosql-databases/redis/others"},next:{title:"Redis Data Types",permalink:"/databases/nosql-databases/redis/redis-data-types"}},l={},d=[{value:"Redis keys",id:"redis-keys",level:2},{value:"Redis Strings",id:"redis-strings",level:2},{value:"Redis Expires",id:"redis-expires",level:2},{value:"How Redis expires keys",id:"how-redis-expires-keys",level:2},{value:"Scan",id:"scan",level:2},{value:"Persistence",id:"persistence",level:2},{value:"AOF - Append Only File",id:"aof---append-only-file",level:2},{value:"RDB - Redis Database Backup",id:"rdb---redis-database-backup",level:2},{value:"Compress AOF",id:"compress-aof",level:2},{value:"Redis Keyspace Notifications",id:"redis-keyspace-notifications",level:2}],c={toc:d},p="wrapper";function m(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,s.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"redis-concepts"},"Redis Concepts"),(0,n.kt)("h2",{id:"redis-keys"},"Redis keys"),(0,n.kt)("p",null,'Redis keys are binary safe, this means that you can use any binary sequence as a key, from a string like "foo" to the content of a JPEG file. The empty string is also a valid key.\nA few other rules about keys:'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Very long keys are not a good idea. For instance a key of 1024 bytes is a bad idea not only memory-wise, but also because the lookup of the key in the dataset may require several costly key-comparisons. Even when the task at hand is to match the existence of a large value, hashing it (for example with SHA1) is a better idea, especially from the perspective of memory and bandwidth."),(0,n.kt)("li",{parentName:"ul"},'Very short keys are often not a good idea. There is little point in writing "u1000flw" as a key if you can instead write "user:1000:followers". The latter is more readable and the added space is minor compared to the space used by the key object itself and the value object. While short keys will obviously consume a bit less memory, your job is to find the right balance.'),(0,n.kt)("li",{parentName:"ul"},'Try to stick with a schema. For instance "object-type:id" is a good idea, as in "user:1000". Dots or dashes are often used for multi-word fields, as in "comment\ud83d\udd22reply.to" or "comment\ud83d\udd22reply-to".'),(0,n.kt)("li",{parentName:"ul"},"The maximum allowed key size is 512 MB.")),(0,n.kt)("h2",{id:"redis-strings"},"Redis Strings"),(0,n.kt)("p",null,"Values can be strings (including binary data) of every kind, for instance you can store a jpeg image inside a value. A value can't be bigger than 512 MB.\nNote that ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/set"},"SET")," will replace any existing value already stored into the key, in the case that the key already exists, even if the key is associated with a non-string value. So ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/set"},"SET")," performs an assignment.\nThe ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/set"},"SET")," command has interesting options, that are provided as additional arguments. For example, I may ask ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/set"},"SET")," to fail if the key already exists, or the opposite, that it only succeed if the key already exists:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"> set mykey newval nx\n(nil)\n> set mykey newval xx\nOK\n")),(0,n.kt)("p",null,"Even if strings are the basic values of Redis, there are interesting operations you can perform with them. For instance, one is atomic increment:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"> set counter 100\nOK\n> incr counter\n(integer) 101\n> incr counter\n(integer) 102\n> incrby counter 50\n(integer) 152\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/incr"},"INCR")," command parses the string value as an integer, increments it by one, and finally sets the obtained value as the new value. There are other similar commands like ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/incrby"},"INCRBY"),", ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/decr"},"DECR")," and ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/decrby"},"DECRBY"),'. Internally it\'s always the same command, acting in a slightly different way.\nWhat does it mean that INCR is atomic? That even multiple clients issuing INCR against the same key will never enter into a race condition. For instance, it will never happen that client 1 reads "10", client 2 reads "10" at the same time, both increment to 11, and set the new value to 11. The final value will always be 12 and the read-increment-set operation is performed while all the other clients are not executing a command at the same time.\nThere are a number of commands for operating on strings. For example the ',(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/getset"},"GETSET")," command sets a key to a new value, returning the old value as the result. You can use this command, for example, if you have a system that increments a Redis key using ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/incr"},"INCR")," every time your web site receives a new visitor. You may want to collect this information once every hour, without losing a single increment. You can ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/getset"},"GETSET"),' the key, assigning it the new value of "0" and reading the old value back.'),(0,n.kt)("p",null,"The ability to set or retrieve the value of multiple keys in a single command is also useful for reduced latency. For this reason there are the ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/mset"},"MSET")," and ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/mget"},"MGET")," commands:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},'> mset a 10 b 20 c 30\nOK\n> mget a b c\n\n1) "10"\n2) "20"\n3) "30"\n')),(0,n.kt)("p",null,"When ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/mget"},"MGET")," is used, Redis returns an array of values."),(0,n.kt)("h2",{id:"redis-expires"},"Redis Expires"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"They can be set both using seconds or milliseconds precision."),(0,n.kt)("li",{parentName:"ul"},"However the expire time resolution is always 1 millisecond."),(0,n.kt)("li",{parentName:"ul"},"Information about expires are replicated and persisted on disk, the time virtually passes when your Redis server remains stopped (this means that Redis saves the date at which a key will expire).")),(0,n.kt)("h2",{id:"how-redis-expires-keys"},"How Redis expires keys"),(0,n.kt)("p",null,"Redis keys are expired in two ways: a passive way, and an active way.\nA key is passively expired simply when some client tries to access it, and the key is found to be timed out.\nOf course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.\nSpecifically this is what Redis does 10 times per second:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Test 20 random keys from the set of keys with an associated expire.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Delete all the keys found expired.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"If more than 25% of keys were expired, start again from step 1.\nThis is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%\nThis means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.\n",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/expire#how-redis-expires-keys"},"https://redis.io/commands/expire#how-redis-expires-keys"),"\n",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/topics/data-types-intro"},"https://redis.io/topics/data-types-intro")))),(0,n.kt)("h2",{id:"scan"},"Scan"),(0,n.kt)("p",null,"Time complexity:O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/scan"},"SCAN")," command and the closely related commands ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/sscan"},"SSCAN"),", ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/hscan"},"HSCAN")," and ",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/zscan"},"ZSCAN")," are used in order to incrementally iterate over a collection of elements."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://redis.io/commands/scan"},"SCAN")," iterates the set of keys in the currently selected Redis database."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://redis.io/commands/sscan"},"SSCAN")," iterates elements of Sets types."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://redis.io/commands/hscan"},"HSCAN")," iterates fields of Hash types and their associated values."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://redis.io/commands/zscan"},"ZSCAN")," iterates elements of Sorted Set types and their associated scores.\nThese commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands likeKEYSorSMEMBERSthat may block the server for a long time (even several seconds) when called against big collections of keys or elements.\nSCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.\nAn iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0.\nStarting an iteration with a cursor value of 0, and calling ",(0,n.kt)("a",{parentName:"li",href:"https://redis.io/commands/scan"},"SCAN")," until the returned cursor is 0 again is called afull iteration.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},'> sscan myset 0 match f*\n> redis-cli -a a6ad92769ef04b711eea18dccfff85ea --no-auth-warning --scan | while read LINE ; do TTL=`redis-cli --no-auth-warning -a a6ad92769ef04b711eea18dccfff85ea ttl "$LINE"`; if [ $TTL -eq -1 ]; then echo "$LINE"; fi; done;\n')),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/scan"},"https://redis.io/commands/scan")),(0,n.kt)("h2",{id:"persistence"},"Persistence"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The RDB persistence performs point-in-time snapshots of your dataset at specified intervals."),(0,n.kt)("li",{parentName:"ul"},"The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big."),(0,n.kt)("li",{parentName:"ul"},"If you wish, you can disable persistence completely, if you want your data to just exist as long as the server is running."),(0,n.kt)("li",{parentName:"ul"},"It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.")),(0,n.kt)("h2",{id:"aof---append-only-file"},"AOF - Append Only File"),(0,n.kt)("p",null,"It's the change-log style persistent format."),(0,n.kt)("p",null,"AOF is actually a persistence technique in which an RDB file is generated once and all the data is appended to it as it comes"),(0,n.kt)("h2",{id:"rdb---redis-database-backup"},"RDB - Redis Database Backup"),(0,n.kt)("p",null,"It's the snapshot style persistence format."),(0,n.kt)("p",null,"RDB file is a dump of all user data stored in an internal, compressed serialization format at a particular timestamp which is used for point-in-time recovery (recovery from a timestamp)."),(0,n.kt)("h2",{id:"compress-aof"},"Compress AOF"),(0,n.kt)("p",null,"BGREWRITEAOF\n",(0,n.kt)("a",{parentName:"p",href:"https://redis.io/commands/bgrewriteaof"},"https://redis.io/commands/bgrewriteaof"),"\n",(0,n.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/39953542/aof-and-rdb-backups-in-redis"},"https://stackoverflow.com/questions/39953542/aof-and-rdb-backups-in-redis")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://redis.io/topics/persistence"},(0,n.kt)("strong",{parentName:"a"},"https://redis.io/topics/persistence"))),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://redislabs.com/ebook/part-2-core-concepts/chapter-4-keeping-data-safe-and-ensuring-performance/4-1-persistence-options"},"https://redislabs.com/ebook/part-2-core-concepts/chapter-4-keeping-data-safe-and-ensuring-performance/4-1-persistence-options")),(0,n.kt)("h2",{id:"redis-keyspace-notifications"},"Redis Keyspace Notifications"),(0,n.kt)("p",null,"Keyspace notifications allow clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way.\nExamples of events that can be received are:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"All the commands affecting a given key."),(0,n.kt)("li",{parentName:"ul"},"All the keys receiving an LPUSH operation."),(0,n.kt)("li",{parentName:"ul"},"All the keys expiring in the database 0.\nEvents are delivered using the normal Pub/Sub layer of Redis, so clients implementing Pub/Sub are able to use this feature without modifications.\nBecause Redis Pub/Sub isfire and forgetcurrently there is no way to use this feature if your application demandsreliable notificationof events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.\nIn the future there are plans to allow for more reliable delivering of events, but probably this will be addressed at a more general level either bringing reliability to Pub/Sub itself, or allowing Lua scripts to intercept Pub/Sub messages to perform operations like pushing the events into a list.\n",(0,n.kt)("a",{parentName:"li",href:"https://redis.io/topics/notifications"},"https://redis.io/topics/notifications"))))}m.isMDXComponent=!0}}]);