"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[78980],{603905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var n=a(667294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=u(a),p=o,d=m["".concat(l,".").concat(p)]||m[p]||h[p]||r;return a?n.createElement(d,s(s({ref:t},c),{},{components:a})):n.createElement(d,s({ref:t},c))}));function d(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=a[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},287052:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var n=a(487462),o=(a(667294),a(603905));const r={},s="Kafka Consumers",i={unversionedId:"technologies/kafka/kafka-consumers",id:"technologies/kafka/kafka-consumers",title:"Kafka Consumers",description:"Kafka Consumers: Reading Data from Kafka (Definitive Guide)",source:"@site/docs/technologies/kafka/kafka-consumers.md",sourceDirName:"technologies/kafka",slug:"/technologies/kafka/kafka-consumers",permalink:"/technologies/kafka/kafka-consumers",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/technologies/kafka/kafka-consumers.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Kafka Connect",permalink:"/technologies/kafka/kafka-connect"},next:{title:"Kafka Listeners",permalink:"/technologies/kafka/kafka-listeners"}},l={},u=[{value:"Kafka Consumers: Reading Data from Kafka (Definitive Guide)",id:"kafka-consumers-reading-data-from-kafka-definitive-guide",level:2},{value:"Kafka Consumer Groups",id:"kafka-consumer-groups",level:2},{value:"Kafka Consumer Load Share",id:"kafka-consumer-load-share",level:2},{value:"Kafka Consumer Failover",id:"kafka-consumer-failover",level:2},{value:"Offset Management",id:"offset-management",level:2},{value:"What Can Kafka Consumers See?",id:"what-can-kafka-consumers-see",level:2},{value:"When can a consumer see a record?",id:"when-can-a-consumer-see-a-record",level:2},{value:"Consumer to Partition Cardinality - Load Sharing Redux",id:"consumer-to-partition-cardinality---load-sharing-redux",level:2},{value:"Multi-Threaded Kafka Consumers",id:"multi-threaded-kafka-consumers",level:2},{value:"Consumer With Many Threads",id:"consumer-with-many-threads",level:2},{value:"Thread per Consumer",id:"thread-per-consumer",level:2},{value:"What happens if you run multiple consumers in many threads in the same JVM?",id:"what-happens-if-you-run-multiple-consumers-in-many-threads-in-the-same-jvm",level:2},{value:"References",id:"references",level:2},{value:"Kafka Partition Assignment Strategies",id:"kafka-partition-assignment-strategies",level:2},{value:"Advanced",id:"advanced",level:2}],c={toc:u},m="wrapper";function h(e){let{components:t,...r}=e;return(0,o.kt)(m,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"kafka-consumers"},"Kafka Consumers"),(0,o.kt)("h2",{id:"kafka-consumers-reading-data-from-kafka-definitive-guide"},"Kafka Consumers: Reading Data from Kafka (Definitive Guide)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Consumer and Consumer Groups"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Rebalance"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Moving partition ownership from one consumer to another"),(0,o.kt)("li",{parentName:"ul"},"During a rebalance, consumers can't consume messages, so a rebalance is basically a short window of unavailability of the entire consumer group"),(0,o.kt)("li",{parentName:"ul"},"when partitions are moved from one consumer to another, the consumer loses its current state; if it was caching any data, it will need to refresh its caches - slowing down the application until the con\u2010 sumer sets up its state again."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Heatbeats"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The way consumers maintain membership in a consumer group and ownership of the partitions assigned to them is by sending ",(0,o.kt)("em",{parentName:"li"},"heartbeats")," to a Kafka broker designated as the ",(0,o.kt)("em",{parentName:"li"},"group coordinator")," (this broker can be different for different consumer groups)."),(0,o.kt)("li",{parentName:"ul"},"As long as the consumer is sending heartbeats at regular intervals, it is assumed to be alive, well, and processing messages from its partitions."),(0,o.kt)("li",{parentName:"ul"},"Heartbeats are sent when the consumer polls (i.e., retrieves records) and when it commits records it has consumed."),(0,o.kt)("li",{parentName:"ul"},"If the consumer stops sending heartbeats for long enough, its session will time out and the group coordinator will consider it dead and trigger a rebalance. If a consumer crashed and stopped processing messages, it will take the group coordinator a few seconds without heartbeats to decide it is dead and trigger the rebalance. During those seconds, no messages will be processed from the partitions owned by the dead consumer. When closing a consumer cleanly, the consumer will notify the group coordinator that it is leaving, and the group coordinator will trigger a rebalance immediately, reducing the gap in processing."))),(0,o.kt)("li",{parentName:"ul"},"How Does the Process of Assigning Partitions to Brokers Work?",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"When a consumer wants to join a group, it sends a JoinGroup request to the group coordinator. The first consumer to join the group becomes the group leader. The leader receives a list of all consumers in the group from the group coordinator (this will include all consumers that sent a heartbeat recently and which are therefore considered alive) and is responsible for assigning a subset of partitions to each consumer. It uses an implementation of PartitionAssignor to decide which partitions should be handled by which consumer."),(0,o.kt)("li",{parentName:"ul"},"Kafka has two built-in partition assignment policies. After deciding on the partition assignment, the consumer leader sends the list of assignments to the GroupCoordinator, which sends this information to all the consumers. Each consumer only sees his own assignment - the leader is the only client process that has the full list of consumers in the group and their assignments. This process repeats every time a rebalance happens."),(0,o.kt)("li",{parentName:"ul"},"partition.assignment.strategy ","[ ",(0,o.kt)("em",{parentName:"li"},"Range"),", RoundRobin ]"))),(0,o.kt)("li",{parentName:"ul"},"The poll loop")),(0,o.kt)("p",null,"At the heart of the consumer API is a simple loop for polling the server for more data. Once the consumer subscribes to topics, the poll loop handles all details of coordina\u2010 tion, partition rebalances, heartbeats, and data fetching, leaving the developer with a clean API that simply returns available data from the assigned partitions."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Configuration of Consumers",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"fetch.min.bytes"),(0,o.kt)("li",{parentName:"ul"},"fetch.max.wait.ms"),(0,o.kt)("li",{parentName:"ul"},"max.partition.fetch.bytes"),(0,o.kt)("li",{parentName:"ul"},"session.timeout.ms"),(0,o.kt)("li",{parentName:"ul"},"auto.offset.reset"),(0,o.kt)("li",{parentName:"ul"},"enable.auto.commit"),(0,o.kt)("li",{parentName:"ul"},"partition.assignment.strategy ","[ ",(0,o.kt)("em",{parentName:"li"},"Range"),", RoundRobin ]"),(0,o.kt)("li",{parentName:"ul"},"client.id"),(0,o.kt)("li",{parentName:"ul"},"max.poll.records"),(0,o.kt)("li",{parentName:"ul"},"receive.buffer.bytes and send.buffer.bytes"))),(0,o.kt)("li",{parentName:"ul"},"Commits and Offsets",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"__consumer_offsets")," topic"),(0,o.kt)("li",{parentName:"ul"},"Automatic Commit"),(0,o.kt)("li",{parentName:"ul"},"Commit Current Offset"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"auto.commit.offset = ","[true, false]")),(0,o.kt)("li",{parentName:"ul"},"Asynchronous Commit"),(0,o.kt)("li",{parentName:"ul"},"Commit Specified Offset",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"commitSync()")," or ",(0,o.kt)("em",{parentName:"li"},"CommitAsync()")))),(0,o.kt)("li",{parentName:"ul"},"Rebalance Listeners"),(0,o.kt)("li",{parentName:"ul"},"Consuming Records with Specific Offsets"),(0,o.kt)("li",{parentName:"ul"},"Exiting the consumer",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"consumer.wakeup()"),(0,o.kt)("li",{parentName:"ul"},"consumer.close()"))),(0,o.kt)("li",{parentName:"ul"},"Standalone Consumer, Consumer without a group")))),(0,o.kt)("h2",{id:"kafka-consumer-groups"},"Kafka Consumer Groups"),(0,o.kt)("p",null,"A consumer group is a group of related consumers that perform a task, like putting data into Hadoop or sending messages to a service. Consumer groups each have unique offsets per partition. Different consumer groups can read from different locations in a partition."),(0,o.kt)("p",null,"The consumer groups have their own offset for every partition in the topic which is unique to what other consumer groups have."),(0,o.kt)("p",null,"A consumer group has a unique id. Each consumer group is a subscriber to one or more Kafka topics. Each consumer group maintains its offset per topic partition. If you need multiple subscribers, then you have multiple consumer groups. A record gets delivered to only one consumer in a consumer group."),(0,o.kt)("p",null,"Each consumer in a consumer group processes records and only one consumer in that group will get the same record. Consumers in a consumer group load balance record processing."),(0,o.kt)("p",null,"The partitions of any topics subscribed to by consumers in a consumer group are guaranteed to be assigned to at most one individual consumer in that group at any time. The messages from each topic partition are delivered to the assigned consumer strictly in the order they are stored in the log."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(890846).Z,width:"801",height:"504"})),(0,o.kt)("p",null,"Consumers remember offset where they left off reading. Consumers groups each have their own offset per partition."),(0,o.kt)("p",null,"Supposeyou have an application that needs to read messages from a Kafka topic, run some validations against them, and write the results to another data store. In this case your application will create a consumer object, subscribe to the appropriate topic, and start receiving messages, validating them and writing the results. This may work well for a while, but what if the rate at which producers write messages to the topic exceeds the rate at which your application can validate them? If you are limited to a single consumer reading and processing the data, your application may fall farther and farther behind, unable to keep up with the rate of incoming messages. Obviously there is a need to scale consumption from topics. Just like multiple producers can write to the same topic, we need to allow multiple consumers to read from the same topic, splitting the data between them."),(0,o.kt)("p",null,"Kafka consumers are typically part of aconsumer group. When multiple consumers are subscribed to a topic and belong to the same consumer group, each consumer in the group will receive messages from a different subset of the partitions in the topic."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(300808).Z,width:"710",height:"501"})),(0,o.kt)("h2",{id:"kafka-consumer-load-share"},"Kafka Consumer Load Share"),(0,o.kt)("p",null,'Kafka consumer consumption divides partitions over consumer instances within a consumer group. Each consumer in the consumer group is an exclusive consumer of a "fair share" of partitions. This is how Kafka does load balancing of consumers in a consumer group. Consumer membership within a consumer group is handled by the Kafka protocol dynamically. If new consumers join a consumer group, it gets a share of partitions. If a consumer dies, its partitions are split among the remaining live consumers in the consumer group. This is how Kafka does fail over of consumers in a consumer group.'),(0,o.kt)("h2",{id:"kafka-consumer-failover"},"Kafka Consumer Failover"),(0,o.kt)("p",null,"Consumers notify the Kafka broker when they have successfully processed a record, which advances the offset."),(0,o.kt)("p",null,"If a consumer fails before sending commit offset to Kafka broker, then a different consumer can continue from the last committed offset."),(0,o.kt)("p",null,"If a consumer fails after processing the record but before sending the commit to the broker, then some Kafka records could be reprocessed. In this scenario, Kafka implements the at least once behavior, and you should make sure the messages (record deliveries ) are idempotent."),(0,o.kt)("h2",{id:"offset-management"},"Offset Management"),(0,o.kt)("p",null,'Kafka stores offset data in a topic called"__consumer_offset". These topics use log compaction, which means they only save the most recent value per key.'),(0,o.kt)("p",null,'When a consumer has processed data, it should commit offsets. If consumer process dies, it will be able to start up and start reading where it left off based on offset stored in"__consumer_offset"or as discussed another consumer in the consumer group can take over.'),(0,o.kt)("h2",{id:"what-can-kafka-consumers-see"},"What Can Kafka Consumers See?"),(0,o.kt)("p",null,'What records can be consumed by a Kafka consumer? Consumers can\'t read un-replicated data. Kafka consumers can only consume messages beyond the "High Watermark" offset of the partition. "Log end offset" is offset of the last record written to log partition and where producers writes to next.'),(0,o.kt)("p",null,'"High Watermark" is the offset of the last record that was successfully replicated to all partition\'s followers. Consumer only reads up to the "High Watermark".'),(0,o.kt)("h2",{id:"when-can-a-consumer-see-a-record"},"When can a consumer see a record?"),(0,o.kt)("p",null,"A consumer can see a record after the record gets fully replicated to all followers."),(0,o.kt)("h2",{id:"consumer-to-partition-cardinality---load-sharing-redux"},"Consumer to Partition Cardinality - Load Sharing Redux"),(0,o.kt)("p",null,"Only a single consumer from the same consumer group can access a single partition. If consumer group count exceeds the partition count, then the extra consumers remain idle. Kafka can use the idle consumers for failover. If there are more partitions than consumer group, then some consumers will read from more than one partition."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(824903).Z,width:"804",height:"548"})),(0,o.kt)("p",null,"Notice that server 1 has topic partition P2, P3, and P4, while server 2 has partition P0, P1, and P5. Notice that Consumer C0 from Consumer Group A is processing records from P0 and P2. Notice that no single partition is shared by any consumer from any consumer group. Notice that each partition gets its fair share of partitions for the topics."),(0,o.kt)("h2",{id:"multi-threaded-kafka-consumers"},"Multi-Threaded Kafka Consumers"),(0,o.kt)("p",null,"You can run more than one Consumer in a JVM process by using threads."),(0,o.kt)("h2",{id:"consumer-with-many-threads"},"Consumer With Many Threads"),(0,o.kt)("p",null,"If processing a record takes a while, a single Consumer can run multiple threads to process records, but it is harder to manage offset for each Thread/Task. If one consumer runs multiple threads, then two messages on the same partitions could be processed by two different threads which make it hard to guarantee record delivery order without complex thread coordination. This setup might be appropriate if processing a single task takes a long time, but try to avoid it."),(0,o.kt)("h2",{id:"thread-per-consumer"},"Thread per Consumer"),(0,o.kt)("p",null,"If you need to run multiple consumers, then run each consumer in their own thread. This way Kafka can deliver record batches to the consumer and the consumer does not have to worry about the offset ordering. A thread per consumer makes it easier to manage offsets. It is also simpler to manage failover (each process runs X num of consumer threads) as you can allow Kafka to do the brunt of the work."),(0,o.kt)("h2",{id:"what-happens-if-you-run-multiple-consumers-in-many-threads-in-the-same-jvm"},"What happens if you run multiple consumers in many threads in the same JVM?"),(0,o.kt)("p",null,"Each thread manages a share of partitions for that consumer group."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image",src:a(534566).Z,width:"644",height:"203"})),(0,o.kt)("p",null,"When a partition gets reassigned to another consumer in the group, the initial position is set to the last committed offset. If the consumer in the example above suddenly crashed, then the group member taking over the partition would begin consumption from offset 1. In that case, it would have to reprocess the messages up to the crashed consumer's position of 6."),(0,o.kt)("p",null,"The diagram also shows two other significant positions in the log. The log end offset is the offset of the last message written to the log. The high watermark is the offset of the last message that was successfully copied to all of the log's replicas. From the perspective of the consumer, the main thing to know is that you can only read up to the high watermark. This prevents the consumer from reading unreplicated data which could later be lost."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0-9-consumer-client"},"https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0-9-consumer-client")),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.oreilly.com/library/view/kafka-the-definitive/9781491936153/ch04.html"},"https://www.oreilly.com/library/view/kafka-the-definitive/9781491936153/ch04.html")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e"},"https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://streaml.io/blog/exactly-once"},"https://streaml.io/blog/exactly-once")),(0,o.kt)("h2",{id:"kafka-partition-assignment-strategies"},"Kafka Partition Assignment Strategies"),(0,o.kt)("p",null,"When creating a new Kafka consumer, we can configure the strategy that will be used to assign the partitions amongst the consumer instances."),(0,o.kt)("p",null,"The assignment strategy is configurable through the property"),(0,o.kt)("p",null,"partition.assignment.strategy"),(0,o.kt)("p",null,"Kafka Clients provides three built-in strategies"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Range (default)"),(0,o.kt)("p",{parentName:"li"},"Assigns to each consumer a consecutive subset of partitions from each topic it subscribes to. So if consumers C1 and C2 are subscribed to two topics, T1 and T2, and each of the topics has three partitions, then C1 will be assigned partitions 0 and 1 from topics T1 and T2, while C2 will be assigned partition 2 from those topics. Because each topic has an uneven number of partitions and the assignment is done for each topic independently, the first consumer ends up with more partitions than the second. This happens whenever Range assignment is used and the number of consumers does not divide the number of partitions in each topic neatly.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"RoundRobin"),(0,o.kt)("p",{parentName:"li"},"Takes all the partitions from all subscribed topics and assigns them to consumers sequentially, one by one. If C1 and C2 described previously used RoundRobin assignment, C1 would have partitions 0 and 2 from topic T1 and partition 1 from topic T2. C2 would have partition 1 from topic T1 and partitions 0 and 2 from topic T2. In general, if all consumers are subscribed to the same topics (a very common scenario), RoundRobin assignment will end up with all consumers having the same number of partitions (or at most 1 partition difference).")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"StickyAssignor"))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://medium.com/streamthoughts/understanding-kafka-partition-assignment-strategies-and-how-to-write-your-own-custom-assignor-ebeda1fc06f3"},"https://medium.com/streamthoughts/understanding-kafka-partition-assignment-strategies-and-how-to-write-your-own-custom-assignor-ebeda1fc06f3")),(0,o.kt)("h2",{id:"advanced"},"Advanced"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.confluent.io/blog/kafka-python-asyncio-integration"},"https://www.confluent.io/blog/kafka-python-asyncio-integration")))}h.isMDXComponent=!0},890846:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Technologies-Kafka-Kafka-Consumers-image1-7d9a71b8b8532c443bd7af4de3997737.jpg"},300808:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Technologies-Kafka-Kafka-Consumers-image2-ca0f8e5189e22c0d599efbd565d31806.jpg"},824903:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Technologies-Kafka-Kafka-Consumers-image3-45b3a6f627cb64c46c0e5f3ddc979ffb.jpg"},534566:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Technologies-Kafka-Kafka-Consumers-image4-13a4e5a5643905808a52a8f00296c0e9.jpg"}}]);