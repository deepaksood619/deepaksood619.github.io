"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[92839],{603905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var i=a(667294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,r=function(e,t){if(null==e)return{};var a,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(a),u=r,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return a?i.createElement(h,n(n({ref:t},d),{},{components:a})):i.createElement(h,n({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,n=new Array(o);n[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,n[1]=s;for(var c=2;c<o;c++)n[c]=a[c];return i.createElement.apply(null,n)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},57289:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=a(487462),r=(a(667294),a(603905));const o={},n="Redis Eviction Policies",s={unversionedId:"databases/nosql-databases/redis/redis-eviction-policies",id:"databases/nosql-databases/redis/redis-eviction-policies",title:"Redis Eviction Policies",description:"The exact behavior Redis follows when themaxmemorylimit is reached is configured using themaxmemory-policyconfiguration directive.",source:"@site/docs/databases/nosql-databases/redis/redis-eviction-policies.md",sourceDirName:"databases/nosql-databases/redis",slug:"/databases/nosql-databases/redis/redis-eviction-policies",permalink:"/databases/nosql-databases/redis/redis-eviction-policies",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/databases/nosql-databases/redis/redis-eviction-policies.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Redis Data Types",permalink:"/databases/nosql-databases/redis/redis-data-types"},next:{title:"redis-py",permalink:"/databases/nosql-databases/redis/redis-py"}},l={},c=[{value:"How the eviction process works",id:"how-the-eviction-process-works",level:2},{value:"Approximated LRU algorithm",id:"approximated-lru-algorithm",level:2},{value:"LFU Mode (Least Frequently Used)",id:"lfu-mode-least-frequently-used",level:2}],d={toc:c},p="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"redis-eviction-policies"},"Redis Eviction Policies"),(0,r.kt)("p",null,"The exact behavior Redis follows when themaxmemorylimit is reached is configured using themaxmemory-policyconfiguration directive.\nThe following policies are available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"noeviction:")," return errors when the memory limit was reached and the client is trying to execute commands that could result in more memory to be used (most write commands, but ",(0,r.kt)("a",{parentName:"li",href:"https://redis.io/commands/del"},"DEL")," and a few more exceptions)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"allkeys-lru:")," evict keys by trying to remove the less recently used (LRU) keys first, in order to make space for the new data added."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile-lru:")," evict keys by trying to remove the less recently used (LRU) keys first, but only among keys that have anexpire set, in order to make space for the new data added."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"allkeys-random:")," evict keys randomly in order to make space for the new data added."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile-random:")," evict keys randomly in order to make space for the new data added, but only evict keys with anexpire set."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile-ttl:")," evict keys with anexpire set, and try to evict keys with a shorter time to live (TTL) first, in order to make space for the new data added.\nThe policies ",(0,r.kt)("strong",{parentName:"li"},"volatile-lru, volatile-random")," and ",(0,r.kt)("strong",{parentName:"li"},"volatile-ttl")," behave like ",(0,r.kt)("strong",{parentName:"li"},"noeviction")," if there are no keys to evict matching the prerequisites.\nPicking the right eviction policy is important depending on the access pattern of your application, however you can reconfigure the policy at runtime while the application is running, and monitor the number of cache misses and hits using the Redis ",(0,r.kt)("a",{parentName:"li",href:"https://redis.io/commands/info"},"INFO")," output in order to tune your setup.\nIn general as a rule of thumb:"),(0,r.kt)("li",{parentName:"ul"},"Use the ",(0,r.kt)("strong",{parentName:"li"},"allkeys-lru")," policy when you expect a power-law distribution in the popularity of your requests, that is, you expect that a subset of elements will be accessed far more often than the rest. ",(0,r.kt)("strong",{parentName:"li"},"This is a good pick if you are unsure.")),(0,r.kt)("li",{parentName:"ul"},"Use the ",(0,r.kt)("strong",{parentName:"li"},"allkeys-random")," if you have a cyclic access where all the keys are scanned continuously, or when you expect the distribution to be uniform (all elements likely accessed with the same probability)."),(0,r.kt)("li",{parentName:"ul"},"Use the ",(0,r.kt)("strong",{parentName:"li"},"volatile-ttl")," if you want to be able to provide hints to Redis about what are good candidate for expiration by using different TTL values when you create your cache objects.\nThe ",(0,r.kt)("strong",{parentName:"li"},"volatile-lru and volatile-random")," policies are mainly useful when you want to use a single instance for both caching and to have a set of persistent keys. However it is usually a better idea to run two Redis instances to solve such a problem.\nIt is also worth noting that setting an expire to a key costs memory, so using a policy like ",(0,r.kt)("strong",{parentName:"li"},"allkeys-lru")," is more memory efficient since there is no need to set an expire for the key to be evicted under memory pressure.")),(0,r.kt)("h2",{id:"how-the-eviction-process-works"},"How the eviction process works"),(0,r.kt)("p",null,"It is important to understand that the eviction process works like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A client runs a new command, resulting in more data added."),(0,r.kt)("li",{parentName:"ul"},"Redis checks the memory usage, and if it is greater than themaxmemorylimit , it evicts keys according to the policy."),(0,r.kt)("li",{parentName:"ul"},"A new command is executed, and so forth.\nSo we continuously cross the boundaries of the memory limit, by going over it, and then by evicting keys to return back under the limits.\nIf a command results in a lot of memory being used (like a big set intersection stored into a new key) for some time the memory limit can be surpassed by a noticeable amount.")),(0,r.kt)("h2",{id:"approximated-lru-algorithm"},"Approximated LRU algorithm"),(0,r.kt)("p",null,"Redis LRU algorithm is not an exact implementation. This means that Redis is not able to pick thebest candidatefor eviction, that is, the access that was accessed the most in the past. Instead it will try to run an approximation of the LRU algorithm, by sampling a small number of keys, and evicting the one that is the best (with the oldest access time) among the sampled keys.\nHowever since Redis 3.0 the algorithm was improved to also take a pool of good candidates for eviction. This improved the performance of the algorithm, making it able to approximate more closely the behavior of a real LRU algorithm.\nWhat is important about the Redis LRU algorithm is that youare able to tunethe precision of the algorithm by changing the number of samples to check for every eviction. This parameter is controlled by the following configuration directive:"),(0,r.kt)("p",null,"maxmemory-samples 5"),(0,r.kt)("h2",{id:"lfu-mode-least-frequently-used"},"LFU Mode (Least Frequently Used)"),(0,r.kt)("p",null,"If you think at LRU, an item that was recently accessed but is actually almost never requested, will not get expired, so the risk is to evict a key that has an higher chance to be requested in the future. LFU does not have this problem, and in general should adapt better to different access patterns.\nTo configure the LFU mode, the following policies are available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile-lfu")," Evict using approximated LFU among the keys with an expire set."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"allkeys-lfu")," Evict any key using approximated LFU.")),(0,r.kt)("p",null,"LFU is approximated like LRU: it uses a probabilistic counter, called a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Approximate_counting_algorithm"},"Morris counter")," in order to estimate the object access frequency using just a few bits per object, combined with a decay period so that the counter is reduced over time: at some point we no longer want to consider keys as frequently accessed, even if they were in the past, so that the algorithm can adapt to a shift in the access pattern."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://redis.io/topics/lru-cache"},"https://redis.io/topics/lru-cache")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://tokers.github.io/posts/lru-and-lfu-in-redis-memory-eviction"},"https://tokers.github.io/posts/lru-and-lfu-in-redis-memory-eviction")))}m.isMDXComponent=!0}}]);