"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[54416],{603905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>v});var n=r(667294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(r),h=a,v=p["".concat(l,".").concat(h)]||p[h]||u[h]||s;return r?n.createElement(v,o(o({ref:t},d),{},{components:r})):n.createElement(v,o({ref:t},d))}));function v(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},70761:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var n=r(487462),a=(r(667294),r(603905));const s={},o="Services",i={unversionedId:"devops/kubernetes/services-loadbalancing-and-networking/services",id:"devops/kubernetes/services-loadbalancing-and-networking/services",title:"Services",description:"A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service.",source:"@site/docs/devops/kubernetes/services-loadbalancing-and-networking/services.md",sourceDirName:"devops/kubernetes/services-loadbalancing-and-networking",slug:"/devops/kubernetes/services-loadbalancing-and-networking/services",permalink:"/devops/kubernetes/services-loadbalancing-and-networking/services",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/devops/kubernetes/services-loadbalancing-and-networking/services.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Others",permalink:"/devops/kubernetes/services-loadbalancing-and-networking/others"},next:{title:"Storage",permalink:"/devops/kubernetes/storage"}},l={},c=[{value:"Headless services",id:"headless-services",level:2},{value:"With selectors",id:"with-selectors",level:2},{value:"Without selectors",id:"without-selectors",level:2},{value:"Anatomy of a Kubernetes Service",id:"anatomy-of-a-kubernetes-service",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...s}=e;return(0,a.kt)(p,(0,n.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"services"},"Services"),(0,a.kt)("p",null,"A Kubernetes ",(0,a.kt)("strong",{parentName:"p"},"Service")," is an abstraction which defines a logical set of ",(0,a.kt)("strong",{parentName:"p"},"Pods")," and a policy by which to access them - sometimes called a micro-service."),(0,a.kt)("p",null,"Remember that Pods are not durable. When a Pod dies, the ReplicaSet creates a new Pod instance. The new Pod's IP address differs from the old Pod's IP address. Therefore services are used. A service gets its own stable IP address, a stable DNS name and a stable port. Services provide service discovery, load-balancing, and features to support zero-downtime deployments."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"An abstraction to define a logical set of Pods bound by a policy by to access them"),(0,a.kt)("li",{parentName:"ul"},"Services are exposed through intenal and external endpoints"),(0,a.kt)("li",{parentName:"ul"},"Services can also point to non-Kubenetes endpoints through a Virtual-IP-Bridge"),(0,a.kt)("li",{parentName:"ul"},"Supports TCP and UDP"),(0,a.kt)("li",{parentName:"ul"},"Interfaces with kube-proxy to manipulate iptables"),(0,a.kt)("li",{parentName:"ul"},"Service can be exposed internal or external to the cluster")),(0,a.kt)("p",null,"Kubernetes provides two types of Services."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"A ",(0,a.kt)("strong",{parentName:"p"},"ClusterIP service")," gives you a service inside your cluster. Your apps inside your cluster can access that service via a stable IP address, DNS name and port. A ClusterIP service does not provide access from outside the cluster.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"A ",(0,a.kt)("strong",{parentName:"p"},"NodePort service")," provides access to a Pod from outside the cluster. And everything a ClusterIP service provides.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/#loadbalancer"},"LoadBalancer"),": Exposes the service externally using a cloud provider's load balancer.NodePortandClusterIPservices, to which the external load balancer will route, are automatically created.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"https://kubernetes.io/docs/concepts/services-networking/#externalname"},"ExternalName"),":")," Maps the service to the contents of theexternalNamefield (e.g.foo.bar.example.com), by returning aCNAMErecord with its value. No proxying of any kind is set up. This requires version 1.7 or higher ofkube-dns."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"An ExternalName Service is a special case of Service that does not have selectors and uses DNS names instead."),(0,a.kt)("li",{parentName:"ul"},"When looking up the hostmy-service.prod.svc.cluster.local, the cluster DNS Service returns aCNAMErecord with the valuemy.database.example.com. Accessingmy-serviceworks in the same way as other Services but with the crucial difference that redirection happens at the DNS level rather than via proxying or forwarding. Should you later decide to ",(0,a.kt)("strong",{parentName:"li"},"move your database into your cluster"),", you can start its Pods, add appropriate selectors or endpoints, and change the Service'stype.")))),(0,a.kt)("p",null,"For Kubernetes-native applications, Kubernetes offers a simple ",(0,a.kt)("strong",{parentName:"p"},"Endpoints")," API that is updated whenever the set of ",(0,a.kt)("strong",{parentName:"p"},"Pods")," in a ",(0,a.kt)("strong",{parentName:"p"},"Service")," changes. For non-native applications, Kubernetes offers a virtual-IP-based bridge to Services which redirects to the backend ",(0,a.kt)("strong",{parentName:"p"},"Pods"),"."),(0,a.kt)("h2",{id:"headless-services"},"Headless services"),(0,a.kt)("p",null,'Sometimes you don\'t need or want load-balancing and a single service IP. In this case, you can create "headless" services by specifying"None"for the cluster IP (.spec.clusterIP).'),(0,a.kt)("p",null,"This option allows developers to reduce coupling to the Kubernetes system by allowing them freedom to do discovery their own way. Applications can still use a self-registration pattern and adapters for other discovery systems could easily be built upon this API."),(0,a.kt)("p",null,"For suchServices, a cluster IP is not allocated, kube-proxy does not handle these services, and there is no load balancing or proxying done by the platform for them. How DNS is automatically configured depends on whether the service has selectors defined."),(0,a.kt)("h2",{id:"with-selectors"},"With selectors"),(0,a.kt)("p",null,"For headless services that define selectors, the endpoints controller createsEndpointsrecords in the API, and modifies the DNS configuration to return A records (addresses) that point directly to thePodsbacking theService."),(0,a.kt)("h2",{id:"without-selectors"},"Without selectors"),(0,a.kt)("p",null,"For headless services that do not define selectors, the endpoints controller does not createEndpointsrecords. However, the DNS system looks for and configures either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CNAME records for ",(0,a.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname"},"ExternalName"),"-type services."),(0,a.kt)("li",{parentName:"ul"},"A records for anyEndpointsthat share a name with the service, for all other types.")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/service"},"https://kubernetes.io/docs/concepts/services-networking/service")),(0,a.kt)("h2",{id:"anatomy-of-a-kubernetes-service"},"Anatomy of a Kubernetes Service"),(0,a.kt)("p",null,"It's useful to think of a Kubernetes Service as having a front-end and a back-end:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Front-end: name, IP, port that never change"),(0,a.kt)("li",{parentName:"ul"},"Back-end: Pods that match a label selector")),(0,a.kt)("p",null,"The front-end isstableandreliable. This means thename, IPandport numberare guaranteed to never change for the entire life of the Service. The stable nature of the Service front-end also means that you do not need to worry about stale entries on clients that cache DNS results for longer than the standards recommend."),(0,a.kt)("p",null,"The back-end is highly dynamic and will load-balance traffic to all Pods in the cluster that match the set oflabelsthe Service is configured to look for."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image",src:r(155007).Z,width:"1246",height:"250"})),(0,a.kt)("p",null,'Load-balancingin this situation is simple L4 round-robin load-balancing. This works at the "connection" level where all requests over the sameconnectiongo to the same Pod. This means two things:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Multiple requests from the same browser will always hit the samePod. This is because browsers send all requests over a singleconnectionthat is kept open using keepalives. Requests via tools likecurlopen a newconnectionfor each request and will therefore hit different Pods.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Load-balancing is not aware ofapplication layer(L7) concepts such as HTTP headers and cookie-based session affinity."))),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery"},"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery")))}u.isMDXComponent=!0},155007:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/DevOps-Kubernetes-Services-image1-d0f0e40735af867b21ffca247c5977d2.jpg"}}]);