"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[31454],{603905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>h});var n=i(667294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(i),g=a,h=m["".concat(l,".").concat(g)]||m[g]||d[g]||r;return i?n.createElement(h,o(o({ref:t},c),{},{components:i})):n.createElement(h,o({ref:t},c))}));function h(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=i.length,o=new Array(r);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=i[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}g.displayName="MDXCreateElement"},465092:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=i(487462),a=(i(667294),i(603905));const r={},o="Software Complexity",s={unversionedId:"computer-science/software-engineering/complexity",id:"computer-science/software-engineering/complexity",title:"Software Complexity",description:"- Learning and Discovery - Iteration, Feedback, Incrementalism, Experimentation and Empiricism",source:"@site/docs/computer-science/software-engineering/complexity.md",sourceDirName:"computer-science/software-engineering",slug:"/computer-science/software-engineering/complexity",permalink:"/computer-science/software-engineering/complexity",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/software-engineering/complexity.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Smell",permalink:"/computer-science/software-engineering/code-smell"},next:{title:"Developer Roles",permalink:"/computer-science/software-engineering/developer-roles"}},l={},p=[{value:"No Silver Bullet-- Essence and Accident in Software Engineering",id:"no-silver-bullet---essence-and-accident-in-software-engineering",level:2},{value:"Summary",id:"summary",level:3},{value:"Encapsulated vs systemic complexity in protocol design",id:"encapsulated-vs-systemic-complexity-in-protocol-design",level:2},{value:"How do we make the tradeoff?",id:"how-do-we-make-the-tradeoff",level:3}],c={toc:p},m="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"software-complexity"},"Software Complexity"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Learning and Discovery -")," Iteration, Feedback, Incrementalism, Experimentation and Empiricism"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Managing Complexity -")," Modularity, Information Hiring, Seperation of Concerns, Loose-Coupling, Cohesion")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://dont.build"},"https://dont.build")),(0,a.kt)("p",null,"Making great software is more about ",(0,a.kt)("strong",{parentName:"p"},"managing complexity and thinking through details")," than it is about design or pretty pixels. One of the biggest misunderstandings of our era."),(0,a.kt)("h2",{id:"no-silver-bullet---essence-and-accident-in-software-engineering"},"No Silver Bullet-- Essence and Accident in Software Engineering"),(0,a.kt)("p",null,'"No Silver Bullet-- Essence and Accident in Software Engineering" is a widely discussed paper on ',(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Software_engineering"},"software engineering")," written by ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Turing_Award"},"Turing Award")," winner ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fred_Brooks"},"Fred Brooks"),' in 1987.Brooks argues that "there is no single development, in either technology or management technique, which by itself promises even one ',(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Order_of_magnitude"},"order of magnitude"),' (tenfold) improvement within a decade in productivity, in reliability, in simplicity." He also states that "we cannot expect ever to see two-fold gains every two years" in software development, as there is in hardware development (',(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Moore%27s_law"},"Moore's law"),")."),(0,a.kt)("h3",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Brooks distinguishes between two different types of complexity: ",(0,a.kt)("strong",{parentName:"p"},"accidental complexity and essential complexity.")," This is related to ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Aristotle"},"Aristotle"),"'s classification. Accidental complexity relates to problems which engineers create and can fix; for example, the details of writing and optimizing ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Assembly_language"},"assembly")," code or the delays caused by batch processing. Essential complexity is caused by the problem to be solved, and nothing can remove it; if users want a program to do 30 different things, then those 30 things are essential and the program must do those 30 different things."),(0,a.kt)("p",null,"Brooks claims that the accidental complexity has decreased substantially, and today's programmers spend most of their time addressing essential complexity. Brooks argues that this means that shrinking all the accidental activities to zero will not give the same order-of-magnitude improvement as attempting to decrease essential complexity. While Brooks insists that there is no one ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Silver_bullet"},"silver bullet"),", he believes that a series of innovations attacking essential complexity could lead to significant improvements. One technology that had made significant improvement in the area of accidental complexity was the invention of ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/High-level_programming_language"},"high-level programming languages"),", such as ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ada_(programming_language)"},"Ada"),".Today's languages, such as ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/C_(programming_language)"},"C"),", ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/C%2B%2B"},"C++"),", ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/C_Sharp_(programming_language)"},"C#")," and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Java_(programming_language)"},"Java"),", are considered to be improvements, but not of the same order of magnitude."),(0,a.kt)("p",null,'Brooks advocates "growing" software organically through incremental development. He suggests devising and implementing the main and subprograms right at the beginning, filling in the working sub-sections later. He believes that programming this way excites the engineers and provides a working system at every stage of development.'),(0,a.kt)("p",null,'Brooks goes on to argue that there is a difference between "good" designers and "great" designers. He postulates that as programming is a creative process, some designers are inherently better than others. He suggests that there is as much as a tenfold difference between an ordinary designer and a great one. He then advocates treating star designers equally well as star managers, providing them not just with equal ',(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Remuneration"},"remuneration"),", but also all the perks of higher status: large office, staff, travel funds, etc."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/No_Silver_Bullet"},"https://en.wikipedia.org/wiki/No_Silver_Bullet")),(0,a.kt)("h2",{id:"encapsulated-vs-systemic-complexity-in-protocol-design"},"Encapsulated vs systemic complexity in protocol design"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Encapsulated  vs systemic complexity",src:i(104529).Z,width:"901",height:"471"})),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Encapsulated complexity"),' occurs when there is a system with sub-systems that are internally complex, but that present a simple "interface" to the outside. ',(0,a.kt)("strong",{parentName:"p"},"Systemic complexity")," occurs when the different parts of a system can't even be cleanly separated, and have complex interactions with each other."),(0,a.kt)("h3",{id:"how-do-we-make-the-tradeoff"},"How do we make the tradeoff?"),(0,a.kt)("p",null,"Often, the choice with less encapsulated complexity is also the choice with less systemic complexity, and so there is one choice that is obviously simpler. But at other times, you have to make a hard choice between one type of complexity and the other. What should be clear at this point is that\xa0",(0,a.kt)("strong",{parentName:"p"},"complexity is less dangerous if it is encapsulated"),". The risks from complexity of a system are not a simple function of how long the specification is; a small 10-line piece of the specification that interacts with every other piece adds more complexity than a 100-line function that is otherwise treated as a black box."),(0,a.kt)("p",null,"However, there are limits to this approach of preferring encapsulated complexity. Software bugs can occur in any piece of code, and as it gets bigger the probability of a bug approaches 1. Sometimes, when you need to interact with a sub-system in an unexpected and new way,\xa0",(0,a.kt)("strong",{parentName:"p"},"complexity that was originally encapsulated can become systemic"),"."),(0,a.kt)("p",null,"Ultimately, which type of complexity to favor in any given situation is a question with no easy answers. The best that we can do is to have an attitude of moderately favoring encapsulated complexity, but not too much, and exercise our judgement in each specific case. Sometimes, a sacrifice of a little bit of systemic complexity to allow a great reduction of encapsulated complexity really is the best thing to do. And other times, you can even misjudge what is encapsulated and what isn't. Each situation is different."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://vitalik.ca/general/2022/02/28/complexity.html"},"Encapsulated vs systemic complexity in protocol design")))}d.isMDXComponent=!0},104529:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/encapsulated_systemic-c65a8835ab49d15f895f014930cd86d3.jpg"}}]);