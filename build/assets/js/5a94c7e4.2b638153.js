"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[59866],{603905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>u});var r=a(667294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=r.createContext({}),p=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=p(a),m=i,u=h["".concat(c,".").concat(m)]||h[m]||d[m]||n;return a?r.createElement(u,o(o({ref:t},l),{},{components:a})):r.createElement(u,o({ref:t},l))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,o=new Array(n);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<n;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},692992:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>s,toc:()=>p});var r=a(487462),i=(a(667294),a(603905));const n={},o="Lambda Architecture",s={unversionedId:"computer-science/system-design/lambda-architecture",id:"computer-science/system-design/lambda-architecture",title:"Lambda Architecture",description:"Lambda architectureis a data-processing architecture designed to handle massive quantities of data by taking advantage of both batch and stream-processing methods. This approach to architecture attempts to balance latency), throughput, and fault-tolerance by using batch processing to provide comprehensive and accurate views of batch data, while simultaneously using real-time stream processing to provide views of online data. The two view outputs may be joined before presentation. The rise of lambda architecture is correlated with the growth of big data, real-time analytics, and the drive to mitigate the latencies of map-reduce.",source:"@site/docs/computer-science/system-design/lambda-architecture.md",sourceDirName:"computer-science/system-design",slug:"/computer-science/system-design/lambda-architecture",permalink:"/computer-science/system-design/lambda-architecture",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/computer-science/system-design/lambda-architecture.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Intro",permalink:"/computer-science/system-design/intro"},next:{title:"Microservice Architecture",permalink:"/computer-science/system-design/microservice-architecture/"}},c={},p=[{value:"Overview",id:"overview",level:2},{value:"Batch layer",id:"batch-layer",level:2},{value:"Speed layer",id:"speed-layer",level:2},{value:"Serving layer",id:"serving-layer",level:2},{value:"Common Lambda Architectures: Kafka, Spark, and MongoDB/Elasticsearch",id:"common-lambda-architectures-kafka-spark-and-mongodbelasticsearch",level:2},{value:"Shortcomings of Lambda Architecture",id:"shortcomings-of-lambda-architecture",level:2},{value:"Others - ALT (Aggregator Leaf Tailer)",id:"others---alt-aggregator-leaf-tailer",level:2}],l={toc:p},h="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"lambda-architecture"},"Lambda Architecture"),(0,i.kt)("p",null,"Lambda architectureis a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_processing"},"data-processing")," architecture designed to handle massive quantities of data by taking advantage of both ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Batch_processing"},"batch")," and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Stream_processing"},"stream-processing")," methods. This approach to architecture attempts to balance ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Latency_(engineering)"},"latency"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Throughput"},"throughput"),", and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fault-tolerance"},"fault-tolerance")," by using batch processing to provide comprehensive and accurate views of batch data, while simultaneously using real-time stream processing to provide views of online data. The two view outputs may be joined before presentation. The rise of lambda architecture is correlated with the growth of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Big_data"},"big data"),", real-time analytics, and the drive to mitigate the latencies of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Map-reduce"},"map-reduce"),".\nLambda architecture depends on a data model with an append-only, immutable data source that serves as a system of record.It is intended for ingesting and processing timestamped events that are appended to existing events rather than overwriting them. State is determined from the natural time-based ordering of the data.\n",(0,i.kt)("img",{alt:"image",src:a(903786).Z,width:"620",height:"179"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image",src:a(958581).Z,width:"1101",height:"617"})),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Lambda architecture describes a system consisting of three layers: batch processing, speed (or real-time) processing, and a serving layer for responding to queries.The processing layers ingest from an immutable master copy of the entire data set."),(0,i.kt)("h2",{id:"batch-layer"},"Batch layer"),(0,i.kt)("p",null,"The batch layer precomputes results using a distributed processing system that can handle very large quantities of data. The batch layer aims at perfect accuracy by being able to processallavailable data when generating views. This means it can fix any errors by recomputing based on the complete data set, then updating existing views. Output is typically stored in a read-only database, with updates completely replacing existing precomputed views.\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hadoop"},"Apache Hadoop")," is the de facto standard batch-processing system used in most high-throughput architectures."),(0,i.kt)("h2",{id:"speed-layer"},"Speed layer"),(0,i.kt)("p",null,"The speed layer processes data streams in real time and without the requirements of fix-ups or completeness. This layer sacrifices throughput as it aims to minimize latency by providing real-time views into the most recent data. Essentially, the speed layer is responsible for filling the \"gap\" caused by the batch layer's lag in providing views based on the most recent data. This layer's views may not be as accurate or complete as the ones eventually produced by the batch layer, but they are available almost immediately after data is received, and can be replaced when the batch layer's views for the same data become available.\nStream-processing technologies typically used in this layer include ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Storm_(event_processor)"},"Apache Storm"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Sqlstream"},"SQLstream")," and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_Spark"},"Apache Spark"),". Output is typically stored on fast NoSQL databases."),(0,i.kt)("h2",{id:"serving-layer"},"Serving layer"),(0,i.kt)("p",null,"Output from the batch and speed layers are stored in the serving layer, which responds to ad-hoc queries by returning precomputed views or building views from the processed data.\nExamples of technologies used in the serving layer include ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Druid_(open-source_data_store)"},"Druid"),", which provides a single cluster to handle output from both layers.Dedicated stores used in the serving layer include ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_Cassandra"},"Apache Cassandra"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_HBase"},"Apache HBase"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/MongoDB"},"MongoDB"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/VoltDB"},"VoltDB")," or ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elasticsearch"},"Elasticsearch")," for speed-layer output, and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nathanmarz/elephantdb"},"Elephant DB"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_Impala"},"Apache Impala"),", ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SAP_HANA"},"SAP HANA")," or ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_Hive"},"Apache Hive")," for batch-layer output.\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lambda_architecture"},"https://en.wikipedia.org/wiki/Lambda_architecture")),(0,i.kt)("h2",{id:"common-lambda-architectures-kafka-spark-and-mongodbelasticsearch"},"Common Lambda Architectures: Kafka, Spark, and MongoDB/Elasticsearch"),(0,i.kt)("p",null,"If you are a data practitioner, you would probably have either implemented or used a data processing platform that incorporates the Lambda architecture. A common implementation would have large batch jobs in Hadoop complemented by an update stream stored in Apache Kafka. Apache Spark is often used to read this data stream from Kafka, perform transformations, and then write the result to another Kafka log. In most cases, this would not be a single Spark job but a pipeline of Spark jobs. Each Spark job in the pipeline would read data produced by the previous job, do its own transformations, and feed it to the next job in the pipeline. The final output would be written to a serving system like Apache Cassandra, Elasticsearch or MongoDB."),(0,i.kt)("h2",{id:"shortcomings-of-lambda-architecture"},"Shortcomings of Lambda Architecture"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Maintaining two different processing paths, one via the batch system and another via the real-time streaming system, is inherently difficult. If you ship new code functionality to the streaming software but fail to make the necessary equivalent change to the batch software, you could get erroneous results.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If you are an application developer or data scientist who wants to make changes to your streaming or batch pipeline, you have to either learn how to operate and modify the pipeline, or you have to wait for someone else to make the changes on your behalf. The former option requires you to pick up data engineering tasks and detracts from your primary role, while the latter forces you into a holding pattern waiting on the pipeline team for resolution.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Most of the data transformation happens as new data enters the system at write time, whereas the serving layer is a simpler key-value lookup that does not handle complex transformations. This complicates the job of the application developer because she/he cannot easily apply new transformations retroactively on pre-existing data.\n",(0,i.kt)("a",{parentName:"p",href:"https://rockset.com/blog/aggregator-leaf-tailer-an-architecture-for-live-analytics-on-event-streams"},"https://rockset.com/blog/aggregator-leaf-tailer-an-architecture-for-live-analytics-on-event-streams")))),(0,i.kt)("h2",{id:"others---alt-aggregator-leaf-tailer"},"Others - ALT (Aggregator Leaf Tailer)"))}d.isMDXComponent=!0},903786:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Lambda-Architecture-image1-18ab9e2faf1a4e33ada9279f89ba9dbb.jpg"},958581:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Lambda-Architecture-image2-0ac15eba6650e06f9617d5eb34b6d3c4.jpg"}}]);