"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[66816],{603905:(t,e,n)=>{n.d(e,{Zo:()=>s,kt:()=>c});var a=n(667294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var m=a.createContext({}),p=function(t){var e=a.useContext(m),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},s=function(t){var e=p(t.components);return a.createElement(m.Provider,{value:e},t.children)},u="mdxType",g={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,m=t.parentName,s=o(t,["components","mdxType","originalType","parentName"]),u=p(n),d=r,c=u["".concat(m,".").concat(d)]||u[d]||g[d]||i;return n?a.createElement(c,l(l({ref:e},s),{},{components:n})):a.createElement(c,l({ref:e},s))}));function c(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=d;var o={};for(var m in e)hasOwnProperty.call(e,m)&&(o[m]=e[m]);o.originalType=t,o[u]="string"==typeof t?t:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},20273:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>m,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(487462),r=(n(667294),n(603905));const i={},l="Time Complexities",o={unversionedId:"algorithms/algorithmic-complexity/time-complexities",id:"algorithms/algorithmic-complexity/time-complexities",title:"Time Complexities",description:"Big O notation (with a capital letter O, not a zero), also called Landau's symbol, is a symbolism used in complexity theory, computer science, and mathematics to describe the asymptotic behavior of functions. Basically, it tells you how fast a function grows or declines. It describes how the runtime or space requirement of a function grows as the input grows.",source:"@site/docs/algorithms/algorithmic-complexity/time-complexities.md",sourceDirName:"algorithms/algorithmic-complexity",slug:"/algorithms/algorithmic-complexity/time-complexities",permalink:"/algorithms/algorithmic-complexity/time-complexities",draft:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/main/docs/algorithms/algorithmic-complexity/time-complexities.md",tags:[],version:"current",lastUpdatedAt:1677955187,formattedLastUpdatedAt:"Mar 4, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sub-linear time",permalink:"/algorithms/algorithmic-complexity/sub-linear-time"},next:{title:"Bit Manipulation",permalink:"/algorithms/bit-manipulation/"}},m={},p=[{value:"Pseudo-polynomial time",id:"pseudo-polynomial-time",level:2}],s={toc:p},u="wrapper";function g(t){let{components:e,...i}=t;return(0,r.kt)(u,(0,a.Z)({},s,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"time-complexities"},"Time Complexities"),(0,r.kt)("p",null,"Big O notation (with a capital letter O, not a zero), also called ",(0,r.kt)("strong",{parentName:"p"},"Landau's symbol,")," is a symbolism used in complexity theory, computer science, and mathematics to describe the asymptotic behavior of functions. Basically, it tells you how fast a function grows or declines. It describes how the runtime or space requirement of a function grows as the input grows."),(0,r.kt)("p",null,"Two functions with the same Big-O notation will tend to have the same growth rate and thus have the same relative performance with large inputs."),(0,r.kt)("p",null,"For example, the bubble sort algorithm has an average time complexity of O(n^2) while merge sort and heap sort both have an average complexity of O(n log n). In average cases, merge sort and heap sort will demonstrate similar performance while they will both outperform bubble sort."),(0,r.kt)("p",null,"In the table, poly(",(0,r.kt)("em",{parentName:"p"},"x"),")=",(0,r.kt)("em",{parentName:"p"},"x^O^"),"^(1)^, i.e., polynomial in",(0,r.kt)("em",{parentName:"p"},"x"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Complexity class")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Running time (T(n))")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Examples of running times")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Example algorithms")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"constant time"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"Determining if an integer (represented in binary) is even or odd"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"inverse Ackermann time"),(0,r.kt)("td",{parentName:"tr",align:null},"O(alpha(n))"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iterated logarithmictime"),(0,r.kt)("td",{parentName:"tr",align:null},"O(log*n)"),(0,r.kt)("td",{parentName:"tr",align:null},"Distributed coloring of cycles"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"log-logarithmic"),(0,r.kt)("td",{parentName:"tr",align:null},"O(log logn)"),(0,r.kt)("td",{parentName:"tr",align:null},"Amortized time per operation using a boundedpriority queue"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"logarithmic time"),(0,r.kt)("td",{parentName:"tr",align:null},"DLOGTIME"),(0,r.kt)("td",{parentName:"tr",align:null},"O(logn)"),(0,r.kt)("td",{parentName:"tr",align:null},"logn, log(n2)"),(0,r.kt)("td",{parentName:"tr",align:null},"Binary search")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"polylogarithmic time"),(0,r.kt)("td",{parentName:"tr",align:null},"poly(logn)"),(0,r.kt)("td",{parentName:"tr",align:null},"(logn)2"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fractional power (sqrt(n)) (sublinear polynomials)"),(0,r.kt)("td",{parentName:"tr",align:null},"O(nc)where 0 < c < 1"),(0,r.kt)("td",{parentName:"tr",align:null},"n1/2,n2/3"),(0,r.kt)("td",{parentName:"tr",align:null},"Integer factorization, Searching in akd-tree, Grover's algorithm (Grover's algorithmis a quantum algorithm for searching an unsorted database of n entries in O(sqrt(n))time.) (String algorithm like longest common prefix, where you do not have to see every data - small oh)"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"linear time"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"n"),(0,r.kt)("td",{parentName:"tr",align:null},"Finding the smallest or largest item in an unsortedarray"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'"n log star n" time'),(0,r.kt)("td",{parentName:"tr",align:null},"O(nlog*n)"),(0,r.kt)("td",{parentName:"tr",align:null},"Seidel's polygon triangulationalgorithm."),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"quasilinear time/linearithmic"),(0,r.kt)("td",{parentName:"tr",align:null},"O(nlogn)"),(0,r.kt)("td",{parentName:"tr",align:null},"nlogn, logn!"),(0,r.kt)("td",{parentName:"tr",align:null},"Fastest possible comparison sort; Fast Fourier transform, Merge Sort"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"quadratic time"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n2)"),(0,r.kt)("td",{parentName:"tr",align:null},"n2"),(0,r.kt)("td",{parentName:"tr",align:null},"Bubble sort; Insertion sort; Direct convolution (Check all doubles)"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cubic time"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n3)"),(0,r.kt)("td",{parentName:"tr",align:null},"n3"),(0,r.kt)("td",{parentName:"tr",align:null},"Naive multiplication of twon\xd7nmatrices. Calculating partial correlation. (Check all triples)"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Pseudo-polynomial time"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"polynomial time"),(0,r.kt)("td",{parentName:"tr",align:null},"P"),(0,r.kt)("td",{parentName:"tr",align:null},"2O(logn)= poly(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"n,nlogn,n10"),(0,r.kt)("td",{parentName:"tr",align:null},"Karmarkar's algorithm for linear programming;AKS primality test")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"quasi-polynomial time"),(0,r.kt)("td",{parentName:"tr",align:null},"QP"),(0,r.kt)("td",{parentName:"tr",align:null},"2poly(logn)"),(0,r.kt)("td",{parentName:"tr",align:null},"nloglogn,nlogn"),(0,r.kt)("td",{parentName:"tr",align:null},"Best-known O(log2n)-approximation algorithmfor the directedSteiner tree problem.")))),(0,r.kt)("p",null,"| sub-exponential time\n(first definition) | SUBEXP | O(2n\u03b5) for all \u03b5>0 | O(2lognlog logn) | Assuming complexity theoretic conjectures,BPPis contained in SUBEXP. |\n| sub-exponential time\n(second definition) | 2o(n) | 2n1/3 | Best-known algorithm forinteger factorizationandgraph isomorphism |\n| exponential time\n(with linear exponent) | E | 2O(n) | 1.1n, 10n | Solving thetraveling salesman problemusingdynamic programming |\n| exponential time | EXPTIME | 2poly(n) | 2n, 2n2 | Solvingmatrix chain multiplicationviabrute-force search (Exhaustive Search / Check all subsets) |\n| factorial time | O(n!) | n! | Solving the traveling salesman problem via brute-force search |\n| double exponential time | 2-EXPTIME | 22poly(n) | 22n | Deciding the truth of a given statement in Presburger arithmetic |"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:n(357012).Z,width:"580",height:"546"})),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Time_complexity"},"https://en.wikipedia.org/wiki/Time_complexity")),(0,r.kt)("h2",{id:"pseudo-polynomial-time"},"Pseudo-polynomial time"),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computational_complexity_theory"},"computational complexity theory"),", a numeric algorithm runs inpseudo-polynomial timeif its ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computation_time"},"running time")," is a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polynomial"},"polynomial")," in thenumeric valueof the input (the largest integer present in the input) --- but not necessarily in thelengthof the input (the number of bits required to represent it), which is the case for ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polynomial_time"},"polynomial time")," algorithms."),(0,r.kt)("p",null,"In general, the numeric value of the input is exponential in the input length, which is why a pseudo-polynomial time algorithm does not necessarily run in polynomial time with respect to the input length."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pseudo-polynomial_time"},"https://en.wikipedia.org/wiki/Pseudo-polynomial_time")))}g.isMDXComponent=!0},357012:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/Time-Complexities-image1-e3e119337fb503caeebb935b74cdf5b9.jpg"}}]);