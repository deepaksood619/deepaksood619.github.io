# Types of programming paradigm

## Imperative (allows side effect)

Uses statements that change a program's state

- Object Oriented Programming Language
- Procedural

[Procedural programming](https://en.wikipedia.org/wiki/Procedural_programming) is a type of imperative programming in which the program is built from one or more procedures (also termed [subroutines](https://en.wikipedia.org/wiki/Subroutine) or functions).

## Declarative (does not state the order in which operations execute)

Focuses on *what* the program should accomplish without specifying *how* the program should achieve the result.

- Functional
- Logic

Example - SQL is a declarative language, we tell to give data and program automatically finds a way to give that data.

## Symbolic

In [computer programming](https://en.wikipedia.org/wiki/Computer_programming "Computer programming"), **symbolic programming** is a [programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm "Programming paradigm") in which the program can manipulate its own formulas and program components as if they were plain data.

Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to "learn", which makes them better suited for applications such as [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence "Artificial intelligence"), [expert systems](https://en.wikipedia.org/wiki/Expert_systems "Expert systems"), [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing "Natural language processing"), and computer games.

Languages that support symbolic programming include [homoiconic](https://en.wikipedia.org/wiki/Homoiconic "Homoiconic") languages such as [Wolfram Language](https://en.wikipedia.org/wiki/Wolfram_Language "Wolfram Language"), [Lisp](https://en.wikipedia.org/wiki/LISP "LISP"), [Prolog](https://en.wikipedia.org/wiki/Prolog "Prolog"), and [Julia](https://en.wikipedia.org/wiki/Julia_(programming_language) "Julia (programming language)").

[Symbolic programming - Wikipedia](https://en.wikipedia.org/wiki/Symbolic_programming)

## Others

- Contract-oriented programming language (for writing smart contracts)
    - Solidity (used in Ethereum)

## Imperative vs Declarative Programming

When you need to do something, there is always the what and the how aspects of it. What exactly needs to be done and how do we do it.

**Imperative programming is about the how. Declarative programming is about the what**

An imperative approach represents a list of steps. Do this first, then do that, and after that do something else. For example: Go over a list of numbers one by one and for every one add its value to a running sum.

A declarative approach represents what we have and what we need. For example: We have a list of numbers and we need the sum of those numbers. The imperative language is closer to the computers of today because they only know how to execute instructions. The declarative language is closer to how we think and command. Get it done, please. Somehow!

The good news is computer languages have evolved. Computer languages offer declarative ways to do the needed imperative computer instructions. Just as cars have evolved from manual stick shift into automatic and self-driving ones!

Imperative programming is like driving a stick shift car. You need to do manual steps (press the clutch, depress it slowly, change gears incrementally, etc). Declarative programming is like driving an automatic car - you just specify the "what": Park or Drive.

You cannot program declaratively unless you have the tools that enable you to do so. While you can imperatively drive an automatic car (by switching to manual mode) you cannot declaratively drive a stick shift car. If all you have is a stick shift car, imperative programming is your only obvious choice. This is unless you take the time to install an automatic gear shifter, which might be worth it in the long term. If you can afford a new car, you will probably go with an automatic one unless you are that true nerd who still likes to program with Assembly!

[Assembly](https://en.wikipedia.org/wiki/Assembly_language) is the original true imperative low-level computer language with pure instructions that directly translate into machine code.

Note that imperative programming might produce faster programs. Additionally, declarative programming requires less effort from you. In general, it will also require less effort to be maintained. Coding does not have to be one way or the other. Any non-trivial computer program will most likely have a little bit of both approaches. Also, knowing how to code declaratively is great, but it does not mean that you do not need to learn the imperative ways as well. You should simply be confident using both.

Tools that enable you to program declaratively evolve into better and faster ways to get you where you are heading. The ultimate declarative experience with modern cars is the self-driving ones. The "what" becomes the destination and the car will do the rest. This is somehow, probably, the future of programming as well. We will have programs that understand all goals and they can just work their magic to generate logic to get us to those goals.

## References

https://medium.freecodecamp.org/hard-coding-concepts-explained-with-simple-real-life-analogies-280635e98e37
