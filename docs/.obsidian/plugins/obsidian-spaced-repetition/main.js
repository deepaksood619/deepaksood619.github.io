/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/pagerank.js/lib/index.js
var require_lib = __commonJS({
  "node_modules/pagerank.js/lib/index.js"(exports, module2) {
    "use strict";
    function forOwn(object, callback2) {
      if (typeof object === "object" && typeof callback2 === "function") {
        for (var key in object) {
          if (object.hasOwnProperty(key) === true) {
            if (callback2(key, object[key]) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = function() {
      var self = {
        count: 0,
        edges: {},
        nodes: {}
      };
      self.link = function(source, target, weight) {
        if (isFinite(weight) !== true || weight === null) {
          weight = 1;
        }
        weight = parseFloat(weight);
        if (self.nodes.hasOwnProperty(source) !== true) {
          self.count++;
          self.nodes[source] = {
            weight: 0,
            outbound: 0
          };
        }
        self.nodes[source].outbound += weight;
        if (self.nodes.hasOwnProperty(target) !== true) {
          self.count++;
          self.nodes[target] = {
            weight: 0,
            outbound: 0
          };
        }
        if (self.edges.hasOwnProperty(source) !== true) {
          self.edges[source] = {};
        }
        if (self.edges[source].hasOwnProperty(target) !== true) {
          self.edges[source][target] = 0;
        }
        self.edges[source][target] += weight;
      };
      self.rank = function(alpha2, epsilon, callback2) {
        var delta = 1, inverse = 1 / self.count;
        forOwn(self.edges, function(source) {
          if (self.nodes[source].outbound > 0) {
            forOwn(self.edges[source], function(target) {
              self.edges[source][target] /= self.nodes[source].outbound;
            });
          }
        });
        forOwn(self.nodes, function(key) {
          self.nodes[key].weight = inverse;
        });
        while (delta > epsilon) {
          var leak = 0, nodes = {};
          forOwn(self.nodes, function(key, value) {
            nodes[key] = value.weight;
            if (value.outbound === 0) {
              leak += value.weight;
            }
            self.nodes[key].weight = 0;
          });
          leak *= alpha2;
          forOwn(self.nodes, function(source) {
            forOwn(self.edges[source], function(target, weight) {
              self.nodes[target].weight += alpha2 * nodes[source] * weight;
            });
            self.nodes[source].weight += (1 - alpha2) * inverse + leak * inverse;
          });
          delta = 0;
          forOwn(self.nodes, function(key, value) {
            delta += Math.abs(value.weight - nodes[key]);
          });
        }
        forOwn(self.nodes, function(key) {
          return callback2(key, self.nodes[key].weight);
        });
      };
      self.reset = function() {
        self.count = 0;
        self.edges = {};
        self.nodes = {};
      };
      return self;
    }();
  }
});

// node_modules/vhtml/dist/vhtml.js
var require_vhtml = __commonJS({
  "node_modules/vhtml/dist/vhtml.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.vhtml = factory();
    })(exports, function() {
      "use strict";
      var emptyTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
      var esc = function esc2(str) {
        return String(str).replace(/[&<>"']/g, function(s) {
          return "&" + map3[s] + ";";
        });
      };
      var map3 = { "&": "amp", "<": "lt", ">": "gt", '"': "quot", "'": "apos" };
      var setInnerHTMLAttr = "dangerouslySetInnerHTML";
      var DOMAttributeNames = {
        className: "class",
        htmlFor: "for"
      };
      var sanitized = {};
      function h4(name2, attrs) {
        var stack = [], s = "";
        attrs = attrs || {};
        for (var i = arguments.length; i-- > 2; ) {
          stack.push(arguments[i]);
        }
        if (typeof name2 === "function") {
          attrs.children = stack.reverse();
          return name2(attrs);
        }
        if (name2) {
          s += "<" + name2;
          if (attrs)
            for (var _i in attrs) {
              if (attrs[_i] !== false && attrs[_i] != null && _i !== setInnerHTMLAttr) {
                s += " " + (DOMAttributeNames[_i] ? DOMAttributeNames[_i] : esc(_i)) + '="' + esc(attrs[_i]) + '"';
              }
            }
          s += ">";
        }
        if (emptyTags.indexOf(name2) === -1) {
          if (attrs[setInnerHTMLAttr]) {
            s += attrs[setInnerHTMLAttr].__html;
          } else
            while (stack.length) {
              var child = stack.pop();
              if (child) {
                if (child.pop) {
                  for (var _i2 = child.length; _i2--; ) {
                    stack.push(child[_i2]);
                  }
                } else {
                  s += sanitized[child] === true ? child : esc(child);
                }
              }
            }
          s += name2 ? "</" + name2 + ">" : "";
        }
        sanitized[s] = true;
        return s;
      }
      return h4;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SRPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");
var graph = __toESM(require_lib());

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {
  DECKS: "Bal\xED\u010Dky",
  DUE_CARDS: "Karti\u010Dky po term\xEDnu",
  NEW_CARDS: "Nov\xE9 karti\u010Dky",
  TOTAL_CARDS: "Karti\u010Dek celkem",
  BACK: "Back",
  EDIT_LATER: "Upravit pozd\u011Bji",
  RESET_CARD_PROGRESS: "Vynulovat pokrok karti\u010Dky",
  HARD: "Te\u017Ek\xE9",
  GOOD: "Dobr\xE9",
  EASY: "Jednoduch\xE9",
  SHOW_ANSWER: "Uk\xE1zat odpov\u011B\u010F",
  CARD_PROGRESS_RESET: "Pokrok karti\u010Dky byl vynulov\xE1n.",
  OPEN_NOTE_FOR_REVIEW: "Otev\u0159\xEDt pozn\xE1mku k revizi",
  REVIEW_CARDS: "Pozn\xE1mek k revizi",
  REVIEW_EASY_FILE_MENU: "Revize: Jednoduch\xE9",
  REVIEW_GOOD_FILE_MENU: "Revize: Dobr\xE9",
  REVIEW_HARD_FILE_MENU: "Revize: T\u011B\u017Ek\xE9",
  REVIEW_NOTE_EASY_CMD: "Ozna\u010Dit pozn\xE1mku jako jednoduchou",
  REVIEW_NOTE_GOOD_CMD: "Ozna\u010Dit pozn\xE1mku jako dobrou",
  REVIEW_NOTE_HARD_CMD: "Ozna\u010Dit pozn\xE1mku jako te\u017Ekou",
  REVIEW_CARDS_IN_NOTE: "Revidovat karti\u010Dky v t\xE9to pozn\xE1mce.",
  CRAM_CARDS_IN_NOTE: "Cram karti\u010Dky v t\xE9to pozn\xE1mce.",
  REVIEW_ALL_CARDS: "Revidovat karti\u010Dky ve v\u0161ech pozn\xE1mk\xE1ch",
  VIEW_STATS: "Uk\xE1zat statistiky",
  STATUS_BAR: "Revize: ${dueNotesCount} pozn\xE1mek, ${dueFlashcardsCount} karti\u010Dek po term\xEDnu",
  SYNC_TIME_TAKEN: "Synchronizace trvala ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Pozn\xE1mka je ulo\u017Eena v ignorovan\xE9 slo\u017Ece (zkontrolujte nastaven\xED).",
  PLEASE_TAG_NOTE: "Pros\xEDm ozna\u010Dne pozn\xE1mku odpov\xEDdaj\xEDc\xEDm tagem pro revizi (v nastaven\xED).",
  RESPONSE_RECEIVED: "Odpov\u011B\u010F p\u0159ijata.",
  NO_DECK_EXISTS: "Neexistuje \u017E\xE1dn\xFD bal\xED\u010Dek pro ${deckName}",
  ALL_CAUGHT_UP: "V\u0161e zrevidov\xE1no",
  DAYS_STR_IVL: "${interval} den/dn\xED",
  MONTHS_STR_IVL: "${interval} m\u011Bs\xEDc(\u016F)",
  YEARS_STR_IVL: "${interval} rok(\u016F)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}r",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Nastaven\xED",
  CHECK_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Ignorovan\xE9 slo\u017Eky",
  FOLDERS_TO_IGNORE_DESC: "Zadejte cesty ke slo\u017Ek\xE1m odd\u011Blen\xE9 od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDkad. \u0160ablony Meta/Scripts",
  FLASHCARDS: "Karti\u010Dky",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Tag pro karti\u010Dky",
  FLASHCARD_TAGS_DESC: "Zadete tagy ood\u011Blen\xE9 mezerou nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad. #karti\u010Dky #bal\xED\u010Dke2 #bal\xED\u010Dek3.",
  CONVERT_FOLDERS_TO_DECKS: "P\u0159ev\xE9st slo\u017Eky na bal\xED\u010Dky a podbal\xED\u010Dky?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Toto je alternativa k tag\u016Fm karti\u010Dek viz nastaven\xED v\xFD\u0161e.",
  INLINE_SCHEDULING_COMMENTS: "Ulo\u017Eit pl\xE1novac\xED koment\xE1\u0159 na stejn\xFD \u0159\xE1dek jako posledn\xED polo\u017Eka karti\u010Dky?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Zapnut\xED t\xE9to volby zp\u016Fsob\xED, \u017Ee HTML koment\xE1\u0159e nebudou rozb\xEDjet form\xE1tov\xE1n\xED list\u016F.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Odlo\u017Eit p\u0159\xEDbuzn\xE9 karti\u010Dky na dal\u0161\xED den?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "P\u0159\xEDbuzn\xE9 karti\u010Dky jsou karti\u010Dky generovan\xE9 z textu stejn\xE9 pozn\xE1mky nap\u0159\xEDklad cloze smaz\xE1n\xED",
  SHOW_CARD_CONTEXT: "Uk\xE1zat kontext v karti\u010Dce?",
  SHOW_CARD_CONTEXT_DESC: "nap\u0159\xEDklad Titulek > Nadpis1 > Podnadpis > ... > Podnadpis",
  CARD_MODAL_HEIGHT_PERCENT: "V\xFD\u0161ka karti\u010Dek v procentech",
  CARD_MODAL_SIZE_PERCENT_DESC: "M\u011Blo by b\xFDt nastaveno na 100% na mobilu nebo kdy\u017E pou\u017E\xEDv\xE1te velk\xE9 obr\xE1zky",
  RESET_DEFAULT: "Resetovat v\xFDchoz\xED nastaven\xED",
  CARD_MODAL_WIDTH_PERCENT: "\u0160\xED\u0159ka karti\u010Dek v procentech",
  FILENAME_OR_OPEN_FILE: "Zobrazit jm\xE9no souboru m\xEDsto 'Zm\u011Bnit pozd\u011Bji' v revizi karti\u010Dky?",
  RANDOMIZE_CARD_ORDER: "N\xE1hodn\u011B zm\u011Bnit po\u0159ad\xED karti\u010Dek b\u011Bhem revize?",
  DISABLE_CLOZE_CARDS: "Vypnout cloze karti\u010Dky?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "P\u0159ev\xE9st ==zv\xFDrazn\u011Bn\xED== na clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "P\u0159ev\xE9st **tu\u010Dn\xFD text** na clozes?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "P\u0159ev\xE9st {{slo\u017Een\xE9 z\xE1vorky}} na clozes?",
  INLINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro inline karti\u010Dky",
  FIX_SEPARATORS_MANUALLY_WARNING: "Pozor. Jakmile toto zm\u011Bn\xEDte, budete muset ru\u010Dn\u011B upravit v\u0161echny existuj\xEDc\xED karti\u010Dky.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro oto\u010Den\xE9 inline karti\u010Dky",
  MULTILINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkov\xE9 karti\u010Dky",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkove oto\u010Den\xE9 karti\u010Dky",
  NOTES: "Pozn\xE1mky",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tag pro revizi",
  TAGS_TO_REVIEW_DESC: "Zadejte tagy odd\u011Blen\xE9 mezerami nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Otev\u0159\xEDt n\xE1hodnou pozn\xE1mku pro revizi",
  OPEN_RANDOM_NOTE_DESC: "Pokud toto vypnete, pozn\xE1mky budou \u0159azeny dle d\u016Fle\u017Eitosti (PageRank).",
  AUTO_NEXT_NOTE: "Otev\u0159\xEDt automaticky dal\u0161\xED pozn\xE1mku po dokon\u010Den\xED revize",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Vypnout volby revize v menu souboru nap\u0159\xEDklad 'Revize: Jednoduch\xE9'",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Po vypnut\xED m\u016F\u017Eete pou\u017E\xEDvat kl\xE1vesov\xE9 zkratky. Restartujte Obsidian po zm\u011Bn\u011B nastaven\xED.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maxim\xE1ln\xED po\u010Det dn\xED zobrazen\xFDch v prav\xE9m panelu",
  MIN_ONE_DAY: "Po\u010Det dn\xED mus\xED b\xFDt minim\xE1ln\u011B 1.",
  VALID_NUMBER_WARNING: "Pros\xEDm zadejte validn\xED \u010D\xEDslo.",
  UI_PREFERENCES: "P\u0159edvolby u\u017Eivatelsk\xE9ho rozhran\xED",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Stromy bal\xED\u010Dky by m\u011Bly b\xFDt zpo\u010D\xE1tku zobrazeny jako rozbalen\xE9",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Vypn\u011Bte toto, chcete-li sbalit vno\u0159en\xE9 bal\xED\u010Dky na stejn\xE9 kart\u011B. To je u\u017Eite\u010Dn\xE9, pokud m\xE1te karti\u010Dky, kter\xE9 pat\u0159\xED k mnoha bal\xED\u010Dk\u016Fm ve stejn\xE9m souboru.",
  ALGORITHM: "Algoritmus",
  CHECK_ALGORITHM_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${algo_url}">popis algoritmu</a>.',
  BASE_EASE: "Z\xE1kladn\xED slo\u017Eitost",
  BASE_EASE_DESC: "minimum = 130, nejl\xE9pe p\u0159ibli\u017En\u011B 250.",
  BASE_EASE_MIN_WARNING: "Z\xE1kladn\xED slo\u017Eitost mus\xED b\xFDt minim\xE1ln\u011B 130.",
  LAPSE_INTERVAL_CHANGE: "Zm\u011Bna intervalu pokud karti\u010Dku/pozn\xE1mku ozna\u010D\xEDte jako slo\u017Eitou",
  LAPSE_INTERVAL_CHANGE_DESC: "nov\xFD_inteval = star\xFD_interval * zm\u011Bna_intevalu / 100.",
  EASY_BONUS: "Bonus pro jednoduch\xE9",
  EASY_BONUS_DESC: "Tento bonus umo\u017E\u0148uje nastavit rozd\xEDl intervalu mezi jednoduch\xFDmi a dobr\xFDmi karti\u010Dkami/pozn\xE1mkami (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Bonus pro jednoduchost mus\xED b\xFDt minim\xE1ln\u011B 100.",
  MAX_INTERVAL: "Maxim\xE1ln\xED interval",
  MAX_INTERVAL_DESC: "Umo\u017E\u0148uje nastavit horn\xED limit pro interval (defaultn\u011B = 100 let).",
  MAX_INTERVAL_MIN_WARNING: "Maxim\xE1ln\xED interval mus\xED b\xFDt alespo\u0148 1 den.",
  MAX_LINK_CONTRIB: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bv\u011Bk prolinkov\xE1n\xED",
  MAX_LINK_CONTRIB_DESC: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bvek v\xE1\u017Een\xE9 slo\u017Eitosti prolinkovan\xFDch pozn\xE1mek pou\u017Eit\xFD pro ur\u010Den\xED po\u010D\xE1te\u010Dn\xED slo\u017Eitosti.",
  LOGGING: "Zaznamen\xE1v\xE1m",
  DISPLAY_DEBUG_INFO: "Zobrazit informace pro lad\u011Bn\xED na v\xFDvoj\xE1\u0159sk\xE9 konzoli?",
  NOTES_REVIEW_QUEUE: "Fronta pozn\xE1mek k revizi",
  CLOSE: "Uzav\u0159en\xE9",
  NEW: "Nov\xE9",
  YESTERDAY: "V\u010Dera",
  TODAY: "Dnes",
  TOMORROW: "Z\xEDtra",
  STATS_TITLE: "Statistiky",
  MONTH: "M\u011Bs\xEDc",
  QUARTER: "\u010Ctvrtlet\xED",
  YEAR: "Rok",
  LIFETIME: "Celkov\u011B",
  FORECAST: "P\u0159edpov\u011B\u010F",
  FORECAST_DESC: "Celkov\xFD po\u010Det karti\u010Dek, kter\xFDm vypr\u0161\xED term\xEDn",
  SCHEDULED: "Napl\xE1nov\xE1no",
  DAYS: "Dn\xED",
  NUMBER_OF_CARDS: "Po\u010Det karti\u010Dek",
  REVIEWS_PER_DAY: "Pr\u016Fm\u011Br: ${avg} revize/den",
  INTERVALS: "Intervaly",
  INTERVALS_DESC: "Doba, za kterou bude znovu zobrazeno k revize",
  COUNT: "Po\u010Det",
  INTERVALS_SUMMARY: "Pr\u016Fm\u011Brn\xFD interval: ${avg}, Nejdel\u0161\xED interval: ${longest}",
  EASES: "Slo\u017Eitost",
  EASES_SUMMARY: "Pr\u016Fm\u011Brn\xE1 slo\u017Eitost: ${avgEase}",
  CARD_TYPES: "Typy karti\u010Dek",
  CARD_TYPES_DESC: "Obsahuje i odlo\u017Een\xE9 karti\u010Dky (pokud existuj\xED)",
  CARD_TYPE_NEW: "Nov\xE1",
  CARD_TYPE_YOUNG: "Mlad\xE1",
  CARD_TYPE_MATURE: "Dosp\u011Bl\xE1",
  CARD_TYPES_SUMMARY: "Karti\u010Dek celkem: ${totalCardsCount}"
};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {
  DECKS: "Stapel",
  DUE_CARDS: "Anstehende Karten",
  NEW_CARDS: "Neue Karten",
  TOTAL_CARDS: "Alle Karten",
  BACK: "Back",
  EDIT_LATER: "Sp\xE4ter bearbeiten",
  RESET_CARD_PROGRESS: "Kartenfortschritt zur\xFCcksetzten",
  HARD: "Schwer",
  GOOD: "Gut",
  EASY: "Einfach",
  SHOW_ANSWER: "Zeige Antwort",
  CARD_PROGRESS_RESET: "Kartenfortschritt wurde zur\xFCckgesetzt.",
  OPEN_NOTE_FOR_REVIEW: "Notiz zur Wiederholung \xF6ffnen",
  REVIEW_CARDS: "Lernkarten wiederholen",
  REVIEW_EASY_FILE_MENU: "Notiz abschliessen als: Einfach",
  REVIEW_GOOD_FILE_MENU: "Notiz abschliessen als: Gut",
  REVIEW_HARD_FILE_MENU: "Notiz abschliessen als: Schwer",
  REVIEW_NOTE_EASY_CMD: "Notiz abschliessen als: Einfach",
  REVIEW_NOTE_GOOD_CMD: "Notiz abschliessen als: Gut",
  REVIEW_NOTE_HARD_CMD: "Notiz abschliessen als: Schwer",
  REVIEW_CARDS_IN_NOTE: "Lernkarten in dieser Notiz wiederholen",
  CRAM_CARDS_IN_NOTE: "Lernkarten in dieser Notiz pauken.",
  REVIEW_ALL_CARDS: "Alle Lernkarten wiederholen",
  VIEW_STATS: "Statistiken anzeigen",
  STATUS_BAR: "Wiederholung: ${dueNotesCount} Notiz(en), ${dueFlashcardsCount} Karte(n) anstehend",
  SYNC_TIME_TAKEN: "Sync dauerte ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Notiz befindet sich in einem ausgeschlossenen Ordner (siehe Einstellungen).",
  PLEASE_TAG_NOTE: "Bitte die Notiz f\xFCr Wiederholungen entsprechend taggen (siehe Einstellungen).",
  RESPONSE_RECEIVED: "Antwort erhalten.",
  NO_DECK_EXISTS: "Kein Stapel f\xFCr ${deckName} gefunden.",
  ALL_CAUGHT_UP: "Yuhu! Alles geschafft! :D.",
  DAYS_STR_IVL: "${interval} Tag(e)",
  MONTHS_STR_IVL: "${interval} Monat(e)",
  YEARS_STR_IVL: "${interval} Jahr(e)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Einstellungen",
  CHECK_WIKI: 'Weitere Informationen gibt es im <a href="${wiki_url}">Wiki</a> (english).',
  FOLDERS_TO_IGNORE: "Ausgeschlossene Ordner",
  FOLDERS_TO_IGNORE_DESC: "Mehrere Ordner mit Zeilenumbr\xFCchen getrennt angeben. Bsp. OrdnerA[Zeilenumbruch]OrdnerB/Unterordner",
  FLASHCARDS: "Lernkarten",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Lernkarten Tags",
  FLASHCARD_TAGS_DESC: "Mehrere Tags mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angeben. Bsp. #karte #stapel2 #stapel3.",
  CONVERT_FOLDERS_TO_DECKS: "Ordner in Stapel und Substapel umwandeln?",
  CONVERT_FOLDERS_TO_DECKS_DESC: 'Eine Alternative zur oberen "Lernkarten Tags" Option.',
  INLINE_SCHEDULING_COMMENTS: "Den Fortschritt in der gleichen Zeile wie die letzte Zeile einer Lernkartei speichern?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Wenn aktiviert, wird der HTML Kommentar die umgebende Liste nicht aufbrechen.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Verwandte Karten auf den n\xE4chsten Tag verlegen?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Verwandte Karten sind aus der gleichen Karte generiert worden (z.B. L\xFCckentextkarten oder beidseitige Karten).",
  SHOW_CARD_CONTEXT: "Kontext in den Karten anzeigen?",
  SHOW_CARD_CONTEXT_DESC: "Bsp. Titel > \xDCberschrift 1 > Sektion > ... > Untersektion",
  CARD_MODAL_HEIGHT_PERCENT: "H\xF6he der Lernkartei in Prozent",
  CARD_MODAL_SIZE_PERCENT_DESC: "Auf kleinen Bildschirmen (z.B. Smartphones) oder bei sehr grossen Bildern sollte dieser Wert auf 100% gesetzt werden.",
  RESET_DEFAULT: "Standardeinstellung wiederherstellen",
  CARD_MODAL_WIDTH_PERCENT: "Breite einer Lernkarte in Prozent",
  FILENAME_OR_OPEN_FILE: "W\xE4hrend der Wiederholung den Notiznamen statt 'Sp\xE4ter bearbeiten' anzeigen?",
  RANDOMIZE_CARD_ORDER: "W\xE4hrend der Wiederhoung die Reihenfolge zuf\xE4llig mischen?",
  DISABLE_CLOZE_CARDS: "L\xFCckentextkarten (cloze deletions) deaktivieren?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==Hervorgehobenen== Text in L\xFCckentextkarten umwandeln?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**Fettgedruckten** Text in L\xFCckentextkarten umwandeln?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{Geschweifte Klammern}} Text in L\xFCckentextkarten umwandeln?",
  INLINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige Lernkarten",
  FIX_SEPARATORS_MANUALLY_WARNING: "Wenn diese Einstellung ge\xE4ndert wird, dann m\xFCssen die entsprechenden Lernkarten manuell angepasst werden.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige beidseitige Lernkarten",
  MULTILINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige Lernkarten",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige beidseitige Lernkarten",
  NOTES: "Notizen",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Zu wiederholende Tags",
  TAGS_TO_REVIEW_DESC: "Mehrere Tags k\xF6nnen mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angegeben werden. Bsp. #karte #tag1 #tag2.",
  OPEN_RANDOM_NOTE: "Zuf\xE4llige Karten wiederholen",
  OPEN_RANDOM_NOTE_DESC: "Wenn dies deaktiviert wird, dann werden die Notizen nach Wichtigkeit wiederholt (PageRank).",
  AUTO_NEXT_NOTE: "Nach einer Wiederholung automatisch die n\xE4chste Karte \xF6ffnen",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Optionen zur Wiederholung im Men\xFC einer Datei deaktivieren. Bsp. Wiederholen: Einfach Gut Schwer",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Nach dem Deaktivieren k\xF6nnen die Tastenk\xFCrzel zur Wiederholung verwendet werden. Obsidian muss nach einer \xC4nderung neu geladen weren.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximale Anzahl anstehender Notizen, die im rechten Fensterbereich angezeigt werden",
  MIN_ONE_DAY: "Anzahl der Tage muss mindestens 1 sein.",
  VALID_NUMBER_WARNING: "Bitte eine g\xFCltige Zahl eingeben.",
  UI_PREFERENCES: "Einstellungen der Benutzeroberfl\xE4che",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deckb\xE4ume sollten anf\xE4nglich erweitert angezeigt werden",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Deaktivieren Sie dies, um verschachtelte Decks in derselben Karte zu reduzieren. N\xFCtzlich, wenn Sie Karten haben, die zu vielen Decks in derselben Datei geh\xF6ren.",
  ALGORITHM: "Algorithmus",
  CHECK_ALGORITHM_WIKI: 'Weiterf\xFChrende Informationen: <a href="${algo_url}">Implementierung des Algorithmus</a> (english).',
  BASE_EASE: "Basis der Einfachheit",
  BASE_EASE_DESC: "Minimum ist 130. Empfohlen wird ca. 250.",
  BASE_EASE_MIN_WARNING: "Basis der Einfachheit muss mindestens 130 sein.",
  LAPSE_INTERVAL_CHANGE: "Anpassungsfaktor des Intervalls wenn eine Notiz / Karte 'Schwer' abgeschlossen wird",
  LAPSE_INTERVAL_CHANGE_DESC: "neuesIntervall = altesIntervall * anpassungsfaktor / 100.",
  EASY_BONUS: "Einfachheit-Bonus",
  EASY_BONUS_DESC: "Der Einfachheit-Bonus gibt an um welchen Faktor (in Prozent) das Intervall l\xE4nger sein soll, wenn eine Notiz / Karte 'Einfach' statt 'Gut' abgeschlossen wird. Minimum ist 100%.",
  EASY_BONUS_MIN_WARNING: "Der Einfachheit-Bonus muss mindestens 100 sein.",
  MAX_INTERVAL: "Maximales Intervall",
  MAX_INTERVAL_DESC: "Das maximale Intervall (in Tagen) f\xFCr Wiederholungen. Standard sind 100 Jahre.",
  MAX_INTERVAL_MIN_WARNING: "Das maximale Interall muss mindestens ein Tag sein.",
  MAX_LINK_CONTRIB: "Maximaler Einfluss von Links",
  MAX_LINK_CONTRIB_DESC: "Maximaler Einfluss der Einfachheiten verlinkter Notizen zur gewichteten initialen Einfachheit einer neuen Lernkarte.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Informationen zum Debugging in der Entwicklerkonsole anzeigen?",
  NOTES_REVIEW_QUEUE: "Anstehende Notizen zur Wiederholung",
  CLOSE: "Schliessen",
  NEW: "Neu",
  YESTERDAY: "Gestern",
  TODAY: "Heute",
  TOMORROW: "Morgen",
  STATS_TITLE: "Statistiken",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Prognose",
  FORECAST_DESC: "Anzahl der k\xFCnftig anstehenden Karten",
  SCHEDULED: "Anstehend",
  DAYS: "Tage",
  NUMBER_OF_CARDS: "Anzahl der Karten",
  REVIEWS_PER_DAY: "Durchschnitt: ${avg} Wiederholungen/Tag",
  INTERVALS: "Intervalle",
  INTERVALS_DESC: "Intervalle bis Wiederholungen anstehen",
  COUNT: "Anzahl",
  INTERVALS_SUMMARY: "Durchschnittliches Intervall: ${avg}, L\xE4ngstes Intervall: ${longest}",
  EASES: "Einfachheit",
  EASES_SUMMARY: "Durchschnittliche Einfachheit: ${avgEase}",
  CARD_TYPES: "Kategorisierung",
  CARD_TYPES_DESC: "Verlegte Karten eingeschlossen",
  CARD_TYPE_NEW: "Neu",
  CARD_TYPE_YOUNG: "Jung",
  CARD_TYPE_MATURE: "Ausgereift",
  CARD_TYPES_SUMMARY: "Insgesamt ${totalCardsCount} Karten"
};

// src/lang/locale/en.ts
var en_default = {
  DECKS: "Decks",
  DUE_CARDS: "Due Cards",
  NEW_CARDS: "New Cards",
  TOTAL_CARDS: "Total Cards",
  BACK: "Back",
  EDIT_LATER: "Edit Later",
  RESET_CARD_PROGRESS: "Reset card's progress",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "Show Answer",
  CARD_PROGRESS_RESET: "Card's progress has been reset.",
  OPEN_NOTE_FOR_REVIEW: "Open a note for review",
  REVIEW_CARDS: "Review flashcards",
  REVIEW_EASY_FILE_MENU: "Review: Easy",
  REVIEW_GOOD_FILE_MENU: "Review: Good",
  REVIEW_HARD_FILE_MENU: "Review: Hard",
  REVIEW_NOTE_EASY_CMD: "Review note as easy",
  REVIEW_NOTE_GOOD_CMD: "Review note as good",
  REVIEW_NOTE_HARD_CMD: "Review note as hard",
  REVIEW_CARDS_IN_NOTE: "Review flashcards in this note",
  CRAM_CARDS_IN_NOTE: "Cram flashcards in this note.",
  REVIEW_ALL_CARDS: "Review flashcards from all notes",
  VIEW_STATS: "View statistics",
  STATUS_BAR: "Review: ${dueNotesCount} note(s), ${dueFlashcardsCount} card(s) due",
  SYNC_TIME_TAKEN: "Sync took ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Note is saved under ignored folder (check settings).",
  PLEASE_TAG_NOTE: "Please tag the note appropriately for reviewing (in settings).",
  RESPONSE_RECEIVED: "Response received.",
  NO_DECK_EXISTS: "No deck exists for ${deckName}",
  ALL_CAUGHT_UP: "You're all caught up now :D.",
  DAYS_STR_IVL: "${interval} day(s)",
  MONTHS_STR_IVL: "${interval} month(s)",
  YEARS_STR_IVL: "${interval} year(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Settings",
  CHECK_WIKI: 'For more information, check the <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Folders to ignore",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths separated by newlines i.e. Templates Meta/Scripts",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Flashcard tags",
  FLASHCARD_TAGS_DESC: "Enter tags separated by spaces or newlines i.e. #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Convert folders to decks and subdecks?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "This is an alternative to the Flashcard tags option above.",
  INLINE_SCHEDULING_COMMENTS: "Save scheduling comment on the same line as the flashcard's last line?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Turning this on will make the HTML comments not break list formatting.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Bury sibling cards until the next day?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Siblings are cards generated from the same card text i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "Show context in cards?",
  SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "Flashcard Height Percentage",
  CARD_MODAL_SIZE_PERCENT_DESC: "Should be set to 100% on mobile or if you have very large images",
  RESET_DEFAULT: "Reset to default",
  CARD_MODAL_WIDTH_PERCENT: "Flashcard Width Percentage",
  FILENAME_OR_OPEN_FILE: "Show file name instead of 'Edit Later' in flashcard review?",
  RANDOMIZE_CARD_ORDER: "Randomize card order during review?",
  DISABLE_CLOZE_CARDS: "Disable cloze cards?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==hightlights== to clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes?",
  INLINE_CARDS_SEPARATOR: "Separator for inline flashcards",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note that after changing this you have to manually edit any flashcards you already have.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separator for inline reversed flashcards",
  MULTILINE_CARDS_SEPARATOR: "Separator for multiline flashcards",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator for multiline reversed flashcards",
  NOTES: "Notes",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tags to review",
  TAGS_TO_REVIEW_DESC: "Enter tags separated by spaces or newlines i.e. #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Open a random note for review",
  OPEN_RANDOM_NOTE_DESC: "When you turn this off, notes are ordered by importance (PageRank).",
  AUTO_NEXT_NOTE: "Open next note automatically after a review",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Disable review options in the file menu i.e. Review: Easy Good Hard",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "After disabling, you can review using the command hotkeys. Reload Obsidian after changing this.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximum number of days to display on right panel",
  MIN_ONE_DAY: "The number of days must be at least 1.",
  VALID_NUMBER_WARNING: "Please provide a valid number.",
  UI_PREFERENCES: "UI Preferences",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deck trees should be initially displayed as expanded",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Turn this off to collapse nested decks in the same card. Useful if you have cards which belong to many decks in the same file.",
  ALGORITHM: "Algorithm",
  CHECK_ALGORITHM_WIKI: 'For more information, check the <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "Base ease",
  BASE_EASE_DESC: "minimum = 130, preferrably approximately 250.",
  BASE_EASE_MIN_WARNING: "The base ease must be at least 130.",
  LAPSE_INTERVAL_CHANGE: "Interval change when you review a flashcard/note as hard",
  LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
  EASY_BONUS: "Easy Bonus",
  EASY_BONUS_DESC: "The easy bonus allows you to set the difference in intervals between answering Good and Easy on a flashcard/note (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "The easy bonus must be at least 100.",
  MAX_INTERVAL: "Maximum Interval",
  MAX_INTERVAL_DESC: "Allows you to place an upper limit on the interval (default = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "The maximum interval must be at least 1 day.",
  MAX_LINK_CONTRIB: "Maximum link contribution",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Display debugging information on the developer console?",
  NOTES_REVIEW_QUEUE: "Notes Review Queue",
  CLOSE: "Close",
  NEW: "New",
  YESTERDAY: "Yesterday",
  TODAY: "Today",
  TOMORROW: "Tomorrow",
  STATS_TITLE: "Statistics",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Forecast",
  FORECAST_DESC: "The number of cards due in the future",
  SCHEDULED: "Scheduled",
  DAYS: "Days",
  NUMBER_OF_CARDS: "Number of cards",
  REVIEWS_PER_DAY: "Average: ${avg} reviews/day",
  INTERVALS: "Intervals",
  INTERVALS_DESC: "Delays until reviews are shown again",
  COUNT: "Count",
  INTERVALS_SUMMARY: "Average interval: ${avg}, Longest interval: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  CARD_TYPES: "Card Types",
  CARD_TYPES_DESC: "This includes buried cards as well, if any",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "Total cards: ${totalCardsCount}"
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {
  DECKS: "\u30C7\u30C3\u30AD",
  DUE_CARDS: "\u671F\u65E5\u306E\u30AB\u30FC\u30C9",
  NEW_CARDS: "\u65B0\u898F\u306E\u30AB\u30FC\u30C9",
  TOTAL_CARDS: "\u30AB\u30FC\u30C9\u5408\u8A08",
  BACK: "Back",
  EDIT_LATER: "\u5F8C\u3067\u7DE8\u96C6",
  RESET_CARD_PROGRESS: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u3092\u30EA\u30BB\u30C3\u30C8",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "\u89E3\u7B54\u3092\u8868\u793A",
  CARD_PROGRESS_RESET: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u304C\u30EA\u30BB\u30C3\u30C8\u3055\u308C\u307E\u3057\u305F\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u30CE\u30FC\u30C8\u3092\u958B\u304F",
  REVIEW_CARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u30EC\u30D3\u30E5\u30FC",
  REVIEW_EASY_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Easy",
  REVIEW_GOOD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Good",
  REVIEW_HARD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Hard",
  REVIEW_NOTE_EASY_CMD: "\u30CE\u30FC\u30C8\u3092Easy\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_GOOD_CMD: "\u30CE\u30FC\u30C8\u3092Good\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_HARD_CMD: "\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  CRAM_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u8A70\u3081\u8FBC\u307F\u5B66\u7FD2\u3059\u308B",
  REVIEW_ALL_CARDS: "\u3059\u3079\u3066\u306E\u30CE\u30FC\u30C8\u304B\u3089\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  VIEW_STATS: "\u7D71\u8A08\u3092\u95B2\u89A7\u3059\u308B",
  STATUS_BAR: "\u30EC\u30D3\u30E5\u30FC: ${dueNotesCount}\u30CE\u30FC\u30C8, ${dueFlashcardsCount}\u30AB\u30FC\u30C9\u304C\u671F\u65E5",
  SYNC_TIME_TAKEN: "\u540C\u671F\u306B${t}ms\u304B\u304B\u308A\u307E\u3057\u305F\u3002",
  NOTE_IN_IGNORED_FOLDER: "\u30CE\u30FC\u30C8\u304C\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306B\u4FDD\u5B58\u3055\u308C\u3066\u3044\u307E\u3059(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  PLEASE_TAG_NOTE: "\u30EC\u30D3\u30E5\u30FC\u3092\u884C\u3046\u306B\u306F\u30CE\u30FC\u30C8\u306B\u5BFE\u3057\u3066\u6B63\u3057\u304F\u30BF\u30B0\u4ED8\u3051\u3057\u3066\u304F\u3060\u3055\u3044(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  RESPONSE_RECEIVED: "\u7B54\u3048\u3092\u53D7\u3051\u53D6\u308A\u307E\u3057\u305F\u3002",
  NO_DECK_EXISTS: "${deckName}\u306B\u306F\u30C7\u30C3\u30AD\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002",
  ALL_CAUGHT_UP: "\u4ECA\u65E5\u306E\u8AB2\u984C\u3092\u3059\u3079\u3066\u9054\u6210\u3057\u307E\u3057\u305F :D",
  DAYS_STR_IVL: "${interval}\u65E5\u5F8C",
  MONTHS_STR_IVL: "${interval}\u6708\u5F8C",
  YEARS_STR_IVL: "${interval}\u5E74\u5F8C",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - \u8A2D\u5B9A",
  CHECK_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${wiki_url}">wiki</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  FOLDERS_TO_IGNORE: "\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0",
  FOLDERS_TO_IGNORE_DESC: '\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9\u3092\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002"Templates Meta/Scripts" \u306E\u3088\u3046\u306A\u30B9\u30DA\u30FC\u30B9\u306B\u3088\u308B\u533A\u5207\u308A\u3067\u306E\u66F8\u304D\u65B9\u306F\u7121\u52B9\u3067\u3059\u3002',
  FLASHCARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  FLASHCARD_TAGS_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#flashcards #deck2 #deck3"',
  CONVERT_FOLDERS_TO_DECKS: "\u30D5\u30A9\u30EB\u30C0\u3092\u30C7\u30C3\u30AD\u3068\u30B5\u30D6\u30C7\u30C3\u30AD\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u3053\u308C\u306F\u4E0A\u8A18\u306E\u30BF\u30B0\u3092\u4F7F\u7528\u3057\u305F\u30C7\u30C3\u30AD\u69CB\u7BC9\u306E\u4EE3\u66FF\u3068\u306A\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3059\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6700\u7D42\u884C\u3068\u540C\u4E00\u306E\u884C\u306B\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001HTML\u30B3\u30E1\u30F3\u30C8\u306B\u3088\u3063\u3066Markdown\u306E\u30EA\u30B9\u30C8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u304C\u5D29\u308C\u306A\u304F\u306A\u308A\u307E\u3059\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u307E\u3067\u30B7\u30D6\u30EA\u30F3\u30B0\u3092\u5EF6\u671F\u3057\u307E\u3059\u304B\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u30B7\u30D6\u30EA\u30F3\u30B0\u306F\u540C\u4E00\u306E\u30AB\u30FC\u30C9\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u751F\u6210\u3055\u308C\u305F\u30AB\u30FC\u30C9\u3001\u3064\u307E\u308A\u7A74\u57CB\u3081\u554F\u984C\u306E\u6D3E\u751F\u30AB\u30FC\u30C9\u3067\u3059\u3002",
  SHOW_CARD_CONTEXT: "\u30AB\u30FC\u30C9\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\uFF62\u30BF\u30A4\u30C8\u30EB > \u898B\u51FA\u3057 1 > \u526F\u898B\u51FA\u3057 > ... > \u526F\u898B\u51FA\u3057\uFF63\u306E\u8868\u793A\u3092\u884C\u3046\u304B\u3069\u3046\u304B\u3092\u6C7A\u3081\u307E\u3059\u3002",
  CARD_MODAL_HEIGHT_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7E26\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u30E2\u30D0\u30A4\u30EB\u7248\u3001\u307E\u305F\u306F\u975E\u5E38\u306B\u5927\u304D\u306A\u30B5\u30A4\u30BA\u306E\u753B\u50CF\u304C\u3042\u308B\u5834\u5408\u306B\u306F100%\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002",
  RESET_DEFAULT: "\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306B\u30EA\u30BB\u30C3\u30C8\u3059\u308B",
  CARD_MODAL_WIDTH_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6A2A\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  FILENAME_OR_OPEN_FILE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u30EC\u30D3\u30E5\u30FC\u3067\uFF62\u5F8C\u3067\u7DE8\u96C6\uFF63\u306E\u4EE3\u308F\u308A\u306B\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u30EC\u30D3\u30E5\u30FC\u4E2D\u306E\u30AB\u30FC\u30C9\u306E\u9806\u756A\u3092\u30E9\u30F3\u30C0\u30E0\u306B\u3057\u307E\u3059\u304B\uFF1F",
  DISABLE_CLOZE_CARDS: "\u7A74\u57CB\u3081\u30AB\u30FC\u30C9\u3092\u7121\u52B9\u5316\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==\u30CF\u30A4\u30E9\u30A4\u30C8==\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**\u30DC\u30FC\u30EB\u30C9\u4F53**\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{\u4E2D\u62EC\u5F27}}\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3059\u308B\u5834\u5408\u306B\u306F\u3001\u4F5C\u6210\u6E08\u307F\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u624B\u52D5\u3067\u7DE8\u96C6\u3057\u76F4\u3059\u5FC5\u8981\u304C\u3042\u308B\u3053\u3068\u306B\u6CE8\u610F\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  NOTES: "\u30CE\u30FC\u30C8",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  TAGS_TO_REVIEW_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#review #tag2 #tag3"',
  OPEN_RANDOM_NOTE: "\u30E9\u30F3\u30C0\u30E0\u306B\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  OPEN_RANDOM_NOTE_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u7121\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u72B6\u614B\u3067\u306F\u3001\u30CE\u30FC\u30C8\u306F\u91CD\u8981\u5EA6(\u30DA\u30FC\u30B8\u30E9\u30F3\u30AF)\u306B\u3088\u308B\u9806\u756A\u3067\u8868\u793A\u3055\u308C\u307E\u3059\u3002",
  AUTO_NEXT_NOTE: "\u30EC\u30D3\u30E5\u30FC\u5F8C\u306B\u6B21\u306E\u30CE\u30FC\u30C8\u3092\u81EA\u52D5\u7684\u306B\u958B\u304F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u306E\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u7121\u52B9\u5316(\uFF62\u30EC\u30D3\u30E5\u30FC: Easy\uFF63\u7B49\u306E\u9805\u76EE\u3092\u975E\u8868\u793A\u306B\u3059\u308B)",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u7121\u52B9\u5316\u3057\u305F\u5F8C\u3001\u30B3\u30DE\u30F3\u30C9\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u4F7F\u3063\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u3053\u3068\u304C\u53EF\u80FD\u306B\u306A\u308A\u307E\u3059\u3002\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3057\u305F\u5834\u5408\u306B\u306FObsidian\u3092\u30EA\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u30D1\u30CD\u30EB\u306B\u8868\u793A\u3059\u308B\u6700\u5927\u306E\u65E5\u6570",
  MIN_ONE_DAY: "\u65E5\u6570\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  VALID_NUMBER_WARNING: "\u6709\u52B9\u306A\u6570\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  UI_PREFERENCES: "\u30E6\u30FC\u30B6\u30FC \u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30A4\u30B9\u306E\u8A2D\u5B9A",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u30C7\u30C3\u30AD \u30C4\u30EA\u30FC\u306F\u6700\u521D\u306F\u5C55\u958B\u3057\u3066\u8868\u793A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u3053\u308C\u3092\u30AA\u30D5\u306B\u3059\u308B\u3068\u3001\u540C\u3058\u30AB\u30FC\u30C9\u5185\u306E\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30C7\u30C3\u30AD\u304C\u6298\u308A\u305F\u305F\u307E\u308C\u307E\u3059\u3002\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u591A\u304F\u306E\u30C7\u30C3\u30AD\u306B\u5C5E\u3059\u308B\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u4FBF\u5229\u3067\u3059\u3002",
  ALGORITHM: "\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0",
  CHECK_ALGORITHM_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${algo_url}">\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u5B9F\u88C5</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  BASE_EASE: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055",
  BASE_EASE_DESC: "\u6700\u5C0F\u5024\u306F130\u3067\u3059\u304C\u3001 \u9069\u6B63\u5024\u306F\u304A\u304A\u3088\u305D250\u3067\u3059\u3002",
  BASE_EASE_MIN_WARNING: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055\u306B\u306F130\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LAPSE_INTERVAL_CHANGE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3057\u305F\u969B\u306E\u9593\u9694\u5909\u66F4",
  LAPSE_INTERVAL_CHANGE_DESC: '"\u65B0\u3057\u3044\u9593\u9694 = \u4EE5\u524D\u306E\u9593\u9694 * \u9593\u9694\u5909\u66F4 / 100" \u3068\u3057\u3066\u8A08\u7B97\u3055\u308C\u307E\u3059\u3002',
  EASY_BONUS: "Easy\u30DC\u30FC\u30CA\u30B9",
  EASY_BONUS_DESC: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u3088\u3063\u3066\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u306B\u304A\u3051\u308B\u9593\u9694\u306E\u5DEE\u5206\u3092\u8A2D\u5B9A\u3067\u304D\u307E\u3059(\u6700\u5C0F\u5024 = 100%)\u3002",
  EASY_BONUS_MIN_WARNING: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u306F100\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_INTERVAL: "\u9593\u9694\u306E\u6700\u5927\u5024",
  MAX_INTERVAL_DESC: "\u9593\u9694\u306B\u4E0A\u9650\u5024\u3092\u8A2D\u5B9A\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8\u5024 = 100\u5E74)\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u9593\u9694\u306E\u6700\u5927\u5024\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_LINK_CONTRIB: "\u30EA\u30F3\u30AF\u30B3\u30F3\u30C8\u30EA\u30D3\u30E5\u30FC\u30B7\u30E7\u30F3\u306E\u6700\u5927\u5024",
  MAX_LINK_CONTRIB_DESC: "\u6700\u521D\u306E\u6613\u3057\u3055\u306B\u5BFE\u3057\u3066\u3001\u30EA\u30F3\u30AF\u3055\u308C\u305F\u30CE\u30FC\u30C8\u306E\u91CD\u307F\u4ED8\u3051\u3055\u308C\u305F\u6613\u3057\u3055\u304C\u5BC4\u4E0E\u3059\u308B\u6700\u5927\u5024\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LOGGING: "\u30ED\u30B0\u7BA1\u7406",
  DISPLAY_DEBUG_INFO: "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u3066\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  NOTES_REVIEW_QUEUE: "\u30CE\u30FC\u30C8\u30EC\u30D3\u30E5\u30FC\u306E\u30AD\u30E5\u30FC",
  CLOSE: "\u9589\u3058\u308B",
  NEW: "\u65B0\u898F",
  YESTERDAY: "\u6628\u65E5",
  TODAY: "\u4ECA\u65E5",
  TOMORROW: "\u660E\u65E5",
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "\u4E88\u6E2C",
  FORECAST_DESC: "\u5FA9\u7FD2\u671F\u65E5\u304C\u6765\u308B\u30AB\u30FC\u30C9\u306E\u679A\u6570",
  SCHEDULED: "\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u6E08\u307F",
  DAYS: "\u65E5",
  NUMBER_OF_CARDS: "\u30AB\u30FC\u30C9\u6570",
  REVIEWS_PER_DAY: "\u5E73\u5747: ${avg}\u30EC\u30D3\u30E5\u30FC/\u65E5",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u4E88\u5B9A\u65E5",
  COUNT: "\u30AB\u30A6\u30F3\u30C8",
  INTERVALS_SUMMARY: "\u9593\u9694\u306E\u5E73\u5747\u5024: ${avg}, \u6700\u9577\u306E\u9593\u9694: ${longest}",
  EASES: "\u6613\u3057\u3055",
  EASES_SUMMARY: "\u6613\u3057\u3055\u306E\u5E73\u5747\u5024: ${avgEase}",
  CARD_TYPES: "\u30AB\u30FC\u30C9\u30BF\u30A4\u30D7",
  CARD_TYPES_DESC: "\u5EF6\u671F\u306E\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u306F\u3053\u308C\u306B\u542B\u307E\u308C\u307E\u3059",
  CARD_TYPE_NEW: "\u65B0\u898F",
  CARD_TYPE_YOUNG: "\u5FA9\u7FD2(\u521D\u671F)",
  CARD_TYPE_MATURE: "\u5FA9\u7FD2(\u5F8C\u671F)",
  CARD_TYPES_SUMMARY: "\u30AB\u30FC\u30C9\u306E\u5408\u8A08: ${totalCardsCount}\u679A"
};

// src/lang/locale/ko.ts
var ko_default = {
  DECKS: "\uB371",
  DUE_CARDS: "\uB2E4\uC2DC \uBCFC \uCE74\uB4DC\uB4E4",
  NEW_CARDS: "\uC0C8\uB85C\uC6B4 \uCE74\uB4DC\uB4E4",
  TOTAL_CARDS: "\uC804\uCCB4 \uCE74\uB4DC\uB4E4",
  BACK: "Back",
  EDIT_LATER: "\uB098\uC911\uC5D0 \uD3B8\uC9D1\uD558\uAE30",
  RESET_CARD_PROGRESS: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC744 \uCD08\uAE30\uD654\uD569\uB2C8\uB2E4.",
  HARD: "\uC5B4\uB824\uC6C0(Hard)",
  GOOD: "\uC88B\uC74C(Good)",
  EASY: "\uC26C\uC6C0(Easy)",
  SHOW_ANSWER: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30",
  CARD_PROGRESS_RESET: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC774 \uCD08\uAE30\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
  OPEN_NOTE_FOR_REVIEW: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uC5F4\uAE30",
  REVIEW_CARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0",
  REVIEW_EASY_FILE_MENU: "\uB9AC\uBDF0: \uC26C\uC6C0(Easy)",
  REVIEW_GOOD_FILE_MENU: "\uB9AC\uBDF0: \uC88B\uC74C(Good)",
  REVIEW_HARD_FILE_MENU: "\uB9AC\uBDF0: \uC5B4\uB824\uC6C0(Hard)",
  REVIEW_NOTE_EASY_CMD: "\uB178\uD2B8\uB97C \uC26C\uC6C0(easy)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_NOTE_GOOD_CMD: "\uB178\uD2B8\uB97C \uC88B\uC74C(good)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_NOTE_HARD_CMD: "\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(hard)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  CRAM_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uBCBC\uB77D\uCE58\uAE30\uD569\uB2C8\uB2E4.",
  REVIEW_ALL_CARDS: "\uBAA8\uB4E0 \uB178\uD2B8\uB4E4\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  VIEW_STATS: "\uD1B5\uACC4 \uD655\uC778",
  STATUS_BAR: "--\uB9AC\uBDF0: ${dueNotesCount} \uB178\uD2B8, ${dueFlashcardsCount} \uCE74\uB4DC \uB0A8\uC558\uC2B5\uB2C8\uB2E4.",
  SYNC_TIME_TAKEN: "\uB3D9\uAE30\uD654\uC5D0 ${t}\uBC00\uB9AC\uCD08 \uAC78\uB838\uC2B5\uB2C8\uB2E4",
  NOTE_IN_IGNORED_FOLDER: "\uB178\uD2B8\uAC00 \uBB34\uC2DC\uB41C \uD3F4\uB354 \uC544\uB798\uC5D0 \uC800\uC7A5\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  PLEASE_TAG_NOTE: "\uB9AC\uBDF0\uB97C \uD558\uAE30\uC704\uD574 \uB178\uD2B8\uC5D0 \uC801\uC808\uD788 \uD0DC\uADF8\uD574\uC8FC\uC138\uC694. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  RESPONSE_RECEIVED: "\uC694\uCCAD\uC774 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  NO_DECK_EXISTS: "${deckName}\uC774\uB77C\uB294 \uC774\uB984\uC758 \uB371\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  ALL_CAUGHT_UP: "\uBAA8\uB450 \uD655\uC778\uD588\uC2B5\uB2C8\uB2E4. :D",
  DAYS_STR_IVL: "${interval} \uC77C \uD6C4",
  MONTHS_STR_IVL: "${interval} \uAC1C\uC6D4 \uD6C4",
  YEARS_STR_IVL: "${interval} \uB144 \uD6C4",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - \uC124\uC815",
  CHECK_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${wiki_url}">wiki</a>\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  FOLDERS_TO_IGNORE: "\uBB34\uC2DC\uD560 \uD3F4\uB354\uB4E4",
  FOLDERS_TO_IGNORE_DESC: "\uD3F4\uB354 \uACBD\uB85C\uB97C \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. 'Templates Meta/Scripts' \uC640 \uAC19\uC774 \uC785\uB825\uD558\uB294 \uAC83\uC740 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  FLASHCARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8",
  FLASHCARD_TAGS_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#flashcards #deck2 #deck3'",
  CONVERT_FOLDERS_TO_DECKS: "\uD3F4\uB354\uB97C \uB371\uACFC \uC11C\uBE0C\uB371\uC73C\uB85C \uC0AC\uC6A9\uD560\uAE4C\uC694?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\uC774 \uAE30\uB2A5\uC740 \uC704\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8 \uC635\uC158\uC744 \uB300\uCCB4\uD569\uB2C8\uB2E4.",
  INLINE_SCHEDULING_COMMENTS: "\uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB9C8\uC9C0\uB9C9 \uC904\uACFC \uB3D9\uC77C\uD55C \uC904\uC5D0 \uC2A4\uCF00\uC904\uB9C1 \uCF54\uBA58\uD2B8\uB97C \uC800\uC7A5\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\uC774 \uC635\uC158\uC744 \uC0AC\uC6A9\uD558\uBA74 HTML \uC8FC\uC11D\uC774 \uBAA9\uB85D\uC758 \uD3EC\uB9E4\uD305\uC744 \uBB34\uB108\uD2B8\uB9AC\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Sibling \uCE74\uB4DC\uB97C \uB2E4\uC74C\uB0A0\uAE4C\uC9C0 \uBB3B\uC5B4\uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Sibling \uCE74\uB4DC\uB294 \uB3D9\uC77C\uD55C \uCE74\uB4DC \uD14D\uC2A4\uD2B8\uC5D0\uC11C \uC0DD\uC131\uB41C \uCE74\uB4DC\uC785\uB2C8\uB2E4. i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "\uCE74\uB4DC\uC758 \uBB38\uB9E5(context)\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  SHOW_CARD_CONTEXT_DESC: "\uCE74\uB4DC\uC5D0\uC11C 'Title > Heading 1 > Subheading > ... > Subheading' \uC758 \uD45C\uC2DC\uB97C \uD560\uC9C0 \uC124\uC815\uD569\uB2C8\uB2E4.",
  CARD_MODAL_HEIGHT_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB192\uC774 \uBE44\uC728",
  CARD_MODAL_SIZE_PERCENT_DESC: "\uBAA8\uBC14\uC77C \uBC84\uC804 \uD639\uC740 \uB9E4\uC6B0 \uD070 \uC774\uBBF8\uC9C0\uAC00 \uC788\uB294 \uACBD\uC6B0 100%\uB85C \uC124\uC815\uD574\uC57C \uD569\uB2C8\uB2E4.",
  RESET_DEFAULT: "\uAE30\uBCF8\uAC12\uC73C\uB85C \uCD08\uAE30\uD654",
  CARD_MODAL_WIDTH_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB108\uBE44 \uBE44\uC728",
  FILENAME_OR_OPEN_FILE: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0\uC5D0\uC11C 'Edit Later' \uB300\uC2E0\uC5D0 \uD30C\uC77C \uC774\uB984\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  RANDOMIZE_CARD_ORDER: "\uB9AC\uBDF0\uC911\uC778 \uCE74\uB4DC\uC758 \uC21C\uC11C\uB97C \uB79C\uB364\uC73C\uB85C \uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  DISABLE_CLOZE_CARDS: "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uCE74\uB4DC\uB97C \uBE44\uD65C\uC131\uD654\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==hightlights== \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**bolded text** \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{curly brackets}} \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  INLINE_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  FIX_SEPARATORS_MANUALLY_WARNING: "\uC8FC\uC758: \uC774 \uC635\uC158\uC744 \uC218\uC815\uD55C \uD6C4\uC5D0\uB294 \uC774\uBBF8 \uC791\uC131\uB41C \uD50C\uB798\uC2DC\uCE74\uB4DC\uB97C \uC218\uB3D9\uC73C\uB85C \uC218\uC815\uD574\uC57C \uD568\uC744 \uC8FC\uC758\uD558\uC2ED\uC2DC\uC624.",
  INLINE_REVERSED_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  NOTES: "\uB178\uD2B8",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\uB9AC\uBDF0\uC5D0 \uC0AC\uC6A9\uD560 \uD0DC\uADF8",
  TAGS_TO_REVIEW_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#review #tag2 #tag3'",
  OPEN_RANDOM_NOTE: "\uB9AC\uBDF0\uB97C \uC704\uD574 \uB79C\uB364 \uB178\uD2B8\uB97C \uC5FD\uB2C8\uB2E4.",
  OPEN_RANDOM_NOTE_DESC: "\uC774 \uC635\uC158\uC774 \uAEBC\uC838\uC788\uC73C\uBA74, \uB178\uD2B8\uB294 \uC911\uC694\uB3C4(\uD398\uC774\uC9C0 \uB7AD\uD06C)\uC5D0 \uB530\uB77C \uC815\uB82C\uB429\uB2C8\uB2E4.",
  AUTO_NEXT_NOTE: "\uB9AC\uBDF0 \uD6C4\uC5D0 \uB2E4\uC74C \uB178\uD2B8\uB97C \uC790\uB3D9\uC73C\uB85C \uC5FD\uB2C8\uB2E4.",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C\uC758 \uB9AC\uBDF0 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654 \uD569\uB2C8\uB2E4. \uC608) \uB9AC\uBDF0: Easy Good Hard",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\uC774 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654 \uD55C \uD6C4, \uBA85\uB839 \uB2E8\uCD95\uD0A4\uB97C \uC774\uC6A9\uD574 \uB9AC\uBDF0\uD558\uC2E4 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uC774 \uC635\uC158\uC744 \uBCC0\uACBD\uD55C \uD6C4\uC5D0 \uC635\uC2DC\uB514\uC5B8\uC744 \uC0C8\uB85C\uACE0\uCE68 \uD558\uC2ED\uC2DC\uC624.",
  MAX_N_DAYS_REVIEW_QUEUE: "\uC624\uB978\uCABD \uD328\uB110\uC5D0 \uD45C\uC2DC\uD560 \uCD5C\uB300 \uC77C\uC218",
  MIN_ONE_DAY: "\uC801\uC5B4\uB3C4 1\uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  VALID_NUMBER_WARNING: "\uC720\uD6A8\uD55C \uC22B\uC790\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
  UI_PREFERENCES: "\uC0AC\uC6A9\uC790 \uC778\uD130\uD398\uC774\uC2A4 \uAE30\uBCF8 \uC124\uC815",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\uB371 \uD2B8\uB9AC\uB294 \uCC98\uC74C\uC5D0 \uD655\uC7A5\uB41C \uAC83\uC73C\uB85C \uD45C\uC2DC\uB418\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\uAC19\uC740 \uCE74\uB4DC\uC5D0 \uC911\uCCA9\uB41C \uB371\uC744 \uC811\uC73C\uB824\uBA74 \uC774 \uC635\uC158\uC744 \uB044\uC2ED\uC2DC\uC624. \uAC19\uC740 \uD30C\uC77C\uC5D0 \uC5EC\uB7EC \uB371\uC5D0 \uC18D\uD55C \uCE74\uB4DC\uAC00 \uC788\uB294 \uACBD\uC6B0 \uC720\uC6A9\uD569\uB2C8\uB2E4.",
  ALGORITHM: "\uC54C\uACE0\uB9AC\uC998",
  CHECK_ALGORITHM_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${algo_url}">algorithm implementation</a>\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  BASE_EASE: "\uAE30\uBCF8 ease",
  BASE_EASE_DESC: "\uCD5C\uC19F\uAC12 = 130, \uC801\uC815\uCE58\uB294 \uB300\uB7B5 250\uC785\uB2C8\uB2E4.",
  BASE_EASE_MIN_WARNING: "\uAE30\uBCF8 ease\uB294 \uC801\uC5B4\uB3C4 130 \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  LAPSE_INTERVAL_CHANGE: "\uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(Hard)\uC73C\uB85C \uB9AC\uBDF0\uD588\uC744 \uB54C\uC758 \uAC04\uACA9 \uBCC0\uACBD",
  LAPSE_INTERVAL_CHANGE_DESC: "\uC0C8\uB85C\uC6B4 \uAC04\uACA9 = \uC774\uC804 \uAC04\uACA9 * \uAC04\uACA9\uBCC0\uACBD \uAC12 / 100.",
  EASY_BONUS: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4",
  EASY_BONUS_DESC: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uC5D0\uC11C \uC88B\uC74C(Good)\uACFC \uC26C\uC6C0(Easy) \uC0AC\uC774\uC758 \uAC04\uACA9 \uCC28\uC774\uB97C \uC124\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uCD5C\uC18C = 100%)",
  EASY_BONUS_MIN_WARNING: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uC801\uC5B4\uB3C4 100\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  MAX_INTERVAL: "\uCD5C\uB300 \uAC04\uACA9",
  MAX_INTERVAL_DESC: "\uAC04\uACA9\uC758 \uC0C1\uD55C\uC120\uC744 \uB458 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uAE30\uBCF8\uAC12 = 100\uB144)",
  MAX_INTERVAL_MIN_WARNING: "\uCD5C\uB300 \uAC04\uACA9\uC740 \uC801\uC5B4\uB3C4 1\uC77C\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  MAX_LINK_CONTRIB: "\uCD5C\uB300 \uC5F0\uACB0 \uAE30\uC5EC\uB3C4",
  MAX_LINK_CONTRIB_DESC: "\uB9C1\uD06C\uB41C \uB178\uD2B8\uC758 \uCD08\uAE30 ease\uC5D0 \uB300\uD55C \uAC00\uC911\uCE58\uAC00 \uC801\uC6A9\uB41C ease\uC758 \uCD5C\uB300 \uAE30\uC5EC\uB3C4\uC785\uB2C8\uB2E4.",
  LOGGING: "\uB85C\uAE45",
  DISPLAY_DEBUG_INFO: "\uB514\uBC84\uAE45 \uC815\uBCF4\uB97C \uAC1C\uBC1C\uC790 \uCF58\uC194\uC5D0 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  NOTES_REVIEW_QUEUE: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uB300\uAE30\uC5F4",
  CLOSE: "\uB2EB\uAE30",
  NEW: "New",
  YESTERDAY: "\uC5B4\uC81C",
  TODAY: "\uC624\uB298",
  TOMORROW: "\uB0B4\uC77C",
  STATS_TITLE: "\uD1B5\uACC4",
  MONTH: "\uC6D4",
  QUARTER: "\uBD84\uAE30",
  YEAR: "\uB144",
  LIFETIME: "\uD3C9\uC0DD",
  FORECAST: "\uC608\uCE21",
  FORECAST_DESC: "\uC774\uD6C4\uC5D0 \uD559\uC2B5\uD560 \uCE74\uB4DC\uC758 \uC218",
  SCHEDULED: "Scheduled",
  DAYS: "\uC77C",
  NUMBER_OF_CARDS: "\uCE74\uB4DC\uC758 \uC218",
  REVIEWS_PER_DAY: "\uD3C9\uADE0: ${avg} \uB9AC\uBDF0/\uC77C",
  INTERVALS: "\uAC04\uACA9",
  INTERVALS_DESC: "\uB9AC\uBDF0\uB97C \uB2E4\uC2DC \uD560 \uB54C \uAE4C\uC9C0\uC758 \uAE30\uAC04",
  COUNT: "Count",
  INTERVALS_SUMMARY: "\uD3C9\uADE0 \uAC04\uACA9: ${avg}, \uAC00\uC7A5 \uAE34 \uAC04\uACA9: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  CARD_TYPES: "\uCE74\uB4DC \uD0C0\uC785",
  CARD_TYPES_DESC: "\uC5EC\uAE30\uC5D0\uB294 \uBB3B\uC5B4\uB454 \uCE74\uB4DC\uB3C4 \uD3EC\uD568\uB429\uB2C8\uB2E4.",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "\uC804\uCCB4 \uCE74\uB4DC \uC218: ${totalCardsCount}"
};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {
  DECKS: "Baralhos",
  DUE_CARDS: "Cartas para Colocar em Dia",
  NEW_CARDS: "Novas Cartas",
  TOTAL_CARDS: "Total de Cartas",
  BACK: "Back",
  EDIT_LATER: "Editar Depois",
  RESET_CARD_PROGRESS: "Reiniciar o Progresso da Carta",
  HARD: "Dif\xEDcil",
  GOOD: "OK",
  EASY: "F\xE1cil",
  SHOW_ANSWER: "Mostrar Resposta",
  CARD_PROGRESS_RESET: "O Progresso da Carta foi reiniciado",
  OPEN_NOTE_FOR_REVIEW: "Abrir uma nota para revisar",
  REVIEW_CARDS: "Revisar flashcards",
  REVIEW_EASY_FILE_MENU: "Revis\xE3o: F\xE1cil",
  REVIEW_GOOD_FILE_MENU: "Revis\xE3o: OK",
  REVIEW_HARD_FILE_MENU: "Revis\xE3o: Dif\xEDcil",
  REVIEW_NOTE_EASY_CMD: "Revisar nota como f\xE1cil",
  REVIEW_NOTE_GOOD_CMD: "Revisar nota como OK",
  REVIEW_NOTE_HARD_CMD: "Revisar nota como dif\xEDcil",
  REVIEW_CARDS_IN_NOTE: "Revisar flashcards nessa nota",
  CRAM_CARDS_IN_NOTE: "Revisar todas as flashcards nessa nota",
  REVIEW_ALL_CARDS: "Revisar flashcards de todas as notas",
  VIEW_STATS: "Ver estat\xEDsticas",
  STATUS_BAR: "Revis\xE3o: ${dueNotesCount} nota(s), ${dueFlashcardsCount} Carta(s) para colocar em dia",
  SYNC_TIME_TAKEN: "Sicroniza\xE7\xE3o levou ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Nota \xE9 salva na pasta ignorada (cheque as configura\xE7\xF5es).",
  PLEASE_TAG_NOTE: "Por favor etiquete a nota apropriadamente para revisar (nas configura\xE7\xF5es).",
  RESPONSE_RECEIVED: "Resposta recebida.",
  NO_DECK_EXISTS: "Nenhum baralho existe para ${deckName}",
  ALL_CAUGHT_UP: "Voc\xEA colocou tudo em prazo agora :D.",
  DAYS_STR_IVL: "${interval} dia(s)",
  MONTHS_STR_IVL: "${interval} m\xEAs(es)",
  YEARS_STR_IVL: "${interval} ano(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}a",
  SETTINGS_HEADER: "Plguin Spaced Repetition - Configura\xE7\xE3o",
  CHECK_WIKI: 'Para mais informa\xE7\xF5es, checke o <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Pastas para ignorar",
  FOLDERS_TO_IGNORE_DESC: "Ensira o caminho das pastas separado por quebras de linha ex: Templates Meta/Scripts",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Texto do Bot\xE3o de F\xE1cil",
  FLASHCARD_GOOD_LABEL: "Texto do Bot\xE3o de OK",
  FLASHCARD_HARD_LABEL: "Texto do Bot\xE3o de Dif\xEDcil",
  FLASHCARD_EASY_DESC: 'Costumize o r\xF3tulo para o bot\xE3o de "F\xE1cil"',
  FLASHCARD_GOOD_DESC: 'Costumize o r\xF3tulo para o bot\xE3o de "OK"',
  FLASHCARD_HARD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "Dif\xEDcil"',
  FLASHCARD_TAGS: "Etiquetas dos Flashcards",
  FLASHCARD_TAGS_DESC: "Ensira etiquetas separadas por espa\xE7os ou quebras de linha ex: #flashcards #baralho2 #baralho3.",
  CONVERT_FOLDERS_TO_DECKS: "Converter pastas para baralhos e sub-baralhos?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Isso \xE9 uma alternativa para a op\xE7\xE3o de etiqueta dos Flashcards em cima.",
  INLINE_SCHEDULING_COMMENTS: "Salvar coment\xE1rios de agendamento na mesma linha que a \xFAltima linha do flashcard?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Ligar isso vai fazer com que os coment\xE1rios em HTML n\xE3o quebrem a formata\xE7\xE3o de listas.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrar cartas irm\xE3s at\xE9 o pr\xF3ximo dia?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Cartas irm\xE3s s\xE3o geradas pelo texto da mesma carta ex: omiss\xE3o de palavras",
  SHOW_CARD_CONTEXT: "Mostrar conxtexto nas cartas?",
  SHOW_CARD_CONTEXT_DESC: "ex: T\xEDtulo > Cabe\xE7alho 1 > Subcabe\xE7alho > ... > Subcabe\xE7alho",
  CARD_MODAL_HEIGHT_PERCENT: "Porcentagem da Altura do Flashcard",
  CARD_MODAL_SIZE_PERCENT_DESC: "Deveria estar configurado em 100% em dispositivos m\xF3veis ou se voc\xEA tem imagens muito grandes",
  RESET_DEFAULT: "Reiniciar para a pr\xE9-defini\xE7\xE3o",
  CARD_MODAL_WIDTH_PERCENT: "Porcentagem de Largura do Flashcard",
  FILENAME_OR_OPEN_FILE: "Mostrar o nome do arquivo ao inv\xE9s de 'Editar Depois' na revis\xE3o dos flashcards?",
  RANDOMIZE_CARD_ORDER: "Aleatorizar a ordem das cartas durante a revis\xE3o?",
  DISABLE_CLOZE_CARDS: "Desabilitar cartas que usam omiss\xE3o de palavras?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Converter ==marca-texto== em omiss\xF5es?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "Converter **texto em negrito** em omiss\xF5es?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Converter {{chaves}} em omiss\xF5es?",
  INLINE_CARDS_SEPARATOR: "Separador para flashcards inline",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note que depois de mudar isso voc\xEA vai ter que manualmente mudar quaisquer flashcards que voc\xEA tenha.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards inline reversos",
  MULTILINE_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas reversos",
  NOTES: "Notas",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Etiquetas para revisar",
  TAGS_TO_REVIEW_DESC: "Ensira etiquetas separadas por espa\xE7os ou quebra de linhas ex: #revisar #etiqueta2 #etiqueta3.",
  OPEN_RANDOM_NOTE: "Abrir uma nota aleat\xF3ria para revisar",
  OPEN_RANDOM_NOTE_DESC: "Quando voc\xEA desabilitar isso, as notas v\xE3o ser ordenadas por import\xE2ncia (PageRank).",
  AUTO_NEXT_NOTE: "Abrir a pr\xF3xima nota automaticamente depois de uma revis\xE3o",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Desabilitar op\xE7\xF5es de revis\xE3o no menu de arquivos ex: Revis\xE3o: F\xE1cil OK Dif\xEDcil",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Depois de desabilitar, voc\xEA pode revisar usando os atalhos de comando. Reinicie Obsidian depois de mudar isso.",
  MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de dias para exibir no painel direito",
  MIN_ONE_DAY: "O n\xFAmero de dias deve ser pelo menos 1.",
  VALID_NUMBER_WARNING: "Por favor ensira um n\xFAmero v\xE1lido.",
  UI_PREFERENCES: "Prefer\xEAncias de UI",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\xC1rvores de baralhos devem inicialmente serem exibidas como expandidas",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Desabilite isso para colapsar baralhos que est\xE3o um dentro do outro na mesma carta. \xDAtil se voc\xEA tem cartas que pertencem a muitos baralhos em um mesmo arquivo.",
  ALGORITHM: "Algor\xEDtmo",
  CHECK_ALGORITHM_WIKI: 'Para mais informa\xE7\xF5es, cheque a <a href="${algo_url}">implementa\xE7\xE3o do algor\xEDtmo</a>.',
  BASE_EASE: "Facilidade base",
  BASE_EASE_DESC: "m\xEDnimo = 130, preferivelmente aproximadamente 250.",
  BASE_EASE_MIN_WARNING: "A facilidade base deve ser pelo menos 130.",
  LAPSE_INTERVAL_CHANGE: "Mudan\xE7a de intervalo quando voc\xEA revisa um(a) flashcard/nota como dif\xEDcil",
  LAPSE_INTERVAL_CHANGE_DESC: "novoIntervalo = velhoIntervalo * mudancaIntervalo / 100.",
  EASY_BONUS: "B\xF4nus de F\xE1cil",
  EASY_BONUS_DESC: "O b\xF4nus de f\xE1cil te permite mudar a difer\xEAncia entre intervalos de responder OK e F\xE1cil em um(a) flashcard/nota (m\xEDnimo = 100%).",
  EASY_BONUS_MIN_WARNING: "O b\xF4nus de f\xE1cil deve ser pelo menos 100.",
  MAX_INTERVAL: "Intervalo M\xE1ximo",
  MAX_INTERVAL_DESC: "Te permite colocar um limite m\xE1ximo no intervalo (pr\xE9-defini\xE7\xE3o = 100 anos).",
  MAX_INTERVAL_MIN_WARNING: "O intervalo m\xE1ximo deve ser pelo menos 1 dia.",
  MAX_LINK_CONTRIB: "Contribui\xE7\xE3o M\xE1xima de Links",
  MAX_LINK_CONTRIB_DESC: "Contribui\xE7\xE3o m\xE1xima da facilidade ponderada das notas linkadas \xE0 facilidade inicial.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Mostrar informa\xE7\xE3o de debugging no console de desenvolvimento?",
  NOTES_REVIEW_QUEUE: "Fila de Notas para Revisar",
  CLOSE: "Fechar",
  NEW: "Novo",
  YESTERDAY: "Ontem",
  TODAY: "Hoje",
  TOMORROW: "Amanh\xE3",
  STATS_TITLE: "Estat\xEDsticas",
  MONTH: "M\xEAs",
  QUARTER: "Quarto",
  YEAR: "Ano",
  LIFETIME: "Tempo Total",
  FORECAST: "Previs\xE3o",
  FORECAST_DESC: "O n\xFAmero de cartas a serem colocadas em dia no futuro",
  SCHEDULED: "Agendado",
  DAYS: "Dias",
  NUMBER_OF_CARDS: "N\xFAmero de cartas",
  REVIEWS_PER_DAY: "M\xE9dia: ${avg} revis\xF5es/dia",
  INTERVALS: "Intervalos",
  INTERVALS_DESC: "Atrasos at\xE9 que as revis\xF5es sejam exibidas de novo",
  COUNT: "Contagem",
  INTERVALS_SUMMARY: "Intervalo em m\xE9dia: ${avg}, Maior intervalo: ${longest}",
  EASES: "Facilidades",
  EASES_SUMMARY: "Facilidade em m\xE9dia: ${avgEase}",
  CARD_TYPES: "Tipos de Cartas",
  CARD_TYPES_DESC: "Isso tamb\xE9m inclui cartas enterrados, caso existam",
  CARD_TYPE_NEW: "Novo",
  CARD_TYPE_YOUNG: "Jovem",
  CARD_TYPE_MATURE: "Amadurecido",
  CARD_TYPES_SUMMARY: "Total de cartas: ${totalCardsCount}"
};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {
  DECKS: "\u0423\u0440\u043E\u0432\u043D\u0438",
  DUE_CARDS: "\u041F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  NEW_CARDS: "\u041D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  TOTAL_CARDS: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  EDIT_LATER: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435",
  BACK: "Back",
  RESET_CARD_PROGRESS: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  HARD: "\u0421\u043B\u043E\u0436\u043D\u043E",
  GOOD: "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  EASY: "\u041B\u0435\u0433\u043A\u043E",
  SHOW_ANSWER: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u0442\u0432\u0435\u0442",
  CARD_PROGRESS_RESET: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  OPEN_NOTE_FOR_REVIEW: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  REVIEW_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  REVIEW_EASY_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E",
  REVIEW_GOOD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  REVIEW_HARD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u0421\u043B\u043E\u0436\u043D\u043E",
  REVIEW_NOTE_EASY_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041B\u0451\u0433\u043A\u0443\u044E",
  REVIEW_NOTE_GOOD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u0443\u044E",
  REVIEW_NOTE_HARD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u0421\u043B\u043E\u0436\u043D\u0443\u044E",
  REVIEW_CARDS_IN_NOTE: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  CRAM_CARDS_IN_NOTE: "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  REVIEW_ALL_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
  VIEW_STATS: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443",
  STATUS_BAR: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C: ${dueNotesCount} \u0437\u0430\u043C\u0435\u0442\u043E\u043A(-\u043A\u0438), ${dueFlashcardsCount} \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A(-\u043A\u0438) \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u0438\u0442",
  SYNC_TIME_TAKEN: "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u043D\u044F\u043B\u0430 ${t}\u043C\u0441",
  NOTE_IN_IGNORED_FOLDER: "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u0443\u044E \u043F\u0430\u043F\u043A\u0443 (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  PLEASE_TAG_NOTE: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u043F\u043E\u043C\u0435\u0442\u044C\u0442\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u043D\u0430\u0434\u043E \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  RESPONSE_RECEIVED: "\u041E\u0442\u0432\u0435\u0442 \u043F\u043E\u043B\u0443\u0447\u0435\u043D.",
  NO_DECK_EXISTS: "\u041D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u0440\u043E\u0432\u043D\u044F ${deckName}",
  ALL_CAUGHT_UP: "\u0415\u0441\u0442\u044C! \u0422\u044B \u0441\u043F\u0440\u0430\u0432\u0438\u043B\u0441\u044F! :D.",
  DAYS_STR_IVL: "${interval} \u0434\u043D\u0435\u0439",
  MONTHS_STR_IVL: "${interval} \u043C\u0435\u0441\u044F\u0446\u043E\u0432",
  YEARS_STR_IVL: "${interval} \u0433\u043E\u0434\u0430(\u043B\u0435\u0442)",
  DAYS_STR_IVL_MOBILE: "${interval}\u0434",
  MONTHS_STR_IVL_MOBILE: "${interval}\u043C",
  YEARS_STR_IVL_MOBILE: "${interval}\u0433",
  SETTINGS_HEADER: "Spaced Repetition \u041F\u043B\u0430\u0433\u0438\u043D - \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  CHECK_WIKI: '\u0414\u043B\u044F \u0434\u043E\u043F \u0438\u043D\u0444\u044B, \u0441\u043C\u043E\u0442\u0440\u0438 <a href="${wiki_url}">wiki</a>. \u0421\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434 :3',
  FOLDERS_TO_IGNORE: "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
  FOLDERS_TO_IGNORE_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u043F\u0443\u0442\u0438 \u043F\u0430\u043F\u043E\u043A \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: Templates Meta/Scripts",
  FLASHCARDS: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\u0422\u044D\u0433\u0438 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FLASHCARD_TAGS_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0432 \u0443\u0440\u043E\u0432\u043D\u0438 \u0438 \u043F\u043E\u0434\u0443\u0440\u043E\u0432\u043D\u0438?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u042D\u0442\u043E \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u0430 \u0442\u044D\u0433\u0430\u043C \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A, \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u0441\u0432\u0435\u0440\u0445\u0443.",
  INLINE_SCHEDULING_COMMENTS: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0430 \u0441\u0442\u0440\u043E\u043A\u0435 \u043F\u043E\u0441\u043B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0433\u043E \u0441\u0434\u0435\u043B\u0430\u0435\u0442 \u0442\u0430\u043A, \u0447\u0442\u043E HTML \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043C\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u041F\u0440\u044F\u0442\u0430\u0442\u044C \u0440\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0434\u043E \u0441\u043B\u0435\u0434. \u0434\u043D\u044F?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u0420\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 - \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u044B \u0438\u0437 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438([...])",
  SHOW_CARD_CONTEXT: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442(\u0443\u0440\u043E\u0432\u0435\u043D\u044C) \u0432 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0430\u0445(\u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F)?",
  SHOW_CARD_CONTEXT_DESC: "\u043F\u0440\u0438\u043C\u0435\u0440: Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "\u0412\u044B\u0441\u043E\u0442\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u0415\u0441\u043B\u0438 \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0435\u0441\u044C \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u043C \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u043E\u043C, \u0432\u044B\u0441\u0442\u0430\u0432\u044C\u0442\u0435 100% \u0438\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0431\u0443\u0434\u0443\u0442 \u043E\u0433\u0440\u043E\u043C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
  RESET_DEFAULT: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  CARD_MODAL_WIDTH_PERCENT: "\u0428\u0438\u0440\u0438\u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  FILENAME_OR_OPEN_FILE: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0432\u043C\u0435\u0441\u0442\u043E '\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435' \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  RANDOMIZE_CARD_ORDER: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u044B\u0439 \u043F\u043E\u0440\u044F\u0434\u043E\u043A \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  DISABLE_CLOZE_CARDS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u044B \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C ==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442== \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C **\u0436\u0438\u0440\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442** \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C {{\u0444\u0438\u0433\u0443\u0440\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438}} \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  INLINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435! \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u0432\u0430\u043C \u043F\u0440\u0438\u0434\u0451\u0442\u0441\u044F \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  NOTES: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u0422\u044D\u0433\u0438 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  TAGS_TO_REVIEW_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0440\u043E\u0431\u0435\u043B\u0430\u043C\u0438 \u0438\u043B\u0438 enter`\u0430\u043C\u0438, \u043F\u0440\u0438\u043C\u0435\u0440: #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  OPEN_RANDOM_NOTE_DESC: "\u0415\u0441\u043B\u0438 \u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C, \u0442\u043E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0432\u0430\u0436\u043D\u043E\u0441\u0442\u0438 (PageRank).",
  AUTO_NEXT_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u044B\u0431\u043E\u0440 \u0441\u043B\u043E\u0436\u043D\u043E\u0441\u0442\u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0432 \u043C\u0435\u043D\u044E \u0444\u0430\u0439\u043B\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E \u0421\u043B\u043E\u0436\u043D\u043E",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u041F\u043E\u0441\u043B\u0435 \u0432\u044B\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0432\u044B \u0441\u043C\u043E\u0436\u0435\u0442\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u043F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u0445\u043E\u0442\u043A\u0435\u0435\u0432. \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 Obsidian \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E.",
  MAX_N_DAYS_REVIEW_QUEUE: "\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u043F\u0440\u0430\u0432\u0430",
  MIN_ONE_DAY: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  VALID_NUMBER_WARNING: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0435\u0435 \u0447\u0438\u0441\u043B\u043E.",
  UI_PREFERENCES: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u0414\u0435\u0440\u0435\u0432\u044C\u044F \u043A\u043E\u043B\u043E\u0434 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0437\u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u0440\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044B\u0435",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u044D\u0442\u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440, \u0447\u0442\u043E\u0431\u044B \u0441\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u043A\u043E\u043B\u043E\u0434\u044B \u043D\u0430 \u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435. \u041F\u043E\u043B\u0435\u0437\u043D\u043E, \u0435\u0441\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044C \u043A\u0430\u0440\u0442\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043F\u0440\u0438\u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0442 \u043C\u043D\u043E\u0433\u0438\u043C \u043A\u043E\u043B\u043E\u0434\u0430\u043C \u0432 \u043E\u0434\u043D\u043E\u043C \u0444\u0430\u0439\u043B\u0435.",
  ALGORITHM: "\u0410\u043B\u0433\u043E\u0440\u0438\u0442\u043C",
  CHECK_ALGORITHM_WIKI: '\u0417\u0430 \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E\u0431\u0440\u0430\u0449\u0430\u0439\u0442\u0435\u0441\u044C \u043A <a href="${algo_url}">\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430</a>(\u0441\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434).',
  BASE_EASE: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C",
  BASE_EASE_DESC: "\u043C\u0438\u043D\u0438\u043C\u0443\u043C = 130, \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043E\u043A\u043E\u043B\u043E 250.",
  BASE_EASE_MIN_WARNING: "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C 130.",
  LAPSE_INTERVAL_CHANGE: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 \u043A\u043E\u0433\u0434\u0430 \u0432\u044B \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442\u0435 \u0421\u043B\u043E\u0436\u043D\u043E \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438/\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
  LAPSE_INTERVAL_CHANGE_DESC: "\u043D\u043E\u0432\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A = \u0441\u0442\u0430\u0440\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A * \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 / 100.",
  EASY_BONUS: "\u041B\u0435\u0433\u043A\u043E: \u0431\u043E\u043D\u0443\u0441",
  EASY_BONUS_DESC: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u043D\u0438\u0446\u0443 \u0432 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043E\u0442\u0432\u0435\u0442\u0430\u043C\u0438 \u0425\u043E\u0440\u043E\u0448\u043E \u0438 \u041B\u0435\u0433\u043A\u043E \u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435/\u0437\u0430\u043C\u0435\u0442\u043A\u0435 (\u043C\u0438\u043D. = 100%).",
  EASY_BONUS_MIN_WARNING: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 100.",
  MAX_INTERVAL: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A(\u043E\u0442\u043A\u043B\u0430\u0434\u044B\u0432\u0430\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438)",
  MAX_INTERVAL_DESC: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u044E\u044E \u0433\u0440\u0430\u043D\u0438\u0446\u0443 \u043D\u0430 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  MAX_LINK_CONTRIB: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0432\u044F\u0437\u0438(\u0441\u0441\u044B\u043B\u043A\u0438)",
  MAX_LINK_CONTRIB_DESC: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0432\u0437\u0432\u0435\u0448\u0435\u043D\u043D\u043E\u0439 \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438 \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u0443\u044E \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C.",
  LOGGING: "\u0412\u0435\u0434\u0435\u043D\u0438\u0435 \u043B\u043E\u0433\u0430",
  DISPLAY_DEBUG_INFO: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E\u0442\u043B\u0430\u0434\u043A\u0438 \u043D\u0430 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430(developer console)?",
  NOTES_REVIEW_QUEUE: "\u041E\u0447\u0435\u0440\u0435\u0434\u044C \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435",
  CLOSE: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
  NEW: "\u041D\u043E\u0432\u044B\u0435",
  YESTERDAY: "\u0412\u0447\u0435\u0440\u0430\u0448\u043D\u0438\u0435",
  TODAY: "\u0421\u0435\u0433\u043E\u0434\u043D\u044F\u0448\u043D\u0438\u0435",
  TOMORROW: "\u0417\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
  STATS_TITLE: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430",
  MONTH: "\u041C\u0435\u0441\u044F\u0446",
  QUARTER: "\u0427\u0435\u0442\u0432\u0435\u0440\u0442\u044C",
  YEAR: "\u0413\u043E\u0434",
  LIFETIME: "\u0412\u0441\u0451 \u0432\u0440\u0435\u043C\u044F",
  FORECAST: "\u041F\u0440\u043E\u0433\u043D\u043E\u0437",
  FORECAST_DESC: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0445 \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C",
  SCHEDULED: "\u0417\u0430\u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
  DAYS: "\u0414\u043D\u0435\u0439",
  NUMBER_OF_CARDS: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  REVIEWS_PER_DAY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0441\u0442\u0432\u043E: ${avg} \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0439/\u0434\u0435\u043D\u044C",
  INTERVALS: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B",
  INTERVALS_DESC: "\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  COUNT: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E",
  INTERVALS_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0438\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${avg}, \u0421\u0430\u043C\u044B\u0439 \u0434\u043B\u0438\u043D\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${longest}",
  EASES: "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C(\u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440 \u0432 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u0432\u043B\u0438\u044F\u0435\u0442 \u043D\u0430 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442 \u0438 \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A) \n (\u043E\u0442 \u0430\u043D\u0433\u043B. ease, \u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430)",
  EASES_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438: ${avgEase}",
  CARD_TYPES: "\u0422\u0438\u043F\u044B \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  CARD_TYPES_DESC: "\u042D\u0442\u043E \u0432\u043A\u043B\u044E\u0447\u0430\u044F \u0441\u043F\u0440\u044F\u0442\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0435\u0441\u043B\u0438 \u0447\u0442\u043E:",
  CARD_TYPE_NEW: "\u041D\u043E\u0432\u044B\u0445",
  CARD_TYPE_YOUNG: "\u041C\u043E\u043B\u043E\u0434\u044B\u0445",
  CARD_TYPE_MATURE: "\u0412\u0437\u0440\u043E\u0441\u043B\u044B\u0445",
  CARD_TYPES_SUMMARY: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A: ${totalCardsCount}"
};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  DECKS: "\u5361\u7EC4",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  BACK: "Back",
  EDIT_LATER: "\u7A0D\u540E\u7F16\u8F91",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F83\u96BE",
  GOOD: "\u8BB0\u5F97",
  EASY: "\u7B80\u5355",
  SHOW_ANSWER: "\u663E\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u5F00\u59CB\u590D\u4E60",
  REVIEW_CARDS: "\u590D\u4E60\u5361\u7247",
  REVIEW_EASY_FILE_MENU: "\u590D\u4E60\uFF1A\u7B80\u5355",
  REVIEW_GOOD_FILE_MENU: "\u590D\u4E60\uFF1A\u8BB0\u5F97",
  REVIEW_HARD_FILE_MENU: "\u590D\u4E60\uFF1A\u8F83\u96BE",
  REVIEW_NOTE_EASY_CMD: "\u6807\u8BB0\u4E3A\u201C\u7B80\u5355\u201D",
  REVIEW_NOTE_GOOD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8BB0\u5F97\u201D",
  REVIEW_NOTE_HARD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8F83\u96BE\u201D",
  REVIEW_CARDS_IN_NOTE: "\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  REVIEW_ALL_CARDS: "\u590D\u4E60\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u67E5\u770B\u6570\u636E",
  STATUS_BAR: "\u590D\u4E60: ${dueNotesCount} \u7B14\u8BB0, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u65F6\u95F4 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B14\u8BB0\u4FDD\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F84\u4E2D\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8BF7\u5C06\u9700\u8981\u590D\u4E60\u7684\u7B14\u8BB0\u4E2D\u52A0\u5165\u6B63\u786E\u7684\u6807\u7B7E\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  RESPONSE_RECEIVED: "\u53CD\u9988\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6CA1\u6709 ${deckName} \u5361\u7EC4",
  ALL_CAUGHT_UP: "\u90FD\u590D\u4E60\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  DAYS_STR_IVL: "${interval} \u5929",
  MONTHS_STR_IVL: "${interval} \u6708",
  YEARS_STR_IVL: "${interval} \u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  SETTINGS_HEADER: "\u95F4\u9694\u91CD\u590D\u63D2\u4EF6 - \u8BBE\u7F6E",
  CHECK_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u6587\u4EF6\u5939",
  FOLDERS_TO_IGNORE_DESC: "\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84\uFF0C\u7528\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1ATemplates Meta/Scripts",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u201C\u7B80\u5355\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_GOOD_LABEL: "\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_HARD_LABEL: "\u201C\u8F83\u96BE\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_EASY_DESC: "\u81EA\u5B9A\u4E49\u201C\u7B80\u5355\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_GOOD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_HARD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8F83\u96BE\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_TAGS: "\u5361\u7247\u6807\u7B7E",
  FLASHCARD_TAGS_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C06\u6587\u4EF6\u5939\u5185\u5BB9\u8F6C\u6362\u4E3A\u5361\u7247\u7EC4\u548C\u5B50\u5361\u7247\u7EC4\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9009\u9879\u4E3A\u5361\u7247\u6807\u7B7E\u9009\u9879\u7684\u66FF\u4EE3\u9009\u9879\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C06\u8BA1\u5212\u91CD\u590D\u65F6\u95F4\u4FDD\u5B58\u5728\u5361\u7247\u6700\u540E\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "HTML\u6CE8\u91CA\u4E0D\u518D\u7834\u574F\u5217\u8868\u683C\u5F0F",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C06\u5173\u8054\u5361\u7247\u9690\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u5173\u8054\u5361\u7247\u662F\u6765\u81EA\u540C\u4E00\u5361\u7247\u7684\u4E0D\u540C\u5F62\u5F0F\uFF0C \u4F8B\u5982\uFF1A\u5B8C\u5F62\u586B\u7A7A\u5361\u7247",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u663E\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6807\u9898 > \u526F\u6807\u9898 > \u5C0F\u6807\u9898 > ... > \u5C0F\u6807\u9898",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u8BF7\u5728\u79FB\u52A8\u7AEF\u4F7F\u7528\u5E76\u9700\u8981\u6D4F\u89C8\u8F83\u5927\u56FE\u7247\u65F6\u8BBE\u4E3A100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BBD\u5EA6\u767E\u5206\u6BD4",
  FILENAME_OR_OPEN_FILE: "\u5728\u590D\u4E60\u5361\u7247\u65F6\u663E\u793A\u6587\u4EF6\u540D\u79F0\u800C\u4E0D\u662F\u201C\u7A0D\u540E\u7F16\u8F91\u201D\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u590D\u4E60\u65F6\u968F\u673A\u663E\u793A\u5361\u7247\uFF1F",
  DISABLE_CLOZE_CARDS: "\u4E0D\u8FDB\u884C\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C06 ==\u9AD8\u4EAE== \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C06 **\u7C97\u4F53** \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C06 {{\u5927\u62EC\u53F7}} \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u5355\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9009\u9879\u540E\u4F60\u5C06\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u7B26\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u5355\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  NOTES: "\u7B14\u8BB0",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u590D\u4E60\u6807\u7B7E",
  TAGS_TO_REVIEW_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u590D\u4E60\u968F\u673A\u7B14\u8BB0",
  OPEN_RANDOM_NOTE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\uFF0C\u7B14\u8BB0\u5C06\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u590D\u4E60\u540E\u81EA\u52A8\u6253\u5F00\u4E0B\u4E00\u4E2A\u7B14\u8BB0",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u5173\u95ED\u6587\u4EF6\u9009\u5355\u4E2D\u7684\u590D\u4E60\u9009\u9879 \u4F8B\u5982\uFF1A\u590D\u4E60\uFF1A\u7B80\u5355 \u8BB0\u5F97 \u8F83\u96BE",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u540E\u4F60\u53EF\u4EE5\u4F7F\u7528\u5FEB\u6377\u952E\u5F00\u59CB\u590D\u4E60\u3002\u91CD\u65B0\u542F\u52A8Obsidian\u4F7F\u672C\u9009\u9879\u751F\u6548\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u8FB9\u680F\u4E2D\u663E\u793A\u7684\u6700\u5927\u5929\u6570",
  MIN_ONE_DAY: "\u5929\u6570\u6700\u5C0F\u503C\u4E3A1",
  VALID_NUMBER_WARNING: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u6570\u5B57\u3002",
  UI_PREFERENCES: "\u7528\u6237\u754C\u9762\u9996\u9009\u9879",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u7532\u677F\u6811\u6700\u521D\u5E94\u663E\u793A\u4E3A\u5C55\u5F00",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u6298\u53E0\u540C\u4E00\u5F20\u5361\u7247\u4E2D\u7684\u5D4C\u5957\u724C\u7EC4\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C5E\u4E8E\u540C\u4E00\u6587\u4EF6\u4E2D\u7684\u8BB8\u591A\u5957\u724C\uFF0C\u5219\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u8350\u503C\u7EA6250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u4E3A130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C06\u590D\u4E60\u65F6\u6807\u6CE8\u4E3A\u201C\u8F83\u96BE\u201D\u7684\u5361\u7247\u6216\u7B14\u8BB0\u590D\u4E60\u95F4\u9694\u7F29\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u590D\u4E60\u95F4\u9694 = \u539F\u590D\u4E60\u95F4\u9694 * \u95F4\u9694\u6539\u53D8\u7CFB\u6570 / 100.",
  EASY_BONUS: "\u7B80\u5355\u5956\u52B1",
  EASY_BONUS_DESC: "\u7B80\u5355\u5956\u52B1\u8BBE\u5B9A\u201C\u8BB0\u5F97\u201D\u548C\u201C\u7B80\u5355\u201D\u5361\u7247\u6216\u7B14\u8BB0\u7684\u590D\u4E60\u95F4\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7B80\u5355\u5956\u52B1\u81F3\u5C11\u4E3A100\u3002",
  MAX_INTERVAL: "\u6700\u5927\u95F4\u9694",
  MAX_INTERVAL_DESC: "\u8BBE\u5B9A\u590D\u4E60\u7684\u6700\u5927\u95F4\u9694\u65F6\u95F4\uFF08\u9ED8\u8BA4\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u95F4\u9694\u81F3\u5C11\u4E3A1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u94FE\u63A5\u6536\u76CA",
  MAX_LINK_CONTRIB_DESC: "\u7531\u539F\u638C\u63E1\u7A0B\u5EA6\u94FE\u63A5\u7684\u7B14\u8BB0\u7ED9\u4E0E\u7684\u6700\u5927\u52A0\u6743\u638C\u63E1\u5EA6\u6536\u76CA\u3002",
  LOGGING: "\u8BB0\u5F55\u4E2D",
  DISPLAY_DEBUG_INFO: "\u5728\u5F00\u53D1\u8005\u63A7\u5236\u53F0\u4E2D\u663E\u793A\u8C03\u8BD5\u4FE1\u606F\uFF1F",
  NOTES_REVIEW_QUEUE: "\u7B14\u8BB0\u590D\u4E60\u5E8F\u5217",
  CLOSE: "\u4E34\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  STATS_TITLE: "\u6570\u636E",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9884\u671F",
  FORECAST_DESC: "\u5C06\u8981\u5230\u671F\u7684\u5361\u7247\u6570\u91CF",
  SCHEDULED: "\u5DF2\u6392\u671F",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6570\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u590D\u4E60${avg} /\u5929",
  INTERVALS: "\u95F4\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u590D\u4E60\u7684\u65F6\u95F4\u95F4\u9694",
  COUNT: "\u8BA1\u6570",
  INTERVALS_SUMMARY: "\u5E73\u5747\u95F4\u9694\u65F6\u95F4: ${avg}, \u6700\u957F\u95F4\u9694\u65F6\u95F4: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  CARD_TYPES: "\u5361\u7247\u7C7B\u578B",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C06\u663E\u793A\u9690\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F83\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u603B\u5361\u7247\u6570: ${totalCardsCount}"
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {
  DECKS: "\u724C\u7D44",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  EDIT_LATER: "\u7A0D\u5F8C\u7DE8\u8F2F",
  BACK: "Back",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F03\u96E3",
  GOOD: "\u8A18\u5F97",
  EASY: "\u7C21\u55AE",
  SHOW_ANSWER: "\u986F\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u6253\u958B\u4E00\u500B\u7B46\u8A18\u958B\u59CB\u5FA9\u7FD2",
  REVIEW_CARDS: "\u5FA9\u7FD2\u5361\u7247",
  REVIEW_EASY_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u7C21\u55AE",
  REVIEW_GOOD_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u8A18\u5F97",
  REVIEW_HARD_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u8F03\u96E3",
  REVIEW_NOTE_EASY_CMD: "\u6A19\u8A18\u70BA\u300C\u7C21\u55AE\u300D",
  REVIEW_NOTE_GOOD_CMD: "\u6A19\u8A18\u70BA\u300C\u8A18\u5F97\u300D",
  REVIEW_NOTE_HARD_CMD: "\u6A19\u8A18\u70BA\u300C\u8F03\u96E3\u300D",
  REVIEW_CARDS_IN_NOTE: "\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  REVIEW_ALL_CARDS: "\u5FA9\u7FD2\u6240\u6709\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u6AA2\u8996\u6578\u64DA",
  STATUS_BAR: "\u5FA9\u7FD2: ${dueNotesCount} \u7B46\u8A18, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u6642\u9593 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B46\u8A18\u5132\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F91\u4E2D\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8ACB\u5C07\u9700\u8981\u5FA9\u7FD2\u7684\u7B46\u8A18\u4E2D\u52A0\u5165\u6B63\u78BA\u7684\u6A19\u7C64\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  RESPONSE_RECEIVED: "\u56DE\u994B\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6C92\u6709 ${deckName} \u724C\u7D44",
  ALL_CAUGHT_UP: "\u90FD\u5FA9\u7FD2\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  DAYS_STR_IVL: "${interval} \u5929",
  MONTHS_STR_IVL: "${interval} \u6708",
  YEARS_STR_IVL: "${interval} \u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  SETTINGS_HEADER: "\u9593\u9694\u91CD\u8907\u5916\u639B - \u8A2D\u5B9A",
  CHECK_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078 <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u8CC7\u6599\u593E",
  FOLDERS_TO_IGNORE_DESC: "\u8F38\u5165\u8CC7\u6599\u593E\u8DEF\u5F91\uFF08\u7528\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1ATemplates Meta/Scripts",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u7C21\u55AE\u6309\u9215\u6587\u5B57",
  FLASHCARD_GOOD_LABEL: "\u8A18\u5F97\u6309\u9215\u6587\u5B57",
  FLASHCARD_HARD_LABEL: "\u8F03\u96E3\u6309\u9215\u6587\u5B57",
  FLASHCARD_EASY_DESC: "\u81EA\u8A02\u300C\u7C21\u55AE\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_GOOD_DESC: "\u81EA\u8A02\u300C\u8A18\u5F97\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_HARD_DESC: "\u81EA\u8A02\u300C\u8F03\u96E3\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_TAGS: "\u5361\u7247\u6A19\u7C64",
  FLASHCARD_TAGS_DESC: "\u8F38\u5165\u6A19\u7C64\uFF08\u7528\u7A7A\u767D\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C07\u8CC7\u6599\u593E\u5167\u5BB9\u8F49\u63DB\u70BA\u724C\u7D44\u548C\u5B50\u724C\u7D44\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9078\u9805\u70BA\u5361\u7247\u6A19\u7C64\u9078\u9805\u7684\u66FF\u4EE3\u9078\u9805\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C07\u8A08\u5283\u91CD\u8907\u6642\u9593\u5132\u5B58\u5728\u5361\u7247\u6700\u5F8C\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u52FE\u9078\u5F8CHTML\u8A3B\u89E3\u4E0D\u6703\u7834\u58DE\u5217\u8868\u683C\u5F0F\u554F\u984C\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C07\u53CD\u8F49\u5361\u7247\u96B1\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u53CD\u8F49\u5361\u7247\u7531\u540C\u4E00\u5361\u7247\u6587\u5B57\u7522\u751F\uFF0C\u4F8B\u5982\uFF1A\u586B\u7A7A\u514B\u6F0F\u5B57",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u986F\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6A19\u984C > \u526F\u6A19\u984C > \u5C0F\u6A19\u984C > ... > \u5C0F\u6A19\u984C",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u5728\u79FB\u52D5\u7AEF\u6216\u9700\u8981\u8F03\u5927\u5716\u7247\u6642\u61C9\u8A2D\u5B9A\u70BA100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u70BA\u9810\u8A2D\u503C",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BEC\u5EA6\u767E\u5206\u6BD4",
  FILENAME_OR_OPEN_FILE: "\u5728\u5FA9\u7FD2\u5361\u7247\u6642\u986F\u793A\u6A94\u540D\u800C\u4E0D\u662F\u300C\u7A0D\u5F8C\u7DE8\u8F2F\u300D\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u5FA9\u7FD2\u6642\u96A8\u6A5F\u986F\u793A\u5361\u7247\uFF1F",
  DISABLE_CLOZE_CARDS: "\u505C\u7528\u586B\u7A7A\u514B\u6F0F\u5B57\u5361\u7247\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C07 ==\u9AD8\u4EAE== \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C07 **\u7C97\u9AD4** \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C07 {{\u5927\u62EC\u865F}} \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u55AE\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9078\u9805\u5F8C\u4F60\u5C07\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u5B57\u5143\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u55AE\u884C\u53CD\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  NOTES: "\u7B46\u8A18",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u5FA9\u7FD2\u6A19\u7C64",
  TAGS_TO_REVIEW_DESC: "\u8F38\u5165\u6A19\u7C64\uFF0C\u7528\u7A7A\u683C\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u5FA9\u7FD2\u96A8\u6A5F\u7B46\u8A18",
  OPEN_RANDOM_NOTE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\uFF0C\u7B46\u8A18\u5C07\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u5FA9\u7FD2\u5F8C\u81EA\u52D5\u6253\u958B\u4E0B\u4E00\u500B\u7B46\u8A18",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u95DC\u9589\u6A94\u6848\u9078\u55AE\u4E2D\u7684\u5FA9\u7FD2\u9078\u9805 \u4F8B\u5982\uFF1A\u5FA9\u7FD2\uFF1A\u7C21\u55AE \u8A18\u5F97 \u8F03\u96E3",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u95DC\u9589\u6A94\u6848\u9078\u55AE\u7684\u5FA9\u7FD2\u9078\u9805\uFF0C\u4F8B\u5982\uFF1A\u5FA9\u7FD2: \u7C21\u55AE \u8A18\u5F97 \u8F03\u96E3\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u908A\u9762\u677F\u986F\u793A\u7684\u6700\u5927\u5929\u6578",
  MIN_ONE_DAY: "\u5929\u6578\u6700\u5C0F\u503C\u70BA1",
  VALID_NUMBER_WARNING: "\u8ACB\u8F38\u5165\u6709\u6548\u7684\u6578\u5B57\u3002",
  UI_PREFERENCES: "\u7528\u6236\u4ECB\u9762\u9996\u9078\u9805",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u724C\u7D44\u6A39\u6700\u521D\u61C9\u986F\u793A\u70BA\u5C55\u958B",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\u53EF\u647A\u758A\u540C\u4E00\u5F35\u5361\u7247\u4E2D\u7684\u5DE2\u72C0\u724C\u7D44\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C6C\u65BC\u540C\u4E00\u6A94\u6848\u4E2D\u7684\u8A31\u591A\u5957\u724C\uFF0C\u5247\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u6F14\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078 <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u85A6\u503C\u7D04250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u70BA130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C07\u5FA9\u7FD2\u6642\u6A19\u8A3B\u70BA\u300C\u8F03\u96E3\u300D\u7684\u5361\u7247\u6216\u7B46\u8A18\u5FA9\u7FD2\u9593\u9694\u7E2E\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u5FA9\u7FD2\u9593\u9694 = \u539F\u5FA9\u7FD2\u9593\u9694 * \u9593\u9694\u6539\u8B8A\u4FC2\u6578 / 100.",
  EASY_BONUS: "\u7C21\u55AE\u734E\u52F5",
  EASY_BONUS_DESC: "\u7C21\u55AE\u734E\u52F5\u8A2D\u5B9A\u300C\u8A18\u5F97\u300D\u548C\u300C\u7C21\u55AE\u300D\u5361\u7247\u6216\u7B46\u8A18\u7684\u5FA9\u7FD2\u9593\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7C21\u55AE\u734E\u52F5\u81F3\u5C11\u70BA100\u3002",
  MAX_INTERVAL: "\u6700\u5927\u9593\u9694",
  MAX_INTERVAL_DESC: "\u8A2D\u5B9A\u5FA9\u7FD2\u7684\u6700\u5927\u9593\u9694\u6642\u9593\uFF08\u9810\u8A2D\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u9593\u9694\u81F3\u5C11\u70BA1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u93C8\u63A5\u8CA2\u737B",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "\u8A18\u9304\u4E2D",
  DISPLAY_DEBUG_INFO: "\u5728\u958B\u767C\u8005\u63A7\u5236\u53F0\u4E2D\u986F\u793A\u9664\u932F\u8CC7\u8A0A\uFF1F",
  NOTES_REVIEW_QUEUE: "\u7B46\u8A18\u5FA9\u7FD2\u5E8F\u5217",
  CLOSE: "\u81E8\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9810\u6E2C",
  FORECAST_DESC: "\u5C07\u8981\u5230\u671F\u7684\u5361\u7247\u6578\u91CF",
  SCHEDULED: "\u5DF2\u6392\u7A0B",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6578\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u5FA9\u7FD2${avg} /\u5929",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u5FA9\u7FD2\u7684\u6642\u9593\u9593\u9694",
  COUNT: "\u8A08\u6578",
  INTERVALS_SUMMARY: "\u5E73\u5747\u9593\u9694\u6642\u9593: ${avg}, \u6700\u9577\u9593\u9694\u6642\u9593: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  CARD_TYPES: "\u5361\u7247\u578B\u5225",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C07\u986F\u793A\u96B1\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F03\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u7E3D\u5361\u7247\u6578: ${totalCardsCount}"
};

// src/lang/helpers.ts
var localeMap = {
  ar: ar_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  tr: tr_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function interpolate(str, params) {
  const names2 = Object.keys(params);
  const vals = Object.values(params);
  return new Function(...names2, `return \`${str}\`;`)(...vals);
}
function t(str, params) {
  if (!locale) {
    console.error(`SRS error: Locale ${import_obsidian.moment.locale()} not found.`);
  }
  const result = locale && locale[str] || en_default[str];
  if (params) {
    return interpolate(result, params);
  }
  return result;
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  flashcardEasyText: t("EASY"),
  flashcardGoodText: t("GOOD"),
  flashcardHardText: t("HARD"),
  flashcardTags: ["#flashcards"],
  convertFoldersToDecks: false,
  cardCommentOnSameLine: false,
  burySiblingCards: false,
  showContextInCards: true,
  flashcardHeightPercentage: import_obsidian2.Platform.isMobile ? 100 : 80,
  flashcardWidthPercentage: import_obsidian2.Platform.isMobile ? 100 : 40,
  showFileNameInFileLink: false,
  randomizeCardOrder: true,
  convertHighlightsToClozes: true,
  convertBoldTextToClozes: false,
  convertCurlyBracketsToClozes: false,
  singleLineCardSeparator: "::",
  singleLineReversedCardSeparator: ":::",
  multilineCardSeparator: "?",
  multilineReversedCardSeparator: "??",
  enableNoteReviewPaneOnStartup: true,
  tagsToReview: ["#review"],
  noteFoldersToIgnore: [],
  openRandomNote: false,
  autoNextNote: false,
  disableFileMenuReviewOptions: false,
  maxNDaysNotesReviewQueue: 365,
  initiallyExpandAllSubdecksInTree: false,
  baseEase: 250,
  lapsesIntervalChange: 0.5,
  easyBonus: 1.3,
  maximumInterval: 36525,
  maxLinkFactor: 1,
  showDebugMessages: false
};
var applyDebounceTimer = 0;
function applySettingsUpdate(callback2) {
  clearTimeout(applyDebounceTimer);
  applyDebounceTimer = window.setTimeout(callback2, 512);
}
var SRSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: `${t("SETTINGS_HEADER")}` });
    containerEl.createDiv().innerHTML = t("CHECK_WIKI", {
      wiki_url: "https://github.com/st3v3nmw/obsidian-spaced-repetition/wiki"
    });
    new import_obsidian2.Setting(containerEl).setName(t("FOLDERS_TO_IGNORE")).setDesc(t("FOLDERS_TO_IGNORE_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.noteFoldersToIgnore.join("\n")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.noteFoldersToIgnore = value.split(/\n+/).map((v) => v.trim()).filter((v) => v);
          await this.plugin.savePluginData();
        });
      })
    );
    containerEl.createEl("h3", { text: `${t("FLASHCARDS")}` });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_TAGS")).setDesc(t("FLASHCARD_TAGS_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.flashcardTags.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardTags = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_FOLDERS_TO_DECKS")).setDesc(t("CONVERT_FOLDERS_TO_DECKS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertFoldersToDecks).onChange(async (value) => {
        this.plugin.data.settings.convertFoldersToDecks = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_SCHEDULING_COMMENTS")).setDesc(t("INLINE_SCHEDULING_COMMENTS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.cardCommentOnSameLine).onChange(async (value) => {
        this.plugin.data.settings.cardCommentOnSameLine = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("BURY_SIBLINGS_TILL_NEXT_DAY")).setDesc(t("BURY_SIBLINGS_TILL_NEXT_DAY_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.burySiblingCards).onChange(async (value) => {
        this.plugin.data.settings.burySiblingCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("SHOW_CARD_CONTEXT")).setDesc(t("SHOW_CARD_CONTEXT_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showContextInCards).onChange(async (value) => {
        this.plugin.data.settings.showContextInCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_HEIGHT_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardHeightPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardHeightPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHeightPercentage = DEFAULT_SETTINGS.flashcardHeightPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_WIDTH_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardWidthPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardWidthPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardWidthPercentage = DEFAULT_SETTINGS.flashcardWidthPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FILENAME_OR_OPEN_FILE")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showFileNameInFileLink).onChange(async (value) => {
        this.plugin.data.settings.showFileNameInFileLink = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("RANDOMIZE_CARD_ORDER")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.randomizeCardOrder).onChange(async (value) => {
        this.plugin.data.settings.randomizeCardOrder = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_HIGHLIGHTS_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertHighlightsToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertHighlightsToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_BOLD_TEXT_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertBoldTextToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertBoldTextToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_CURLY_BRACKETS_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertCurlyBracketsToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertCurlyBracketsToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineCardSeparator = DEFAULT_SETTINGS.singleLineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineReversedCardSeparator = DEFAULT_SETTINGS.singleLineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineCardSeparator = DEFAULT_SETTINGS.multilineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineReversedCardSeparator = DEFAULT_SETTINGS.multilineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_EASY_LABEL")).setDesc(t("FLASHCARD_EASY_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardEasyText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardEasyText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardEasyText = DEFAULT_SETTINGS.flashcardEasyText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_GOOD_LABEL")).setDesc(t("FLASHCARD_GOOD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardGoodText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardGoodText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardGoodText = DEFAULT_SETTINGS.flashcardGoodText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_HARD_LABEL")).setDesc(t("FLASHCARD_HARD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardHardText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardHardText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHardText = DEFAULT_SETTINGS.flashcardHardText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("NOTES")}` });
    new import_obsidian2.Setting(containerEl).setName(t("REVIEW_PANE_ON_STARTUP")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.enableNoteReviewPaneOnStartup).onChange(async (value) => {
        this.plugin.data.settings.enableNoteReviewPaneOnStartup = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("TAGS_TO_REVIEW")).setDesc(t("TAGS_TO_REVIEW_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.tagsToReview.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.tagsToReview = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("OPEN_RANDOM_NOTE")).setDesc(t("OPEN_RANDOM_NOTE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.openRandomNote).onChange(async (value) => {
        this.plugin.data.settings.openRandomNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("AUTO_NEXT_NOTE")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.autoNextNote).onChange(async (value) => {
        this.plugin.data.settings.autoNextNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("DISABLE_FILE_MENU_REVIEW_OPTIONS")).setDesc(t("DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.disableFileMenuReviewOptions).onChange(async (value) => {
        this.plugin.data.settings.disableFileMenuReviewOptions = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("MAX_N_DAYS_REVIEW_QUEUE")).addText(
      (text) => text.setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("MIN_ONE_DAY"));
              text.setValue(
                this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()
              );
              return;
            }
            this.plugin.data.settings.maxNDaysNotesReviewQueue = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxNDaysNotesReviewQueue = DEFAULT_SETTINGS.maxNDaysNotesReviewQueue;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("UI_PREFERENCES")}` });
    new import_obsidian2.Setting(containerEl).setName(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE")).setDesc(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.initiallyExpandAllSubdecksInTree).onChange(async (value) => {
        this.plugin.data.settings.initiallyExpandAllSubdecksInTree = value;
        await this.plugin.savePluginData();
      })
    );
    containerEl.createEl("h3", { text: `${t("ALGORITHM")}` });
    containerEl.createDiv().innerHTML = t("CHECK_ALGORITHM_WIKI", {
      algo_url: "https://github.com/st3v3nmw/obsidian-spaced-repetition/wiki/Spaced-Repetition-Algorithm"
    });
    new import_obsidian2.Setting(containerEl).setName(t("BASE_EASE")).setDesc(t("BASE_EASE_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.baseEase.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 130) {
              new import_obsidian2.Notice(t("BASE_EASE_MIN_WARNING"));
              text.setValue(this.plugin.data.settings.baseEase.toString());
              return;
            }
            this.plugin.data.settings.baseEase = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.baseEase = DEFAULT_SETTINGS.baseEase;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("LAPSE_INTERVAL_CHANGE")).setDesc(t("LAPSE_INTERVAL_CHANGE_DESC")).addSlider(
      (slider) => slider.setLimits(1, 99, 1).setValue(this.plugin.data.settings.lapsesIntervalChange * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.lapsesIntervalChange = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.lapsesIntervalChange = DEFAULT_SETTINGS.lapsesIntervalChange;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("EASY_BONUS")).setDesc(t("EASY_BONUS_DESC")).addText(
      (text) => text.setValue((this.plugin.data.settings.easyBonus * 100).toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value) / 100;
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("EASY_BONUS_MIN_WARNING"));
              text.setValue(
                (this.plugin.data.settings.easyBonus * 100).toString()
              );
              return;
            }
            this.plugin.data.settings.easyBonus = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.easyBonus = DEFAULT_SETTINGS.easyBonus;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_INTERVAL")).setDesc(t("MAX_INTERVAL_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.maximumInterval.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("MAX_INTERVAL_MIN_WARNING"));
              text.setValue(
                this.plugin.data.settings.maximumInterval.toString()
              );
              return;
            }
            this.plugin.data.settings.maximumInterval = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maximumInterval = DEFAULT_SETTINGS.maximumInterval;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_LINK_CONTRIB")).setDesc(t("MAX_LINK_CONTRIB_DESC")).addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.data.settings.maxLinkFactor * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.maxLinkFactor = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxLinkFactor = DEFAULT_SETTINGS.maxLinkFactor;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("LOGGING")}` });
    new import_obsidian2.Setting(containerEl).setName(t("DISPLAY_DEBUG_INFO")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showDebugMessages).onChange(async (value) => {
        this.plugin.data.settings.showDebugMessages = value;
        await this.plugin.savePluginData();
      })
    );
  }
};

// src/flashcard-modal.tsx
var import_obsidian3 = require("obsidian");
var import_vhtml = __toESM(require_vhtml());

// src/scheduling.ts
function schedule(response, interval, ease, delayBeforeReview, settingsObj, dueDates) {
  delayBeforeReview = Math.max(0, Math.floor(delayBeforeReview / (24 * 3600 * 1e3)));
  if (response === 0 /* Easy */) {
    ease += 20;
    interval = (interval + delayBeforeReview) * ease / 100;
    interval *= settingsObj.easyBonus;
  } else if (response === 1 /* Good */) {
    interval = (interval + delayBeforeReview / 2) * ease / 100;
  } else if (response === 2 /* Hard */) {
    ease = Math.max(130, ease - 20);
    interval = Math.max(
      1,
      (interval + delayBeforeReview / 4) * settingsObj.lapsesIntervalChange
    );
  }
  if (dueDates !== void 0) {
    interval = Math.round(interval);
    if (!Object.prototype.hasOwnProperty.call(dueDates, interval)) {
      dueDates[interval] = 0;
    } else {
      if (interval > 4) {
        let fuzz = 0;
        if (interval < 7)
          fuzz = 1;
        else if (interval < 30)
          fuzz = Math.max(2, Math.floor(interval * 0.15));
        else
          fuzz = Math.max(4, Math.floor(interval * 0.05));
        const originalInterval = interval;
        outer:
          for (let i = 1; i <= fuzz; i++) {
            for (const ivl of [originalInterval - i, originalInterval + i]) {
              if (!Object.prototype.hasOwnProperty.call(dueDates, ivl)) {
                dueDates[ivl] = 0;
                interval = ivl;
                break outer;
              }
              if (dueDates[ivl] < dueDates[interval])
                interval = ivl;
            }
          }
      }
    }
    dueDates[interval]++;
  }
  interval = Math.min(interval, settingsObj.maximumInterval);
  return { interval: Math.round(interval * 10) / 10, ease };
}
function textInterval(interval, isMobile) {
  const m = Math.round(interval / 3.04375) / 10, y = Math.round(interval / 36.525) / 10;
  if (isMobile) {
    if (m < 1)
      return t("DAYS_STR_IVL_MOBILE", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL_MOBILE", { interval: m });
    else
      return t("YEARS_STR_IVL_MOBILE", { interval: y });
  } else {
    if (m < 1)
      return t("DAYS_STR_IVL", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL", { interval: m });
    else
      return t("YEARS_STR_IVL", { interval: y });
  }
}

// src/constants.ts
var SCHEDULING_INFO_REGEX = /^---\n((?:.*\n)*)sr-due: (.+)\nsr-interval: (\d+)\nsr-ease: (\d+)\n((?:.*\n)*)---/;
var YAML_FRONT_MATTER_REGEX = /^---\n((?:.*\n)*?)---/;
var MULTI_SCHEDULING_EXTRACTOR = /!([\d-]+),(\d+),(\d+)/gm;
var LEGACY_SCHEDULING_EXTRACTOR = /<!--SR:([\d-]+),(\d+),(\d+)-->/gm;
var IMAGE_FORMATS = ["jpg", "jpeg", "gif", "png", "svg"];
var AUDIO_FORMATS = ["mp3", "webm", "m4a", "wav", "ogg"];
var VIDEO_FORMATS = ["mp4", "mkv", "avi", "mov"];
var COLLAPSE_ICON = '<svg viewBox="0 0 100 100" width="8" height="8" class="right-triangle"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>';

// src/utils.ts
function getTypedObjectEntries(obj) {
  return Object.entries(obj);
}
var getKeysPreserveType = Object.keys;
var escapeRegexString = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
function cyrb53(str, seed = 0) {
  let h12 = 3735928559 ^ seed, h22 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h22 = Math.imul(h22 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h22 ^ h22 >>> 13, 3266489909);
  h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h22) + (h12 >>> 0)).toString(16);
}

// src/flashcard-modal.tsx
var FlashcardModal = class extends import_obsidian3.Modal {
  constructor(app2, plugin, ignoreStats = false) {
    super(app2);
    this.plugin = plugin;
    this.ignoreStats = ignoreStats;
    this.titleEl.setText(t("DECKS"));
    this.titleEl.addClass("sr-centered");
    if (import_obsidian3.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
    this.modalEl.style.height = this.plugin.data.settings.flashcardHeightPercentage + "%";
    this.modalEl.style.width = this.plugin.data.settings.flashcardWidthPercentage + "%";
    this.contentEl.style.position = "relative";
    this.contentEl.style.height = "92%";
    this.contentEl.addClass("sr-modal-content");
    document.body.onkeydown = (e) => {
      if (this.mode !== 0 /* DecksList */) {
        if (this.mode !== 3 /* Closed */ && e.code === "KeyS") {
          this.currentDeck.deleteFlashcardAtIndex(
            this.currentCardIdx,
            this.currentCard.isDue
          );
          this.burySiblingCards(false);
          this.currentDeck.nextCard(this);
        } else if (this.mode === 1 /* Front */ && (e.code === "Space" || e.code === "Enter")) {
          this.showAnswer();
        } else if (this.mode === 2 /* Back */) {
          if (e.code === "Numpad1" || e.code === "Digit1") {
            this.processReview(2 /* Hard */);
          } else if (e.code === "Numpad2" || e.code === "Digit2" || e.code === "Space") {
            this.processReview(1 /* Good */);
          } else if (e.code === "Numpad3" || e.code === "Digit3") {
            this.processReview(0 /* Easy */);
          } else if (e.code === "Numpad0" || e.code === "Digit0") {
            this.processReview(3 /* Reset */);
          }
        }
      }
    };
  }
  onOpen() {
    this.decksList();
  }
  onClose() {
    this.mode = 3 /* Closed */;
  }
  decksList() {
    const aimDeck = this.plugin.deckTree.subdecks.filter(
      (deck) => deck.deckName === this.plugin.data.historyDeck
    );
    if (this.plugin.data.historyDeck && aimDeck.length > 0) {
      const deck = aimDeck[0];
      this.currentDeck = deck;
      this.checkDeck = deck.parent;
      this.setupCardsView();
      deck.nextCard(this);
      return;
    }
    this.mode = 0 /* DecksList */;
    this.titleEl.setText(t("DECKS"));
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("p", { style: "margin:0px;line-height:12px;" }, /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#4caf50;color:#ffffff;",
        "aria-label": t("DUE_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.dueFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#2196f3;",
        "aria-label": t("NEW_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.newFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#ff7043;",
        "aria-label": t("TOTAL_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.totalFlashcards.toString()
    ));
    this.contentEl.innerHTML = "";
    this.contentEl.setAttribute("id", "sr-flashcard-view");
    for (const deck of this.plugin.deckTree.subdecks) {
      deck.render(this.contentEl, this);
    }
  }
  setupCardsView() {
    this.contentEl.innerHTML = "";
    const historyLinkView = this.contentEl.createEl("button");
    historyLinkView.addClass("sr-back-btn");
    historyLinkView.setAttribute("aria-label", t("BACK"));
    historyLinkView.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewbox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        class: "svg-icon lucide-arrow-left"
      },
      /* @__PURE__ */ (0, import_vhtml.default)("line", { x1: "19", y1: "12", x2: "5", y2: "12" }),
      /* @__PURE__ */ (0, import_vhtml.default)("polyline", { points: "12 19 5 12 12 5" })
    );
    historyLinkView.addEventListener("click", (e) => {
      if (e.pointerType.length > 0) {
        this.plugin.data.historyDeck = "";
        this.decksList();
      }
    });
    this.fileLinkView = this.contentEl.createDiv("sr-link");
    this.fileLinkView.setText(t("EDIT_LATER"));
    if (this.plugin.data.settings.showFileNameInFileLink) {
      this.fileLinkView.setAttribute("aria-label", t("EDIT_LATER"));
    }
    this.fileLinkView.addEventListener("click", async () => {
      const activeLeaf = this.plugin.app.workspace.getLeaf();
      if (this.plugin.app.workspace.getActiveFile() === null)
        await activeLeaf.openFile(this.currentCard.note);
      else {
        const newLeaf = this.plugin.app.workspace.createLeafBySplit(
          activeLeaf,
          "vertical",
          false
        );
        await newLeaf.openFile(this.currentCard.note, { active: true });
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      activeView.editor.setCursor({
        line: this.currentCard.lineNo,
        ch: 0
      });
      this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
      this.burySiblingCards(false);
      this.currentDeck.nextCard(this);
    });
    this.resetLinkView = this.contentEl.createDiv("sr-link");
    this.resetLinkView.setText(t("RESET_CARD_PROGRESS"));
    this.resetLinkView.addEventListener("click", () => {
      this.processReview(3 /* Reset */);
    });
    this.resetLinkView.style.float = "right";
    if (this.plugin.data.settings.showContextInCards) {
      this.contextView = this.contentEl.createDiv();
      this.contextView.setAttribute("id", "sr-context");
    }
    this.flashcardView = this.contentEl.createDiv("div");
    this.flashcardView.setAttribute("id", "sr-flashcard-view");
    this.responseDiv = this.contentEl.createDiv("sr-response");
    this.hardBtn = document.createElement("button");
    this.hardBtn.setAttribute("id", "sr-hard-btn");
    this.hardBtn.setText(this.plugin.data.settings.flashcardHardText);
    this.hardBtn.addEventListener("click", () => {
      this.processReview(2 /* Hard */);
    });
    this.responseDiv.appendChild(this.hardBtn);
    this.goodBtn = document.createElement("button");
    this.goodBtn.setAttribute("id", "sr-good-btn");
    this.goodBtn.setText(this.plugin.data.settings.flashcardGoodText);
    this.goodBtn.addEventListener("click", () => {
      this.processReview(1 /* Good */);
    });
    this.responseDiv.appendChild(this.goodBtn);
    this.easyBtn = document.createElement("button");
    this.easyBtn.setAttribute("id", "sr-easy-btn");
    this.easyBtn.setText(this.plugin.data.settings.flashcardEasyText);
    this.easyBtn.addEventListener("click", () => {
      this.processReview(0 /* Easy */);
    });
    this.responseDiv.appendChild(this.easyBtn);
    this.responseDiv.style.display = "none";
    this.answerBtn = this.contentEl.createDiv();
    this.answerBtn.setAttribute("id", "sr-show-answer");
    this.answerBtn.setText(t("SHOW_ANSWER"));
    this.answerBtn.addEventListener("click", () => {
      this.showAnswer();
    });
    if (this.ignoreStats) {
      this.goodBtn.style.display = "none";
      this.responseDiv.addClass("sr-ignorestats-response");
      this.easyBtn.addClass("sr-ignorestats-btn");
      this.hardBtn.addClass("sr-ignorestats-btn");
    }
  }
  showAnswer() {
    this.mode = 2 /* Back */;
    this.answerBtn.style.display = "none";
    this.responseDiv.style.display = "grid";
    if (this.currentCard.isDue) {
      this.resetLinkView.style.display = "inline-block";
    }
    if (this.currentCard.cardType !== 4 /* Cloze */) {
      const hr = document.createElement("hr");
      hr.setAttribute("id", "sr-hr-card-divide");
      this.flashcardView.appendChild(hr);
    } else {
      this.flashcardView.innerHTML = "";
    }
    this.renderMarkdownWrapper(this.currentCard.back, this.flashcardView);
  }
  async processReview(response) {
    if (this.ignoreStats) {
      if (response == 0 /* Easy */) {
        this.currentDeck.deleteFlashcardAtIndex(
          this.currentCardIdx,
          this.currentCard.isDue
        );
      }
      this.currentDeck.nextCard(this);
      return;
    }
    let interval, ease, due;
    this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
    if (response !== 3 /* Reset */) {
      let schedObj;
      if (this.currentCard.isDue) {
        schedObj = schedule(
          response,
          this.currentCard.interval,
          this.currentCard.ease,
          this.currentCard.delayBeforeReview,
          this.plugin.data.settings,
          this.plugin.dueDatesFlashcards
        );
      } else {
        let initial_ease = this.plugin.data.settings.baseEase;
        if (Object.prototype.hasOwnProperty.call(
          this.plugin.easeByPath,
          this.currentCard.note.path
        )) {
          initial_ease = Math.round(this.plugin.easeByPath[this.currentCard.note.path]);
        }
        schedObj = schedule(
          response,
          1,
          initial_ease,
          0,
          this.plugin.data.settings,
          this.plugin.dueDatesFlashcards
        );
        interval = schedObj.interval;
        ease = schedObj.ease;
      }
      interval = schedObj.interval;
      ease = schedObj.ease;
      due = window.moment(Date.now() + interval * 24 * 3600 * 1e3);
    } else {
      this.currentCard.interval = 1;
      this.currentCard.ease = this.plugin.data.settings.baseEase;
      if (this.currentCard.isDue) {
        this.currentDeck.dueFlashcards.push(this.currentCard);
      } else {
        this.currentDeck.newFlashcards.push(this.currentCard);
      }
      due = window.moment(Date.now());
      new import_obsidian3.Notice(t("CARD_PROGRESS_RESET"));
      this.currentDeck.nextCard(this);
      return;
    }
    const dueString = due.format("YYYY-MM-DD");
    let fileText = await this.app.vault.read(this.currentCard.note);
    const replacementRegex = new RegExp(escapeRegexString(this.currentCard.cardText), "gm");
    let sep = this.plugin.data.settings.cardCommentOnSameLine ? " " : "\n";
    if (this.currentCard.cardText.endsWith("```") && sep !== "\n") {
      sep = "\n";
    }
    if (this.currentCard.cardText.lastIndexOf("<!--SR:") === -1) {
      this.currentCard.cardText = this.currentCard.cardText + sep + `<!--SR:!${dueString},${interval},${ease}-->`;
    } else {
      let scheduling = [
        ...this.currentCard.cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)
      ];
      if (scheduling.length === 0) {
        scheduling = [...this.currentCard.cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
      }
      const currCardSched = ["0", dueString, interval.toString(), ease.toString()];
      if (this.currentCard.isDue) {
        scheduling[this.currentCard.siblingIdx] = currCardSched;
      } else {
        scheduling.push(currCardSched);
      }
      this.currentCard.cardText = this.currentCard.cardText.replace(/<!--SR:.+-->/gm, "");
      this.currentCard.cardText += "<!--SR:";
      for (let i = 0; i < scheduling.length; i++) {
        this.currentCard.cardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
      }
      this.currentCard.cardText += "-->";
    }
    fileText = fileText.replace(replacementRegex, () => this.currentCard.cardText);
    for (const sibling of this.currentCard.siblings) {
      sibling.cardText = this.currentCard.cardText;
    }
    if (this.plugin.data.settings.burySiblingCards) {
      this.burySiblingCards(true);
    }
    await this.app.vault.modify(this.currentCard.note, fileText);
    this.currentDeck.nextCard(this);
  }
  async burySiblingCards(tillNextDay) {
    if (tillNextDay) {
      this.plugin.data.buryList.push(cyrb53(this.currentCard.cardText));
      await this.plugin.savePluginData();
    }
    for (const sibling of this.currentCard.siblings) {
      const dueIdx = this.currentDeck.dueFlashcards.indexOf(sibling);
      const newIdx = this.currentDeck.newFlashcards.indexOf(sibling);
      if (dueIdx !== -1) {
        this.currentDeck.deleteFlashcardAtIndex(
          dueIdx,
          this.currentDeck.dueFlashcards[dueIdx].isDue
        );
      } else if (newIdx !== -1) {
        this.currentDeck.deleteFlashcardAtIndex(
          newIdx,
          this.currentDeck.newFlashcards[newIdx].isDue
        );
      }
    }
  }
  async renderMarkdownWrapper(markdownString, containerEl, recursiveDepth = 0) {
    if (recursiveDepth > 4)
      return;
    import_obsidian3.MarkdownRenderer.renderMarkdown(
      markdownString,
      containerEl,
      this.currentCard.note.path,
      this.plugin
    );
    containerEl.findAll(".internal-embed").forEach((el) => {
      const link2 = this.parseLink(el.getAttribute("src"));
      if (!link2.target) {
        el.innerText = link2.text;
      } else if (link2.target instanceof import_obsidian3.TFile) {
        if (link2.target.extension !== "md") {
          this.embedMediaFile(el, link2.target);
        } else {
          el.innerText = "";
          this.renderTransclude(el, link2, recursiveDepth);
        }
      }
    });
  }
  parseLink(src) {
    const linkComponentsRegex = /^(?<file>[^#^]+)?(?:#(?!\^)(?<heading>.+)|#\^(?<blockId>.+)|#)?$/;
    const matched = typeof src === "string" && src.match(linkComponentsRegex);
    const file = matched.groups.file || this.currentCard.note.path;
    const target = this.plugin.app.metadataCache.getFirstLinkpathDest(
      file,
      this.currentCard.note.path
    );
    return {
      text: matched[0],
      file: matched.groups.file,
      heading: matched.groups.heading,
      blockId: matched.groups.blockId,
      target
    };
  }
  embedMediaFile(el, target) {
    el.innerText = "";
    if (IMAGE_FORMATS.includes(target.extension)) {
      el.createEl(
        "img",
        {
          attr: {
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (img) => {
          if (el.hasAttribute("width"))
            img.setAttribute("width", el.getAttribute("width"));
          else
            img.setAttribute("width", "100%");
          if (el.hasAttribute("alt"))
            img.setAttribute("alt", el.getAttribute("alt"));
          el.addEventListener(
            "click",
            (ev) => ev.target.style.minWidth = ev.target.style.minWidth === "100%" ? null : "100%"
          );
        }
      );
      el.addClasses(["image-embed", "is-loaded"]);
    } else if (AUDIO_FORMATS.includes(target.extension) || VIDEO_FORMATS.includes(target.extension)) {
      el.createEl(
        AUDIO_FORMATS.includes(target.extension) ? "audio" : "video",
        {
          attr: {
            controls: "",
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (audio) => {
          if (el.hasAttribute("alt"))
            audio.setAttribute("alt", el.getAttribute("alt"));
        }
      );
      el.addClasses(["media-embed", "is-loaded"]);
    } else {
      el.innerText = target.path;
    }
  }
  async renderTransclude(el, link2, recursiveDepth) {
    var _a, _b, _c, _d;
    const cache = this.app.metadataCache.getCache(link2.target.path);
    const text = await this.app.vault.cachedRead(link2.target);
    let blockText;
    if (link2.heading) {
      const clean = (s) => s.replace(/[\W\s]/g, "");
      const headingIndex = (_a = cache.headings) == null ? void 0 : _a.findIndex(
        (h4) => clean(h4.heading) === clean(link2.heading)
      );
      const heading = cache.headings[headingIndex];
      const startAt = heading.position.start.offset;
      const endAt = ((_d = (_c = (_b = cache.headings.slice(headingIndex + 1).find((h4) => h4.level <= heading.level)) == null ? void 0 : _b.position) == null ? void 0 : _c.start) == null ? void 0 : _d.offset) || text.length;
      blockText = text.substring(startAt, endAt);
    } else if (link2.blockId) {
      const block = cache.blocks[link2.blockId];
      const startAt = block.position.start.offset;
      const endAt = block.position.end.offset;
      blockText = text.substring(startAt, endAt);
    } else {
      blockText = text;
    }
    this.renderMarkdownWrapper(blockText, el, recursiveDepth + 1);
  }
};
var Deck = class {
  constructor(deckName, parent) {
    this.newFlashcardsCount = 0;
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.deckName = deckName;
    this.newFlashcards = [];
    this.newFlashcardsCount = 0;
    this.dueFlashcards = [];
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.subdecks = [];
    this.parent = parent;
  }
  createDeck(deckPath) {
    if (deckPath.length === 0) {
      return;
    }
    const deckName = deckPath.shift();
    for (const deck2 of this.subdecks) {
      if (deckName === deck2.deckName) {
        deck2.createDeck(deckPath);
        return;
      }
    }
    const deck = new Deck(deckName, this);
    this.subdecks.push(deck);
    deck.createDeck(deckPath);
  }
  insertFlashcard(deckPath, cardObj) {
    if (cardObj.isDue) {
      this.dueFlashcardsCount++;
    } else {
      this.newFlashcardsCount++;
    }
    this.totalFlashcards++;
    if (deckPath.length === 0) {
      if (cardObj.isDue) {
        this.dueFlashcards.push(cardObj);
      } else {
        this.newFlashcards.push(cardObj);
      }
      return;
    }
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.insertFlashcard(deckPath, cardObj);
        return;
      }
    }
  }
  countFlashcard(deckPath, n = 1) {
    this.totalFlashcards += n;
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.countFlashcard(deckPath, n);
        return;
      }
    }
  }
  deleteFlashcardAtIndex(index, cardIsDue) {
    if (cardIsDue) {
      this.dueFlashcards.splice(index, 1);
      this.dueFlashcardsCount--;
    } else {
      this.newFlashcards.splice(index, 1);
      this.newFlashcardsCount--;
    }
    let deck = this.parent;
    while (deck !== null) {
      if (cardIsDue) {
        deck.dueFlashcardsCount--;
      } else {
        deck.newFlashcardsCount--;
      }
      deck = deck.parent;
    }
  }
  sortSubdecksList() {
    this.subdecks.sort((a, b) => {
      if (a.deckName < b.deckName) {
        return -1;
      } else if (a.deckName > b.deckName) {
        return 1;
      }
      return 0;
    });
    for (const deck of this.subdecks) {
      deck.sortSubdecksList();
    }
  }
  render(containerEl, modal) {
    const deckView = containerEl.createDiv("tree-item");
    const deckViewSelf = deckView.createDiv(
      "tree-item-self tag-pane-tag is-clickable"
    );
    const shouldBeInitiallyExpanded = modal.plugin.data.settings.initiallyExpandAllSubdecksInTree;
    let collapsed = shouldBeInitiallyExpanded;
    let collapseIconEl = null;
    if (this.subdecks.length > 0) {
      collapseIconEl = deckViewSelf.createDiv("tree-item-icon collapse-icon");
      collapseIconEl.innerHTML = COLLAPSE_ICON;
      collapseIconEl.childNodes[0].style.transform = shouldBeInitiallyExpanded ? "" : "rotate(-90deg)";
    }
    const deckViewInner = deckViewSelf.createDiv("tree-item-inner");
    deckViewInner.addEventListener("click", () => {
      modal.plugin.data.historyDeck = this.deckName;
      modal.currentDeck = this;
      modal.checkDeck = this.parent;
      modal.setupCardsView();
      this.nextCard(modal);
    });
    const deckViewInnerText = deckViewInner.createDiv("tag-pane-tag-text");
    deckViewInnerText.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("span", { class: "tag-pane-tag-self" }, this.deckName);
    const deckViewOuter = deckViewSelf.createDiv("tree-item-flair-outer");
    deckViewOuter.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("span", null, /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#4caf50;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.dueFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#2196f3;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.newFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#ff7043;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.totalFlashcards.toString()
    ));
    const deckViewChildren = deckView.createDiv("tree-item-children");
    deckViewChildren.style.display = shouldBeInitiallyExpanded ? "block" : "none";
    if (this.subdecks.length > 0) {
      collapseIconEl.addEventListener("click", () => {
        if (collapsed) {
          collapseIconEl.childNodes[0].style.transform = "";
          deckViewChildren.style.display = "block";
        } else {
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deckViewChildren.style.display = "none";
        }
        collapsed = !collapsed;
      });
    }
    for (const deck of this.subdecks) {
      deck.render(deckViewChildren, modal);
    }
  }
  nextCard(modal) {
    if (this.newFlashcards.length + this.dueFlashcards.length === 0) {
      if (this.dueFlashcardsCount + this.newFlashcardsCount > 0) {
        for (const deck of this.subdecks) {
          if (deck.dueFlashcardsCount + deck.newFlashcardsCount > 0) {
            modal.currentDeck = deck;
            deck.nextCard(modal);
            return;
          }
        }
      }
      if (this.parent == modal.checkDeck) {
        modal.plugin.data.historyDeck = "";
        modal.decksList();
      } else {
        this.parent.nextCard(modal);
      }
      return;
    }
    modal.responseDiv.style.display = "none";
    modal.resetLinkView.style.display = "none";
    modal.titleEl.setText(
      `${this.deckName}: ${this.dueFlashcardsCount + this.newFlashcardsCount}`
    );
    modal.answerBtn.style.display = "initial";
    modal.flashcardView.innerHTML = "";
    modal.mode = 1 /* Front */;
    let interval = 1, ease = modal.plugin.data.settings.baseEase, delayBeforeReview = 0;
    if (this.dueFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        modal.currentCardIdx = Math.floor(Math.random() * this.dueFlashcards.length);
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.dueFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      interval = modal.currentCard.interval;
      ease = modal.currentCard.ease;
      delayBeforeReview = modal.currentCard.delayBeforeReview;
    } else if (this.newFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        const pickedCardIdx = Math.floor(Math.random() * this.newFlashcards.length);
        modal.currentCardIdx = pickedCardIdx;
        const pickedCard = this.newFlashcards[pickedCardIdx];
        let idx = pickedCardIdx;
        while (idx >= 0 && pickedCard.siblings.includes(this.newFlashcards[idx])) {
          if (!this.newFlashcards[idx].isDue) {
            modal.currentCardIdx = idx;
          }
          idx--;
        }
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.newFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      if (Object.prototype.hasOwnProperty.call(
        modal.plugin.easeByPath,
        modal.currentCard.note.path
      )) {
        ease = modal.plugin.easeByPath[modal.currentCard.note.path];
      }
    }
    const hardInterval = schedule(
      2 /* Hard */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    const goodInterval = schedule(
      1 /* Good */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    const easyInterval = schedule(
      0 /* Easy */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    if (modal.ignoreStats) {
      modal.hardBtn.setText(`${modal.plugin.data.settings.flashcardHardText}`);
      modal.easyBtn.setText(`${modal.plugin.data.settings.flashcardEasyText}`);
    } else if (import_obsidian3.Platform.isMobile) {
      modal.hardBtn.setText(textInterval(hardInterval, true));
      modal.goodBtn.setText(textInterval(goodInterval, true));
      modal.easyBtn.setText(textInterval(easyInterval, true));
    } else {
      modal.hardBtn.setText(
        `${modal.plugin.data.settings.flashcardHardText} - ${textInterval(
          hardInterval,
          false
        )}`
      );
      modal.goodBtn.setText(
        `${modal.plugin.data.settings.flashcardGoodText} - ${textInterval(
          goodInterval,
          false
        )}`
      );
      modal.easyBtn.setText(
        `${modal.plugin.data.settings.flashcardEasyText} - ${textInterval(
          easyInterval,
          false
        )}`
      );
    }
    if (modal.plugin.data.settings.showContextInCards)
      modal.contextView.setText(modal.currentCard.context);
    if (modal.plugin.data.settings.showFileNameInFileLink)
      modal.fileLinkView.setText(modal.currentCard.note.basename);
  }
};

// src/stats-modal.tsx
var import_obsidian4 = require("obsidian");
var import_vhtml2 = __toESM(require_vhtml());

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = /* @__PURE__ */ new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let ticking = false;
  return function(...args) {
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
var atEdge = (t2) => t2 === 0 || t2 === 1;
var elasticIn = (t2, s, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p));
var elasticOut = (t2, s, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p) + 1;
var effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p);
  },
  easeInBack(t2) {
    const s = 1.70158;
    return t2 * t2 * ((s + 1) * t2 - s);
  },
  easeOutBack(t2) {
    const s = 1.70158;
    return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
  },
  easeInOutBack(t2) {
    let s = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m = 7.5625;
    const d = 2.75;
    if (t2 < 1 / d) {
      return m * t2 * t2;
    }
    if (t2 < 2 / d) {
      return m * (t2 -= 1.5 / d) * t2 + 0.75;
    }
    if (t2 < 2.5 / d) {
      return m * (t2 -= 2.25 / d) * t2 + 0.9375;
    }
    return m * (t2 -= 2.625 / d) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
var effects$1 = effects;
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h4) => Math.max(Math.min(v, h4), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h4, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h4 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h4, s, v) {
  const f = (n, k = (n + h4 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h4, w, b) {
  const rgb = hsl2rgbn(h4, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h4, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h4 = hueValue(r, g, b, d, max);
    h4 = h4 * 60 + 0.5;
  }
  return [h4 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h4, s, l) {
  return calln(hsl2rgbn, h4, s, l);
}
function hwb2rgb(h4, w, b) {
  return calln(hwb2rgbn, h4, w, b);
}
function hsv2rgb(h4, s, v) {
  return calln(hsv2rgbn, h4, s, v);
}
function hue(h4) {
  return (h4 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h4 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h4, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h4, p1, p2);
  } else {
    v = hsl2rgb(h4, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h4 = rgb2hsl(v);
  h4[0] = hue(h4[0] + deg);
  h4 = hsl2rgb(h4);
  v.r = h4[0];
  v.g = h4[1];
  v.b = h4[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h4 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h4}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h4}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate2(rgb1, rgb2, t2) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t2 * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t2 * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate2(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name2, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name2;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name2],
        writable: true
      },
      [name2]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name2) => !name2.startsWith("on"),
  _indexable: (name2) => name2 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h: h4, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h4 - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h4 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h4);
  ctx.arc(x + w - radius.bottomRight, y + h4 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects$1[cfg.easing] || effects$1.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t2, r, b, l;
  if (isObject(value)) {
    t2 = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t2 = r = b = l = value;
  }
  return {
    top: t2,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset2 = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name2, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset2) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset2 = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset2 && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset2);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset2);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name2) => name2 !== "spacing",
  _indexable: (name2) => name2 !== "spacing"
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  constructor(options) {
    this.options = options || {};
  }
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height1 = chartArea.h * weight;
      const width1 = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);
      }
      stack.start = x;
      stack.placed += height1;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "active", false);
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID1 = Object.keys(position)[0];
      const value1 = position[positionAxisID1];
      titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name2) {
    this.chart.notifyPlugins(name2, this.getContext());
    callback(this.options[name2], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h4 * cos > w * sin ? w / cos : h4 / sin : h4 * sin < w * cos ? h4 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret1 = this._getYAxisLabelAlignment(tl);
      textAlign = ret1.textAlign;
      x = ret1.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [
          x,
          y
        ],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t2) => t2.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i1 = 0; i1 < local.length; i1++) {
    const plugin = local[i1];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
  id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);
  if (id) {
    return id;
  }
  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.0.1";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getDatasetArea(meta) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset2);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
      this._updateDataset(i1, isFunction(mode) ? mode({
        datasetIndex: i1
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
var Chart$1 = Chart;
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h4,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox1 of hitboxes) {
        if (hitbox1.col !== col) {
          col = hitbox1.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox1.top = top;
        hitbox1.left += this.left + padding;
        hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
        top += hitbox1.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name2) => !name2.startsWith("on"),
    labels: {
      _scriptable: (name2) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name2)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name2, ctx, arg) {
  const result = callbacks[name2].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name2].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({
      index,
      label: raw
    });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({
      value: Math.round((niceMin + j * spacing) * factor) / factor
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h4, angle) {
  if (angle === 90 || angle === 270) {
    y -= h4 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h4;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h4 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h4) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate3(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate3(table, this.min);
    this._tableRange = interpolate3(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

// src/stats-modal.tsx
Chart$1.register(
  BarElement,
  BarController,
  plugin_legend,
  plugin_title,
  plugin_tooltip,
  plugin_subtitle,
  CategoryScale,
  LinearScale,
  PieController,
  ArcElement
);
var StatsModal = class extends import_obsidian4.Modal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
    this.titleEl.setText(`${t("STATS_TITLE")} `);
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("select", { id: "chartPeriod" }, /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "month", selected: true }, t("MONTH")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "quarter" }, t("QUARTER")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "year" }, t("YEAR")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "lifetime" }, t("LIFETIME")));
    this.modalEl.style.height = "100%";
    this.modalEl.style.width = "100%";
    if (import_obsidian4.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.style.textAlign = "center";
    let maxN = Math.max(...getKeysPreserveType(this.plugin.dueDatesFlashcards));
    for (let dueOffset = 0; dueOffset <= maxN; dueOffset++) {
      if (!Object.prototype.hasOwnProperty.call(this.plugin.dueDatesFlashcards, dueOffset)) {
        this.plugin.dueDatesFlashcards[dueOffset] = 0;
      }
    }
    const dueDatesFlashcardsCopy = { 0: 0 };
    for (const [dueOffset, dueCount] of getTypedObjectEntries(this.plugin.dueDatesFlashcards)) {
      if (dueOffset <= 0) {
        dueDatesFlashcardsCopy[0] += dueCount;
      } else {
        dueDatesFlashcardsCopy[dueOffset] = dueCount;
      }
    }
    const cardStats = this.plugin.cardStats;
    const scheduledCount = cardStats.youngCount + cardStats.matureCount;
    maxN = Math.max(maxN, 1);
    contentEl.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("div", null, /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "forecastChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "forecastChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "intervalsChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "intervalsChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "easesChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "easesChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("div", { style: "width: 50%; margin: auto;" }, /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "cardTypesChart" })), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "cardTypesChartSummary" }));
    createStatsChart(
      "bar",
      "forecastChart",
      t("FORECAST"),
      t("FORECAST_DESC"),
      Object.keys(dueDatesFlashcardsCopy),
      Object.values(dueDatesFlashcardsCopy),
      t("REVIEWS_PER_DAY", { avg: (scheduledCount / maxN).toFixed(1) }),
      t("SCHEDULED"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    maxN = Math.max(...getKeysPreserveType(cardStats.intervals));
    for (let interval = 0; interval <= maxN; interval++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.intervals, interval)) {
        cardStats.intervals[interval] = 0;
      }
    }
    const average_interval = textInterval(
      Math.round(
        getTypedObjectEntries(cardStats.intervals).map(([interval, count]) => interval * count).reduce((a, b) => a + b, 0) / scheduledCount * 10
      ) / 10 || 0,
      false
    ), longest_interval = textInterval(
      Math.max(...getKeysPreserveType(cardStats.intervals)) || 0,
      false
    );
    createStatsChart(
      "bar",
      "intervalsChart",
      t("INTERVALS"),
      t("INTERVALS_DESC"),
      Object.keys(cardStats.intervals),
      Object.values(cardStats.intervals),
      t("INTERVALS_SUMMARY", { avg: average_interval, longest: longest_interval }),
      t("COUNT"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    const eases = getKeysPreserveType(cardStats.eases);
    for (let ease = Math.min(...eases); ease <= Math.max(...eases); ease++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.eases, ease)) {
        cardStats.eases[ease] = 0;
      }
    }
    const average_ease = Math.round(
      getTypedObjectEntries(cardStats.eases).map(([ease, count]) => ease * count).reduce((a, b) => a + b, 0) / scheduledCount
    ) || 0;
    createStatsChart(
      "bar",
      "easesChart",
      t("EASES"),
      "",
      Object.keys(cardStats.eases),
      Object.values(cardStats.eases),
      t("EASES_SUMMARY", { avgEase: average_ease }),
      t("COUNT"),
      t("EASES"),
      t("NUMBER_OF_CARDS")
    );
    const totalCardsCount = this.plugin.deckTree.totalFlashcards;
    createStatsChart(
      "pie",
      "cardTypesChart",
      t("CARD_TYPES"),
      t("CARD_TYPES_DESC"),
      [
        `${t("CARD_TYPE_NEW")} - ${Math.round(
          cardStats.newCount / totalCardsCount * 100
        )}%`,
        `${t("CARD_TYPE_YOUNG")} - ${Math.round(
          cardStats.youngCount / totalCardsCount * 100
        )}%`,
        `${t("CARD_TYPE_MATURE")} - ${Math.round(
          cardStats.matureCount / totalCardsCount * 100
        )}%`
      ],
      [cardStats.newCount, cardStats.youngCount, cardStats.matureCount],
      t("CARD_TYPES_SUMMARY", { totalCardsCount })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function createStatsChart(type, canvasId, title, subtitle, labels, data, summary, seriesTitle = "", xAxisTitle = "", yAxisTitle = "") {
  let scales = {}, backgroundColor = ["#2196f3"];
  if (type !== "pie") {
    scales = {
      x: {
        title: {
          display: true,
          text: xAxisTitle
        }
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle
        }
      }
    };
  } else {
    backgroundColor = ["#2196f3", "#4caf50", "green"];
  }
  const shouldFilter = canvasId === "forecastChart" || canvasId === "intervalsChart";
  const statsChart = new Chart$1(document.getElementById(canvasId), {
    type,
    data: {
      labels: shouldFilter ? labels.slice(0, 31) : labels,
      datasets: [
        {
          label: seriesTitle,
          backgroundColor,
          data: shouldFilter ? data.slice(0, 31) : data
        }
      ]
    },
    options: {
      scales,
      plugins: {
        title: {
          display: true,
          text: title,
          font: {
            size: 22
          }
        },
        subtitle: {
          display: true,
          text: subtitle,
          font: {
            size: 16
          }
        },
        legend: {
          display: false
        }
      }
    }
  });
  if (shouldFilter) {
    const chartPeriodEl = document.getElementById("chartPeriod");
    chartPeriodEl.addEventListener("click", () => {
      let filteredLabels, filteredData;
      const chartPeriod = chartPeriodEl.value;
      if (chartPeriod === "month") {
        filteredLabels = labels.slice(0, 31);
        filteredData = data.slice(0, 31);
      } else if (chartPeriod === "quarter") {
        filteredLabels = labels.slice(0, 91);
        filteredData = data.slice(0, 91);
      } else if (chartPeriod === "year") {
        filteredLabels = labels.slice(0, 366);
        filteredData = data.slice(0, 366);
      } else {
        filteredLabels = labels;
        filteredData = data;
      }
      statsChart.data.labels = filteredLabels;
      statsChart.data.datasets[0] = {
        label: seriesTitle,
        backgroundColor,
        data: filteredData
      };
      statsChart.update();
    });
  }
  document.getElementById(`${canvasId}Summary`).innerText = summary;
}

// src/sidebar.ts
var import_obsidian5 = require("obsidian");
var REVIEW_QUEUE_VIEW_TYPE = "review-queue-list-view";
var ReviewQueueListView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.registerEvent(this.app.workspace.on("file-open", () => this.redraw()));
    this.registerEvent(this.app.vault.on("rename", () => this.redraw()));
  }
  getViewType() {
    return REVIEW_QUEUE_VIEW_TYPE;
  }
  getDisplayText() {
    return t("NOTES_REVIEW_QUEUE");
  }
  getIcon() {
    return "SpacedRepIcon";
  }
  onHeaderMenu(menu) {
    menu.addItem((item) => {
      item.setTitle(t("CLOSE")).setIcon("cross").onClick(() => {
        this.app.workspace.detachLeavesOfType(REVIEW_QUEUE_VIEW_TYPE);
      });
    });
  }
  redraw() {
    const activeFile = this.app.workspace.getActiveFile();
    const rootEl = createDiv("nav-folder mod-root");
    const childrenEl = rootEl.createDiv("nav-folder-children");
    for (const deckKey in this.plugin.reviewDecks) {
      const deck = this.plugin.reviewDecks[deckKey];
      const deckCollapsed = !deck.activeFolders.has(deck.deckName);
      const deckFolderEl = this.createRightPaneFolder(
        childrenEl,
        deckKey,
        deckCollapsed,
        false,
        deck
      ).getElementsByClassName("nav-folder-children")[0];
      if (deck.newNotes.length > 0) {
        const newNotesFolderEl = this.createRightPaneFolder(
          deckFolderEl,
          t("NEW"),
          !deck.activeFolders.has(t("NEW")),
          deckCollapsed,
          deck
        );
        for (const newFile of deck.newNotes) {
          const fileIsOpen = activeFile && newFile.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(t("NEW"));
            this.changeFolderIconToExpanded(newNotesFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(
            newNotesFolderEl,
            newFile,
            fileIsOpen,
            !deck.activeFolders.has(t("NEW")),
            deck,
            this.plugin
          );
        }
      }
      if (deck.scheduledNotes.length > 0) {
        const now = Date.now();
        let currUnix = -1;
        let schedFolderEl = null, folderTitle = "";
        const maxDaysToRender = this.plugin.data.settings.maxNDaysNotesReviewQueue;
        for (const sNote of deck.scheduledNotes) {
          if (sNote.dueUnix != currUnix) {
            const nDays = Math.ceil((sNote.dueUnix - now) / (24 * 3600 * 1e3));
            if (nDays > maxDaysToRender) {
              break;
            }
            if (nDays === -1) {
              folderTitle = t("YESTERDAY");
            } else if (nDays === 0) {
              folderTitle = t("TODAY");
            } else if (nDays === 1) {
              folderTitle = t("TOMORROW");
            } else {
              folderTitle = new Date(sNote.dueUnix).toDateString();
            }
            schedFolderEl = this.createRightPaneFolder(
              deckFolderEl,
              folderTitle,
              !deck.activeFolders.has(folderTitle),
              deckCollapsed,
              deck
            );
            currUnix = sNote.dueUnix;
          }
          const fileIsOpen = activeFile && sNote.note.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(folderTitle);
            this.changeFolderIconToExpanded(schedFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(
            schedFolderEl,
            sNote.note,
            fileIsOpen,
            !deck.activeFolders.has(folderTitle),
            deck,
            this.plugin
          );
        }
      }
    }
    const contentEl = this.containerEl.children[1];
    contentEl.empty();
    contentEl.appendChild(rootEl);
  }
  createRightPaneFolder(parentEl, folderTitle, collapsed, hidden, deck) {
    const folderEl = parentEl.createDiv("nav-folder");
    const folderTitleEl = folderEl.createDiv("nav-folder-title");
    const childrenEl = folderEl.createDiv("nav-folder-children");
    const collapseIconEl = folderTitleEl.createDiv(
      "nav-folder-collapse-indicator collapse-icon"
    );
    collapseIconEl.innerHTML = COLLAPSE_ICON;
    if (collapsed) {
      collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
    }
    folderTitleEl.createDiv("nav-folder-title-content").setText(folderTitle);
    if (hidden) {
      folderEl.style.display = "none";
    }
    folderTitleEl.onClickEvent(() => {
      for (const child of childrenEl.childNodes) {
        if (child.style.display === "block" || child.style.display === "") {
          child.style.display = "none";
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deck.activeFolders.delete(folderTitle);
        } else {
          child.style.display = "block";
          collapseIconEl.childNodes[0].style.transform = "";
          deck.activeFolders.add(folderTitle);
        }
      }
    });
    return folderEl;
  }
  createRightPaneFile(folderEl, file, fileElActive, hidden, deck, plugin) {
    const navFileEl = folderEl.getElementsByClassName("nav-folder-children")[0].createDiv("nav-file");
    if (hidden) {
      navFileEl.style.display = "none";
    }
    const navFileTitle = navFileEl.createDiv("nav-file-title");
    if (fileElActive) {
      navFileTitle.addClass("is-active");
    }
    navFileTitle.createDiv("nav-file-title-content").setText(file.basename);
    navFileTitle.addEventListener(
      "click",
      async (event) => {
        event.preventDefault();
        plugin.lastSelectedReviewDeck = deck.deckName;
        await this.app.workspace.getLeaf().openFile(file);
        return false;
      },
      false
    );
    navFileTitle.addEventListener(
      "contextmenu",
      (event) => {
        event.preventDefault();
        const fileMenu = new import_obsidian5.Menu();
        this.app.workspace.trigger("file-menu", fileMenu, file, "my-context-menu", null);
        fileMenu.showAtPosition({
          x: event.pageX,
          y: event.pageY
        });
        return false;
      },
      false
    );
  }
  changeFolderIconToExpanded(folderEl) {
    const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
    collapseIconEl.childNodes[0].style.transform = "";
  }
};

// src/review-deck.ts
var import_obsidian6 = require("obsidian");
var ReviewDeck = class {
  constructor(name2) {
    this.newNotes = [];
    this.scheduledNotes = [];
    this.dueNotesCount = 0;
    this.deckName = name2;
    this.activeFolders = /* @__PURE__ */ new Set([this.deckName, t("TODAY")]);
  }
  sortNotes(pageranks) {
    this.newNotes = this.newNotes.sort(
      (a, b) => (pageranks[b.path] || 0) - (pageranks[a.path] || 0)
    );
    this.scheduledNotes = this.scheduledNotes.sort((a, b) => {
      const result = a.dueUnix - b.dueUnix;
      if (result != 0) {
        return result;
      }
      return (pageranks[b.note.path] || 0) - (pageranks[a.note.path] || 0);
    });
  }
};
var ReviewDeckSelectionModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, deckKeys) {
    super(app2);
    this.deckKeys = [];
    this.deckKeys = deckKeys;
  }
  getItems() {
    return this.deckKeys;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(deckKey, _) {
    this.close();
    this.submitCallback(deckKey);
  }
};

// src/parser.ts
function parse2(text, singlelineCardSeparator, singlelineReversedCardSeparator, multilineCardSeparator, multilineReversedCardSeparator, convertHighlightsToClozes, convertBoldTextToClozes, convertCurlyBracketsToClozes) {
  let cardText = "";
  const cards = [];
  let cardType = null;
  let lineNo = 0;
  const lines = text.replaceAll("\r\n", "\n").split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length === 0) {
      if (cardType) {
        cards.push([cardType, cardText, lineNo]);
        cardType = null;
      }
      cardText = "";
      continue;
    } else if (lines[i].startsWith("<!--") && !lines[i].startsWith("<!--SR:")) {
      while (i + 1 < lines.length && !lines[i].includes("-->"))
        i++;
      i++;
      continue;
    }
    if (cardText.length > 0) {
      cardText += "\n";
    }
    cardText += lines[i];
    if (lines[i].includes(singlelineReversedCardSeparator) || lines[i].includes(singlelineCardSeparator)) {
      cardType = lines[i].includes(singlelineReversedCardSeparator) ? 1 /* SingleLineReversed */ : 0 /* SingleLineBasic */;
      cardText = lines[i];
      lineNo = i;
      if (i + 1 < lines.length && lines[i + 1].startsWith("<!--SR:")) {
        cardText += "\n" + lines[i + 1];
        i++;
      }
      cards.push([cardType, cardText, lineNo]);
      cardType = null;
      cardText = "";
    } else if (cardType === null && (convertHighlightsToClozes && /==.*?==/gm.test(lines[i]) || convertBoldTextToClozes && /\*\*.*?\*\*/gm.test(lines[i]) || convertCurlyBracketsToClozes && /{{.*?}}/gm.test(lines[i]))) {
      cardType = 4 /* Cloze */;
      lineNo = i;
    } else if (lines[i] === multilineCardSeparator) {
      cardType = 2 /* MultiLineBasic */;
      lineNo = i;
    } else if (lines[i] === multilineReversedCardSeparator) {
      cardType = 3 /* MultiLineReversed */;
      lineNo = i;
    } else if (lines[i].startsWith("```") || lines[i].startsWith("~~~")) {
      const codeBlockClose = lines[i].match(/`+|~+/)[0];
      while (i + 1 < lines.length && !lines[i + 1].startsWith(codeBlockClose)) {
        i++;
        cardText += "\n" + lines[i];
      }
      cardText += "\n" + codeBlockClose;
      i++;
    }
  }
  if (cardType && cardText) {
    cards.push([cardType, cardText, lineNo]);
  }
  return cards;
}

// src/icons/appicon.ts
var import_obsidian7 = require("obsidian");
function appIcon() {
  (0, import_obsidian7.addIcon)(
    "SpacedRepIcon",
    `<path fill="currentColor" stroke="currentColor" d="M 88.960938 17.257812 L 47.457031 17.257812 C 45.679688 17.257812 44.230469 18.703125 44.230469 20.484375 L 44.230469 86.558594 C 44.230469 88.335938 45.679688 89.785156 47.457031 89.785156 L 88.960938 89.785156 C 90.738281 89.785156 92.1875 88.335938 92.1875 86.558594 L 92.1875 20.484375 C 92.1875 18.703125 90.738281 17.257812 88.960938 17.257812 Z M 88.28125 85.878906 L 48.136719 85.878906 L 48.136719 21.164062 L 88.28125 21.164062 Z M 88.28125 85.878906 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 88.960938 9.445312 L 61.667969 9.445312 C 59.925781 3.816406 54.011719 0.515625 48.269531 2.054688 L 8.183594 12.796875 C 2.304688 14.371094 -1.199219 20.4375 0.378906 26.316406 L 17.476562 90.140625 C 18.796875 95.066406 23.269531 98.324219 28.144531 98.324219 C 29.085938 98.324219 30.046875 98.199219 31 97.945312 L 40.765625 95.328125 C 42.625 96.75 44.941406 97.597656 47.457031 97.597656 L 88.960938 97.597656 C 95.046875 97.597656 100 92.644531 100 86.558594 L 100 20.484375 C 100 14.398438 95.046875 9.445312 88.960938 9.445312 Z M 29.988281 94.171875 C 26.1875 95.191406 22.269531 92.925781 21.25 89.128906 L 4.152344 25.304688 C 3.132812 21.507812 5.394531 17.585938 9.195312 16.570312 L 49.28125 5.828125 C 52.578125 4.945312 55.960938 6.53125 57.464844 9.445312 L 47.457031 9.445312 C 41.371094 9.445312 36.417969 14.398438 36.417969 20.484375 L 36.417969 86.558594 C 36.417969 88.558594 36.957031 90.433594 37.890625 92.054688 Z M 96.09375 86.558594 C 96.09375 90.492188 92.894531 93.691406 88.960938 93.691406 L 47.457031 93.691406 C 43.523438 93.691406 40.324219 90.492188 40.324219 86.558594 L 40.324219 20.484375 C 40.324219 16.550781 43.523438 13.351562 47.457031 13.351562 L 88.960938 13.351562 C 92.894531 13.351562 96.09375 16.550781 96.09375 20.484375 Z M 96.09375 86.558594 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 54.101562 53.09375 L 60.070312 57.410156 L 57.789062 64.378906 C 56.90625 67.074219 59.996094 69.320312 62.285156 67.648438 L 68.210938 63.324219 L 74.132812 67.648438 C 76.421875 69.320312 79.511719 67.074219 78.628906 64.378906 L 76.347656 57.410156 L 82.320312 53.09375 C 84.613281 51.433594 83.441406 47.804688 80.605469 47.804688 L 73.242188 47.804688 L 70.988281 40.839844 C 70.117188 38.144531 66.300781 38.144531 65.429688 40.839844 L 63.179688 47.804688 L 55.8125 47.804688 C 52.980469 47.804688 51.804688 51.433594 54.101562 53.09375 Z M 54.101562 53.09375 "/>
        `
  );
}

// src/main.ts
var DEFAULT_DATA = {
  settings: DEFAULT_SETTINGS,
  buryDate: "",
  buryList: [],
  historyDeck: null
};
var SRPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.syncLock = false;
    this.reviewDecks = {};
    this.newNotes = [];
    this.scheduledNotes = [];
    this.easeByPath = {};
    this.incomingLinks = {};
    this.pageranks = {};
    this.dueNotesCount = 0;
    this.dueDatesNotes = {};
    this.deckTree = new Deck("root", null);
    this.dueDatesFlashcards = {};
  }
  async onload() {
    await this.loadPluginData();
    appIcon();
    this.statusBar = this.addStatusBarItem();
    this.statusBar.classList.add("mod-clickable");
    this.statusBar.setAttribute("aria-label", t("OPEN_NOTE_FOR_REVIEW"));
    this.statusBar.setAttribute("aria-label-position", "top");
    this.statusBar.addEventListener("click", async () => {
      if (!this.syncLock) {
        await this.sync();
        this.reviewNextNoteModal();
      }
    });
    this.addRibbonIcon("SpacedRepIcon", t("REVIEW_CARDS"), async () => {
      if (!this.syncLock) {
        await this.sync();
        new FlashcardModal(this.app, this).open();
      }
    });
    if (!this.data.settings.disableFileMenuReviewOptions) {
      this.registerEvent(
        this.app.workspace.on("file-menu", (menu, fileish) => {
          if (fileish instanceof import_obsidian8.TFile && fileish.extension === "md") {
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_EASY_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 0 /* Easy */);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_GOOD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 1 /* Good */);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_HARD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 2 /* Hard */);
              });
            });
          }
        })
      );
    }
    this.addCommand({
      id: "srs-note-review-open-note",
      name: t("OPEN_NOTE_FOR_REVIEW"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          this.reviewNextNoteModal();
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-easy",
      name: t("REVIEW_NOTE_EASY_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 0 /* Easy */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-good",
      name: t("REVIEW_NOTE_GOOD_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 1 /* Good */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-hard",
      name: t("REVIEW_NOTE_HARD_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 2 /* Hard */);
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards",
      name: t("REVIEW_ALL_CARDS"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          new FlashcardModal(this.app, this).open();
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards-in-note",
      name: t("REVIEW_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.deckTree = new Deck("root", null);
          const deckPath = this.findDeckPath(openFile);
          await this.findFlashcardsInNote(openFile, deckPath);
          new FlashcardModal(this.app, this).open();
        }
      }
    });
    this.addCommand({
      id: "srs-cram-flashcards-in-note",
      name: t("CRAM_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.deckTree = new Deck("root", null);
          const deckPath = this.findDeckPath(openFile);
          await this.findFlashcardsInNote(openFile, deckPath, false, true);
          new FlashcardModal(this.app, this, true).open();
        }
      }
    });
    this.addCommand({
      id: "srs-view-stats",
      name: t("VIEW_STATS"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          new StatsModal(this.app, this).open();
        }
      }
    });
    this.addSettingTab(new SRSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.initView();
      setTimeout(async () => {
        if (!this.syncLock) {
          await this.sync();
        }
      }, 2e3);
    });
  }
  onunload() {
    this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).forEach((leaf) => leaf.detach());
  }
  async sync() {
    if (this.syncLock) {
      return;
    }
    this.syncLock = true;
    graph.reset();
    this.easeByPath = {};
    this.incomingLinks = {};
    this.pageranks = {};
    this.dueNotesCount = 0;
    this.dueDatesNotes = {};
    this.reviewDecks = {};
    this.deckTree = new Deck("root", null);
    this.dueDatesFlashcards = {};
    this.cardStats = {
      eases: {},
      intervals: {},
      newCount: 0,
      youngCount: 0,
      matureCount: 0
    };
    const now = window.moment(Date.now());
    const todayDate = now.format("YYYY-MM-DD");
    if (todayDate !== this.data.buryDate) {
      this.data.buryDate = todayDate;
      this.data.buryList = [];
    }
    const notes = this.app.vault.getMarkdownFiles();
    for (const note of notes) {
      if (this.data.settings.noteFoldersToIgnore.some(
        (folder) => note.path.startsWith(folder)
      )) {
        continue;
      }
      if (this.incomingLinks[note.path] === void 0) {
        this.incomingLinks[note.path] = [];
      }
      const links = this.app.metadataCache.resolvedLinks[note.path] || {};
      for (const targetPath in links) {
        if (this.incomingLinks[targetPath] === void 0)
          this.incomingLinks[targetPath] = [];
        if (targetPath.split(".").pop().toLowerCase() === "md") {
          this.incomingLinks[targetPath].push({
            sourcePath: note.path,
            linkCount: links[targetPath]
          });
          graph.link(note.path, targetPath, links[targetPath]);
        }
      }
      const deckPath = this.findDeckPath(note);
      if (deckPath.length !== 0) {
        const flashcardsInNoteAvgEase = await this.findFlashcardsInNote(
          note,
          deckPath
        );
        if (flashcardsInNoteAvgEase > 0) {
          this.easeByPath[note.path] = flashcardsInNoteAvgEase;
        }
      }
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const frontmatter = fileCachedData.frontmatter || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      let shouldIgnore = true;
      const matchedNoteTags = [];
      for (const tagToReview of this.data.settings.tagsToReview) {
        if (tags.some((tag) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
          if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, tagToReview)) {
            this.reviewDecks[tagToReview] = new ReviewDeck(tagToReview);
          }
          matchedNoteTags.push(tagToReview);
          shouldIgnore = false;
          break;
        }
      }
      if (shouldIgnore) {
        continue;
      }
      if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
        for (const matchedNoteTag of matchedNoteTags) {
          this.reviewDecks[matchedNoteTag].newNotes.push(note);
        }
        continue;
      }
      const dueUnix = window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
      for (const matchedNoteTag of matchedNoteTags) {
        this.reviewDecks[matchedNoteTag].scheduledNotes.push({ note, dueUnix });
        if (dueUnix <= now.valueOf()) {
          this.reviewDecks[matchedNoteTag].dueNotesCount++;
        }
      }
      if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
        this.easeByPath[note.path] = (this.easeByPath[note.path] + frontmatter["sr-ease"]) / 2;
      } else {
        this.easeByPath[note.path] = frontmatter["sr-ease"];
      }
      if (dueUnix <= now.valueOf()) {
        this.dueNotesCount++;
      }
      const nDays = Math.ceil((dueUnix - now.valueOf()) / (24 * 3600 * 1e3));
      if (!Object.prototype.hasOwnProperty.call(this.dueDatesNotes, nDays)) {
        this.dueDatesNotes[nDays] = 0;
      }
      this.dueDatesNotes[nDays]++;
    }
    graph.rank(0.85, 1e-6, (node, rank2) => {
      this.pageranks[node] = rank2 * 1e4;
    });
    this.deckTree.sortSubdecksList();
    if (this.data.settings.showDebugMessages) {
      console.log(`SR: ${t("EASES")}`, this.easeByPath);
      console.log(`SR: ${t("DECKS")}`, this.deckTree);
    }
    for (const deckKey in this.reviewDecks) {
      this.reviewDecks[deckKey].sortNotes(this.pageranks);
    }
    if (this.data.settings.showDebugMessages) {
      console.log(
        "SR: " + t("SYNC_TIME_TAKEN", {
          t: Date.now() - now.valueOf()
        })
      );
    }
    this.statusBar.setText(
      t("STATUS_BAR", {
        dueNotesCount: this.dueNotesCount,
        dueFlashcardsCount: this.deckTree.dueFlashcardsCount
      })
    );
    if (this.data.settings.enableNoteReviewPaneOnStartup)
      this.reviewQueueView.redraw();
    this.syncLock = false;
  }
  async saveReviewResponse(note, response) {
    const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
    const frontmatter = fileCachedData.frontmatter || {};
    const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
    if (this.data.settings.noteFoldersToIgnore.some((folder) => note.path.startsWith(folder))) {
      new import_obsidian8.Notice(t("NOTE_IN_IGNORED_FOLDER"));
      return;
    }
    let shouldIgnore = true;
    for (const tag of tags) {
      if (this.data.settings.tagsToReview.some(
        (tagToReview) => tag === tagToReview || tag.startsWith(tagToReview + "/")
      )) {
        shouldIgnore = false;
        break;
      }
    }
    if (shouldIgnore) {
      new import_obsidian8.Notice(t("PLEASE_TAG_NOTE"));
      return;
    }
    let fileText = await this.app.vault.read(note);
    let ease, interval, delayBeforeReview;
    const now = Date.now();
    if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
      let linkTotal = 0, linkPGTotal = 0, totalLinkCount = 0;
      for (const statObj of this.incomingLinks[note.path] || []) {
        const ease2 = this.easeByPath[statObj.sourcePath];
        if (ease2) {
          linkTotal += statObj.linkCount * this.pageranks[statObj.sourcePath] * ease2;
          linkPGTotal += this.pageranks[statObj.sourcePath] * statObj.linkCount;
          totalLinkCount += statObj.linkCount;
        }
      }
      const outgoingLinks = this.app.metadataCache.resolvedLinks[note.path] || {};
      for (const linkedFilePath in outgoingLinks) {
        const ease2 = this.easeByPath[linkedFilePath];
        if (ease2) {
          linkTotal += outgoingLinks[linkedFilePath] * this.pageranks[linkedFilePath] * ease2;
          linkPGTotal += this.pageranks[linkedFilePath] * outgoingLinks[linkedFilePath];
          totalLinkCount += outgoingLinks[linkedFilePath];
        }
      }
      const linkContribution = this.data.settings.maxLinkFactor * Math.min(1, Math.log(totalLinkCount + 0.5) / Math.log(64));
      ease = (1 - linkContribution) * this.data.settings.baseEase + (totalLinkCount > 0 ? linkContribution * linkTotal / linkPGTotal : linkContribution * this.data.settings.baseEase);
      if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
        ease = (ease + this.easeByPath[note.path]) / 2;
      }
      ease = Math.round(ease);
      interval = 1;
      delayBeforeReview = 0;
    } else {
      interval = frontmatter["sr-interval"];
      ease = frontmatter["sr-ease"];
      delayBeforeReview = now - window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
    }
    const schedObj = schedule(
      response,
      interval,
      ease,
      delayBeforeReview,
      this.data.settings,
      this.dueDatesNotes
    );
    interval = schedObj.interval;
    ease = schedObj.ease;
    const due = window.moment(now + interval * 24 * 3600 * 1e3);
    const dueString = due.format("YYYY-MM-DD");
    if (SCHEDULING_INFO_REGEX.test(fileText)) {
      const schedulingInfo = SCHEDULING_INFO_REGEX.exec(fileText);
      fileText = fileText.replace(
        SCHEDULING_INFO_REGEX,
        `---
${schedulingInfo[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
${schedulingInfo[5]}---`
      );
    } else if (YAML_FRONT_MATTER_REGEX.test(fileText)) {
      const existingYaml = YAML_FRONT_MATTER_REGEX.exec(fileText);
      fileText = fileText.replace(
        YAML_FRONT_MATTER_REGEX,
        `---
${existingYaml[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---`
      );
    } else {
      fileText = `---
sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---

${fileText}`;
    }
    if (this.data.settings.burySiblingCards) {
      await this.findFlashcardsInNote(note, [], true);
      await this.savePluginData();
    }
    await this.app.vault.modify(note, fileText);
    new import_obsidian8.Notice(t("RESPONSE_RECEIVED"));
    await this.sync();
    if (this.data.settings.autoNextNote) {
      this.reviewNextNote(this.lastSelectedReviewDeck);
    }
  }
  async reviewNextNoteModal() {
    const reviewDeckNames = Object.keys(this.reviewDecks);
    if (reviewDeckNames.length === 1) {
      this.reviewNextNote(reviewDeckNames[0]);
    } else {
      const deckSelectionModal = new ReviewDeckSelectionModal(this.app, reviewDeckNames);
      deckSelectionModal.submitCallback = (deckKey) => this.reviewNextNote(deckKey);
      deckSelectionModal.open();
    }
  }
  async reviewNextNote(deckKey) {
    if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, deckKey)) {
      new import_obsidian8.Notice(t("NO_DECK_EXISTS", { deckName: deckKey }));
      return;
    }
    this.lastSelectedReviewDeck = deckKey;
    const deck = this.reviewDecks[deckKey];
    if (deck.dueNotesCount > 0) {
      const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.dueNotesCount) : 0;
      await this.app.workspace.getLeaf().openFile(deck.scheduledNotes[index].note);
      return;
    }
    if (deck.newNotes.length > 0) {
      const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.newNotes.length) : 0;
      this.app.workspace.getLeaf().openFile(deck.newNotes[index]);
      return;
    }
    new import_obsidian8.Notice(t("ALL_CAUGHT_UP"));
  }
  findDeckPath(note) {
    let deckPath = [];
    if (this.data.settings.convertFoldersToDecks) {
      deckPath = note.path.split("/");
      deckPath.pop();
      if (deckPath.length === 0) {
        deckPath = ["/"];
      }
    } else {
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      outer:
        for (const tagToReview of this.data.settings.flashcardTags) {
          for (const tag of tags) {
            if (tag === tagToReview || tag.startsWith(tagToReview + "/")) {
              deckPath = tag.substring(1).split("/");
              break outer;
            }
          }
        }
    }
    return deckPath;
  }
  async findFlashcardsInNote(note, deckPath, buryOnly = false, ignoreStats = false) {
    var _a;
    let fileText = await this.app.vault.read(note);
    const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
    const headings = fileCachedData.headings || [];
    let fileChanged = false, totalNoteEase = 0, scheduledCount = 0;
    const settings = this.data.settings;
    const noteDeckPath = deckPath;
    const now = Date.now();
    const parsedCards = parse2(
      fileText,
      settings.singleLineCardSeparator,
      settings.singleLineReversedCardSeparator,
      settings.multilineCardSeparator,
      settings.multilineReversedCardSeparator,
      settings.convertHighlightsToClozes,
      settings.convertBoldTextToClozes,
      settings.convertCurlyBracketsToClozes
    );
    for (const parsedCard of parsedCards) {
      deckPath = noteDeckPath;
      const cardType = parsedCard[0], lineNo = parsedCard[2];
      let cardText = parsedCard[1];
      if (!settings.convertFoldersToDecks) {
        const tagInCardRegEx = /^#[^\s#]+/gi;
        const cardDeckPath = (_a = cardText.match(tagInCardRegEx)) == null ? void 0 : _a.slice(-1)[0].replace("#", "").split("/");
        if (cardDeckPath) {
          deckPath = cardDeckPath;
          cardText = cardText.replaceAll(tagInCardRegEx, "");
        }
      }
      this.deckTree.createDeck([...deckPath]);
      const cardTextHash = cyrb53(cardText);
      if (buryOnly) {
        this.data.buryList.push(cardTextHash);
        continue;
      }
      const siblingMatches = [];
      if (cardType === 4 /* Cloze */) {
        const siblings2 = [];
        if (settings.convertHighlightsToClozes) {
          siblings2.push(...cardText.matchAll(/==(.*?)==/gm));
        }
        if (settings.convertBoldTextToClozes) {
          siblings2.push(...cardText.matchAll(/\*\*(.*?)\*\*/gm));
        }
        if (settings.convertCurlyBracketsToClozes) {
          siblings2.push(...cardText.matchAll(/{{(.*?)}}/gm));
        }
        siblings2.sort((a, b) => {
          if (a.index < b.index) {
            return -1;
          }
          if (a.index > b.index) {
            return 1;
          }
          return 0;
        });
        let front, back;
        for (const m of siblings2) {
          const deletionStart = m.index, deletionEnd = deletionStart + m[0].length;
          front = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>[...]</span>" + cardText.substring(deletionEnd);
          front = front.replace(/==/gm, "").replace(/\*\*/gm, "").replace(/{{/gm, "").replace(/}}/gm, "");
          back = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>" + cardText.substring(deletionStart, deletionEnd) + "</span>" + cardText.substring(deletionEnd);
          back = back.replace(/==/gm, "").replace(/\*\*/gm, "").replace(/{{/gm, "").replace(/}}/gm, "");
          siblingMatches.push([front, back]);
        }
      } else {
        let idx;
        if (cardType === 0 /* SingleLineBasic */) {
          idx = cardText.indexOf(settings.singleLineCardSeparator);
          siblingMatches.push([
            cardText.substring(0, idx),
            cardText.substring(idx + settings.singleLineCardSeparator.length)
          ]);
        } else if (cardType === 1 /* SingleLineReversed */) {
          idx = cardText.indexOf(settings.singleLineReversedCardSeparator);
          const side1 = cardText.substring(0, idx), side2 = cardText.substring(
            idx + settings.singleLineReversedCardSeparator.length
          );
          siblingMatches.push([side1, side2]);
          siblingMatches.push([side2, side1]);
        } else if (cardType === 2 /* MultiLineBasic */) {
          idx = cardText.indexOf("\n" + settings.multilineCardSeparator + "\n");
          siblingMatches.push([
            cardText.substring(0, idx),
            cardText.substring(idx + 2 + settings.multilineCardSeparator.length)
          ]);
        } else if (cardType === 3 /* MultiLineReversed */) {
          idx = cardText.indexOf("\n" + settings.multilineReversedCardSeparator + "\n");
          const side1 = cardText.substring(0, idx), side2 = cardText.substring(
            idx + 2 + settings.multilineReversedCardSeparator.length
          );
          siblingMatches.push([side1, side2]);
          siblingMatches.push([side2, side1]);
        }
      }
      let scheduling = [...cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)];
      if (scheduling.length === 0)
        scheduling = [...cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
      if (scheduling.length > siblingMatches.length) {
        const idxSched = cardText.lastIndexOf("<!--SR:") + 7;
        let newCardText = cardText.substring(0, idxSched);
        for (let i = 0; i < siblingMatches.length; i++)
          newCardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
        newCardText += "-->";
        const replacementRegex = new RegExp(escapeRegexString(cardText), "gm");
        fileText = fileText.replace(replacementRegex, () => newCardText);
        fileChanged = true;
      }
      const context = settings.showContextInCards ? getCardContext(lineNo, headings) : "";
      const siblings = [];
      for (let i = 0; i < siblingMatches.length; i++) {
        const front = siblingMatches[i][0].trim(), back = siblingMatches[i][1].trim();
        const cardObj = {
          isDue: i < scheduling.length,
          note,
          lineNo,
          front,
          back,
          cardText,
          context,
          cardType,
          siblingIdx: i,
          siblings
        };
        if (ignoreStats) {
          this.cardStats.newCount++;
          cardObj.isDue = true;
          this.deckTree.insertFlashcard([...deckPath], cardObj);
        } else if (i < scheduling.length) {
          const dueUnix = window.moment(scheduling[i][1], ["YYYY-MM-DD", "DD-MM-YYYY"]).valueOf();
          const nDays = Math.ceil((dueUnix - now) / (24 * 3600 * 1e3));
          if (!Object.prototype.hasOwnProperty.call(this.dueDatesFlashcards, nDays)) {
            this.dueDatesFlashcards[nDays] = 0;
          }
          this.dueDatesFlashcards[nDays]++;
          const interval = parseInt(scheduling[i][2]), ease = parseInt(scheduling[i][3]);
          if (!Object.prototype.hasOwnProperty.call(this.cardStats.intervals, interval)) {
            this.cardStats.intervals[interval] = 0;
          }
          this.cardStats.intervals[interval]++;
          if (!Object.prototype.hasOwnProperty.call(this.cardStats.eases, ease)) {
            this.cardStats.eases[ease] = 0;
          }
          this.cardStats.eases[ease]++;
          totalNoteEase += ease;
          scheduledCount++;
          if (interval >= 32) {
            this.cardStats.matureCount++;
          } else {
            this.cardStats.youngCount++;
          }
          if (this.data.buryList.includes(cardTextHash)) {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
          if (dueUnix <= now) {
            cardObj.interval = interval;
            cardObj.ease = ease;
            cardObj.delayBeforeReview = now - dueUnix;
            this.deckTree.insertFlashcard([...deckPath], cardObj);
          } else {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
        } else {
          this.cardStats.newCount++;
          if (this.data.buryList.includes(cyrb53(cardText))) {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
          this.deckTree.insertFlashcard([...deckPath], cardObj);
        }
        siblings.push(cardObj);
      }
    }
    if (fileChanged) {
      await this.app.vault.modify(note, fileText);
    }
    if (scheduledCount > 0) {
      const flashcardsInNoteAvgEase = totalNoteEase / scheduledCount;
      const flashcardContribution = Math.min(
        1,
        Math.log(scheduledCount + 0.5) / Math.log(64)
      );
      return flashcardsInNoteAvgEase * flashcardContribution + settings.baseEase * (1 - flashcardContribution);
    }
    return 0;
  }
  async loadPluginData() {
    this.data = Object.assign({}, DEFAULT_DATA, await this.loadData());
    this.data.settings = Object.assign({}, DEFAULT_SETTINGS, this.data.settings);
  }
  async savePluginData() {
    await this.saveData(this.data);
  }
  initView() {
    this.registerView(
      REVIEW_QUEUE_VIEW_TYPE,
      (leaf) => this.reviewQueueView = new ReviewQueueListView(leaf, this)
    );
    if (this.data.settings.enableNoteReviewPaneOnStartup && app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).length == 0) {
      this.app.workspace.getRightLeaf(false).setViewState({
        type: REVIEW_QUEUE_VIEW_TYPE,
        active: true
      });
    }
  }
};
function getCardContext(cardLine, headings) {
  const stack = [];
  for (const heading of headings) {
    if (heading.position.start.line > cardLine) {
      break;
    }
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop();
    }
    stack.push(heading);
  }
  let context = "";
  for (const headingObj of stack) {
    headingObj.heading = headingObj.heading.replace(/\[\^\d+\]/gm, "").trim();
    context += headingObj.heading + " > ";
  }
  return context.slice(0, -3);
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3BhZ2VyYW5rLmpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvdmh0bWwvc3JjL2VtcHR5LXRhZ3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ZodG1sL3NyYy92aHRtbC5qcyIsICIuLi9zcmMvbWFpbi50cyIsICIuLi9zcmMvc2V0dGluZ3MudHMiLCAiLi4vc3JjL2xhbmcvaGVscGVycy50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvYXIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2N6LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9kYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZGUudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2VuLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9lbi1nYi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZXMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2ZyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9oaS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvaWQudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2l0LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9qYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUva28udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL25sLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9uby50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcGwudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3B0LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9wdC1ici50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcm8udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3J1LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS90ci50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvemgtY24udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3poLXR3LnRzIiwgIi4uL3NyYy9mbGFzaGNhcmQtbW9kYWwudHN4IiwgIi4uL3NyYy9zY2hlZHVsaW5nLnRzIiwgIi4uL3NyYy9jb25zdGFudHMudHMiLCAiLi4vc3JjL3V0aWxzLnRzIiwgIi4uL3NyYy9zdGF0cy1tb2RhbC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvbm9kZV9tb2R1bGVzLy5wbnBtL0BrdXJrbGUrY29sb3JAMC4yLjEvbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudGlja3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuZGVmYXVsdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGVmYXVsdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm9wdGlvbnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmN1cnZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmRvbS50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnJ0bC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdG9yLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5iYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuZG91Z2hudXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmxpbmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucGllLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hZGFwdGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2ljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50eXBlZFJlZ2lzdHJ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnBsdWdpbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29uZmlnLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmFyYy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmJhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmNvbG9ycy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnNlZ21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmhlbHBlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LnN0YWNrLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL3NpbXBsZUFyYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5kcmF3aW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udGl0bGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5zdWJ0aXRsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUuY2F0ZWdvcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubG9nYXJpdGhtaWMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUucmFkaWFsTGluZWFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZXNlcmllcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9zaWRlYmFyLnRzIiwgIi4uL3NyYy9yZXZpZXctZGVjay50cyIsICIuLi9zcmMvcGFyc2VyLnRzIiwgIi4uL3NyYy9pY29ucy9hcHBpY29uLnRzIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLG1EQUFBQSxTQUFBO0FBQUE7QUFFQSxhQUFTLE9BQU8sUUFBUUMsV0FBVTtBQUM5QixVQUFLLE9BQU8sV0FBVyxZQUFjLE9BQU9BLGNBQWEsWUFBYTtBQUNsRSxpQkFBUyxPQUFPLFFBQVE7QUFDcEIsY0FBSSxPQUFPLGVBQWUsR0FBRyxNQUFNLE1BQU07QUFDckMsZ0JBQUlBLFVBQVMsS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPO0FBQ3RDO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFBRCxRQUFPLFVBQVcsV0FBWTtBQUMxQixVQUFJLE9BQU87QUFBQSxRQUNQLE9BQU87QUFBQSxRQUNQLE9BQU8sQ0FBQztBQUFBLFFBQ1IsT0FBTyxDQUFDO0FBQUEsTUFDWjtBQUVBLFdBQUssT0FBTyxTQUFVLFFBQVEsUUFBUSxRQUFRO0FBQzFDLFlBQUssU0FBUyxNQUFNLE1BQU0sUUFBVSxXQUFXLE1BQU87QUFDbEQsbUJBQVM7QUFBQSxRQUNiO0FBRUEsaUJBQVMsV0FBVyxNQUFNO0FBRTFCLFlBQUksS0FBSyxNQUFNLGVBQWUsTUFBTSxNQUFNLE1BQU07QUFDNUMsZUFBSztBQUNMLGVBQUssTUFBTSxVQUFVO0FBQUEsWUFDakIsUUFBUTtBQUFBLFlBQ1IsVUFBVTtBQUFBLFVBQ2Q7QUFBQSxRQUNKO0FBRUEsYUFBSyxNQUFNLFFBQVEsWUFBWTtBQUUvQixZQUFJLEtBQUssTUFBTSxlQUFlLE1BQU0sTUFBTSxNQUFNO0FBQzVDLGVBQUs7QUFDTCxlQUFLLE1BQU0sVUFBVTtBQUFBLFlBQ2pCLFFBQVE7QUFBQSxZQUNSLFVBQVU7QUFBQSxVQUNkO0FBQUEsUUFDSjtBQUVBLFlBQUksS0FBSyxNQUFNLGVBQWUsTUFBTSxNQUFNLE1BQU07QUFDNUMsZUFBSyxNQUFNLFVBQVUsQ0FBQztBQUFBLFFBQzFCO0FBRUEsWUFBSSxLQUFLLE1BQU0sUUFBUSxlQUFlLE1BQU0sTUFBTSxNQUFNO0FBQ3BELGVBQUssTUFBTSxRQUFRLFVBQVU7QUFBQSxRQUNqQztBQUVBLGFBQUssTUFBTSxRQUFRLFdBQVc7QUFBQSxNQUNsQztBQUVBLFdBQUssT0FBTyxTQUFVRSxRQUFPLFNBQVNELFdBQVU7QUFDNUMsWUFBSSxRQUFRLEdBQ1IsVUFBVSxJQUFJLEtBQUs7QUFFdkIsZUFBTyxLQUFLLE9BQU8sU0FBVSxRQUFRO0FBQ2pDLGNBQUksS0FBSyxNQUFNLFFBQVEsV0FBVyxHQUFHO0FBQ2pDLG1CQUFPLEtBQUssTUFBTSxTQUFTLFNBQVUsUUFBUTtBQUN6QyxtQkFBSyxNQUFNLFFBQVEsV0FBVyxLQUFLLE1BQU0sUUFBUTtBQUFBLFlBQ3JELENBQUM7QUFBQSxVQUNMO0FBQUEsUUFDSixDQUFDO0FBRUQsZUFBTyxLQUFLLE9BQU8sU0FBVSxLQUFLO0FBQzlCLGVBQUssTUFBTSxLQUFLLFNBQVM7QUFBQSxRQUM3QixDQUFDO0FBRUQsZUFBTyxRQUFRLFNBQVM7QUFDcEIsY0FBSSxPQUFPLEdBQ1AsUUFBUSxDQUFDO0FBRWIsaUJBQU8sS0FBSyxPQUFPLFNBQVUsS0FBSyxPQUFPO0FBQ3JDLGtCQUFNLE9BQU8sTUFBTTtBQUVuQixnQkFBSSxNQUFNLGFBQWEsR0FBRztBQUN0QixzQkFBUSxNQUFNO0FBQUEsWUFDbEI7QUFFQSxpQkFBSyxNQUFNLEtBQUssU0FBUztBQUFBLFVBQzdCLENBQUM7QUFFRCxrQkFBUUM7QUFFUixpQkFBTyxLQUFLLE9BQU8sU0FBVSxRQUFRO0FBQ2pDLG1CQUFPLEtBQUssTUFBTSxTQUFTLFNBQVUsUUFBUSxRQUFRO0FBQ2pELG1CQUFLLE1BQU0sUUFBUSxVQUFVQSxTQUFRLE1BQU0sVUFBVTtBQUFBLFlBQ3pELENBQUM7QUFFRCxpQkFBSyxNQUFNLFFBQVEsV0FBVyxJQUFJQSxVQUFTLFVBQVUsT0FBTztBQUFBLFVBQ2hFLENBQUM7QUFFRCxrQkFBUTtBQUVSLGlCQUFPLEtBQUssT0FBTyxTQUFVLEtBQUssT0FBTztBQUNyQyxxQkFBUyxLQUFLLElBQUksTUFBTSxTQUFTLE1BQU0sSUFBSTtBQUFBLFVBQy9DLENBQUM7QUFBQSxRQUNMO0FBRUEsZUFBTyxLQUFLLE9BQU8sU0FBVSxLQUFLO0FBQzlCLGlCQUFPRCxVQUFTLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLFFBQy9DLENBQUM7QUFBQSxNQUNMO0FBRUEsV0FBSyxRQUFRLFdBQVk7QUFDckIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxRQUFRLENBQUM7QUFDZCxhQUFLLFFBQVEsQ0FBQztBQUFBLE1BQ2xCO0FBRUEsYUFBTztBQUFBLElBQ1gsRUFBRztBQUFBO0FBQUE7Ozs7Ozs7OztBQ3BISCxVQUFBLFlBQWUsQ0FDZCxRQUNBLFFBQ0EsTUFDQSxPQUNBLFdBQ0EsU0FDQSxNQUNBLE9BQ0EsU0FDQSxVQUNBLFFBQ0EsUUFDQSxTQUNBLFVBQ0EsU0FDQSxLQWhCYztBQ0dmLFVBQUlFLE1BQU0sU0FBTkEsS0FBTSxLQUFBO2VBQU9DLE9BQU9DLEdBQVAsRUFBWUMsUUFBUSxZQUFZLFNBQUEsR0FBQTt1QkFBT0MsS0FBSUMsS0FBWDtTQUFoQzs7QUFDakIsVUFBSUQsT0FBTSxFQUFDLEtBQUksT0FBTSxLQUFJLE1BQUssS0FBSSxNQUFLLEtBQUksUUFBTyxLQUFJLE9BQTVDO0FBQ1YsVUFBSUUsbUJBQW1CO0FBQ3ZCLFVBQUlDLG9CQUFvQjttQkFDWjtpQkFDRjs7QUFHVixVQUFJQyxZQUFZLENBQUE7QUFHaEIsZUFBd0JDLEdBQUVDLE9BQU1DLE9BQU87WUFDbENDLFFBQU0sQ0FBQSxHQUFJUCxJQUFJO2dCQUNWTSxTQUFTLENBQUE7aUJBQ1JFLElBQUVDLFVBQVVDLFFBQVFGLE1BQU0sS0FBSztnQkFDakNHLEtBQUtGLFVBQVVELEVBQXJCOztZQUlHLE9BQU9ILFVBQU8sWUFBWTtnQkFDdkJPLFdBQVdMLE1BQU1NLFFBQU47aUJBQ1ZSLE1BQUtDLEtBQUw7O1lBSUpELE9BQU07ZUFDSixNQUFNQTtjQUNQQztBQUFPLHFCQUFTRSxNQUFLRixPQUFPO2tCQUMzQkEsTUFBTUUsUUFBSyxTQUFTRixNQUFNRSxPQUFJLFFBQVFBLE9BQU1QLGtCQUFrQjs0QkFDeERDLGtCQUFrQk0sTUFBS04sa0JBQWtCTSxNQUFLYixJQUFJYSxFQUFKLEtBQXZELE9BQWtFYixJQUFJVyxNQUFNRSxHQUFWLElBQWxFOzs7ZUFHRzs7WUFHRk0sVUFBVUMsUUFBUVYsS0FBbEIsTUFBNEIsSUFBSTtjQUMvQkMsTUFBTUwsbUJBQW1CO2lCQUN2QkssTUFBTUwsa0JBQWtCZTs7QUFFekIsbUJBQU9ULE1BQU1HLFFBQVE7a0JBQ3JCTyxRQUFRVixNQUFNVyxJQUFOO2tCQUNSRCxPQUFPO29CQUNOQSxNQUFNQyxLQUFLOzJCQUNMVixNQUFFUyxNQUFNUCxRQUFRRixTQUF6QjswQkFBc0NHLEtBQUtNLE1BQU1ULElBQWpCOzt1QkFFNUI7dUJBQ0NMLFVBQVVjLFdBQVMsT0FBT0EsUUFBUXRCLElBQUlzQixLQUFKOzs7O2VBS3JDWixRQUFBQSxPQUFZQSxRQUFaLE1BQXNCOztrQkFHbEJMLEtBQUs7ZUFDUkE7Ozs7Ozs7O0FDMURSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBbUIsbUJBUU87QUFDUCxZQUF1Qjs7O0FDVHZCLElBQUFDLG1CQUFpRTs7O0FDRWpFLHNCQUF1Qjs7O0FDQXZCLElBQU8sYUFBUSxDQUFDOzs7QUNBaEIsSUFBTyxhQUFRO0FBQUEsRUFFWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixxQkFBcUI7QUFBQSxFQUNyQixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixxQkFBcUI7QUFBQSxFQUdyQixzQkFBc0I7QUFBQSxFQUN0QixjQUFjO0FBQUEsRUFDZCx1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixvQkFBb0I7QUFBQSxFQUNwQixrQkFBa0I7QUFBQSxFQUNsQixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQix3QkFBd0I7QUFBQSxFQUN4QixpQkFBaUI7QUFBQSxFQUNqQixtQkFBbUI7QUFBQSxFQUNuQixnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFHZixjQUFjO0FBQUEsRUFDZCxnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFDZixxQkFBcUI7QUFBQSxFQUNyQix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUd0QixpQkFBaUI7QUFBQSxFQUNqQixZQUFZO0FBQUEsRUFDWixtQkFBbUI7QUFBQSxFQUNuQix3QkFDSTtBQUFBLEVBQ0osWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIsZ0JBQWdCO0FBQUEsRUFDaEIscUJBQ0k7QUFBQSxFQUNKLDBCQUEwQjtBQUFBLEVBQzFCLCtCQUErQjtBQUFBLEVBQy9CLDRCQUNJO0FBQUEsRUFDSixpQ0FDSTtBQUFBLEVBQ0osNkJBQTZCO0FBQUEsRUFDN0Isa0NBQ0k7QUFBQSxFQUNKLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLDJCQUEyQjtBQUFBLEVBQzNCLDhCQUNJO0FBQUEsRUFDSixlQUFlO0FBQUEsRUFDZiwwQkFBMEI7QUFBQSxFQUMxQix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQiw4QkFBOEI7QUFBQSxFQUM5Qiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FBa0M7QUFBQSxFQUNsQyx3QkFBd0I7QUFBQSxFQUN4QixpQ0FDSTtBQUFBLEVBQ0osaUNBQWlDO0FBQUEsRUFDakMsMkJBQTJCO0FBQUEsRUFDM0Isb0NBQW9DO0FBQUEsRUFDcEMsT0FBTztBQUFBLEVBQ1Asd0JBQXdCO0FBQUEsRUFDeEIsZ0JBQWdCO0FBQUEsRUFDaEIscUJBQ0k7QUFBQSxFQUNKLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUF1QjtBQUFBLEVBQ3ZCLGdCQUFnQjtBQUFBLEVBQ2hCLGtDQUNJO0FBQUEsRUFDSix1Q0FDSTtBQUFBLEVBQ0oseUJBQXlCO0FBQUEsRUFDekIsYUFBYTtBQUFBLEVBQ2Isc0JBQXNCO0FBQUEsRUFDdEIsZ0JBQWdCO0FBQUEsRUFDaEIsbUNBQ0k7QUFBQSxFQUNKLHdDQUNJO0FBQUEsRUFDSixXQUFXO0FBQUEsRUFDWCxzQkFBc0I7QUFBQSxFQUN0QixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qiw0QkFBNEI7QUFBQSxFQUM1QixZQUFZO0FBQUEsRUFDWixpQkFDSTtBQUFBLEVBQ0osd0JBQXdCO0FBQUEsRUFDeEIsY0FBYztBQUFBLEVBQ2QsbUJBQW1CO0FBQUEsRUFDbkIsMEJBQTBCO0FBQUEsRUFDMUIsa0JBQWtCO0FBQUEsRUFDbEIsdUJBQ0k7QUFBQSxFQUNKLFNBQVM7QUFBQSxFQUNULG9CQUFvQjtBQUFBLEVBR3BCLG9CQUFvQjtBQUFBLEVBQ3BCLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUdWLGFBQWE7QUFBQSxFQUNiLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLGVBQWU7QUFBQSxFQUNmLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLGlCQUFpQjtBQUFBLEVBQ2pCLGlCQUFpQjtBQUFBLEVBQ2pCLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLE9BQU87QUFBQSxFQUNQLG1CQUFtQjtBQUFBLEVBQ25CLE9BQU87QUFBQSxFQUNQLGVBQWU7QUFBQSxFQUNmLFlBQVk7QUFBQSxFQUNaLGlCQUFpQjtBQUFBLEVBQ2pCLGVBQWU7QUFBQSxFQUNmLGlCQUFpQjtBQUFBLEVBQ2pCLGtCQUFrQjtBQUFBLEVBQ2xCLG9CQUFvQjtBQUN4Qjs7O0FDaEtBLElBQU8sYUFBUSxDQUFDOzs7QUNHaEIsSUFBTyxhQUFRO0FBQUEsRUFFWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixxQkFBcUI7QUFBQSxFQUNyQixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixxQkFBcUI7QUFBQSxFQUdyQixzQkFBc0I7QUFBQSxFQUN0QixjQUFjO0FBQUEsRUFDZCx1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixvQkFBb0I7QUFBQSxFQUNwQixrQkFBa0I7QUFBQSxFQUNsQixZQUFZO0FBQUEsRUFDWixZQUNJO0FBQUEsRUFDSixpQkFBaUI7QUFBQSxFQUNqQix3QkFDSTtBQUFBLEVBQ0osaUJBQ0k7QUFBQSxFQUNKLG1CQUFtQjtBQUFBLEVBQ25CLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUdmLGNBQWM7QUFBQSxFQUNkLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLHFCQUFxQjtBQUFBLEVBQ3JCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBR3RCLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUNJO0FBQUEsRUFDSixZQUFZO0FBQUEsRUFDWixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixnQkFBZ0I7QUFBQSxFQUNoQixxQkFDSTtBQUFBLEVBQ0osMEJBQTBCO0FBQUEsRUFDMUIsK0JBQStCO0FBQUEsRUFDL0IsNEJBQ0k7QUFBQSxFQUNKLGlDQUNJO0FBQUEsRUFDSiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FDSTtBQUFBLEVBQ0osbUJBQW1CO0FBQUEsRUFDbkIsd0JBQXdCO0FBQUEsRUFDeEIsMkJBQTJCO0FBQUEsRUFDM0IsOEJBQ0k7QUFBQSxFQUNKLGVBQWU7QUFBQSxFQUNmLDBCQUEwQjtBQUFBLEVBQzFCLHVCQUNJO0FBQUEsRUFDSixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQiw4QkFBOEI7QUFBQSxFQUM5Qiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FDSTtBQUFBLEVBQ0osd0JBQXdCO0FBQUEsRUFDeEIsaUNBQ0k7QUFBQSxFQUNKLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osZ0JBQWdCO0FBQUEsRUFDaEIsa0NBQ0k7QUFBQSxFQUNKLHVDQUNJO0FBQUEsRUFDSix5QkFDSTtBQUFBLEVBQ0osYUFBYTtBQUFBLEVBQ2Isc0JBQXNCO0FBQUEsRUFDdEIsZ0JBQWdCO0FBQUEsRUFDaEIsbUNBQW1DO0FBQUEsRUFDbkMsd0NBQ0k7QUFBQSxFQUNKLFdBQVc7QUFBQSxFQUNYLHNCQUNJO0FBQUEsRUFDSixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQix1QkFBdUI7QUFBQSxFQUN2Qix1QkFDSTtBQUFBLEVBQ0osNEJBQTRCO0FBQUEsRUFDNUIsWUFBWTtBQUFBLEVBQ1osaUJBQ0k7QUFBQSxFQUNKLHdCQUF3QjtBQUFBLEVBQ3hCLGNBQWM7QUFBQSxFQUNkLG1CQUNJO0FBQUEsRUFDSiwwQkFBMEI7QUFBQSxFQUMxQixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1Qsb0JBQW9CO0FBQUEsRUFHcEIsb0JBQW9CO0FBQUEsRUFDcEIsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBR1YsYUFBYTtBQUFBLEVBQ2IsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04saUJBQWlCO0FBQUEsRUFDakIsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsT0FBTztBQUFBLEVBQ1AsbUJBQW1CO0FBQUEsRUFDbkIsT0FBTztBQUFBLEVBQ1AsZUFBZTtBQUFBLEVBQ2YsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQ3hCOzs7QUM1S0EsSUFBTyxhQUFRO0FBQUEsRUFFWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixxQkFBcUI7QUFBQSxFQUNyQixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixxQkFBcUI7QUFBQSxFQUdyQixzQkFBc0I7QUFBQSxFQUN0QixjQUFjO0FBQUEsRUFDZCx1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixvQkFBb0I7QUFBQSxFQUNwQixrQkFBa0I7QUFBQSxFQUNsQixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQix3QkFBd0I7QUFBQSxFQUN4QixpQkFBaUI7QUFBQSxFQUNqQixtQkFBbUI7QUFBQSxFQUNuQixnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFHZixjQUFjO0FBQUEsRUFDZCxnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFDZixxQkFBcUI7QUFBQSxFQUNyQix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUd0QixpQkFBaUI7QUFBQSxFQUNqQixZQUFZO0FBQUEsRUFDWixtQkFBbUI7QUFBQSxFQUNuQix3QkFBd0I7QUFBQSxFQUN4QixZQUFZO0FBQUEsRUFDWixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixnQkFBZ0I7QUFBQSxFQUNoQixxQkFDSTtBQUFBLEVBQ0osMEJBQTBCO0FBQUEsRUFDMUIsK0JBQStCO0FBQUEsRUFDL0IsNEJBQ0k7QUFBQSxFQUNKLGlDQUNJO0FBQUEsRUFDSiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FDSTtBQUFBLEVBQ0osbUJBQW1CO0FBQUEsRUFDbkIsd0JBQXdCO0FBQUEsRUFDeEIsMkJBQTJCO0FBQUEsRUFDM0IsOEJBQ0k7QUFBQSxFQUNKLGVBQWU7QUFBQSxFQUNmLDBCQUEwQjtBQUFBLEVBQzFCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLDhCQUE4QjtBQUFBLEVBQzlCLDZCQUE2QjtBQUFBLEVBQzdCLGtDQUFrQztBQUFBLEVBQ2xDLHdCQUF3QjtBQUFBLEVBQ3hCLGlDQUNJO0FBQUEsRUFDSixpQ0FBaUM7QUFBQSxFQUNqQywyQkFBMkI7QUFBQSxFQUMzQixvQ0FBb0M7QUFBQSxFQUNwQyxPQUFPO0FBQUEsRUFDUCx3QkFBd0I7QUFBQSxFQUN4QixnQkFBZ0I7QUFBQSxFQUNoQixxQkFBcUI7QUFBQSxFQUNyQixrQkFBa0I7QUFBQSxFQUNsQix1QkFBdUI7QUFBQSxFQUN2QixnQkFBZ0I7QUFBQSxFQUNoQixrQ0FDSTtBQUFBLEVBQ0osdUNBQ0k7QUFBQSxFQUNKLHlCQUF5QjtBQUFBLEVBQ3pCLGFBQWE7QUFBQSxFQUNiLHNCQUFzQjtBQUFBLEVBQ3RCLGdCQUFnQjtBQUFBLEVBQ2hCLG1DQUFtQztBQUFBLEVBQ25DLHdDQUNJO0FBQUEsRUFDSixXQUFXO0FBQUEsRUFDWCxzQkFDSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsdUJBQXVCO0FBQUEsRUFDdkIsdUJBQXVCO0FBQUEsRUFDdkIsNEJBQTRCO0FBQUEsRUFDNUIsWUFBWTtBQUFBLEVBQ1osaUJBQ0k7QUFBQSxFQUNKLHdCQUF3QjtBQUFBLEVBQ3hCLGNBQWM7QUFBQSxFQUNkLG1CQUFtQjtBQUFBLEVBQ25CLDBCQUEwQjtBQUFBLEVBQzFCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUNJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxvQkFBb0I7QUFBQSxFQUdwQixvQkFBb0I7QUFBQSxFQUNwQixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFHVixhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQUEsRUFDZixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixpQkFBaUI7QUFBQSxFQUNqQixpQkFBaUI7QUFBQSxFQUNqQixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQixPQUFPO0FBQUEsRUFDUCxtQkFBbUI7QUFBQSxFQUNuQixPQUFPO0FBQUEsRUFDUCxlQUFlO0FBQUEsRUFDZixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFDZixpQkFBaUI7QUFBQSxFQUNqQixrQkFBa0I7QUFBQSxFQUNsQixvQkFBb0I7QUFDeEI7OztBQzlKQSxJQUFPLGdCQUFRLENBQUM7OztBQ0FoQixJQUFPLGFBQVEsQ0FBQzs7O0FDQWhCLElBQU8sYUFBUSxDQUFDOzs7QUNBaEIsSUFBTyxhQUFRLENBQUM7OztBQ0FoQixJQUFPLGFBQVEsQ0FBQzs7O0FDQWhCLElBQU8sYUFBUSxDQUFDOzs7QUNBaEIsSUFBTyxhQUFRO0FBQUEsRUFFWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixxQkFBcUI7QUFBQSxFQUNyQixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixxQkFBcUI7QUFBQSxFQUdyQixzQkFBc0I7QUFBQSxFQUN0QixjQUFjO0FBQUEsRUFDZCx1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixvQkFBb0I7QUFBQSxFQUNwQixrQkFBa0I7QUFBQSxFQUNsQixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQix3QkFBd0I7QUFBQSxFQUN4QixpQkFDSTtBQUFBLEVBQ0osbUJBQW1CO0FBQUEsRUFDbkIsZ0JBQWdCO0FBQUEsRUFDaEIsZUFBZTtBQUFBLEVBR2YsY0FBYztBQUFBLEVBQ2QsZ0JBQWdCO0FBQUEsRUFDaEIsZUFBZTtBQUFBLEVBQ2YscUJBQXFCO0FBQUEsRUFDckIsdUJBQXVCO0FBQUEsRUFDdkIsc0JBQXNCO0FBQUEsRUFHdEIsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osbUJBQW1CO0FBQUEsRUFDbkIsd0JBQ0k7QUFBQSxFQUNKLFlBQVk7QUFBQSxFQUNaLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSiwwQkFBMEI7QUFBQSxFQUMxQiwrQkFDSTtBQUFBLEVBQ0osNEJBQ0k7QUFBQSxFQUNKLGlDQUNJO0FBQUEsRUFDSiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FDSTtBQUFBLEVBQ0osbUJBQW1CO0FBQUEsRUFDbkIsd0JBQ0k7QUFBQSxFQUNKLDJCQUEyQjtBQUFBLEVBQzNCLDhCQUNJO0FBQUEsRUFDSixlQUFlO0FBQUEsRUFDZiwwQkFBMEI7QUFBQSxFQUMxQix1QkFDSTtBQUFBLEVBQ0osc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsOEJBQThCO0FBQUEsRUFDOUIsNkJBQTZCO0FBQUEsRUFDN0Isa0NBQWtDO0FBQUEsRUFDbEMsd0JBQXdCO0FBQUEsRUFDeEIsaUNBQ0k7QUFBQSxFQUNKLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osZ0JBQWdCO0FBQUEsRUFDaEIsa0NBQ0k7QUFBQSxFQUNKLHVDQUNJO0FBQUEsRUFDSix5QkFBeUI7QUFBQSxFQUN6QixhQUFhO0FBQUEsRUFDYixzQkFBc0I7QUFBQSxFQUN0QixnQkFBZ0I7QUFBQSxFQUNoQixtQ0FBbUM7QUFBQSxFQUNuQyx3Q0FDSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsc0JBQ0k7QUFBQSxFQUNKLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLDRCQUE0QjtBQUFBLEVBQzVCLFlBQVk7QUFBQSxFQUNaLGlCQUNJO0FBQUEsRUFDSix3QkFBd0I7QUFBQSxFQUN4QixjQUFjO0FBQUEsRUFDZCxtQkFBbUI7QUFBQSxFQUNuQiwwQkFBMEI7QUFBQSxFQUMxQixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1Qsb0JBQW9CO0FBQUEsRUFHcEIsb0JBQW9CO0FBQUEsRUFDcEIsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBR1YsYUFBYTtBQUFBLEVBQ2IsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04saUJBQWlCO0FBQUEsRUFDakIsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsT0FBTztBQUFBLEVBQ1AsbUJBQW1CO0FBQUEsRUFDbkIsT0FBTztBQUFBLEVBQ1AsZUFBZTtBQUFBLEVBQ2YsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQ3hCOzs7QUNyS0EsSUFBTyxhQUFRO0FBQUEsRUFFWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixxQkFBcUI7QUFBQSxFQUNyQixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixxQkFBcUI7QUFBQSxFQUdyQixzQkFBc0I7QUFBQSxFQUN0QixjQUFjO0FBQUEsRUFDZCx1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixvQkFBb0I7QUFBQSxFQUNwQixrQkFBa0I7QUFBQSxFQUNsQixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQix3QkFBd0I7QUFBQSxFQUN4QixpQkFBaUI7QUFBQSxFQUNqQixtQkFBbUI7QUFBQSxFQUNuQixnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFHZixjQUFjO0FBQUEsRUFDZCxnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFDZixxQkFBcUI7QUFBQSxFQUNyQix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUd0QixpQkFBaUI7QUFBQSxFQUNqQixZQUFZO0FBQUEsRUFDWixtQkFBbUI7QUFBQSxFQUNuQix3QkFDSTtBQUFBLEVBQ0osWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIsZ0JBQWdCO0FBQUEsRUFDaEIscUJBQ0k7QUFBQSxFQUNKLDBCQUEwQjtBQUFBLEVBQzFCLCtCQUErQjtBQUFBLEVBQy9CLDRCQUNJO0FBQUEsRUFDSixpQ0FDSTtBQUFBLEVBQ0osNkJBQTZCO0FBQUEsRUFDN0Isa0NBQ0k7QUFBQSxFQUNKLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUNJO0FBQUEsRUFDSiwyQkFBMkI7QUFBQSxFQUMzQiw4QkFDSTtBQUFBLEVBQ0osZUFBZTtBQUFBLEVBQ2YsMEJBQTBCO0FBQUEsRUFDMUIsdUJBQXVCO0FBQUEsRUFDdkIsc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsOEJBQThCO0FBQUEsRUFDOUIsNkJBQTZCO0FBQUEsRUFDN0Isa0NBQWtDO0FBQUEsRUFDbEMsd0JBQXdCO0FBQUEsRUFDeEIsaUNBQ0k7QUFBQSxFQUNKLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSixrQkFBa0I7QUFBQSxFQUNsQix1QkFBdUI7QUFBQSxFQUN2QixnQkFBZ0I7QUFBQSxFQUNoQixrQ0FDSTtBQUFBLEVBQ0osdUNBQ0k7QUFBQSxFQUNKLHlCQUF5QjtBQUFBLEVBQ3pCLGFBQWE7QUFBQSxFQUNiLHNCQUFzQjtBQUFBLEVBQ3RCLGdCQUFnQjtBQUFBLEVBQ2hCLG1DQUFtQztBQUFBLEVBQ25DLHdDQUNJO0FBQUEsRUFDSixXQUFXO0FBQUEsRUFDWCxzQkFDSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsdUJBQXVCO0FBQUEsRUFDdkIsdUJBQXVCO0FBQUEsRUFDdkIsNEJBQTRCO0FBQUEsRUFDNUIsWUFBWTtBQUFBLEVBQ1osaUJBQ0k7QUFBQSxFQUNKLHdCQUF3QjtBQUFBLEVBQ3hCLGNBQWM7QUFBQSxFQUNkLG1CQUFtQjtBQUFBLEVBQ25CLDBCQUEwQjtBQUFBLEVBQzFCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUNJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxvQkFBb0I7QUFBQSxFQUdwQixvQkFBb0I7QUFBQSxFQUNwQixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFHVixhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQUEsRUFDZixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixpQkFBaUI7QUFBQSxFQUNqQixpQkFBaUI7QUFBQSxFQUNqQixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQixPQUFPO0FBQUEsRUFDUCxtQkFBbUI7QUFBQSxFQUNuQixPQUFPO0FBQUEsRUFDUCxlQUFlO0FBQUEsRUFDZixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFDZixpQkFBaUI7QUFBQSxFQUNqQixrQkFBa0I7QUFBQSxFQUNsQixvQkFBb0I7QUFDeEI7OztBQ2pLQSxJQUFPLGFBQVEsQ0FBQzs7O0FDQWhCLElBQU8sYUFBUSxDQUFDOzs7QUNBaEIsSUFBTyxhQUFRLENBQUM7OztBQ0FoQixJQUFPLGFBQVEsQ0FBQzs7O0FDQ2hCLElBQU8sZ0JBQVE7QUFBQSxFQUVYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLGFBQWE7QUFBQSxFQUNiLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLHFCQUFxQjtBQUFBLEVBQ3JCLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLGFBQWE7QUFBQSxFQUNiLHFCQUFxQjtBQUFBLEVBR3JCLHNCQUFzQjtBQUFBLEVBQ3RCLGNBQWM7QUFBQSxFQUNkLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLG9CQUFvQjtBQUFBLEVBQ3BCLGtCQUFrQjtBQUFBLEVBQ2xCLFlBQVk7QUFBQSxFQUNaLFlBQ0k7QUFBQSxFQUNKLGlCQUFpQjtBQUFBLEVBQ2pCLHdCQUF3QjtBQUFBLEVBQ3hCLGlCQUFpQjtBQUFBLEVBQ2pCLG1CQUFtQjtBQUFBLEVBQ25CLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUdmLGNBQWM7QUFBQSxFQUNkLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLHFCQUFxQjtBQUFBLEVBQ3JCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBR3RCLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUNJO0FBQUEsRUFDSixZQUFZO0FBQUEsRUFDWixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixxQkFBcUI7QUFBQSxFQUNyQixnQkFBZ0I7QUFBQSxFQUNoQixxQkFDSTtBQUFBLEVBQ0osMEJBQTBCO0FBQUEsRUFDMUIsK0JBQ0k7QUFBQSxFQUNKLDRCQUNJO0FBQUEsRUFDSixpQ0FDSTtBQUFBLEVBQ0osNkJBQTZCO0FBQUEsRUFDN0Isa0NBQ0k7QUFBQSxFQUNKLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLDJCQUEyQjtBQUFBLEVBQzNCLDhCQUNJO0FBQUEsRUFDSixlQUFlO0FBQUEsRUFDZiwwQkFBMEI7QUFBQSxFQUMxQix1QkFDSTtBQUFBLEVBQ0osc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsOEJBQThCO0FBQUEsRUFDOUIsNkJBQTZCO0FBQUEsRUFDN0Isa0NBQWtDO0FBQUEsRUFDbEMsd0JBQXdCO0FBQUEsRUFDeEIsaUNBQ0k7QUFBQSxFQUNKLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osZ0JBQWdCO0FBQUEsRUFDaEIsa0NBQ0k7QUFBQSxFQUNKLHVDQUNJO0FBQUEsRUFDSix5QkFBeUI7QUFBQSxFQUN6QixhQUFhO0FBQUEsRUFDYixzQkFBc0I7QUFBQSxFQUN0QixnQkFBZ0I7QUFBQSxFQUNoQixtQ0FDSTtBQUFBLEVBQ0osd0NBQ0k7QUFBQSxFQUNKLFdBQVc7QUFBQSxFQUNYLHNCQUNJO0FBQUEsRUFDSixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQix1QkFBdUI7QUFBQSxFQUN2Qix1QkFDSTtBQUFBLEVBQ0osNEJBQTRCO0FBQUEsRUFDNUIsWUFBWTtBQUFBLEVBQ1osaUJBQ0k7QUFBQSxFQUNKLHdCQUF3QjtBQUFBLEVBQ3hCLGNBQWM7QUFBQSxFQUNkLG1CQUNJO0FBQUEsRUFDSiwwQkFBMEI7QUFBQSxFQUMxQixrQkFBa0I7QUFBQSxFQUNsQix1QkFDSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1Qsb0JBQW9CO0FBQUEsRUFHcEIsb0JBQW9CO0FBQUEsRUFDcEIsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBR1YsYUFBYTtBQUFBLEVBQ2IsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04saUJBQWlCO0FBQUEsRUFDakIsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsT0FBTztBQUFBLEVBQ1AsbUJBQW1CO0FBQUEsRUFDbkIsT0FBTztBQUFBLEVBQ1AsZUFBZTtBQUFBLEVBQ2YsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQ3hCOzs7QUN4S0EsSUFBTyxhQUFRLENBQUM7OztBQ0doQixJQUFPLGFBQVE7QUFBQSxFQUVYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLGFBQWE7QUFBQSxFQUNiLFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLHFCQUFxQjtBQUFBLEVBQ3JCLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLGFBQWE7QUFBQSxFQUNiLHFCQUFxQjtBQUFBLEVBR3JCLHNCQUFzQjtBQUFBLEVBQ3RCLGNBQWM7QUFBQSxFQUNkLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLG9CQUFvQjtBQUFBLEVBQ3BCLGtCQUFrQjtBQUFBLEVBQ2xCLFlBQVk7QUFBQSxFQUNaLFlBQ0k7QUFBQSxFQUNKLGlCQUFpQjtBQUFBLEVBQ2pCLHdCQUF3QjtBQUFBLEVBQ3hCLGlCQUFpQjtBQUFBLEVBQ2pCLG1CQUFtQjtBQUFBLEVBQ25CLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUdmLGNBQWM7QUFBQSxFQUNkLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLHFCQUFxQjtBQUFBLEVBQ3JCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBR3RCLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLFlBQVk7QUFBQSxFQUNaLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSiwwQkFBMEI7QUFBQSxFQUMxQiwrQkFBK0I7QUFBQSxFQUMvQiw0QkFBNEI7QUFBQSxFQUM1QixpQ0FDSTtBQUFBLEVBQ0osNkJBQTZCO0FBQUEsRUFDN0Isa0NBQ0k7QUFBQSxFQUNKLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLDJCQUEyQjtBQUFBLEVBQzNCLDhCQUNJO0FBQUEsRUFDSixlQUFlO0FBQUEsRUFDZiwwQkFBMEI7QUFBQSxFQUMxQix1QkFBdUI7QUFBQSxFQUN2QixzQkFBc0I7QUFBQSxFQUN0QixxQkFBcUI7QUFBQSxFQUNyQiw4QkFBOEI7QUFBQSxFQUM5Qiw2QkFBNkI7QUFBQSxFQUM3QixrQ0FDSTtBQUFBLEVBQ0osd0JBQXdCO0FBQUEsRUFDeEIsaUNBQ0k7QUFBQSxFQUNKLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUNJO0FBQUEsRUFDSixrQkFBa0I7QUFBQSxFQUNsQix1QkFBdUI7QUFBQSxFQUN2QixnQkFBZ0I7QUFBQSxFQUNoQixrQ0FDSTtBQUFBLEVBQ0osdUNBQ0k7QUFBQSxFQUNKLHlCQUF5QjtBQUFBLEVBQ3pCLGFBQWE7QUFBQSxFQUNiLHNCQUFzQjtBQUFBLEVBQ3RCLGdCQUFnQjtBQUFBLEVBQ2hCLG1DQUNJO0FBQUEsRUFDSix3Q0FDSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsc0JBQ0k7QUFBQSxFQUNKLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUNJO0FBQUEsRUFDSiw0QkFBNEI7QUFBQSxFQUM1QixZQUFZO0FBQUEsRUFDWixpQkFDSTtBQUFBLEVBQ0osd0JBQXdCO0FBQUEsRUFDeEIsY0FBYztBQUFBLEVBQ2QsbUJBQ0k7QUFBQSxFQUNKLDBCQUEwQjtBQUFBLEVBQzFCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUNJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxvQkFBb0I7QUFBQSxFQUdwQixvQkFBb0I7QUFBQSxFQUNwQixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFHVixhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQUEsRUFDZixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixpQkFBaUI7QUFBQSxFQUNqQixpQkFBaUI7QUFBQSxFQUNqQixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQixPQUFPO0FBQUEsRUFDUCxtQkFBbUI7QUFBQSxFQUNuQixPQUFPO0FBQUEsRUFDUCxlQUFlO0FBQUEsRUFDZixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFDZixpQkFBaUI7QUFBQSxFQUNqQixrQkFBa0I7QUFBQSxFQUNsQixvQkFBb0I7QUFDeEI7OztBQ3RLQSxJQUFPLGFBQVEsQ0FBQzs7O0FDQWhCLElBQU8sZ0JBQVE7QUFBQSxFQUVYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLGFBQWE7QUFBQSxFQUNiLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLHFCQUFxQjtBQUFBLEVBQ3JCLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLGFBQWE7QUFBQSxFQUNiLHFCQUFxQjtBQUFBLEVBR3JCLHNCQUFzQjtBQUFBLEVBQ3RCLGNBQWM7QUFBQSxFQUNkLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLG9CQUFvQjtBQUFBLEVBQ3BCLGtCQUFrQjtBQUFBLEVBQ2xCLFlBQVk7QUFBQSxFQUNaLFlBQVk7QUFBQSxFQUNaLGlCQUFpQjtBQUFBLEVBQ2pCLHdCQUF3QjtBQUFBLEVBQ3hCLGlCQUFpQjtBQUFBLEVBQ2pCLG1CQUFtQjtBQUFBLEVBQ25CLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUdmLGNBQWM7QUFBQSxFQUNkLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLHFCQUFxQjtBQUFBLEVBQ3JCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBR3RCLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLFlBQVk7QUFBQSxFQUNaLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUFxQjtBQUFBLEVBQ3JCLDBCQUEwQjtBQUFBLEVBQzFCLCtCQUErQjtBQUFBLEVBQy9CLDRCQUE0QjtBQUFBLEVBQzVCLGlDQUFpQztBQUFBLEVBQ2pDLDZCQUE2QjtBQUFBLEVBQzdCLGtDQUFrQztBQUFBLEVBQ2xDLG1CQUFtQjtBQUFBLEVBQ25CLHdCQUF3QjtBQUFBLEVBQ3hCLDJCQUEyQjtBQUFBLEVBQzNCLDhCQUE4QjtBQUFBLEVBQzlCLGVBQWU7QUFBQSxFQUNmLDBCQUEwQjtBQUFBLEVBQzFCLHVCQUF1QjtBQUFBLEVBQ3ZCLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLDhCQUE4QjtBQUFBLEVBQzlCLDZCQUE2QjtBQUFBLEVBQzdCLGtDQUFrQztBQUFBLEVBQ2xDLHdCQUF3QjtBQUFBLEVBQ3hCLGlDQUFpQztBQUFBLEVBQ2pDLGlDQUFpQztBQUFBLEVBQ2pDLDJCQUEyQjtBQUFBLEVBQzNCLG9DQUFvQztBQUFBLEVBQ3BDLE9BQU87QUFBQSxFQUNQLHdCQUF3QjtBQUFBLEVBQ3hCLGdCQUFnQjtBQUFBLEVBQ2hCLHFCQUFxQjtBQUFBLEVBQ3JCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUF1QjtBQUFBLEVBQ3ZCLGdCQUFnQjtBQUFBLEVBQ2hCLGtDQUFrQztBQUFBLEVBQ2xDLHVDQUNJO0FBQUEsRUFDSix5QkFBeUI7QUFBQSxFQUN6QixhQUFhO0FBQUEsRUFDYixzQkFBc0I7QUFBQSxFQUN0QixnQkFBZ0I7QUFBQSxFQUNoQixtQ0FBbUM7QUFBQSxFQUNuQyx3Q0FDSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsc0JBQXNCO0FBQUEsRUFDdEIsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsdUJBQXVCO0FBQUEsRUFDdkIsdUJBQXVCO0FBQUEsRUFDdkIsNEJBQTRCO0FBQUEsRUFDNUIsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsd0JBQXdCO0FBQUEsRUFDeEIsY0FBYztBQUFBLEVBQ2QsbUJBQW1CO0FBQUEsRUFDbkIsMEJBQTBCO0FBQUEsRUFDMUIsa0JBQWtCO0FBQUEsRUFDbEIsdUJBQXVCO0FBQUEsRUFDdkIsU0FBUztBQUFBLEVBQ1Qsb0JBQW9CO0FBQUEsRUFHcEIsb0JBQW9CO0FBQUEsRUFDcEIsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBR1YsYUFBYTtBQUFBLEVBQ2IsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04saUJBQWlCO0FBQUEsRUFDakIsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsT0FBTztBQUFBLEVBQ1AsbUJBQW1CO0FBQUEsRUFDbkIsT0FBTztBQUFBLEVBQ1AsZUFBZTtBQUFBLEVBQ2YsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQ3hCOzs7QUNwSkEsSUFBTyxnQkFBUTtBQUFBLEVBRVgsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsV0FBVztBQUFBLEVBQ1gsYUFBYTtBQUFBLEVBQ2IsWUFBWTtBQUFBLEVBQ1osTUFBTTtBQUFBLEVBQ04scUJBQXFCO0FBQUEsRUFDckIsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sYUFBYTtBQUFBLEVBQ2IscUJBQXFCO0FBQUEsRUFHckIsc0JBQXNCO0FBQUEsRUFDdEIsY0FBYztBQUFBLEVBQ2QsdUJBQXVCO0FBQUEsRUFDdkIsdUJBQXVCO0FBQUEsRUFDdkIsdUJBQXVCO0FBQUEsRUFDdkIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsb0JBQW9CO0FBQUEsRUFDcEIsa0JBQWtCO0FBQUEsRUFDbEIsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsd0JBQXdCO0FBQUEsRUFDeEIsaUJBQWlCO0FBQUEsRUFDakIsbUJBQW1CO0FBQUEsRUFDbkIsZ0JBQWdCO0FBQUEsRUFDaEIsZUFBZTtBQUFBLEVBR2YsY0FBYztBQUFBLEVBQ2QsZ0JBQWdCO0FBQUEsRUFDaEIsZUFBZTtBQUFBLEVBQ2YscUJBQXFCO0FBQUEsRUFDckIsdUJBQXVCO0FBQUEsRUFDdkIsc0JBQXNCO0FBQUEsRUFHdEIsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osbUJBQW1CO0FBQUEsRUFDbkIsd0JBQXdCO0FBQUEsRUFDeEIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIsc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIsZ0JBQWdCO0FBQUEsRUFDaEIscUJBQXFCO0FBQUEsRUFDckIsMEJBQTBCO0FBQUEsRUFDMUIsK0JBQStCO0FBQUEsRUFDL0IsNEJBQTRCO0FBQUEsRUFDNUIsaUNBQWlDO0FBQUEsRUFDakMsNkJBQTZCO0FBQUEsRUFDN0Isa0NBQWtDO0FBQUEsRUFDbEMsbUJBQW1CO0FBQUEsRUFDbkIsd0JBQXdCO0FBQUEsRUFDeEIsMkJBQTJCO0FBQUEsRUFDM0IsOEJBQThCO0FBQUEsRUFDOUIsZUFBZTtBQUFBLEVBQ2YsMEJBQTBCO0FBQUEsRUFDMUIsdUJBQXVCO0FBQUEsRUFDdkIsc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsOEJBQThCO0FBQUEsRUFDOUIsNkJBQTZCO0FBQUEsRUFDN0Isa0NBQWtDO0FBQUEsRUFDbEMsd0JBQXdCO0FBQUEsRUFDeEIsaUNBQWlDO0FBQUEsRUFDakMsaUNBQWlDO0FBQUEsRUFDakMsMkJBQTJCO0FBQUEsRUFDM0Isb0NBQW9DO0FBQUEsRUFDcEMsT0FBTztBQUFBLEVBQ1Asd0JBQXdCO0FBQUEsRUFDeEIsZ0JBQWdCO0FBQUEsRUFDaEIscUJBQXFCO0FBQUEsRUFDckIsa0JBQWtCO0FBQUEsRUFDbEIsdUJBQXVCO0FBQUEsRUFDdkIsZ0JBQWdCO0FBQUEsRUFDaEIsa0NBQWtDO0FBQUEsRUFDbEMsdUNBQXVDO0FBQUEsRUFDdkMseUJBQXlCO0FBQUEsRUFDekIsYUFBYTtBQUFBLEVBQ2Isc0JBQXNCO0FBQUEsRUFDdEIsZ0JBQWdCO0FBQUEsRUFDaEIsbUNBQW1DO0FBQUEsRUFDbkMsd0NBQ0k7QUFBQSxFQUNKLFdBQVc7QUFBQSxFQUNYLHNCQUFzQjtBQUFBLEVBQ3RCLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLHVCQUF1QjtBQUFBLEVBQ3ZCLHVCQUF1QjtBQUFBLEVBQ3ZCLDRCQUE0QjtBQUFBLEVBQzVCLFlBQVk7QUFBQSxFQUNaLGlCQUFpQjtBQUFBLEVBQ2pCLHdCQUF3QjtBQUFBLEVBQ3hCLGNBQWM7QUFBQSxFQUNkLG1CQUFtQjtBQUFBLEVBQ25CLDBCQUEwQjtBQUFBLEVBQzFCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUNJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxvQkFBb0I7QUFBQSxFQUdwQixvQkFBb0I7QUFBQSxFQUNwQixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFHVixhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQUEsRUFDZixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixpQkFBaUI7QUFBQSxFQUNqQixpQkFBaUI7QUFBQSxFQUNqQixXQUFXO0FBQUEsRUFDWCxnQkFBZ0I7QUFBQSxFQUNoQixPQUFPO0FBQUEsRUFDUCxtQkFBbUI7QUFBQSxFQUNuQixPQUFPO0FBQUEsRUFDUCxlQUFlO0FBQUEsRUFDZixZQUFZO0FBQUEsRUFDWixpQkFBaUI7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFDZixpQkFBaUI7QUFBQSxFQUNqQixrQkFBa0I7QUFBQSxFQUNsQixvQkFBb0I7QUFDeEI7OztBdkIzSE8sSUFBTSxZQUFpRDtBQUFBLEVBQzFEO0FBQUEsRUFDQSxJQUFJO0FBQUEsRUFDSjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSxTQUFTO0FBQUEsRUFDVDtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBLElBQUk7QUFBQSxFQUNKO0FBQUEsRUFDQTtBQUFBLEVBQ0EsU0FBUztBQUFBLEVBQ1Q7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUNiO0FBRUEsSUFBTSxTQUFTLFVBQVUsdUJBQU8sT0FBTztBQUd2QyxTQUFTLFlBQVksS0FBYSxRQUF5QztBQUN2RSxRQUFNQyxTQUFrQixPQUFPLEtBQUssTUFBTTtBQUMxQyxRQUFNLE9BQWtCLE9BQU8sT0FBTyxNQUFNO0FBQzVDLFNBQU8sSUFBSSxTQUFTLEdBQUdBLFFBQU8sWUFBWSxRQUFRLEVBQUUsR0FBRyxJQUFJO0FBQy9EO0FBRU8sU0FBUyxFQUFFLEtBQXNCLFFBQTBDO0FBQzlFLE1BQUksQ0FBQyxRQUFRO0FBQ1QsWUFBUSxNQUFNLHFCQUFxQix1QkFBTyxPQUFPLGNBQWM7QUFBQSxFQUNuRTtBQUVBLFFBQU0sU0FBVSxVQUFVLE9BQU8sUUFBUyxXQUFHO0FBRTdDLE1BQUksUUFBUTtBQUNSLFdBQU8sWUFBWSxRQUFRLE1BQU07QUFBQSxFQUNyQztBQUVBLFNBQU87QUFDWDs7O0FEN0JPLElBQU0sbUJBQStCO0FBQUEsRUFFeEMsbUJBQW1CLEVBQUUsTUFBTTtBQUFBLEVBQzNCLG1CQUFtQixFQUFFLE1BQU07QUFBQSxFQUMzQixtQkFBbUIsRUFBRSxNQUFNO0FBQUEsRUFDM0IsZUFBZSxDQUFDLGFBQWE7QUFBQSxFQUM3Qix1QkFBdUI7QUFBQSxFQUN2Qix1QkFBdUI7QUFBQSxFQUN2QixrQkFBa0I7QUFBQSxFQUNsQixvQkFBb0I7QUFBQSxFQUNwQiwyQkFBMkIsMEJBQVMsV0FBVyxNQUFNO0FBQUEsRUFDckQsMEJBQTBCLDBCQUFTLFdBQVcsTUFBTTtBQUFBLEVBQ3BELHdCQUF3QjtBQUFBLEVBQ3hCLG9CQUFvQjtBQUFBLEVBQ3BCLDJCQUEyQjtBQUFBLEVBQzNCLHlCQUF5QjtBQUFBLEVBQ3pCLDhCQUE4QjtBQUFBLEVBQzlCLHlCQUF5QjtBQUFBLEVBQ3pCLGlDQUFpQztBQUFBLEVBQ2pDLHdCQUF3QjtBQUFBLEVBQ3hCLGdDQUFnQztBQUFBLEVBRWhDLCtCQUErQjtBQUFBLEVBQy9CLGNBQWMsQ0FBQyxTQUFTO0FBQUEsRUFDeEIscUJBQXFCLENBQUM7QUFBQSxFQUN0QixnQkFBZ0I7QUFBQSxFQUNoQixjQUFjO0FBQUEsRUFDZCw4QkFBOEI7QUFBQSxFQUM5QiwwQkFBMEI7QUFBQSxFQUUxQixrQ0FBa0M7QUFBQSxFQUVsQyxVQUFVO0FBQUEsRUFDVixzQkFBc0I7QUFBQSxFQUN0QixXQUFXO0FBQUEsRUFDWCxpQkFBaUI7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFFZixtQkFBbUI7QUFDdkI7QUFHQSxJQUFJLHFCQUFxQjtBQUN6QixTQUFTLG9CQUFvQkMsV0FBNEI7QUFDckQsZUFBYSxrQkFBa0I7QUFDL0IsdUJBQXFCLE9BQU8sV0FBV0EsV0FBVSxHQUFHO0FBQ3hEO0FBRU8sSUFBTSxlQUFOLGNBQTJCLGtDQUFpQjtBQUFBLEVBRy9DLFlBQVlDLE1BQVUsUUFBa0I7QUFDcEMsVUFBTUEsTUFBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2xCO0FBQUEsRUFFQSxVQUFnQjtBQUNaLFVBQU0sRUFBRSxZQUFZLElBQUk7QUFFeEIsZ0JBQVksTUFBTTtBQUVsQixnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxpQkFBaUIsSUFBSSxDQUFDO0FBRTlELGdCQUFZLFVBQVUsRUFBRSxZQUFZLEVBQUUsY0FBYztBQUFBLE1BQ2hELFVBQVU7QUFBQSxJQUNkLENBQUM7QUFFRCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLG1CQUFtQixDQUFDLEVBQzlCLFFBQVEsRUFBRSx3QkFBd0IsQ0FBQyxFQUNuQztBQUFBLE1BQVksQ0FBQyxTQUNWLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUFvQixLQUFLLElBQUksQ0FBQyxFQUNqRSxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLHNCQUFzQixNQUMzQyxNQUFNLEtBQUssRUFDWCxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUNuQixPQUFPLENBQUMsTUFBTSxDQUFDO0FBQ3BCLGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1Q7QUFFSixnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxZQUFZLElBQUksQ0FBQztBQUV6RCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLEVBQzNCLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVksQ0FBQyxTQUNWLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGNBQWMsS0FBSyxHQUFHLENBQUMsRUFDMUQsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsTUFBTSxNQUFNLEtBQUs7QUFDM0QsZ0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUNyQyxDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsMEJBQTBCLENBQUMsRUFDckMsUUFBUSxFQUFFLCtCQUErQixDQUFDLEVBQzFDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMscUJBQXFCLEVBQ3hELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsd0JBQXdCO0FBQ2xELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsNEJBQTRCLENBQUMsRUFDdkMsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLEVBQzVDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMscUJBQXFCLEVBQ3hELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsd0JBQXdCO0FBQ2xELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsNkJBQTZCLENBQUMsRUFDeEMsUUFBUSxFQUFFLGtDQUFrQyxDQUFDLEVBQzdDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLEVBQ25ELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsbUJBQW1CO0FBQzdDLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsbUJBQW1CLENBQUMsRUFDOUIsUUFBUSxFQUFFLHdCQUF3QixDQUFDLEVBQ25DO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsa0JBQWtCLEVBQ3JELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMscUJBQXFCO0FBQy9DLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsMkJBQTJCLENBQUMsRUFDdEMsUUFBUSxFQUFFLDhCQUE4QixDQUFDLEVBQ3pDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxVQUFVLElBQUksS0FBSyxDQUFDLEVBQ3BCLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyx5QkFBeUIsRUFDNUQsa0JBQWtCLEVBQ2xCLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsNEJBQTRCO0FBQ3RELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyw0QkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsMEJBQTBCLENBQUMsRUFDckMsUUFBUSxFQUFFLDhCQUE4QixDQUFDLEVBQ3pDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxVQUFVLElBQUksS0FBSyxDQUFDLEVBQ3BCLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyx3QkFBd0IsRUFDM0Qsa0JBQWtCLEVBQ2xCLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsMkJBQTJCO0FBQ3JELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUywyQkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSx1QkFBdUIsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQ3BFLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHNCQUFzQixFQUN6RCxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLHlCQUF5QjtBQUNuRCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFQSxRQUFJLHlCQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsc0JBQXNCLENBQUMsRUFBRTtBQUFBLE1BQVUsQ0FBQyxXQUNuRSxPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxrQkFBa0IsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxxQkFBcUI7QUFDL0MsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQUUsUUFBUSxFQUFFLDhCQUE4QixDQUFDLEVBQUU7QUFBQSxNQUFVLENBQUMsV0FDM0UsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMseUJBQXlCLEVBQzVELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsNEJBQTRCO0FBQ3RELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVBLFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSw2QkFBNkIsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQzFFLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixFQUMxRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLDBCQUEwQjtBQUNwRCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFQSxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGtDQUFrQyxDQUFDLEVBQzdDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsNEJBQTRCLEVBQy9ELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsK0JBQStCO0FBQ3pELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsd0JBQXdCLENBQUMsRUFDbkMsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLEVBQzVDO0FBQUEsTUFBUSxDQUFDLFNBQ04sS0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsdUJBQXVCLEVBQzFELFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsMEJBQTBCO0FBQ3BELGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsMEJBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLEVBQzVDLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLCtCQUErQixFQUNsRSxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLGtDQUFrQztBQUM1RCxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLGtDQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUNqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxFQUN0QyxRQUFRLEVBQUUsaUNBQWlDLENBQUMsRUFDNUM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxzQkFBc0IsRUFDekQsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyx5QkFBeUI7QUFDbkQsZ0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUNyQyxDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyx5QkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsb0NBQW9DLENBQUMsRUFDL0MsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLEVBQzVDO0FBQUEsTUFBUSxDQUFDLFNBQ04sS0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsOEJBQThCLEVBQ2pFLFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsaUNBQWlDO0FBQzNELGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsaUNBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHNCQUFzQixDQUFDLEVBQ2pDLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxVQUFVO0FBQzNFLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsb0JBQW9CO0FBQzlDLGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0wsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsb0JBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHNCQUFzQixDQUFDLEVBQ2pDLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxVQUFVO0FBQzNFLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsb0JBQW9CO0FBQzlDLGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0wsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsb0JBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHNCQUFzQixDQUFDLEVBQ2pDLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxVQUFVO0FBQzNFLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsb0JBQW9CO0FBQzlDLGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0wsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsb0JBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxPQUFPLElBQUksQ0FBQztBQUVwRCxRQUFJLHlCQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsd0JBQXdCLENBQUMsRUFBRTtBQUFBLE1BQVUsQ0FBQyxXQUNyRSxPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyw2QkFBNkIsRUFDaEUsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxnQ0FBZ0M7QUFDMUQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxFQUMzQixRQUFRLEVBQUUscUJBQXFCLENBQUMsRUFDaEM7QUFBQSxNQUFZLENBQUMsU0FDVixLQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxhQUFhLEtBQUssR0FBRyxDQUFDLEVBQ3pELFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsZUFBZSxNQUFNLE1BQU0sS0FBSztBQUMxRCxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxFQUM3QixRQUFRLEVBQUUsdUJBQXVCLENBQUMsRUFDbEM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxjQUFjLEVBQ2pELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCO0FBQzNDLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQzdELE9BQU8sU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVksRUFBRSxTQUFTLE9BQU8sVUFBVTtBQUM5RSxhQUFLLE9BQU8sS0FBSyxTQUFTLGVBQWU7QUFDekMsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNMO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxrQ0FBa0MsQ0FBQyxFQUM3QyxRQUFRLEVBQUUsdUNBQXVDLENBQUMsRUFDbEQ7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyw0QkFBNEIsRUFDL0QsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUywrQkFBK0I7QUFDekQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSx5QkFBeUIsQ0FBQyxFQUNwQztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHlCQUF5QixTQUFTLENBQUMsRUFDdEUsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZ0JBQU0sV0FBbUIsT0FBTyxTQUFTLEtBQUs7QUFDOUMsY0FBSSxDQUFDLE1BQU0sUUFBUSxHQUFHO0FBQ2xCLGdCQUFJLFdBQVcsR0FBRztBQUNkLGtCQUFJLHdCQUFPLEVBQUUsYUFBYSxDQUFDO0FBQzNCLG1CQUFLO0FBQUEsZ0JBQ0QsS0FBSyxPQUFPLEtBQUssU0FBUyx5QkFBeUIsU0FBUztBQUFBLGNBQ2hFO0FBQ0E7QUFBQSxZQUNKO0FBRUEsaUJBQUssT0FBTyxLQUFLLFNBQVMsMkJBQTJCO0FBQ3JELGtCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsVUFDckMsT0FBTztBQUNILGdCQUFJLHdCQUFPLEVBQUUsc0JBQXNCLENBQUM7QUFBQSxVQUN4QztBQUFBLFFBQ0osQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsMkJBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxDQUFDO0FBRTdELFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsbUNBQW1DLENBQUMsRUFDOUMsUUFBUSxFQUFFLHdDQUF3QyxDQUFDLEVBQ25EO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsZ0NBQWdDLEVBQ25FLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsbUNBQW1DO0FBQzdELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sR0FBRyxFQUFFLFdBQVcsSUFBSSxDQUFDO0FBQ3hELGdCQUFZLFVBQVUsRUFBRSxZQUFZLEVBQUUsd0JBQXdCO0FBQUEsTUFDMUQsVUFDSTtBQUFBLElBQ1IsQ0FBQztBQUVELFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsV0FBVyxDQUFDLEVBQ3RCLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxFQUMzQjtBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLFNBQVMsU0FBUyxDQUFDLEVBQUUsU0FBUyxDQUFDLFVBQVU7QUFDN0UsNEJBQW9CLFlBQVk7QUFDNUIsZ0JBQU0sV0FBbUIsT0FBTyxTQUFTLEtBQUs7QUFDOUMsY0FBSSxDQUFDLE1BQU0sUUFBUSxHQUFHO0FBQ2xCLGdCQUFJLFdBQVcsS0FBSztBQUNoQixrQkFBSSx3QkFBTyxFQUFFLHVCQUF1QixDQUFDO0FBQ3JDLG1CQUFLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxTQUFTLFNBQVMsQ0FBQztBQUMzRDtBQUFBLFlBQ0o7QUFFQSxpQkFBSyxPQUFPLEtBQUssU0FBUyxXQUFXO0FBQ3JDLGtCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsVUFDckMsT0FBTztBQUNILGdCQUFJLHdCQUFPLEVBQUUsc0JBQXNCLENBQUM7QUFBQSxVQUN4QztBQUFBLFFBQ0osQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0wsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsV0FBVyxpQkFBaUI7QUFDdEQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUNqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSx1QkFBdUIsQ0FBQyxFQUNsQyxRQUFRLEVBQUUsNEJBQTRCLENBQUMsRUFDdkM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFDbEIsU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixHQUFHLEVBQzdELGtCQUFrQixFQUNsQixTQUFTLE9BQU8sVUFBa0I7QUFDL0IsYUFBSyxPQUFPLEtBQUssU0FBUyx1QkFBdUIsUUFBUTtBQUN6RCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsdUJBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLFlBQVksQ0FBQyxFQUN2QixRQUFRLEVBQUUsaUJBQWlCLENBQUMsRUFDNUI7QUFBQSxNQUFRLENBQUMsU0FDTixLQUNLLFVBQVUsS0FBSyxPQUFPLEtBQUssU0FBUyxZQUFZLEtBQUssU0FBUyxDQUFDLEVBQy9ELFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGdCQUFNLFdBQW1CLE9BQU8sU0FBUyxLQUFLLElBQUk7QUFDbEQsY0FBSSxDQUFDLE1BQU0sUUFBUSxHQUFHO0FBQ2xCLGdCQUFJLFdBQVcsR0FBSztBQUNoQixrQkFBSSx3QkFBTyxFQUFFLHdCQUF3QixDQUFDO0FBQ3RDLG1CQUFLO0FBQUEsaUJBQ0EsS0FBSyxPQUFPLEtBQUssU0FBUyxZQUFZLEtBQUssU0FBUztBQUFBLGNBQ3pEO0FBQ0E7QUFBQSxZQUNKO0FBRUEsaUJBQUssT0FBTyxLQUFLLFNBQVMsWUFBWTtBQUN0QyxrQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFVBQ3JDLE9BQU87QUFDSCxnQkFBSSx3QkFBTyxFQUFFLHNCQUFzQixDQUFDO0FBQUEsVUFDeEM7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVksaUJBQWlCO0FBQ3ZELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsY0FBYyxDQUFDLEVBQ3pCLFFBQVEsRUFBRSxtQkFBbUIsQ0FBQyxFQUM5QjtBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGdCQUFnQixTQUFTLENBQUMsRUFDN0QsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZ0JBQU0sV0FBbUIsT0FBTyxTQUFTLEtBQUs7QUFDOUMsY0FBSSxDQUFDLE1BQU0sUUFBUSxHQUFHO0FBQ2xCLGdCQUFJLFdBQVcsR0FBRztBQUNkLGtCQUFJLHdCQUFPLEVBQUUsMEJBQTBCLENBQUM7QUFDeEMsbUJBQUs7QUFBQSxnQkFDRCxLQUFLLE9BQU8sS0FBSyxTQUFTLGdCQUFnQixTQUFTO0FBQUEsY0FDdkQ7QUFDQTtBQUFBLFlBQ0o7QUFFQSxpQkFBSyxPQUFPLEtBQUssU0FBUyxrQkFBa0I7QUFDNUMsa0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxVQUNyQyxPQUFPO0FBQ0gsZ0JBQUksd0JBQU8sRUFBRSxzQkFBc0IsQ0FBQztBQUFBLFVBQ3hDO0FBQUEsUUFDSixDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyxrQkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsa0JBQWtCLENBQUMsRUFDN0IsUUFBUSxFQUFFLHVCQUF1QixDQUFDLEVBQ2xDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxVQUFVLEdBQUcsS0FBSyxDQUFDLEVBQ25CLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsR0FBRyxFQUN0RCxrQkFBa0IsRUFDbEIsU0FBUyxPQUFPLFVBQWtCO0FBQy9CLGFBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLFFBQVE7QUFDbEQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLGdCQUFnQixpQkFBaUI7QUFDM0QsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUNqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxHQUFHLEVBQUUsU0FBUyxJQUFJLENBQUM7QUFDdEQsUUFBSSx5QkFBUSxXQUFXLEVBQUUsUUFBUSxFQUFFLG9CQUFvQixDQUFDLEVBQUU7QUFBQSxNQUFVLENBQUMsV0FDakUsT0FBTyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCLEVBQUUsU0FBUyxPQUFPLFVBQVU7QUFDbkYsYUFBSyxPQUFPLEtBQUssU0FBUyxvQkFBb0I7QUFDOUMsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNMO0FBQUEsRUFDSjtBQUNKOzs7QXlCanVCQSxJQUFBQyxtQkFTTztBQUVQLG1CQUFjOzs7QUNnQ1AsU0FBUyxTQUNaLFVBQ0EsVUFDQSxNQUNBLG1CQUNBLGFBQ0EsVUFDc0I7QUFDdEIsc0JBQW9CLEtBQUssSUFBSSxHQUFHLEtBQUssTUFBTSxxQkFBcUIsS0FBSyxPQUFPLElBQUssQ0FBQztBQUVsRixNQUFJLGFBQWEsY0FBcUI7QUFDbEMsWUFBUTtBQUNSLGdCQUFhLFdBQVcscUJBQXFCLE9BQVE7QUFDckQsZ0JBQVksWUFBWTtBQUFBLEVBQzVCLFdBQVcsYUFBYSxjQUFxQjtBQUN6QyxnQkFBYSxXQUFXLG9CQUFvQixLQUFLLE9BQVE7QUFBQSxFQUM3RCxXQUFXLGFBQWEsY0FBcUI7QUFDekMsV0FBTyxLQUFLLElBQUksS0FBSyxPQUFPLEVBQUU7QUFDOUIsZUFBVyxLQUFLO0FBQUEsTUFDWjtBQUFBLE9BQ0MsV0FBVyxvQkFBb0IsS0FBSyxZQUFZO0FBQUEsSUFDckQ7QUFBQSxFQUNKO0FBR0EsTUFBSSxhQUFhLFFBQVc7QUFDeEIsZUFBVyxLQUFLLE1BQU0sUUFBUTtBQUM5QixRQUFJLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxVQUFVLFFBQVEsR0FBRztBQUMzRCxlQUFTLFlBQVk7QUFBQSxJQUN6QixPQUFPO0FBRUgsVUFBSSxXQUFXLEdBQUc7QUFDZCxZQUFJLE9BQU87QUFDWCxZQUFJLFdBQVc7QUFBRyxpQkFBTztBQUFBLGlCQUNoQixXQUFXO0FBQUksaUJBQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxNQUFNLFdBQVcsSUFBSSxDQUFDO0FBQUE7QUFDakUsaUJBQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxNQUFNLFdBQVcsSUFBSSxDQUFDO0FBRW5ELGNBQU0sbUJBQW1CO0FBQ3pCO0FBQU8sbUJBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxLQUFLO0FBQ25DLHVCQUFXLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHO0FBQzVELGtCQUFJLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxVQUFVLEdBQUcsR0FBRztBQUN0RCx5QkFBUyxPQUFPO0FBQ2hCLDJCQUFXO0FBQ1gsc0JBQU07QUFBQSxjQUNWO0FBQ0Esa0JBQUksU0FBUyxPQUFPLFNBQVM7QUFBVywyQkFBVztBQUFBLFlBQ3ZEO0FBQUEsVUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsYUFBUztBQUFBLEVBQ2I7QUFFQSxhQUFXLEtBQUssSUFBSSxVQUFVLFlBQVksZUFBZTtBQUV6RCxTQUFPLEVBQUUsVUFBVSxLQUFLLE1BQU0sV0FBVyxFQUFFLElBQUksSUFBSSxLQUFLO0FBQzVEO0FBRU8sU0FBUyxhQUFhLFVBQWtCLFVBQTJCO0FBQ3RFLFFBQU0sSUFBWSxLQUFLLE1BQU0sV0FBVyxPQUFPLElBQUksSUFDL0MsSUFBWSxLQUFLLE1BQU0sV0FBVyxNQUFNLElBQUk7QUFFaEQsTUFBSSxVQUFVO0FBQ1YsUUFBSSxJQUFJO0FBQUssYUFBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsQ0FBQztBQUFBLGFBQ2hELElBQUk7QUFBSyxhQUFPLEVBQUUseUJBQXlCLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFBQTtBQUM5RCxhQUFPLEVBQUUsd0JBQXdCLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFBQSxFQUN6RCxPQUFPO0FBQ0gsUUFBSSxJQUFJO0FBQUssYUFBTyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsQ0FBQztBQUFBLGFBQ3pDLElBQUk7QUFBSyxhQUFPLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFBQTtBQUN2RCxhQUFPLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFBQSxFQUNsRDtBQUNKOzs7QUNuSE8sSUFBTSx3QkFDVDtBQUNHLElBQU0sMEJBQTBCO0FBRWhDLElBQU0sNkJBQTZCO0FBQ25DLElBQU0sOEJBQThCO0FBRXBDLElBQU0sZ0JBQWdCLENBQUMsT0FBTyxRQUFRLE9BQU8sT0FBTyxLQUFLO0FBQ3pELElBQU0sZ0JBQWdCLENBQUMsT0FBTyxRQUFRLE9BQU8sT0FBTyxLQUFLO0FBQ3pELElBQU0sZ0JBQWdCLENBQUMsT0FBTyxPQUFPLE9BQU8sS0FBSztBQUlqRCxJQUFNLGdCQUNUOzs7QUNORyxTQUFTLHNCQUFnRCxLQUFrQztBQUM5RixTQUFPLE9BQU8sUUFBUSxHQUFHO0FBQzdCO0FBVU8sSUFBTSxzQkFBc0IsT0FBTztBQWFuQyxJQUFNLG9CQUFvQixDQUFDLFNBQzlCLEtBQUssUUFBUSx1QkFBdUIsTUFBTTtBQVV2QyxTQUFTLE9BQU8sS0FBYSxPQUFPLEdBQVc7QUFDbEQsTUFBSUMsTUFBVSxhQUFhLE1BQ3ZCQyxNQUFVLGFBQWE7QUFDM0IsV0FBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ3JDLFNBQUssSUFBSSxXQUFXLENBQUM7QUFDckIsSUFBQUQsTUFBSyxLQUFLLEtBQUtBLE1BQUssSUFBSSxVQUFVO0FBQ2xDLElBQUFDLE1BQUssS0FBSyxLQUFLQSxNQUFLLElBQUksVUFBVTtBQUFBLEVBQ3RDO0FBQ0EsRUFBQUQsTUFBSyxLQUFLLEtBQUtBLE1BQU1BLFFBQU8sSUFBSyxVQUFVLElBQUksS0FBSyxLQUFLQyxNQUFNQSxRQUFPLElBQUssVUFBVTtBQUNyRixFQUFBQSxNQUFLLEtBQUssS0FBS0EsTUFBTUEsUUFBTyxJQUFLLFVBQVUsSUFBSSxLQUFLLEtBQUtELE1BQU1BLFFBQU8sSUFBSyxVQUFVO0FBQ3JGLFVBQVEsY0FBYyxVQUFVQyxRQUFPRCxRQUFPLElBQUksU0FBUyxFQUFFO0FBQ2pFOzs7QUh0Qk8sSUFBTSxpQkFBTixjQUE2Qix1QkFBTTtBQUFBLEVBbUJ0QyxZQUFZRSxNQUFVLFFBQWtCLGNBQWMsT0FBTztBQUN6RCxVQUFNQSxJQUFHO0FBRVQsU0FBSyxTQUFTO0FBQ2QsU0FBSyxjQUFjO0FBRW5CLFNBQUssUUFBUSxRQUFRLEVBQUUsT0FBTyxDQUFDO0FBQy9CLFNBQUssUUFBUSxTQUFTLGFBQWE7QUFFbkMsUUFBSSwwQkFBUyxVQUFVO0FBQ25CLFdBQUssVUFBVSxNQUFNLFVBQVU7QUFBQSxJQUNuQztBQUNBLFNBQUssUUFBUSxNQUFNLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyw0QkFBNEI7QUFDbEYsU0FBSyxRQUFRLE1BQU0sUUFBUSxLQUFLLE9BQU8sS0FBSyxTQUFTLDJCQUEyQjtBQUVoRixTQUFLLFVBQVUsTUFBTSxXQUFXO0FBQ2hDLFNBQUssVUFBVSxNQUFNLFNBQVM7QUFDOUIsU0FBSyxVQUFVLFNBQVMsa0JBQWtCO0FBRTFDLGFBQVMsS0FBSyxZQUFZLENBQUMsTUFBTTtBQUM3QixVQUFJLEtBQUssU0FBUyxtQkFBOEI7QUFDNUMsWUFBSSxLQUFLLFNBQVMsa0JBQTZCLEVBQUUsU0FBUyxRQUFRO0FBQzlELGVBQUssWUFBWTtBQUFBLFlBQ2IsS0FBSztBQUFBLFlBQ0wsS0FBSyxZQUFZO0FBQUEsVUFDckI7QUFDQSxlQUFLLGlCQUFpQixLQUFLO0FBQzNCLGVBQUssWUFBWSxTQUFTLElBQUk7QUFBQSxRQUNsQyxXQUNJLEtBQUssU0FBUyxrQkFDYixFQUFFLFNBQVMsV0FBVyxFQUFFLFNBQVMsVUFDcEM7QUFDRSxlQUFLLFdBQVc7QUFBQSxRQUNwQixXQUFXLEtBQUssU0FBUyxjQUF5QjtBQUM5QyxjQUFJLEVBQUUsU0FBUyxhQUFhLEVBQUUsU0FBUyxVQUFVO0FBQzdDLGlCQUFLLDBCQUFpQztBQUFBLFVBQzFDLFdBQVcsRUFBRSxTQUFTLGFBQWEsRUFBRSxTQUFTLFlBQVksRUFBRSxTQUFTLFNBQVM7QUFDMUUsaUJBQUssMEJBQWlDO0FBQUEsVUFDMUMsV0FBVyxFQUFFLFNBQVMsYUFBYSxFQUFFLFNBQVMsVUFBVTtBQUNwRCxpQkFBSywwQkFBaUM7QUFBQSxVQUMxQyxXQUFXLEVBQUUsU0FBUyxhQUFhLEVBQUUsU0FBUyxVQUFVO0FBQ3BELGlCQUFLLDJCQUFrQztBQUFBLFVBQzNDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRUEsU0FBZTtBQUNYLFNBQUssVUFBVTtBQUFBLEVBQ25CO0FBQUEsRUFFQSxVQUFnQjtBQUNaLFNBQUssT0FBTztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxZQUFrQjtBQUNkLFVBQU0sVUFBVSxLQUFLLE9BQU8sU0FBUyxTQUFTO0FBQUEsTUFDMUMsQ0FBQyxTQUFTLEtBQUssYUFBYSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ2pEO0FBQ0EsUUFBSSxLQUFLLE9BQU8sS0FBSyxlQUFlLFFBQVEsU0FBUyxHQUFHO0FBQ3BELFlBQU0sT0FBTyxRQUFRO0FBQ3JCLFdBQUssY0FBYztBQUNuQixXQUFLLFlBQVksS0FBSztBQUN0QixXQUFLLGVBQWU7QUFDcEIsV0FBSyxTQUFTLElBQUk7QUFDbEI7QUFBQSxJQUNKO0FBRUEsU0FBSyxPQUFPO0FBQ1osU0FBSyxRQUFRLFFBQVEsRUFBRSxPQUFPLENBQUM7QUFDL0IsU0FBSyxRQUFRLGFBQ1QsaUNBQUFDLFNBQUMsT0FBRSxPQUFNLGtDQUNMLGlDQUFBQTtBQUFBLE1BQUM7QUFBQTtBQUFBLFFBQ0csT0FBTTtBQUFBLFFBQ04sY0FBWSxFQUFFLFdBQVc7QUFBQSxRQUN6QixPQUFNO0FBQUE7QUFBQSxNQUVMLEtBQUssT0FBTyxTQUFTLG1CQUFtQixTQUFTO0FBQUEsSUFDdEQsR0FDQSxpQ0FBQUE7QUFBQSxNQUFDO0FBQUE7QUFBQSxRQUNHLE9BQU07QUFBQSxRQUNOLGNBQVksRUFBRSxXQUFXO0FBQUEsUUFDekIsT0FBTTtBQUFBO0FBQUEsTUFFTCxLQUFLLE9BQU8sU0FBUyxtQkFBbUIsU0FBUztBQUFBLElBQ3RELEdBQ0EsaUNBQUFBO0FBQUEsTUFBQztBQUFBO0FBQUEsUUFDRyxPQUFNO0FBQUEsUUFDTixjQUFZLEVBQUUsYUFBYTtBQUFBLFFBQzNCLE9BQU07QUFBQTtBQUFBLE1BRUwsS0FBSyxPQUFPLFNBQVMsZ0JBQWdCLFNBQVM7QUFBQSxJQUNuRCxDQUNKO0FBRUosU0FBSyxVQUFVLFlBQVk7QUFDM0IsU0FBSyxVQUFVLGFBQWEsTUFBTSxtQkFBbUI7QUFFckQsZUFBVyxRQUFRLEtBQUssT0FBTyxTQUFTLFVBQVU7QUFDOUMsV0FBSyxPQUFPLEtBQUssV0FBVyxJQUFJO0FBQUEsSUFDcEM7QUFBQSxFQUNKO0FBQUEsRUFFQSxpQkFBdUI7QUFDbkIsU0FBSyxVQUFVLFlBQVk7QUFFM0IsVUFBTSxrQkFBa0IsS0FBSyxVQUFVLFNBQVMsUUFBUTtBQUN4RCxvQkFBZ0IsU0FBUyxhQUFhO0FBQ3RDLG9CQUFnQixhQUFhLGNBQWMsRUFBRSxNQUFNLENBQUM7QUFDcEQsb0JBQWdCLGFBQ1osaUNBQUFBO0FBQUEsTUFBQztBQUFBO0FBQUEsUUFDRyxPQUFNO0FBQUEsUUFDTixPQUFNO0FBQUEsUUFDTixRQUFPO0FBQUEsUUFDUCxTQUFRO0FBQUEsUUFDUixNQUFLO0FBQUEsUUFDTCxRQUFPO0FBQUEsUUFDUCxnQkFBYTtBQUFBLFFBQ2Isa0JBQWU7QUFBQSxRQUNmLG1CQUFnQjtBQUFBLFFBQ2hCLE9BQU07QUFBQTtBQUFBLE1BRU4saUNBQUFBLFNBQUMsVUFBSyxJQUFHLE1BQUssSUFBRyxNQUFLLElBQUcsS0FBSSxJQUFHLE1BQUs7QUFBQSxNQUNyQyxpQ0FBQUEsU0FBQyxjQUFTLFFBQU8sbUJBQWtCO0FBQUEsSUFDdkM7QUFFSixvQkFBZ0IsaUJBQWlCLFNBQVMsQ0FBQyxNQUFvQjtBQUMzRCxVQUFJLEVBQUUsWUFBWSxTQUFTLEdBQUc7QUFDMUIsYUFBSyxPQUFPLEtBQUssY0FBYztBQUMvQixhQUFLLFVBQVU7QUFBQSxNQUNuQjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssZUFBZSxLQUFLLFVBQVUsVUFBVSxTQUFTO0FBQ3RELFNBQUssYUFBYSxRQUFRLEVBQUUsWUFBWSxDQUFDO0FBQ3pDLFFBQUksS0FBSyxPQUFPLEtBQUssU0FBUyx3QkFBd0I7QUFDbEQsV0FBSyxhQUFhLGFBQWEsY0FBYyxFQUFFLFlBQVksQ0FBQztBQUFBLElBQ2hFO0FBQ0EsU0FBSyxhQUFhLGlCQUFpQixTQUFTLFlBQVk7QUFDcEQsWUFBTSxhQUE0QixLQUFLLE9BQU8sSUFBSSxVQUFVLFFBQVE7QUFDcEUsVUFBSSxLQUFLLE9BQU8sSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUM5QyxjQUFNLFdBQVcsU0FBUyxLQUFLLFlBQVksSUFBSTtBQUFBLFdBQzlDO0FBQ0QsY0FBTSxVQUFVLEtBQUssT0FBTyxJQUFJLFVBQVU7QUFBQSxVQUN0QztBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDSjtBQUNBLGNBQU0sUUFBUSxTQUFTLEtBQUssWUFBWSxNQUFNLEVBQUUsUUFBUSxLQUFLLENBQUM7QUFBQSxNQUNsRTtBQUNBLFlBQU0sYUFBMkIsS0FBSyxJQUFJLFVBQVUsb0JBQW9CLDZCQUFZO0FBQ3BGLGlCQUFXLE9BQU8sVUFBVTtBQUFBLFFBQ3hCLE1BQU0sS0FBSyxZQUFZO0FBQUEsUUFDdkIsSUFBSTtBQUFBLE1BQ1IsQ0FBQztBQUNELFdBQUssWUFBWSx1QkFBdUIsS0FBSyxnQkFBZ0IsS0FBSyxZQUFZLEtBQUs7QUFDbkYsV0FBSyxpQkFBaUIsS0FBSztBQUMzQixXQUFLLFlBQVksU0FBUyxJQUFJO0FBQUEsSUFDbEMsQ0FBQztBQUVELFNBQUssZ0JBQWdCLEtBQUssVUFBVSxVQUFVLFNBQVM7QUFDdkQsU0FBSyxjQUFjLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQztBQUNuRCxTQUFLLGNBQWMsaUJBQWlCLFNBQVMsTUFBTTtBQUMvQyxXQUFLLDJCQUFrQztBQUFBLElBQzNDLENBQUM7QUFDRCxTQUFLLGNBQWMsTUFBTSxRQUFRO0FBRWpDLFFBQUksS0FBSyxPQUFPLEtBQUssU0FBUyxvQkFBb0I7QUFDOUMsV0FBSyxjQUFjLEtBQUssVUFBVSxVQUFVO0FBQzVDLFdBQUssWUFBWSxhQUFhLE1BQU0sWUFBWTtBQUFBLElBQ3BEO0FBRUEsU0FBSyxnQkFBZ0IsS0FBSyxVQUFVLFVBQVUsS0FBSztBQUNuRCxTQUFLLGNBQWMsYUFBYSxNQUFNLG1CQUFtQjtBQUV6RCxTQUFLLGNBQWMsS0FBSyxVQUFVLFVBQVUsYUFBYTtBQUV6RCxTQUFLLFVBQVUsU0FBUyxjQUFjLFFBQVE7QUFDOUMsU0FBSyxRQUFRLGFBQWEsTUFBTSxhQUFhO0FBQzdDLFNBQUssUUFBUSxRQUFRLEtBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCO0FBQ2hFLFNBQUssUUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQ3pDLFdBQUssMEJBQWlDO0FBQUEsSUFDMUMsQ0FBQztBQUNELFNBQUssWUFBWSxZQUFZLEtBQUssT0FBTztBQUV6QyxTQUFLLFVBQVUsU0FBUyxjQUFjLFFBQVE7QUFDOUMsU0FBSyxRQUFRLGFBQWEsTUFBTSxhQUFhO0FBQzdDLFNBQUssUUFBUSxRQUFRLEtBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCO0FBQ2hFLFNBQUssUUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQ3pDLFdBQUssMEJBQWlDO0FBQUEsSUFDMUMsQ0FBQztBQUNELFNBQUssWUFBWSxZQUFZLEtBQUssT0FBTztBQUV6QyxTQUFLLFVBQVUsU0FBUyxjQUFjLFFBQVE7QUFDOUMsU0FBSyxRQUFRLGFBQWEsTUFBTSxhQUFhO0FBQzdDLFNBQUssUUFBUSxRQUFRLEtBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCO0FBQ2hFLFNBQUssUUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQ3pDLFdBQUssMEJBQWlDO0FBQUEsSUFDMUMsQ0FBQztBQUNELFNBQUssWUFBWSxZQUFZLEtBQUssT0FBTztBQUN6QyxTQUFLLFlBQVksTUFBTSxVQUFVO0FBRWpDLFNBQUssWUFBWSxLQUFLLFVBQVUsVUFBVTtBQUMxQyxTQUFLLFVBQVUsYUFBYSxNQUFNLGdCQUFnQjtBQUNsRCxTQUFLLFVBQVUsUUFBUSxFQUFFLGFBQWEsQ0FBQztBQUN2QyxTQUFLLFVBQVUsaUJBQWlCLFNBQVMsTUFBTTtBQUMzQyxXQUFLLFdBQVc7QUFBQSxJQUNwQixDQUFDO0FBRUQsUUFBSSxLQUFLLGFBQWE7QUFDbEIsV0FBSyxRQUFRLE1BQU0sVUFBVTtBQUU3QixXQUFLLFlBQVksU0FBUyx5QkFBeUI7QUFDbkQsV0FBSyxRQUFRLFNBQVMsb0JBQW9CO0FBQzFDLFdBQUssUUFBUSxTQUFTLG9CQUFvQjtBQUFBLElBQzlDO0FBQUEsRUFDSjtBQUFBLEVBRUEsYUFBbUI7QUFDZixTQUFLLE9BQU87QUFFWixTQUFLLFVBQVUsTUFBTSxVQUFVO0FBQy9CLFNBQUssWUFBWSxNQUFNLFVBQVU7QUFFakMsUUFBSSxLQUFLLFlBQVksT0FBTztBQUN4QixXQUFLLGNBQWMsTUFBTSxVQUFVO0FBQUEsSUFDdkM7QUFFQSxRQUFJLEtBQUssWUFBWSw0QkFBNkI7QUFDOUMsWUFBTSxLQUFrQixTQUFTLGNBQWMsSUFBSTtBQUNuRCxTQUFHLGFBQWEsTUFBTSxtQkFBbUI7QUFDekMsV0FBSyxjQUFjLFlBQVksRUFBRTtBQUFBLElBQ3JDLE9BQU87QUFDSCxXQUFLLGNBQWMsWUFBWTtBQUFBLElBQ25DO0FBRUEsU0FBSyxzQkFBc0IsS0FBSyxZQUFZLE1BQU0sS0FBSyxhQUFhO0FBQUEsRUFDeEU7QUFBQSxFQUVBLE1BQU0sY0FBYyxVQUF5QztBQUN6RCxRQUFJLEtBQUssYUFBYTtBQUNsQixVQUFJLDBCQUFpQztBQUNqQyxhQUFLLFlBQVk7QUFBQSxVQUNiLEtBQUs7QUFBQSxVQUNMLEtBQUssWUFBWTtBQUFBLFFBQ3JCO0FBQUEsTUFDSjtBQUNBLFdBQUssWUFBWSxTQUFTLElBQUk7QUFDOUI7QUFBQSxJQUNKO0FBRUEsUUFBSSxVQUFrQixNQUFjO0FBRXBDLFNBQUssWUFBWSx1QkFBdUIsS0FBSyxnQkFBZ0IsS0FBSyxZQUFZLEtBQUs7QUFDbkYsUUFBSSw0QkFBbUM7QUFDbkMsVUFBSTtBQUVKLFVBQUksS0FBSyxZQUFZLE9BQU87QUFDeEIsbUJBQVc7QUFBQSxVQUNQO0FBQUEsVUFDQSxLQUFLLFlBQVk7QUFBQSxVQUNqQixLQUFLLFlBQVk7QUFBQSxVQUNqQixLQUFLLFlBQVk7QUFBQSxVQUNqQixLQUFLLE9BQU8sS0FBSztBQUFBLFVBQ2pCLEtBQUssT0FBTztBQUFBLFFBQ2hCO0FBQUEsTUFDSixPQUFPO0FBQ0gsWUFBSSxlQUF1QixLQUFLLE9BQU8sS0FBSyxTQUFTO0FBQ3JELFlBQ0ksT0FBTyxVQUFVLGVBQWU7QUFBQSxVQUM1QixLQUFLLE9BQU87QUFBQSxVQUNaLEtBQUssWUFBWSxLQUFLO0FBQUEsUUFDMUIsR0FDRjtBQUNFLHlCQUFlLEtBQUssTUFBTSxLQUFLLE9BQU8sV0FBVyxLQUFLLFlBQVksS0FBSyxLQUFLO0FBQUEsUUFDaEY7QUFFQSxtQkFBVztBQUFBLFVBQ1A7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLEtBQUssT0FBTyxLQUFLO0FBQUEsVUFDakIsS0FBSyxPQUFPO0FBQUEsUUFDaEI7QUFDQSxtQkFBVyxTQUFTO0FBQ3BCLGVBQU8sU0FBUztBQUFBLE1BQ3BCO0FBRUEsaUJBQVcsU0FBUztBQUNwQixhQUFPLFNBQVM7QUFDaEIsWUFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJLElBQUksV0FBVyxLQUFLLE9BQU8sR0FBSTtBQUFBLElBQ2hFLE9BQU87QUFDSCxXQUFLLFlBQVksV0FBVztBQUM1QixXQUFLLFlBQVksT0FBTyxLQUFLLE9BQU8sS0FBSyxTQUFTO0FBQ2xELFVBQUksS0FBSyxZQUFZLE9BQU87QUFDeEIsYUFBSyxZQUFZLGNBQWMsS0FBSyxLQUFLLFdBQVc7QUFBQSxNQUN4RCxPQUFPO0FBQ0gsYUFBSyxZQUFZLGNBQWMsS0FBSyxLQUFLLFdBQVc7QUFBQSxNQUN4RDtBQUNBLFlBQU0sT0FBTyxPQUFPLEtBQUssSUFBSSxDQUFDO0FBQzlCLFVBQUksd0JBQU8sRUFBRSxxQkFBcUIsQ0FBQztBQUNuQyxXQUFLLFlBQVksU0FBUyxJQUFJO0FBQzlCO0FBQUEsSUFDSjtBQUVBLFVBQU0sWUFBb0IsSUFBSSxPQUFPLFlBQVk7QUFFakQsUUFBSSxXQUFtQixNQUFNLEtBQUssSUFBSSxNQUFNLEtBQUssS0FBSyxZQUFZLElBQUk7QUFDdEUsVUFBTSxtQkFBbUIsSUFBSSxPQUFPLGtCQUFrQixLQUFLLFlBQVksUUFBUSxHQUFHLElBQUk7QUFFdEYsUUFBSSxNQUFjLEtBQUssT0FBTyxLQUFLLFNBQVMsd0JBQXdCLE1BQU07QUFFMUUsUUFBSSxLQUFLLFlBQVksU0FBUyxTQUFTLEtBQUssS0FBSyxRQUFRLE1BQU07QUFDM0QsWUFBTTtBQUFBLElBQ1Y7QUFJQSxRQUFJLEtBQUssWUFBWSxTQUFTLFlBQVksU0FBUyxNQUFNLElBQUk7QUFDekQsV0FBSyxZQUFZLFdBQ2IsS0FBSyxZQUFZLFdBQVcsTUFBTSxXQUFXLGFBQWEsWUFBWTtBQUFBLElBQzlFLE9BQU87QUFDSCxVQUFJLGFBQWlDO0FBQUEsUUFDakMsR0FBRyxLQUFLLFlBQVksU0FBUyxTQUFTLDBCQUEwQjtBQUFBLE1BQ3BFO0FBQ0EsVUFBSSxXQUFXLFdBQVcsR0FBRztBQUN6QixxQkFBYSxDQUFDLEdBQUcsS0FBSyxZQUFZLFNBQVMsU0FBUywyQkFBMkIsQ0FBQztBQUFBLE1BQ3BGO0FBRUEsWUFBTSxnQkFBMEIsQ0FBQyxLQUFLLFdBQVcsU0FBUyxTQUFTLEdBQUcsS0FBSyxTQUFTLENBQUM7QUFDckYsVUFBSSxLQUFLLFlBQVksT0FBTztBQUN4QixtQkFBVyxLQUFLLFlBQVksY0FBYztBQUFBLE1BQzlDLE9BQU87QUFDSCxtQkFBVyxLQUFLLGFBQWE7QUFBQSxNQUNqQztBQUVBLFdBQUssWUFBWSxXQUFXLEtBQUssWUFBWSxTQUFTLFFBQVEsa0JBQWtCLEVBQUU7QUFDbEYsV0FBSyxZQUFZLFlBQVk7QUFDN0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSztBQUN4QyxhQUFLLFlBQVksWUFBWSxJQUFJLFdBQVcsR0FBRyxNQUFNLFdBQVcsR0FBRyxNQUFNLFdBQVcsR0FBRztBQUFBLE1BQzNGO0FBQ0EsV0FBSyxZQUFZLFlBQVk7QUFBQSxJQUNqQztBQUVBLGVBQVcsU0FBUyxRQUFRLGtCQUFrQixNQUFNLEtBQUssWUFBWSxRQUFRO0FBQzdFLGVBQVcsV0FBVyxLQUFLLFlBQVksVUFBVTtBQUM3QyxjQUFRLFdBQVcsS0FBSyxZQUFZO0FBQUEsSUFDeEM7QUFDQSxRQUFJLEtBQUssT0FBTyxLQUFLLFNBQVMsa0JBQWtCO0FBQzVDLFdBQUssaUJBQWlCLElBQUk7QUFBQSxJQUM5QjtBQUVBLFVBQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLFlBQVksTUFBTSxRQUFRO0FBQzNELFNBQUssWUFBWSxTQUFTLElBQUk7QUFBQSxFQUNsQztBQUFBLEVBRUEsTUFBTSxpQkFBaUIsYUFBcUM7QUFDeEQsUUFBSSxhQUFhO0FBQ2IsV0FBSyxPQUFPLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxZQUFZLFFBQVEsQ0FBQztBQUNoRSxZQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsSUFDckM7QUFFQSxlQUFXLFdBQVcsS0FBSyxZQUFZLFVBQVU7QUFDN0MsWUFBTSxTQUFTLEtBQUssWUFBWSxjQUFjLFFBQVEsT0FBTztBQUM3RCxZQUFNLFNBQVMsS0FBSyxZQUFZLGNBQWMsUUFBUSxPQUFPO0FBRTdELFVBQUksV0FBVyxJQUFJO0FBQ2YsYUFBSyxZQUFZO0FBQUEsVUFDYjtBQUFBLFVBQ0EsS0FBSyxZQUFZLGNBQWMsUUFBUTtBQUFBLFFBQzNDO0FBQUEsTUFDSixXQUFXLFdBQVcsSUFBSTtBQUN0QixhQUFLLFlBQVk7QUFBQSxVQUNiO0FBQUEsVUFDQSxLQUFLLFlBQVksY0FBYyxRQUFRO0FBQUEsUUFDM0M7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUlBLE1BQU0sc0JBQ0YsZ0JBQ0EsYUFDQSxpQkFBaUIsR0FDSjtBQUNiLFFBQUksaUJBQWlCO0FBQUc7QUFFeEIsc0NBQWlCO0FBQUEsTUFDYjtBQUFBLE1BQ0E7QUFBQSxNQUNBLEtBQUssWUFBWSxLQUFLO0FBQUEsTUFDdEIsS0FBSztBQUFBLElBQ1Q7QUFFQSxnQkFBWSxRQUFRLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxPQUFPO0FBQ25ELFlBQU1DLFFBQU8sS0FBSyxVQUFVLEdBQUcsYUFBYSxLQUFLLENBQUM7QUFHbEQsVUFBSSxDQUFDQSxNQUFLLFFBQVE7QUFDZCxXQUFHLFlBQVlBLE1BQUs7QUFBQSxNQUN4QixXQUFXQSxNQUFLLGtCQUFrQix3QkFBTztBQUNyQyxZQUFJQSxNQUFLLE9BQU8sY0FBYyxNQUFNO0FBQ2hDLGVBQUssZUFBZSxJQUFJQSxNQUFLLE1BQU07QUFBQSxRQUN2QyxPQUFPO0FBQ0gsYUFBRyxZQUFZO0FBQ2YsZUFBSyxpQkFBaUIsSUFBSUEsT0FBTSxjQUFjO0FBQUEsUUFDbEQ7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUEsVUFBVSxLQUFhO0FBQ25CLFVBQU0sc0JBQ0Y7QUFDSixVQUFNLFVBQVUsT0FBTyxRQUFRLFlBQVksSUFBSSxNQUFNLG1CQUFtQjtBQUN4RSxVQUFNLE9BQU8sUUFBUSxPQUFPLFFBQVEsS0FBSyxZQUFZLEtBQUs7QUFDMUQsVUFBTSxTQUFTLEtBQUssT0FBTyxJQUFJLGNBQWM7QUFBQSxNQUN6QztBQUFBLE1BQ0EsS0FBSyxZQUFZLEtBQUs7QUFBQSxJQUMxQjtBQUVBLFdBQU87QUFBQSxNQUNILE1BQU0sUUFBUTtBQUFBLE1BQ2QsTUFBTSxRQUFRLE9BQU87QUFBQSxNQUNyQixTQUFTLFFBQVEsT0FBTztBQUFBLE1BQ3hCLFNBQVMsUUFBUSxPQUFPO0FBQUEsTUFDeEI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRUEsZUFBZSxJQUFpQixRQUFlO0FBQzNDLE9BQUcsWUFBWTtBQUNmLFFBQUksY0FBYyxTQUFTLE9BQU8sU0FBUyxHQUFHO0FBQzFDLFNBQUc7QUFBQSxRQUNDO0FBQUEsUUFDQTtBQUFBLFVBQ0ksTUFBTTtBQUFBLFlBQ0YsS0FBSyxLQUFLLE9BQU8sSUFBSSxNQUFNLGdCQUFnQixNQUFNO0FBQUEsVUFDckQ7QUFBQSxRQUNKO0FBQUEsUUFDQSxDQUFDLFFBQVE7QUFDTCxjQUFJLEdBQUcsYUFBYSxPQUFPO0FBQ3ZCLGdCQUFJLGFBQWEsU0FBUyxHQUFHLGFBQWEsT0FBTyxDQUFDO0FBQUE7QUFDakQsZ0JBQUksYUFBYSxTQUFTLE1BQU07QUFDckMsY0FBSSxHQUFHLGFBQWEsS0FBSztBQUFHLGdCQUFJLGFBQWEsT0FBTyxHQUFHLGFBQWEsS0FBSyxDQUFDO0FBQzFFLGFBQUc7QUFBQSxZQUNDO0FBQUEsWUFDQSxDQUFDLE9BQ0ssR0FBRyxPQUF1QixNQUFNLFdBQzdCLEdBQUcsT0FBdUIsTUFBTSxhQUFhLFNBQ3hDLE9BQ0E7QUFBQSxVQUNsQjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQ0EsU0FBRyxXQUFXLENBQUMsZUFBZSxXQUFXLENBQUM7QUFBQSxJQUM5QyxXQUNJLGNBQWMsU0FBUyxPQUFPLFNBQVMsS0FDdkMsY0FBYyxTQUFTLE9BQU8sU0FBUyxHQUN6QztBQUNFLFNBQUc7QUFBQSxRQUNDLGNBQWMsU0FBUyxPQUFPLFNBQVMsSUFBSSxVQUFVO0FBQUEsUUFDckQ7QUFBQSxVQUNJLE1BQU07QUFBQSxZQUNGLFVBQVU7QUFBQSxZQUNWLEtBQUssS0FBSyxPQUFPLElBQUksTUFBTSxnQkFBZ0IsTUFBTTtBQUFBLFVBQ3JEO0FBQUEsUUFDSjtBQUFBLFFBQ0EsQ0FBQyxVQUFVO0FBQ1AsY0FBSSxHQUFHLGFBQWEsS0FBSztBQUFHLGtCQUFNLGFBQWEsT0FBTyxHQUFHLGFBQWEsS0FBSyxDQUFDO0FBQUEsUUFDaEY7QUFBQSxNQUNKO0FBQ0EsU0FBRyxXQUFXLENBQUMsZUFBZSxXQUFXLENBQUM7QUFBQSxJQUM5QyxPQUFPO0FBQ0gsU0FBRyxZQUFZLE9BQU87QUFBQSxJQUMxQjtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0saUJBQ0YsSUFDQUEsT0FPQSxnQkFDRjtBQWhpQk47QUFpaUJRLFVBQU0sUUFBUSxLQUFLLElBQUksY0FBYyxTQUFTQSxNQUFLLE9BQU8sSUFBSTtBQUM5RCxVQUFNLE9BQU8sTUFBTSxLQUFLLElBQUksTUFBTSxXQUFXQSxNQUFLLE1BQU07QUFDeEQsUUFBSTtBQUNKLFFBQUlBLE1BQUssU0FBUztBQUNkLFlBQU0sUUFBUSxDQUFDLE1BQWMsRUFBRSxRQUFRLFdBQVcsRUFBRTtBQUNwRCxZQUFNLGdCQUFlLFdBQU0sYUFBTixtQkFBZ0I7QUFBQSxRQUNqQyxDQUFDRCxPQUFNLE1BQU1BLEdBQUUsT0FBTyxNQUFNLE1BQU1DLE1BQUssT0FBTztBQUFBO0FBRWxELFlBQU0sVUFBVSxNQUFNLFNBQVM7QUFFL0IsWUFBTSxVQUFVLFFBQVEsU0FBUyxNQUFNO0FBQ3ZDLFlBQU0sVUFDRix1QkFBTSxTQUFTLE1BQU0sZUFBZSxDQUFDLEVBQUUsS0FBSyxDQUFDRCxPQUFNQSxHQUFFLFNBQVMsUUFBUSxLQUFLLE1BQTNFLG1CQUNNLGFBRE4sbUJBQ2dCLFVBRGhCLG1CQUN1QixXQUFVLEtBQUs7QUFFMUMsa0JBQVksS0FBSyxVQUFVLFNBQVMsS0FBSztBQUFBLElBQzdDLFdBQVdDLE1BQUssU0FBUztBQUNyQixZQUFNLFFBQVEsTUFBTSxPQUFPQSxNQUFLO0FBQ2hDLFlBQU0sVUFBVSxNQUFNLFNBQVMsTUFBTTtBQUNyQyxZQUFNLFFBQVEsTUFBTSxTQUFTLElBQUk7QUFDakMsa0JBQVksS0FBSyxVQUFVLFNBQVMsS0FBSztBQUFBLElBQzdDLE9BQU87QUFDSCxrQkFBWTtBQUFBLElBQ2hCO0FBRUEsU0FBSyxzQkFBc0IsV0FBVyxJQUFJLGlCQUFpQixDQUFDO0FBQUEsRUFDaEU7QUFDSjtBQUVPLElBQU0sT0FBTixNQUFXO0FBQUEsRUFVZCxZQUFZLFVBQWtCLFFBQXFCO0FBUG5ELFNBQU8scUJBQXFCO0FBRTVCLFNBQU8scUJBQXFCO0FBQzVCLFNBQU8sa0JBQWtCO0FBS3JCLFNBQUssV0FBVztBQUNoQixTQUFLLGdCQUFnQixDQUFDO0FBQ3RCLFNBQUsscUJBQXFCO0FBQzFCLFNBQUssZ0JBQWdCLENBQUM7QUFDdEIsU0FBSyxxQkFBcUI7QUFDMUIsU0FBSyxrQkFBa0I7QUFDdkIsU0FBSyxXQUFXLENBQUM7QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDbEI7QUFBQSxFQUVBLFdBQVcsVUFBMEI7QUFDakMsUUFBSSxTQUFTLFdBQVcsR0FBRztBQUN2QjtBQUFBLElBQ0o7QUFFQSxVQUFNLFdBQW1CLFNBQVMsTUFBTTtBQUN4QyxlQUFXQyxTQUFRLEtBQUssVUFBVTtBQUM5QixVQUFJLGFBQWFBLE1BQUssVUFBVTtBQUM1QixRQUFBQSxNQUFLLFdBQVcsUUFBUTtBQUN4QjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsVUFBTSxPQUFhLElBQUksS0FBSyxVQUFVLElBQUk7QUFDMUMsU0FBSyxTQUFTLEtBQUssSUFBSTtBQUN2QixTQUFLLFdBQVcsUUFBUTtBQUFBLEVBQzVCO0FBQUEsRUFFQSxnQkFBZ0IsVUFBb0IsU0FBcUI7QUFDckQsUUFBSSxRQUFRLE9BQU87QUFDZixXQUFLO0FBQUEsSUFDVCxPQUFPO0FBQ0gsV0FBSztBQUFBLElBQ1Q7QUFDQSxTQUFLO0FBRUwsUUFBSSxTQUFTLFdBQVcsR0FBRztBQUN2QixVQUFJLFFBQVEsT0FBTztBQUNmLGFBQUssY0FBYyxLQUFLLE9BQU87QUFBQSxNQUNuQyxPQUFPO0FBQ0gsYUFBSyxjQUFjLEtBQUssT0FBTztBQUFBLE1BQ25DO0FBQ0E7QUFBQSxJQUNKO0FBRUEsVUFBTSxXQUFtQixTQUFTLE1BQU07QUFDeEMsZUFBVyxRQUFRLEtBQUssVUFBVTtBQUM5QixVQUFJLGFBQWEsS0FBSyxVQUFVO0FBQzVCLGFBQUssZ0JBQWdCLFVBQVUsT0FBTztBQUN0QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBSUEsZUFBZSxVQUFvQixJQUFJLEdBQVM7QUFDNUMsU0FBSyxtQkFBbUI7QUFFeEIsVUFBTSxXQUFtQixTQUFTLE1BQU07QUFDeEMsZUFBVyxRQUFRLEtBQUssVUFBVTtBQUM5QixVQUFJLGFBQWEsS0FBSyxVQUFVO0FBQzVCLGFBQUssZUFBZSxVQUFVLENBQUM7QUFDL0I7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUVBLHVCQUF1QixPQUFlLFdBQTBCO0FBQzVELFFBQUksV0FBVztBQUNYLFdBQUssY0FBYyxPQUFPLE9BQU8sQ0FBQztBQUNsQyxXQUFLO0FBQUEsSUFDVCxPQUFPO0FBQ0gsV0FBSyxjQUFjLE9BQU8sT0FBTyxDQUFDO0FBQ2xDLFdBQUs7QUFBQSxJQUNUO0FBRUEsUUFBSSxPQUFhLEtBQUs7QUFDdEIsV0FBTyxTQUFTLE1BQU07QUFDbEIsVUFBSSxXQUFXO0FBQ1gsYUFBSztBQUFBLE1BQ1QsT0FBTztBQUNILGFBQUs7QUFBQSxNQUNUO0FBQ0EsYUFBTyxLQUFLO0FBQUEsSUFDaEI7QUFBQSxFQUNKO0FBQUEsRUFFQSxtQkFBeUI7QUFDckIsU0FBSyxTQUFTLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFDekIsVUFBSSxFQUFFLFdBQVcsRUFBRSxVQUFVO0FBQ3pCLGVBQU87QUFBQSxNQUNYLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBVTtBQUNoQyxlQUFPO0FBQUEsTUFDWDtBQUNBLGFBQU87QUFBQSxJQUNYLENBQUM7QUFFRCxlQUFXLFFBQVEsS0FBSyxVQUFVO0FBQzlCLFdBQUssaUJBQWlCO0FBQUEsSUFDMUI7QUFBQSxFQUNKO0FBQUEsRUFFQSxPQUFPLGFBQTBCLE9BQTZCO0FBQzFELFVBQU0sV0FBd0IsWUFBWSxVQUFVLFdBQVc7QUFFL0QsVUFBTSxlQUE0QixTQUFTO0FBQUEsTUFDdkM7QUFBQSxJQUNKO0FBQ0EsVUFBTSw0QkFDRixNQUFNLE9BQU8sS0FBSyxTQUFTO0FBQy9CLFFBQUksWUFBWTtBQUNoQixRQUFJLGlCQUFxQztBQUN6QyxRQUFJLEtBQUssU0FBUyxTQUFTLEdBQUc7QUFDMUIsdUJBQWlCLGFBQWEsVUFBVSw4QkFBOEI7QUFDdEUscUJBQWUsWUFBWTtBQUMzQixNQUFDLGVBQWUsV0FBVyxHQUFtQixNQUFNLFlBQ2hELDRCQUE0QixLQUFLO0FBQUEsSUFDekM7QUFFQSxVQUFNLGdCQUE2QixhQUFhLFVBQVUsaUJBQWlCO0FBQzNFLGtCQUFjLGlCQUFpQixTQUFTLE1BQU07QUFDMUMsWUFBTSxPQUFPLEtBQUssY0FBYyxLQUFLO0FBQ3JDLFlBQU0sY0FBYztBQUNwQixZQUFNLFlBQVksS0FBSztBQUN2QixZQUFNLGVBQWU7QUFDckIsV0FBSyxTQUFTLEtBQUs7QUFBQSxJQUN2QixDQUFDO0FBQ0QsVUFBTSxvQkFBaUMsY0FBYyxVQUFVLG1CQUFtQjtBQUNsRixzQkFBa0IsYUFBYSxpQ0FBQUYsU0FBQyxVQUFLLE9BQU0sdUJBQXFCLEtBQUssUUFBUztBQUM5RSxVQUFNLGdCQUE2QixhQUFhLFVBQVUsdUJBQXVCO0FBQ2pGLGtCQUFjLGFBQ1YsaUNBQUFBLFNBQUMsY0FDRyxpQ0FBQUE7QUFBQSxNQUFDO0FBQUE7QUFBQSxRQUNHLE9BQU07QUFBQSxRQUNOLE9BQU07QUFBQTtBQUFBLE1BRUwsS0FBSyxtQkFBbUIsU0FBUztBQUFBLElBQ3RDLEdBQ0EsaUNBQUFBO0FBQUEsTUFBQztBQUFBO0FBQUEsUUFDRyxPQUFNO0FBQUEsUUFDTixPQUFNO0FBQUE7QUFBQSxNQUVMLEtBQUssbUJBQW1CLFNBQVM7QUFBQSxJQUN0QyxHQUNBLGlDQUFBQTtBQUFBLE1BQUM7QUFBQTtBQUFBLFFBQ0csT0FBTTtBQUFBLFFBQ04sT0FBTTtBQUFBO0FBQUEsTUFFTCxLQUFLLGdCQUFnQixTQUFTO0FBQUEsSUFDbkMsQ0FDSjtBQUdKLFVBQU0sbUJBQWdDLFNBQVMsVUFBVSxvQkFBb0I7QUFDN0UscUJBQWlCLE1BQU0sVUFBVSw0QkFBNEIsVUFBVTtBQUN2RSxRQUFJLEtBQUssU0FBUyxTQUFTLEdBQUc7QUFDMUIscUJBQWUsaUJBQWlCLFNBQVMsTUFBTTtBQUMzQyxZQUFJLFdBQVc7QUFDWCxVQUFDLGVBQWUsV0FBVyxHQUFtQixNQUFNLFlBQVk7QUFDaEUsMkJBQWlCLE1BQU0sVUFBVTtBQUFBLFFBQ3JDLE9BQU87QUFDSCxVQUFDLGVBQWUsV0FBVyxHQUFtQixNQUFNLFlBQ2hEO0FBQ0osMkJBQWlCLE1BQU0sVUFBVTtBQUFBLFFBQ3JDO0FBQ0Esb0JBQVksQ0FBQztBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNMO0FBQ0EsZUFBVyxRQUFRLEtBQUssVUFBVTtBQUM5QixXQUFLLE9BQU8sa0JBQWtCLEtBQUs7QUFBQSxJQUN2QztBQUFBLEVBQ0o7QUFBQSxFQUVBLFNBQVMsT0FBNkI7QUFDbEMsUUFBSSxLQUFLLGNBQWMsU0FBUyxLQUFLLGNBQWMsV0FBVyxHQUFHO0FBQzdELFVBQUksS0FBSyxxQkFBcUIsS0FBSyxxQkFBcUIsR0FBRztBQUN2RCxtQkFBVyxRQUFRLEtBQUssVUFBVTtBQUM5QixjQUFJLEtBQUsscUJBQXFCLEtBQUsscUJBQXFCLEdBQUc7QUFDdkQsa0JBQU0sY0FBYztBQUNwQixpQkFBSyxTQUFTLEtBQUs7QUFDbkI7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFFQSxVQUFJLEtBQUssVUFBVSxNQUFNLFdBQVc7QUFDaEMsY0FBTSxPQUFPLEtBQUssY0FBYztBQUNoQyxjQUFNLFVBQVU7QUFBQSxNQUNwQixPQUFPO0FBQ0gsYUFBSyxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQzlCO0FBQ0E7QUFBQSxJQUNKO0FBRUEsVUFBTSxZQUFZLE1BQU0sVUFBVTtBQUNsQyxVQUFNLGNBQWMsTUFBTSxVQUFVO0FBQ3BDLFVBQU0sUUFBUTtBQUFBLE1BQ1YsR0FBRyxLQUFLLGFBQWEsS0FBSyxxQkFBcUIsS0FBSztBQUFBLElBQ3hEO0FBRUEsVUFBTSxVQUFVLE1BQU0sVUFBVTtBQUNoQyxVQUFNLGNBQWMsWUFBWTtBQUNoQyxVQUFNLE9BQU87QUFFYixRQUFJLFdBQVcsR0FDWCxPQUFlLE1BQU0sT0FBTyxLQUFLLFNBQVMsVUFDMUMsb0JBQW9CO0FBQ3hCLFFBQUksS0FBSyxjQUFjLFNBQVMsR0FBRztBQUMvQixVQUFJLE1BQU0sT0FBTyxLQUFLLFNBQVMsb0JBQW9CO0FBQy9DLGNBQU0saUJBQWlCLEtBQUssTUFBTSxLQUFLLE9BQU8sSUFBSSxLQUFLLGNBQWMsTUFBTTtBQUFBLE1BQy9FLE9BQU87QUFDSCxjQUFNLGlCQUFpQjtBQUFBLE1BQzNCO0FBQ0EsWUFBTSxjQUFjLEtBQUssY0FBYyxNQUFNO0FBQzdDLFlBQU0sc0JBQXNCLE1BQU0sWUFBWSxPQUFPLE1BQU0sYUFBYTtBQUV4RSxpQkFBVyxNQUFNLFlBQVk7QUFDN0IsYUFBTyxNQUFNLFlBQVk7QUFDekIsMEJBQW9CLE1BQU0sWUFBWTtBQUFBLElBQzFDLFdBQVcsS0FBSyxjQUFjLFNBQVMsR0FBRztBQUN0QyxVQUFJLE1BQU0sT0FBTyxLQUFLLFNBQVMsb0JBQW9CO0FBQy9DLGNBQU0sZ0JBQWdCLEtBQUssTUFBTSxLQUFLLE9BQU8sSUFBSSxLQUFLLGNBQWMsTUFBTTtBQUMxRSxjQUFNLGlCQUFpQjtBQUd2QixjQUFNLGFBQW1CLEtBQUssY0FBYztBQUM1QyxZQUFJLE1BQU07QUFDVixlQUFPLE9BQU8sS0FBSyxXQUFXLFNBQVMsU0FBUyxLQUFLLGNBQWMsSUFBSSxHQUFHO0FBQ3RFLGNBQUksQ0FBQyxLQUFLLGNBQWMsS0FBSyxPQUFPO0FBQ2hDLGtCQUFNLGlCQUFpQjtBQUFBLFVBQzNCO0FBQ0E7QUFBQSxRQUNKO0FBQUEsTUFDSixPQUFPO0FBQ0gsY0FBTSxpQkFBaUI7QUFBQSxNQUMzQjtBQUVBLFlBQU0sY0FBYyxLQUFLLGNBQWMsTUFBTTtBQUM3QyxZQUFNLHNCQUFzQixNQUFNLFlBQVksT0FBTyxNQUFNLGFBQWE7QUFFeEUsVUFDSSxPQUFPLFVBQVUsZUFBZTtBQUFBLFFBQzVCLE1BQU0sT0FBTztBQUFBLFFBQ2IsTUFBTSxZQUFZLEtBQUs7QUFBQSxNQUMzQixHQUNGO0FBQ0UsZUFBTyxNQUFNLE9BQU8sV0FBVyxNQUFNLFlBQVksS0FBSztBQUFBLE1BQzFEO0FBQUEsSUFDSjtBQUVBLFVBQU0sZUFBdUI7QUFBQTtBQUFBLE1BRXpCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLE1BQU0sT0FBTyxLQUFLO0FBQUEsSUFDdEIsRUFBRTtBQUNGLFVBQU0sZUFBdUI7QUFBQTtBQUFBLE1BRXpCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLE1BQU0sT0FBTyxLQUFLO0FBQUEsSUFDdEIsRUFBRTtBQUNGLFVBQU0sZUFBdUI7QUFBQTtBQUFBLE1BRXpCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLE1BQU0sT0FBTyxLQUFLO0FBQUEsSUFDdEIsRUFBRTtBQUVGLFFBQUksTUFBTSxhQUFhO0FBRW5CLFlBQU0sUUFBUSxRQUFRLEdBQUcsTUFBTSxPQUFPLEtBQUssU0FBUyxtQkFBbUI7QUFDdkUsWUFBTSxRQUFRLFFBQVEsR0FBRyxNQUFNLE9BQU8sS0FBSyxTQUFTLG1CQUFtQjtBQUFBLElBQzNFLFdBQVcsMEJBQVMsVUFBVTtBQUMxQixZQUFNLFFBQVEsUUFBUSxhQUFhLGNBQWMsSUFBSSxDQUFDO0FBQ3RELFlBQU0sUUFBUSxRQUFRLGFBQWEsY0FBYyxJQUFJLENBQUM7QUFDdEQsWUFBTSxRQUFRLFFBQVEsYUFBYSxjQUFjLElBQUksQ0FBQztBQUFBLElBQzFELE9BQU87QUFDSCxZQUFNLFFBQVE7QUFBQSxRQUNWLEdBQUcsTUFBTSxPQUFPLEtBQUssU0FBUyx1QkFBdUI7QUFBQSxVQUNqRDtBQUFBLFVBQ0E7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNBLFlBQU0sUUFBUTtBQUFBLFFBQ1YsR0FBRyxNQUFNLE9BQU8sS0FBSyxTQUFTLHVCQUF1QjtBQUFBLFVBQ2pEO0FBQUEsVUFDQTtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQ0EsWUFBTSxRQUFRO0FBQUEsUUFDVixHQUFHLE1BQU0sT0FBTyxLQUFLLFNBQVMsdUJBQXVCO0FBQUEsVUFDakQ7QUFBQSxVQUNBO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsUUFBSSxNQUFNLE9BQU8sS0FBSyxTQUFTO0FBQzNCLFlBQU0sWUFBWSxRQUFRLE1BQU0sWUFBWSxPQUFPO0FBQ3ZELFFBQUksTUFBTSxPQUFPLEtBQUssU0FBUztBQUMzQixZQUFNLGFBQWEsUUFBUSxNQUFNLFlBQVksS0FBSyxRQUFRO0FBQUEsRUFDbEU7QUFDSjs7O0FJNTNCQSxJQUFBRyxtQkFBcUM7QUFFckMsSUFBQUMsZ0JBQWM7OztBQ1FQLFNBQVNDLE9BQU87QUFDckI7QUFNSyxJQUFNQyxPQUFPLE1BQU07QUFDeEIsTUFBSUMsS0FBSztBQUNULFNBQU8sTUFBTUE7QUFDZCxHQUFBO0FBT00sU0FBU0MsY0FBY0MsT0FBMkM7QUFDdkUsU0FBT0EsVUFBVSxRQUFRLE9BQU9BLFVBQVU7QUFDM0M7QUFPTSxTQUFTQyxRQUFxQkQsT0FBOEI7QUFDakUsTUFBSUUsTUFBTUQsV0FBV0MsTUFBTUQsUUFBUUQsS0FBSyxHQUFHO0FBQ3pDLFdBQU87RUFDUjtBQUNELFFBQU1HLE9BQU9DLE9BQU9DLFVBQVVDLFNBQVNDLEtBQUtQLEtBQUs7QUFDakQsTUFBSUcsS0FBS0ssTUFBTSxHQUFHLENBQUMsTUFBTSxhQUFhTCxLQUFLSyxNQUFNLEVBQUUsTUFBTSxVQUFVO0FBQ2pFLFdBQU87RUFDUjtBQUNELFNBQU87QUFDUjtBQU9NLFNBQVNDLFNBQVNULE9BQW9DO0FBQzNELFNBQU9BLFVBQVUsUUFBUUksT0FBT0MsVUFBVUMsU0FBU0MsS0FBS1AsS0FBSyxNQUFNO0FBQ3BFO0FBTUQsU0FBU1UsZUFBZVYsT0FBaUM7QUFDdkQsVUFBUSxPQUFPQSxVQUFVLFlBQVlBLGlCQUFpQlcsV0FBV0MsU0FBUyxDQUFDWixLQUFLO0FBQ2pGO0FBVU0sU0FBU2EsZ0JBQWdCYixPQUFnQmMsY0FBc0I7QUFDcEUsU0FBT0osZUFBZVYsS0FBSyxJQUFJQSxRQUFRYztBQUN4QztBQU9NLFNBQVNDLGVBQWtCZixPQUFzQmMsY0FBaUI7QUFDdkUsU0FBTyxPQUFPZCxVQUFVLGNBQWNjLGVBQWVkO0FBQ3REO0FBRVlnQixJQUFBQSxlQUFlLENBQUNoQixPQUF3QmlCLGNBQ25ELE9BQU9qQixVQUFVLFlBQVlBLE1BQU1rQixTQUFTLEdBQUcsSUFDN0NDLFdBQVduQixLQUFLLElBQUksTUFDbEIsQ0FBQ0EsUUFBUWlCO0FBRUZHLElBQUFBLGNBQWMsQ0FBQ3BCLE9BQXdCaUIsY0FDbEQsT0FBT2pCLFVBQVUsWUFBWUEsTUFBTWtCLFNBQVMsR0FBRyxJQUM3Q0MsV0FBV25CLEtBQUssSUFBSSxNQUFNaUIsWUFDeEIsQ0FBQ2pCO0FBU0EsU0FBU3FCLFNBQ2RDLElBQ0FDLE1BQ0FDLFNBQ2U7QUFDZixNQUFJRixNQUFNLE9BQU9BLEdBQUdmLFNBQVMsWUFBWTtBQUN2QyxXQUFPZSxHQUFHRyxNQUFNRCxTQUFTRCxJQUFJO0VBQzlCO0FBQ0Y7QUF1Qk0sU0FBU0csS0FDZEMsVUFDQUwsSUFDQUUsU0FDQUksU0FDQTtBQUNBLE1BQUlDLEdBQVdDLEtBQWFDO0FBQzVCLE1BQUk5QixRQUFRMEIsUUFBUSxHQUFHO0FBQ3JCRyxVQUFNSCxTQUFTSztBQUNmLFFBQUlKLFNBQVM7QUFDWCxXQUFLQyxJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSztBQUM3QlAsV0FBR2YsS0FBS2lCLFNBQVNHLFNBQVNFLElBQUlBLENBQUM7TUFDaEM7V0FDSTtBQUNMLFdBQUtBLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSztBQUN4QlAsV0FBR2YsS0FBS2lCLFNBQVNHLFNBQVNFLElBQUlBLENBQUM7TUFDaEM7SUFDRjtFQUNGLFdBQVVwQixTQUFTa0IsUUFBUSxHQUFHO0FBQzdCSSxXQUFPM0IsT0FBTzJCLEtBQUtKLFFBQVE7QUFDM0JHLFVBQU1DLEtBQUtDO0FBQ1gsU0FBS0gsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLO0FBQ3hCUCxTQUFHZixLQUFLaUIsU0FBU0csU0FBU0ksS0FBS0YsS0FBS0UsS0FBS0YsRUFBRTtJQUM1QztFQUNGO0FBQ0Y7QUFRTSxTQUFTSSxlQUFlQyxJQUF1QkMsSUFBdUI7QUFDM0UsTUFBSU4sR0FBV08sTUFBY0MsSUFBcUJDO0FBRWxELE1BQUksQ0FBQ0osTUFBTSxDQUFDQyxNQUFNRCxHQUFHRixXQUFXRyxHQUFHSCxRQUFRO0FBQ3pDLFdBQU87RUFDUjtBQUVELE9BQUtILElBQUksR0FBR08sT0FBT0YsR0FBR0YsUUFBUUgsSUFBSU8sTUFBTSxFQUFFUCxHQUFHO0FBQzNDUSxTQUFLSCxHQUFHTDtBQUNSUyxTQUFLSCxHQUFHTjtBQUVSLFFBQUlRLEdBQUdFLGlCQUFpQkQsR0FBR0MsZ0JBQWdCRixHQUFHRyxVQUFVRixHQUFHRSxPQUFPO0FBQ2hFLGFBQU87SUFDUjtFQUNGO0FBRUQsU0FBTztBQUNSO0FBTU0sU0FBU0MsUUFBU0MsUUFBYztBQUNyQyxNQUFJekMsUUFBUXlDLE1BQU0sR0FBRztBQUNuQixXQUFPQSxPQUFPQyxJQUFJRixPQUFLO0VBQ3hCO0FBRUQsTUFBSWhDLFNBQVNpQyxNQUFNLEdBQUc7QUFDcEIsVUFBTUUsU0FBU3hDLHVCQUFPeUMsT0FBTyxJQUFJO0FBQ2pDLFVBQU1kLE9BQU8zQixPQUFPMkIsS0FBS1csTUFBTTtBQUMvQixVQUFNSSxPQUFPZixLQUFLQztBQUNsQixRQUFJZSxJQUFJO0FBRVIsV0FBT0EsSUFBSUQsTUFBTSxFQUFFQyxHQUFHO0FBQ3BCSCxhQUFPYixLQUFLZ0IsTUFBTU4sUUFBTUMsT0FBT1gsS0FBS2dCLEdBQUc7SUFDeEM7QUFFRCxXQUFPSDtFQUNSO0FBRUQsU0FBT0Y7QUFDUjtBQUVELFNBQVNNLFdBQVdDLEtBQWE7QUFDL0IsU0FBTztJQUFDO0lBQWE7SUFBYTtFQUFjLEVBQUNDLFFBQVFELEdBQUcsTUFBTTtBQUNuRTtBQU9NLFNBQVNFLFFBQVFGLEtBQWFMLFFBQW1CRixRQUFtQlUsU0FBb0I7QUFDN0YsTUFBSSxDQUFDSixXQUFXQyxHQUFHLEdBQUc7QUFDcEI7RUFDRDtBQUVELFFBQU1JLE9BQU9ULE9BQU9LO0FBQ3BCLFFBQU1LLE9BQU9aLE9BQU9PO0FBRXBCLE1BQUl4QyxTQUFTNEMsSUFBSSxLQUFLNUMsU0FBUzZDLElBQUksR0FBRztBQUVwQ0MsVUFBTUYsTUFBTUMsTUFBTUYsT0FBTztTQUNwQjtBQUNMUixXQUFPSyxPQUFPUixRQUFNYSxJQUFJO0VBQ3pCO0FBQ0Y7QUEwQk0sU0FBU0MsTUFBU1gsUUFBV0YsUUFBcUJVLFNBQW1DO0FBQzFGLFFBQU1JLFVBQVV2RCxRQUFReUMsTUFBTSxJQUFJQSxTQUFTO0lBQUNBOztBQUM1QyxRQUFNTixPQUFPb0IsUUFBUXhCO0FBRXJCLE1BQUksQ0FBQ3ZCLFNBQVNtQyxNQUFNLEdBQUc7QUFDckIsV0FBT0E7RUFDUjtBQUVEUSxZQUFVQSxXQUFXLENBQUE7QUFDckIsUUFBTUssU0FBU0wsUUFBUUssVUFBVU47QUFDakMsTUFBSU87QUFFSixXQUFTN0IsSUFBSSxHQUFHQSxJQUFJTyxNQUFNLEVBQUVQLEdBQUc7QUFDN0I2QixjQUFVRixRQUFRM0I7QUFDbEIsUUFBSSxDQUFDcEIsU0FBU2lELE9BQU8sR0FBRztBQUN0QjtJQUNEO0FBRUQsVUFBTTNCLE9BQU8zQixPQUFPMkIsS0FBSzJCLE9BQU87QUFDaEMsYUFBU1gsSUFBSSxHQUFHRCxPQUFPZixLQUFLQyxRQUFRZSxJQUFJRCxNQUFNLEVBQUVDLEdBQUc7QUFDakRVLGFBQU8xQixLQUFLZ0IsSUFBSUgsUUFBUWMsU0FBU04sT0FBTztJQUN6QztFQUNGO0FBRUQsU0FBT1I7QUFDUjtBQWdCTSxTQUFTZSxRQUFXZixRQUFXRixRQUFnQztBQUVwRSxTQUFPYSxNQUFTWCxRQUFRRixRQUFRO0lBQUNlLFFBQVFHO0VBQVUsQ0FBQTtBQUNwRDtBQU1NLFNBQVNBLFVBQVVYLEtBQWFMLFFBQW1CRixRQUFtQjtBQUMzRSxNQUFJLENBQUNNLFdBQVdDLEdBQUcsR0FBRztBQUNwQjtFQUNEO0FBRUQsUUFBTUksT0FBT1QsT0FBT0s7QUFDcEIsUUFBTUssT0FBT1osT0FBT087QUFFcEIsTUFBSXhDLFNBQVM0QyxJQUFJLEtBQUs1QyxTQUFTNkMsSUFBSSxHQUFHO0FBQ3BDSyxZQUFRTixNQUFNQyxJQUFJO0VBQ25CLFdBQVUsQ0FBQ2xELE9BQU9DLFVBQVV3RCxlQUFldEQsS0FBS3FDLFFBQVFLLEdBQUcsR0FBRztBQUM3REwsV0FBT0ssT0FBT1IsUUFBTWEsSUFBSTtFQUN6QjtBQUNGO0FBYUQsSUFBTVEsZUFBZTtFQUVuQixJQUFJQyxDQUFBQSxNQUFLQTtFQUVUQyxHQUFHQyxDQUFBQSxNQUFLQSxFQUFFRDtFQUNWRSxHQUFHRCxDQUFBQSxNQUFLQSxFQUFFQzs7QUFNTCxTQUFTQyxVQUFVQyxLQUFhO0FBQ3JDLFFBQU1DLFFBQVFELElBQUlFLE1BQU0sR0FBRztBQUMzQixRQUFNQyxPQUFpQixDQUFBO0FBQ3ZCLE1BQUlDLE1BQU07QUFDVixhQUFXQyxRQUFRSixPQUFPO0FBQ3hCRyxXQUFPQztBQUNQLFFBQUlELElBQUlFLFNBQVMsSUFBSSxHQUFHO0FBQ3RCRixZQUFNQSxJQUFJRyxNQUFNLEdBQUcsRUFBRSxJQUFJO1dBQ3BCO0FBQ0xKLFdBQUtLLEtBQUtKLEdBQUc7QUFDYkEsWUFBTTtJQUNQO0VBQ0Y7QUFDRCxTQUFPRDtBQUNSO0FBRUQsU0FBU00sZ0JBQWdCVCxLQUFhO0FBQ3BDLFFBQU1HLE9BQU9KLFVBQVVDLEdBQUc7QUFDMUIsU0FBT1UsQ0FBQUEsUUFBTztBQUNaLGVBQVdDLEtBQUtSLE1BQU07QUFDcEIsVUFBSVEsTUFBTSxJQUFJO0FBR1o7TUFDRDtBQUNERCxZQUFNQSxPQUFPQSxJQUFJQztJQUNsQjtBQUNELFdBQU9EOztBQUVWO0FBRU0sU0FBU0UsaUJBQWlCRixLQUFnQlYsS0FBd0I7QUFDdkUsUUFBTWEsV0FBV25CLGFBQWFNLFNBQVNOLGFBQWFNLE9BQU9TLGdCQUFnQlQsR0FBRztBQUM5RSxTQUFPYSxTQUFTSCxHQUFHO0FBQ3BCO0FBS00sU0FBU0ksWUFBWUMsS0FBYTtBQUN2QyxTQUFPQSxJQUFJQyxPQUFPLENBQUMsRUFBRUMsWUFBVyxJQUFLRixJQUFJUixNQUFNLENBQUM7QUFDakQ7QUFHTSxJQUFNVyxVQUFVLENBQUNDLFVBQW1CLE9BQU9BLFVBQVU7QUFFckQsSUFBTUMsYUFBYSxDQUFDRCxVQUFxRCxPQUFPQSxVQUFVO0lBR3BGRSxZQUFZLENBQUlDLEdBQVdDLE1BQWM7QUFDcEQsTUFBSUQsRUFBRUUsU0FBU0QsRUFBRUMsTUFBTTtBQUNyQixXQUFPO0VBQ1I7QUFFRCxhQUFXQyxRQUFRSCxHQUFHO0FBQ3BCLFFBQUksQ0FBQ0MsRUFBRUcsSUFBSUQsSUFBSSxHQUFHO0FBQ2hCLGFBQU87SUFDUjtFQUNGO0FBRUQsU0FBTzs7QUFPRixTQUFTRSxjQUFjQyxHQUFlO0FBQzNDLFNBQU9BLEVBQUVDLFNBQVMsYUFBYUQsRUFBRUMsU0FBUyxXQUFXRCxFQUFFQyxTQUFTO0FBQ2pFO0FDdlpZQyxJQUFBQSxLQUFLQyxLQUFLRDtJQUNWRSxNQUFNLElBQUlGO0lBQ1ZHLFFBQVFELE1BQU1GO0lBQ2RJLFdBQVdDLE9BQU9DO0lBQ2xCQyxjQUFjUCxLQUFLO0lBQ25CUSxVQUFVUixLQUFLO0lBQ2ZTLGFBQWFULEtBQUs7QUFDeEIsSUFBTVUsZ0JBQWdCVixLQUFLLElBQUk7SUFFekJXLFFBQVFWLEtBQUtVO0lBQ2JDLE9BQU9YLEtBQUtXO0FBRWxCLFNBQVNDLGFBQWEvQyxHQUFXRSxHQUFXOEMsU0FBaUI7QUFDbEUsU0FBT2IsS0FBS2MsSUFBSWpELElBQUlFLENBQUMsSUFBSThDO0FBQzFCO0FBS00sU0FBU0UsUUFBUUMsT0FBZTtBQUNyQyxRQUFNQyxlQUFlakIsS0FBS2tCLE1BQU1GLEtBQUs7QUFDckNBLFVBQVFKLGFBQWFJLE9BQU9DLGNBQWNELFFBQVEsR0FBSSxJQUFJQyxlQUFlRDtBQUN6RSxRQUFNRyxZQUFZbkIsS0FBS29CLElBQUksSUFBSXBCLEtBQUtxQixNQUFNWCxNQUFNTSxLQUFLLENBQUMsQ0FBQztBQUN2RCxRQUFNTSxXQUFXTixRQUFRRztBQUN6QixRQUFNSSxlQUFlRCxZQUFZLElBQUksSUFBSUEsWUFBWSxJQUFJLElBQUlBLFlBQVksSUFBSSxJQUFJO0FBQ2pGLFNBQU9DLGVBQWVKO0FBQ3ZCO0FBTU0sU0FBU0ssV0FBV3BDLE9BQWU7QUFDeEMsUUFBTXFDLFNBQW1CLENBQUE7QUFDekIsUUFBTUMsT0FBTzFCLEtBQUswQixLQUFLdEMsS0FBSztBQUM1QixNQUFJdUM7QUFFSixPQUFLQSxJQUFJLEdBQUdBLElBQUlELE1BQU1DLEtBQUs7QUFDekIsUUFBSXZDLFFBQVF1QyxNQUFNLEdBQUc7QUFDbkJGLGFBQU9oRCxLQUFLa0QsQ0FBQztBQUNiRixhQUFPaEQsS0FBS1csUUFBUXVDLENBQUM7SUFDdEI7RUFDRjtBQUNELE1BQUlELFVBQVVBLE9BQU8sSUFBSTtBQUN2QkQsV0FBT2hELEtBQUtpRCxJQUFJO0VBQ2pCO0FBRURELFNBQU9HLEtBQUssQ0FBQ3JDLEdBQUdDLE1BQU1ELElBQUlDLENBQUMsRUFBRXFDLElBQUc7QUFDaEMsU0FBT0o7QUFDUjtBQUVNLFNBQVNLLFNBQVNDLEdBQXlCO0FBQ2hELFNBQU8sQ0FBQ0MsTUFBTUMsV0FBV0YsQ0FBQyxDQUFXLEtBQUtHLFNBQVNILENBQUM7QUFDckQ7QUFFTSxTQUFTSSxZQUFZdEUsR0FBV2dELFNBQWlCO0FBQ3RELFFBQU11QixVQUFVcEMsS0FBS2tCLE1BQU1yRCxDQUFDO0FBQzVCLFNBQU8sVUFBWWdELFdBQVloRCxLQUFPLFVBQVdnRCxXQUFZaEQ7QUFDOUQ7QUFLTSxTQUFTd0UsbUJBQ2RDLE9BQ0FDLFFBQ0FDLFVBQ0E7QUFDQSxNQUFJYixHQUFXYyxNQUFjckQ7QUFFN0IsT0FBS3VDLElBQUksR0FBR2MsT0FBT0gsTUFBTUksUUFBUWYsSUFBSWMsTUFBTWQsS0FBSztBQUM5Q3ZDLFlBQVFrRCxNQUFNWCxHQUFHYTtBQUNqQixRQUFJLENBQUNSLE1BQU01QyxLQUFLLEdBQUc7QUFDakJtRCxhQUFPSSxNQUFNM0MsS0FBSzJDLElBQUlKLE9BQU9JLEtBQUt2RCxLQUFLO0FBQ3ZDbUQsYUFBT0ssTUFBTTVDLEtBQUs0QyxJQUFJTCxPQUFPSyxLQUFLeEQsS0FBSztJQUN4QztFQUNGO0FBQ0Y7QUFFTSxTQUFTeUQsVUFBVUMsU0FBaUI7QUFDekMsU0FBT0EsV0FBVy9DLEtBQUs7QUFDeEI7QUFFTSxTQUFTZ0QsVUFBVUMsU0FBaUI7QUFDekMsU0FBT0EsV0FBVyxNQUFNakQ7QUFDekI7QUFTTSxTQUFTa0QsZUFBZXBGLEdBQVc7QUFDeEMsTUFBSSxDQUFDcUYsZUFBZXJGLENBQUMsR0FBRztBQUN0QjtFQUNEO0FBQ0QsTUFBSWdDLElBQUk7QUFDUixNQUFJc0QsSUFBSTtBQUNSLFNBQU9uRCxLQUFLa0IsTUFBTXJELElBQUlnQyxDQUFDLElBQUlBLE1BQU1oQyxHQUFHO0FBQ2xDZ0MsU0FBSztBQUNMc0Q7RUFDRDtBQUNELFNBQU9BO0FBQ1I7QUFHTSxTQUFTQyxrQkFDZEMsYUFDQUMsWUFDQTtBQUNBLFFBQU1DLHNCQUFzQkQsV0FBV3pGLElBQUl3RixZQUFZeEY7QUFDdkQsUUFBTTJGLHNCQUFzQkYsV0FBV3ZGLElBQUlzRixZQUFZdEY7QUFDdkQsUUFBTTBGLDJCQUEyQnpELEtBQUswQixLQUFLNkIsc0JBQXNCQSxzQkFBc0JDLHNCQUFzQkEsbUJBQW1CO0FBRWhJLE1BQUlFLFFBQVExRCxLQUFLMkQsTUFBTUgscUJBQXFCRCxtQkFBbUI7QUFFL0QsTUFBSUcsUUFBUyxPQUFPM0QsSUFBSztBQUN2QjJELGFBQVN6RDtFQUNWO0FBRUQsU0FBTztJQUNMeUQ7SUFDQUUsVUFBVUg7O0FBRWI7QUFFTSxTQUFTSSxzQkFBc0JDLEtBQVlDLEtBQVk7QUFDNUQsU0FBTy9ELEtBQUswQixLQUFLMUIsS0FBS29CLElBQUkyQyxJQUFJbEcsSUFBSWlHLElBQUlqRyxHQUFHLENBQUMsSUFBSW1DLEtBQUtvQixJQUFJMkMsSUFBSWhHLElBQUkrRixJQUFJL0YsR0FBRyxDQUFDLENBQUM7QUFDekU7QUFjTSxTQUFTaUcsZ0JBQWdCQyxHQUFXO0FBQ3pDLFVBQVFBLElBQUlDLE1BQU1BLE9BQU9BO0FBQzFCO0FBS00sU0FBU0MsY0FBY0MsT0FBZUMsT0FBZUMsS0FBYUMsdUJBQWlDO0FBQ3hHLFFBQU1OLElBQUlELGdCQUFnQkksS0FBSztBQUMvQixRQUFNSSxJQUFJUixnQkFBZ0JLLEtBQUs7QUFDL0IsUUFBTUksSUFBSVQsZ0JBQWdCTSxHQUFHO0FBQzdCLFFBQU1JLGVBQWVWLGdCQUFnQlEsSUFBSVAsQ0FBQztBQUMxQyxRQUFNVSxhQUFhWCxnQkFBZ0JTLElBQUlSLENBQUM7QUFDeEMsUUFBTVcsZUFBZVosZ0JBQWdCQyxJQUFJTyxDQUFDO0FBQzFDLFFBQU1LLGFBQWFiLGdCQUFnQkMsSUFBSVEsQ0FBQztBQUN4QyxTQUFPUixNQUFNTyxLQUFLUCxNQUFNUSxLQUFNRix5QkFBeUJDLE1BQU1DLEtBQ3ZEQyxlQUFlQyxjQUFjQyxlQUFlQztBQUNuRDtBQVNNLFNBQVNDLFlBQVlDLE9BQWVDLEtBQWFDLEtBQWE7QUFDbkUsU0FBT0MsS0FBS0QsSUFBSUQsS0FBS0UsS0FBS0YsSUFBSUMsS0FBS0YsS0FBSyxDQUFDO0FBQzFDO0FBTU0sU0FBU0ksWUFBWUosT0FBZTtBQUN6QyxTQUFPRCxZQUFZQyxPQUFPLFFBQVEsS0FBSztBQUN4QztBQVNNLFNBQVNLLFdBQVdMLE9BQWVWLE9BQWVDLEtBQWFlLFVBQVUsTUFBTTtBQUNwRixTQUFPTixTQUFTRyxLQUFLRixJQUFJWCxPQUFPQyxHQUFHLElBQUllLFdBQVdOLFNBQVNHLEtBQUtELElBQUlaLE9BQU9DLEdBQUcsSUFBSWU7QUFDbkY7QUNwTE0sU0FBU0MsUUFDZEMsT0FDQVIsT0FDQVMsS0FDQTtBQUNBQSxRQUFNQSxRQUFRLENBQUNDLFVBQVVGLE1BQU1FLFNBQVNWO0FBQ3hDLE1BQUlXLEtBQUtILE1BQU1JLFNBQVM7QUFDeEIsTUFBSUMsS0FBSztBQUNULE1BQUlDO0FBRUosU0FBT0gsS0FBS0UsS0FBSyxHQUFHO0FBQ2xCQyxVQUFNLEtBQU1ILE1BQU87QUFDbkIsUUFBSUYsSUFBSUssR0FBRyxHQUFHO0FBQ1pELFdBQUtDO1dBQ0E7QUFDTEgsV0FBS0c7SUFDTjtFQUNGO0FBRUQsU0FBTztJQUFDRDtJQUFJRjs7QUFDYjtJQVVZSSxlQUFlLENBQzFCUCxPQUNBUSxLQUNBaEIsT0FDQWlCLFNBRUFWLFFBQVFDLE9BQU9SLE9BQU9pQixPQUNsQlAsQ0FBQUEsVUFBUztBQUNULFFBQU1RLEtBQUtWLE1BQU1FLE9BQU9NO0FBQ3hCLFNBQU9FLEtBQUtsQixTQUFTa0IsT0FBT2xCLFNBQVNRLE1BQU1FLFFBQVEsR0FBR00sU0FBU2hCO0FBQ2hFLElBQ0NVLENBQUFBLFVBQVNGLE1BQU1FLE9BQU9NLE9BQU9oQixLQUFLO0FBU2pDLElBQU1tQixnQkFBZ0IsQ0FDM0JYLE9BQ0FRLEtBQ0FoQixVQUVBTyxRQUFRQyxPQUFPUixPQUFPVSxDQUFBQSxVQUFTRixNQUFNRSxPQUFPTSxRQUFRaEIsS0FBSztBQVNwRCxTQUFTb0IsZUFBZUMsUUFBa0JwQixLQUFhQyxLQUFhO0FBQ3pFLE1BQUlaLFFBQVE7QUFDWixNQUFJQyxNQUFNOEIsT0FBT1Q7QUFFakIsU0FBT3RCLFFBQVFDLE9BQU84QixPQUFPL0IsU0FBU1csS0FBSztBQUN6Q1g7RUFDRDtBQUNELFNBQU9DLE1BQU1ELFNBQVMrQixPQUFPOUIsTUFBTSxLQUFLVyxLQUFLO0FBQzNDWDtFQUNEO0FBRUQsU0FBT0QsUUFBUSxLQUFLQyxNQUFNOEIsT0FBT1QsU0FDN0JTLE9BQU9DLE1BQU1oQyxPQUFPQyxHQUFHLElBQ3ZCOEI7QUFDTDtBQUVELElBQU1FLGNBQWM7RUFBQztFQUFRO0VBQU87RUFBUztFQUFVO0FBQVU7QUFnQjFELFNBQVNDLGtCQUFrQkMsT0FBT0MsVUFBVTtBQUNqRCxNQUFJRCxNQUFNRSxVQUFVO0FBQ2xCRixVQUFNRSxTQUFTQyxVQUFVQyxLQUFLSCxRQUFRO0FBQ3RDO0VBQ0Q7QUFFREksU0FBT0MsZUFBZU4sT0FBTyxZQUFZO0lBQ3ZDTyxjQUFjO0lBQ2RDLFlBQVk7SUFDWmpDLE9BQU87TUFDTDRCLFdBQVc7UUFBQ0Y7TUFBUztJQUN0QjtFQUNGLENBQUE7QUFFREgsY0FBWVcsUUFBUSxDQUFDbEIsUUFBUTtBQUMzQixVQUFNbUIsU0FBUyxZQUFZQyxZQUFZcEIsR0FBRztBQUMxQyxVQUFNcUIsT0FBT1osTUFBTVQ7QUFFbkJjLFdBQU9DLGVBQWVOLE9BQU9ULEtBQUs7TUFDaENnQixjQUFjO01BQ2RDLFlBQVk7TUFDWmpDLFNBQVNzQyxNQUFNO0FBQ2IsY0FBTUMsTUFBTUYsS0FBS0csTUFBTSxNQUFNRixJQUFJO0FBRWpDYixjQUFNRSxTQUFTQyxVQUFVTSxRQUFRLENBQUNPLFdBQVc7QUFDM0MsY0FBSSxPQUFPQSxPQUFPTixZQUFZLFlBQVk7QUFDeENNLG1CQUFPTixRQUFXRyxHQUFBQSxJQUFJO1VBQ3ZCO1FBQ0YsQ0FBQTtBQUVELGVBQU9DO01BQ1I7SUFDRixDQUFBO0VBQ0YsQ0FBQTtBQUNGO0FBUU0sU0FBU0csb0JBQW9CakIsT0FBT0MsVUFBVTtBQUNuRCxRQUFNaUIsT0FBT2xCLE1BQU1FO0FBQ25CLE1BQUksQ0FBQ2dCLE1BQU07QUFDVDtFQUNEO0FBRUQsUUFBTWYsWUFBWWUsS0FBS2Y7QUFDdkIsUUFBTWxCLFFBQVFrQixVQUFVZ0IsUUFBUWxCLFFBQVE7QUFDeEMsTUFBSWhCLFVBQVUsSUFBSTtBQUNoQmtCLGNBQVVpQixPQUFPbkMsT0FBTyxDQUFDO0VBQzFCO0FBRUQsTUFBSWtCLFVBQVVoQixTQUFTLEdBQUc7QUFDeEI7RUFDRDtBQUVEVyxjQUFZVyxRQUFRLENBQUNsQixRQUFRO0FBQzNCLFdBQU9TLE1BQU1UO0VBQ2QsQ0FBQTtBQUVELFNBQU9TLE1BQU1FO0FBQ2Q7QUFLTSxTQUFTbUIsYUFBZ0JDLE9BQVk7QUFDMUMsUUFBTUMsT0FBTSxvQkFBSUMsSUFBRztBQUNuQixNQUFJQyxHQUFXQztBQUVmLE9BQUtELElBQUksR0FBR0MsT0FBT0osTUFBTW5DLFFBQVFzQyxJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDOUNGLElBQUFBLEtBQUlJLElBQUlMLE1BQU1HLEVBQUU7RUFDakI7QUFFRCxNQUFJRixLQUFJSyxTQUFTRixNQUFNO0FBQ3JCLFdBQU9KO0VBQ1I7QUFFRCxTQUFPTyxNQUFNQyxLQUFLUCxJQUFHO0FBQ3RCO0FDeExNLElBQU1RLG1CQUFvQixXQUFXO0FBQzFDLE1BQUksT0FBT0MsV0FBVyxhQUFhO0FBQ2pDLFdBQU8sU0FBU0MsV0FBVTtBQUN4QixhQUFPQSxVQUFROztFQUVsQjtBQUNELFNBQU9ELE9BQU9FO0FBQ2YsRUFBQTtBQU1NLFNBQVNDLFVBQ2RDLElBQ0FDLFNBQ0E7QUFDQSxNQUFJQyxVQUFVO0FBRWQsU0FBTyxZQUFZQyxNQUFhO0FBQzlCLFFBQUksQ0FBQ0QsU0FBUztBQUNaQSxnQkFBVTtBQUNWUCx1QkFBaUJTLEtBQUtSLFFBQVEsTUFBTTtBQUNsQ00sa0JBQVU7QUFDVkYsV0FBR0ssTUFBTUosU0FBU0UsSUFBSTtNQUN2QixDQUFBO0lBQ0Y7O0FBRUo7QUFLTSxTQUFTRyxTQUFtQ04sSUFBOEJPLE9BQWU7QUFDOUYsTUFBSUM7QUFDSixTQUFPLFlBQVlMLE1BQWE7QUFDOUIsUUFBSUksT0FBTztBQUNURSxtQkFBYUQsT0FBTztBQUNwQkEsZ0JBQVVFLFdBQVdWLElBQUlPLE9BQU9KLElBQUk7V0FDL0I7QUFDTEgsU0FBR0ssTUFBd0IsTUFBTUYsSUFBSTtJQUN0QztBQUNELFdBQU9JOztBQUVWO0lBTVlJLHFCQUFxQixDQUFDQyxVQUFzQ0EsVUFBVSxVQUFVLFNBQVNBLFVBQVUsUUFBUSxVQUFVO0FBTTNILElBQU1DLGlCQUFpQixDQUFDRCxPQUFtQ0UsT0FBZUMsUUFBZ0JILFVBQVUsVUFBVUUsUUFBUUYsVUFBVSxRQUFRRyxPQUFPRCxRQUFRQyxPQUFPO0FBTTlKLElBQU1DLFNBQVMsQ0FBQ0osT0FBb0NLLE1BQWNDLE9BQWVDLFFBQWlCO0FBQ3ZHLFFBQU1DLFFBQVFELE1BQU0sU0FBUztBQUM3QixTQUFPUCxVQUFVUSxRQUFRRixRQUFRTixVQUFVLFlBQVlLLE9BQU9DLFNBQVMsSUFBSUQ7O0FDMUU3RSxJQUFNSSxTQUFTLENBQUNDLE9BQWNBLE9BQU0sS0FBS0EsT0FBTTtBQUMvQyxJQUFNQyxZQUFZLENBQUNELElBQVdFLEdBQVdDLE1BQWMsRUFBRUMsS0FBS0MsSUFBSSxHQUFHLE1BQU1MLE1BQUssRUFBRSxJQUFJSSxLQUFLRSxLQUFLTixLQUFJRSxLQUFLSyxNQUFNSixDQUFDO0FBQ2hILElBQU1LLGFBQWEsQ0FBQ1IsSUFBV0UsR0FBV0MsTUFBY0MsS0FBS0MsSUFBSSxHQUFHLE1BQU1MLEVBQUMsSUFBSUksS0FBS0UsS0FBS04sS0FBSUUsS0FBS0ssTUFBTUosQ0FBQyxJQUFJO0FBTzdHLElBQU1NLFVBQVU7RUFDZEMsUUFBUSxDQUFDVixPQUFjQTtFQUV2QlcsWUFBWSxDQUFDWCxPQUFjQSxLQUFJQTtFQUUvQlksYUFBYSxDQUFDWixPQUFjLENBQUNBLE1BQUtBLEtBQUk7RUFFdENhLGVBQWUsQ0FBQ2IsUUFBZ0JBLE1BQUssT0FBTyxJQUN4QyxNQUFNQSxLQUFJQSxLQUNWLFFBQVEsRUFBR0EsTUFBTUEsS0FBSSxLQUFLO0VBRTlCYyxhQUFhLENBQUNkLE9BQWNBLEtBQUlBLEtBQUlBO0VBRXBDZSxjQUFjLENBQUNmLFFBQWVBLE1BQUssS0FBS0EsS0FBSUEsS0FBSTtFQUVoRGdCLGdCQUFnQixDQUFDaEIsUUFBZ0JBLE1BQUssT0FBTyxJQUN6QyxNQUFNQSxLQUFJQSxLQUFJQSxLQUNkLFFBQVFBLE1BQUssS0FBS0EsS0FBSUEsS0FBSTtFQUU5QmlCLGFBQWEsQ0FBQ2pCLE9BQWNBLEtBQUlBLEtBQUlBLEtBQUlBO0VBRXhDa0IsY0FBYyxDQUFDbEIsT0FBYyxHQUFHQSxNQUFLLEtBQUtBLEtBQUlBLEtBQUlBLEtBQUk7RUFFdERtQixnQkFBZ0IsQ0FBQ25CLFFBQWdCQSxNQUFLLE9BQU8sSUFDekMsTUFBTUEsS0FBSUEsS0FBSUEsS0FBSUEsS0FDbEIsU0FBU0EsTUFBSyxLQUFLQSxLQUFJQSxLQUFJQSxLQUFJO0VBRW5Db0IsYUFBYSxDQUFDcEIsT0FBY0EsS0FBSUEsS0FBSUEsS0FBSUEsS0FBSUE7RUFFNUNxQixjQUFjLENBQUNyQixRQUFlQSxNQUFLLEtBQUtBLEtBQUlBLEtBQUlBLEtBQUlBLEtBQUk7RUFFeERzQixnQkFBZ0IsQ0FBQ3RCLFFBQWdCQSxNQUFLLE9BQU8sSUFDekMsTUFBTUEsS0FBSUEsS0FBSUEsS0FBSUEsS0FBSUEsS0FDdEIsUUFBUUEsTUFBSyxLQUFLQSxLQUFJQSxLQUFJQSxLQUFJQSxLQUFJO0VBRXRDdUIsWUFBWSxDQUFDdkIsT0FBYyxDQUFDSSxLQUFLb0IsSUFBSXhCLEtBQUl5QixPQUFPLElBQUk7RUFFcERDLGFBQWEsQ0FBQzFCLE9BQWNJLEtBQUtFLElBQUlOLEtBQUl5QixPQUFPO0VBRWhERSxlQUFlLENBQUMzQixPQUFjLFFBQVFJLEtBQUtvQixJQUFJSSxLQUFLNUIsRUFBQyxJQUFJO0VBRXpENkIsWUFBWSxDQUFDN0IsT0FBZUEsT0FBTSxJQUFLLElBQUlJLEtBQUtDLElBQUksR0FBRyxNQUFNTCxLQUFJLEVBQUU7RUFFbkU4QixhQUFhLENBQUM5QixPQUFlQSxPQUFNLElBQUssSUFBSSxDQUFDSSxLQUFLQyxJQUFJLEdBQUcsTUFBTUwsRUFBQyxJQUFJO0VBRXBFK0IsZUFBZSxDQUFDL0IsT0FBY0QsT0FBT0MsRUFBQyxJQUFJQSxLQUFJQSxLQUFJLE1BQzlDLE1BQU1JLEtBQUtDLElBQUksR0FBRyxNQUFNTCxLQUFJLElBQUksRUFBRSxJQUNsQyxPQUFPLENBQUNJLEtBQUtDLElBQUksR0FBRyxPQUFPTCxLQUFJLElBQUksRUFBRSxJQUFJO0VBRTdDZ0MsWUFBWSxDQUFDaEMsT0FBZUEsTUFBSyxJQUFLQSxLQUFJLEVBQUVJLEtBQUs2QixLQUFLLElBQUlqQyxLQUFJQSxFQUFDLElBQUk7RUFFbkVrQyxhQUFhLENBQUNsQyxPQUFjSSxLQUFLNkIsS0FBSyxLQUFLakMsTUFBSyxLQUFLQSxFQUFDO0VBRXREbUMsZUFBZSxDQUFDbkMsUUFBZ0JBLE1BQUssT0FBTyxJQUN4QyxRQUFRSSxLQUFLNkIsS0FBSyxJQUFJakMsS0FBSUEsRUFBQyxJQUFJLEtBQy9CLE9BQU9JLEtBQUs2QixLQUFLLEtBQUtqQyxNQUFLLEtBQUtBLEVBQUMsSUFBSTtFQUV6Q29DLGVBQWUsQ0FBQ3BDLE9BQWNELE9BQU9DLEVBQUMsSUFBSUEsS0FBSUMsVUFBVUQsSUFBRyxPQUFPLEdBQUc7RUFFckVxQyxnQkFBZ0IsQ0FBQ3JDLE9BQWNELE9BQU9DLEVBQUMsSUFBSUEsS0FBSVEsV0FBV1IsSUFBRyxPQUFPLEdBQUc7RUFFdkVzQyxpQkFBaUJ0QyxJQUFXO0FBQzFCLFVBQU1FLElBQUk7QUFDVixVQUFNQyxJQUFJO0FBQ1YsV0FBT0osT0FBT0MsRUFBQyxJQUFJQSxLQUNqQkEsS0FBSSxNQUNBLE1BQU1DLFVBQVVELEtBQUksR0FBR0UsR0FBR0MsQ0FBQyxJQUMzQixNQUFNLE1BQU1LLFdBQVdSLEtBQUksSUFBSSxHQUFHRSxHQUFHQyxDQUFDO0VBQzdDO0VBRURvQyxXQUFXdkMsSUFBVztBQUNwQixVQUFNRSxJQUFJO0FBQ1YsV0FBT0YsS0FBSUEsT0FBTUUsSUFBSSxLQUFLRixLQUFJRTtFQUMvQjtFQUVEc0MsWUFBWXhDLElBQVc7QUFDckIsVUFBTUUsSUFBSTtBQUNWLFlBQVFGLE1BQUssS0FBS0EsT0FBTUUsSUFBSSxLQUFLRixLQUFJRSxLQUFLO0VBQzNDO0VBRUR1QyxjQUFjekMsSUFBVztBQUN2QixRQUFJRSxJQUFJO0FBQ1IsU0FBS0YsTUFBSyxPQUFPLEdBQUc7QUFDbEIsYUFBTyxPQUFPQSxLQUFJQSxRQUFPRSxLQUFNLFNBQVUsS0FBS0YsS0FBSUU7SUFDbkQ7QUFDRCxXQUFPLFFBQVFGLE1BQUssS0FBS0EsUUFBT0UsS0FBTSxTQUFVLEtBQUtGLEtBQUlFLEtBQUs7RUFDL0Q7RUFFRHdDLGNBQWMsQ0FBQzFDLE9BQWMsSUFBSVMsUUFBUWtDLGNBQWMsSUFBSTNDLEVBQUM7RUFFNUQyQyxjQUFjM0MsSUFBVztBQUN2QixVQUFNNEMsSUFBSTtBQUNWLFVBQU1DLElBQUk7QUFDVixRQUFJN0MsS0FBSyxJQUFJNkMsR0FBSTtBQUNmLGFBQU9ELElBQUk1QyxLQUFJQTtJQUNoQjtBQUNELFFBQUlBLEtBQUssSUFBSTZDLEdBQUk7QUFDZixhQUFPRCxLQUFLNUMsTUFBTSxNQUFNNkMsS0FBTTdDLEtBQUk7SUFDbkM7QUFDRCxRQUFJQSxLQUFLLE1BQU02QyxHQUFJO0FBQ2pCLGFBQU9ELEtBQUs1QyxNQUFNLE9BQU82QyxLQUFNN0MsS0FBSTtJQUNwQztBQUNELFdBQU80QyxLQUFLNUMsTUFBTSxRQUFRNkMsS0FBTTdDLEtBQUk7RUFDckM7RUFFRDhDLGlCQUFpQixDQUFDOUMsT0FBY0EsS0FBSyxNQUNqQ1MsUUFBUWlDLGFBQWExQyxLQUFJLENBQUMsSUFBSSxNQUM5QlMsUUFBUWtDLGNBQWMzQyxLQUFJLElBQUksQ0FBQyxJQUFJLE1BQU07QUFDOUM7QUFJRCxJQUFBLFlBQWVTO0FDckhmLFNBQVMsTUFBTSxHQUFHO0FBQ2hCLFNBQU8sSUFBSSxNQUFNO0FBQ25CO0FBQ0EsSUFBTSxNQUFNLENBQUMsR0FBRyxHQUFHc0MsT0FBTSxLQUFLLElBQUksS0FBSyxJQUFJLEdBQUdBLEVBQUMsR0FBRyxDQUFDO0FBQ25ELFNBQVMsSUFBSSxHQUFHO0FBQ2QsU0FBTyxJQUFJLE1BQU0sSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHO0FBQ3BDO0FBSUEsU0FBUyxJQUFJLEdBQUc7QUFDZCxTQUFPLElBQUksTUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDbkM7QUFDQSxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLEtBQUssR0FBRyxDQUFDO0FBQ3hDO0FBQ0EsU0FBUyxJQUFJLEdBQUc7QUFDZCxTQUFPLElBQUksTUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDbkM7QUFFQSxJQUFNLFFBQVEsRUFBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLEdBQUU7QUFDN0osSUFBTSxNQUFNLENBQUMsR0FBRyxrQkFBa0I7QUFDbEMsSUFBTSxLQUFLLE9BQUssSUFBSSxJQUFJO0FBQ3hCLElBQU0sS0FBSyxPQUFLLEtBQUssSUFBSSxRQUFTLEtBQUssSUFBSSxJQUFJO0FBQy9DLElBQU0sS0FBSyxRQUFPLElBQUksUUFBUyxPQUFRLElBQUk7QUFDM0MsSUFBTSxVQUFVLE9BQUssR0FBRyxFQUFFLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDNUQsU0FBUyxTQUFTLEtBQUs7QUFDckIsTUFBSSxNQUFNLElBQUk7QUFDZCxNQUFJO0FBQ0osTUFBSSxJQUFJLE9BQU8sS0FBSztBQUNsQixRQUFJLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDMUIsWUFBTTtRQUNKLEdBQUcsTUFBTSxNQUFNLElBQUksTUFBTTtRQUN6QixHQUFHLE1BQU0sTUFBTSxJQUFJLE1BQU07UUFDekIsR0FBRyxNQUFNLE1BQU0sSUFBSSxNQUFNO1FBQ3pCLEdBQUcsUUFBUSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUs7TUFDNUM7SUFDQSxXQUFlLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDakMsWUFBTTtRQUNKLEdBQUcsTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUk7UUFDbEMsR0FBRyxNQUFNLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSTtRQUNsQyxHQUFHLE1BQU0sSUFBSSxPQUFPLElBQUksTUFBTSxJQUFJO1FBQ2xDLEdBQUcsUUFBUSxJQUFLLE1BQU0sSUFBSSxPQUFPLElBQUksTUFBTSxJQUFJLE1BQU87TUFDOUQ7SUFDQTtFQUNBO0FBQ0UsU0FBTztBQUNUO0FBQ0EsSUFBTSxRQUFRLENBQUMsR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLENBQUMsSUFBSTtBQUN6QyxTQUFTLFVBQVUsR0FBRztBQUNwQixNQUFJLElBQUksUUFBUSxDQUFDLElBQUksS0FBSztBQUMxQixTQUFPLElBQ0gsTUFBTSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQzdDO0FBQ047QUFFQSxJQUFNLFNBQVM7QUFDZixTQUFTLFNBQVNBLElBQUcsR0FBRyxHQUFHO0FBQ3pCLFFBQU0sSUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHLElBQUksQ0FBQztBQUMvQixRQUFNLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSUEsS0FBSSxNQUFNLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUN0RixTQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDMUI7QUFDQSxTQUFTLFNBQVNBLElBQUcsR0FBRyxHQUFHO0FBQ3pCLFFBQU0sSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJQSxLQUFJLE1BQU0sTUFBTSxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQ3BGLFNBQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUMxQjtBQUNBLFNBQVMsU0FBU0EsSUFBRyxHQUFHLEdBQUc7QUFDekIsUUFBTSxNQUFNLFNBQVNBLElBQUcsR0FBRyxHQUFHO0FBQzlCLE1BQUk7QUFDSixNQUFJLElBQUksSUFBSSxHQUFHO0FBQ2IsUUFBSSxLQUFLLElBQUk7QUFDYixTQUFLO0FBQ0wsU0FBSztFQUNUO0FBQ0UsT0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDdEIsUUFBSSxNQUFNLElBQUksSUFBSTtBQUNsQixRQUFJLE1BQU07RUFDZDtBQUNFLFNBQU87QUFDVDtBQUNBLFNBQVMsU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUs7QUFDakMsTUFBSSxNQUFNLEtBQUs7QUFDYixZQUFTLElBQUksS0FBSyxLQUFNLElBQUksSUFBSSxJQUFJO0VBQ3hDO0FBQ0UsTUFBSSxNQUFNLEtBQUs7QUFDYixZQUFRLElBQUksS0FBSyxJQUFJO0VBQ3pCO0FBQ0UsVUFBUSxJQUFJLEtBQUssSUFBSTtBQUN2QjtBQUNBLFNBQVMsUUFBUSxHQUFHO0FBQ2xCLFFBQU0sUUFBUTtBQUNkLFFBQU0sSUFBSSxFQUFFLElBQUk7QUFDaEIsUUFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixRQUFNLElBQUksRUFBRSxJQUFJO0FBQ2hCLFFBQU0sTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUM7QUFDNUIsUUFBTSxNQUFNLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUM1QixRQUFNLEtBQUssTUFBTSxPQUFPO0FBQ3hCLE1BQUlBLElBQUcsR0FBRztBQUNWLE1BQUksUUFBUSxLQUFLO0FBQ2YsUUFBSSxNQUFNO0FBQ1YsUUFBSSxJQUFJLE1BQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLE1BQU07QUFDL0MsSUFBQUEsS0FBSSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUM1QixJQUFBQSxLQUFJQSxLQUFJLEtBQUs7RUFDakI7QUFDRSxTQUFPLENBQUNBLEtBQUksR0FBRyxLQUFLLEdBQUcsQ0FBQztBQUMxQjtBQUNBLFNBQVMsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ3pCLFVBQ0UsTUFBTSxRQUFRLENBQUMsSUFDWCxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLElBQ2xCLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FDYixJQUFJLEdBQUc7QUFDWDtBQUNBLFNBQVMsUUFBUUEsSUFBRyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxNQUFNLFVBQVVBLElBQUcsR0FBRyxDQUFDO0FBQ2hDO0FBQ0EsU0FBUyxRQUFRQSxJQUFHLEdBQUcsR0FBRztBQUN4QixTQUFPLE1BQU0sVUFBVUEsSUFBRyxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTLFFBQVFBLElBQUcsR0FBRyxHQUFHO0FBQ3hCLFNBQU8sTUFBTSxVQUFVQSxJQUFHLEdBQUcsQ0FBQztBQUNoQztBQUNBLFNBQVMsSUFBSUEsSUFBRztBQUNkLFVBQVFBLEtBQUksTUFBTSxPQUFPO0FBQzNCO0FBQ0EsU0FBUyxTQUFTLEtBQUs7QUFDckIsUUFBTSxJQUFJLE9BQU8sS0FBSyxHQUFHO0FBQ3pCLE1BQUksSUFBSTtBQUNSLE1BQUk7QUFDSixNQUFJLENBQUMsR0FBRztBQUNOO0VBQ0o7QUFDRSxNQUFJLEVBQUUsT0FBTyxHQUFHO0FBQ2QsUUFBSSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7RUFDckM7QUFDRSxRQUFNQSxLQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7QUFDbkIsUUFBTSxLQUFLLENBQUMsRUFBRSxLQUFLO0FBQ25CLFFBQU0sS0FBSyxDQUFDLEVBQUUsS0FBSztBQUNuQixNQUFJLEVBQUUsT0FBTyxPQUFPO0FBQ2xCLFFBQUksUUFBUUEsSUFBRyxJQUFJLEVBQUU7RUFDekIsV0FBYSxFQUFFLE9BQU8sT0FBTztBQUN6QixRQUFJLFFBQVFBLElBQUcsSUFBSSxFQUFFO0VBQ3pCLE9BQVM7QUFDTCxRQUFJLFFBQVFBLElBQUcsSUFBSSxFQUFFO0VBQ3pCO0FBQ0UsU0FBTztJQUNMLEdBQUcsRUFBRTtJQUNMLEdBQUcsRUFBRTtJQUNMLEdBQUcsRUFBRTtJQUNMO0VBQ0o7QUFDQTtBQUNBLFNBQVMsT0FBTyxHQUFHLEtBQUs7QUFDdEIsTUFBSUEsS0FBSSxRQUFRLENBQUM7QUFDakIsRUFBQUEsR0FBRSxLQUFLLElBQUlBLEdBQUUsS0FBSyxHQUFHO0FBQ3JCLEVBQUFBLEtBQUksUUFBUUEsRUFBQztBQUNiLElBQUUsSUFBSUEsR0FBRTtBQUNSLElBQUUsSUFBSUEsR0FBRTtBQUNSLElBQUUsSUFBSUEsR0FBRTtBQUNWO0FBQ0EsU0FBUyxVQUFVLEdBQUc7QUFDcEIsTUFBSSxDQUFDLEdBQUc7QUFDTjtFQUNKO0FBQ0UsUUFBTSxJQUFJLFFBQVEsQ0FBQztBQUNuQixRQUFNQSxLQUFJLEVBQUU7QUFDWixRQUFNLElBQUksSUFBSSxFQUFFLEVBQUU7QUFDbEIsUUFBTSxJQUFJLElBQUksRUFBRSxFQUFFO0FBQ2xCLFNBQU8sRUFBRSxJQUFJLE1BQ1QsUUFBUUEsT0FBTSxPQUFPLE9BQU8sSUFBSSxFQUFFLENBQUMsT0FDbkMsT0FBT0EsT0FBTSxPQUFPO0FBQzFCO0FBRUEsSUFBTSxNQUFNO0VBQ1YsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0VBQ0gsR0FBRztFQUNILEdBQUc7RUFDSCxHQUFHO0FBQ0w7QUFDQSxJQUFNLFVBQVU7RUFDZCxRQUFRO0VBQ1IsYUFBYTtFQUNiLE1BQU07RUFDTixXQUFXO0VBQ1gsTUFBTTtFQUNOLE9BQU87RUFDUCxRQUFRO0VBQ1IsT0FBTztFQUNQLGNBQWM7RUFDZCxJQUFJO0VBQ0osU0FBUztFQUNULE1BQU07RUFDTixXQUFXO0VBQ1gsUUFBUTtFQUNSLFVBQVU7RUFDVixTQUFTO0VBQ1QsS0FBSztFQUNMLGFBQWE7RUFDYixTQUFTO0VBQ1QsU0FBUztFQUNULE1BQU07RUFDTixLQUFLO0VBQ0wsT0FBTztFQUNQLFNBQVM7RUFDVCxNQUFNO0VBQ04sTUFBTTtFQUNOLE1BQU07RUFDTixRQUFRO0VBQ1IsU0FBUztFQUNULFVBQVU7RUFDVixRQUFRO0VBQ1IsT0FBTztFQUNQLEtBQUs7RUFDTCxRQUFRO0VBQ1IsUUFBUTtFQUNSLE1BQU07RUFDTixPQUFPO0VBQ1AsT0FBTztFQUNQLEtBQUs7RUFDTCxRQUFRO0VBQ1IsUUFBUTtFQUNSLFVBQVU7RUFDVixRQUFRO0VBQ1IsUUFBUTtFQUNSLFVBQVU7RUFDVixVQUFVO0VBQ1YsVUFBVTtFQUNWLFVBQVU7RUFDVixRQUFRO0VBQ1IsU0FBUztFQUNULFdBQVc7RUFDWCxLQUFLO0VBQ0wsUUFBUTtFQUNSLEtBQUs7RUFDTCxLQUFLO0VBQ0wsT0FBTztFQUNQLEtBQUs7RUFDTCxTQUFTO0VBQ1QsUUFBUTtFQUNSLFNBQVM7RUFDVCxPQUFPO0VBQ1AsTUFBTTtFQUNOLE9BQU87RUFDUCxRQUFRO0VBQ1IsV0FBVztFQUNYLFNBQVM7RUFDVCxZQUFZO0VBQ1osS0FBSztFQUNMLE1BQU07RUFDTixPQUFPO0VBQ1AsV0FBVztFQUNYLE1BQU07RUFDTixNQUFNO0VBQ04sTUFBTTtFQUNOLE1BQU07RUFDTixRQUFRO0VBQ1IsUUFBUTtFQUNSLFFBQVE7RUFDUixPQUFPO0VBQ1AsT0FBTztFQUNQLFNBQVM7RUFDVCxLQUFLO0VBQ0wsTUFBTTtFQUNOLFNBQVM7RUFDVCxLQUFLO0VBQ0wsUUFBUTtFQUNSLE9BQU87RUFDUCxZQUFZO0VBQ1osS0FBSztFQUNMLE9BQU87RUFDUCxRQUFRO0VBQ1IsUUFBUTtFQUNSLE1BQU07RUFDTixXQUFXO0VBQ1gsS0FBSztFQUNMLFVBQVU7RUFDVixZQUFZO0VBQ1osU0FBUztFQUNULFVBQVU7RUFDVixTQUFTO0VBQ1QsWUFBWTtFQUNaLE1BQU07RUFDTixRQUFRO0VBQ1IsTUFBTTtFQUNOLFNBQVM7RUFDVCxPQUFPO0VBQ1AsU0FBUztFQUNULE1BQU07RUFDTixXQUFXO0VBQ1gsUUFBUTtFQUNSLE9BQU87RUFDUCxZQUFZO0VBQ1osV0FBVztFQUNYLFNBQVM7RUFDVCxNQUFNO0VBQ04sS0FBSztFQUNMLE1BQU07RUFDTixTQUFTO0VBQ1QsT0FBTztFQUNQLGFBQWE7RUFDYixJQUFJO0VBQ0osVUFBVTtFQUNWLE9BQU87RUFDUCxXQUFXO0VBQ1gsT0FBTztFQUNQLFdBQVc7RUFDWCxPQUFPO0VBQ1AsU0FBUztFQUNULE9BQU87RUFDUCxRQUFRO0VBQ1IsT0FBTztFQUNQLEtBQUs7RUFDTCxNQUFNO0VBQ04sTUFBTTtFQUNOLE1BQU07RUFDTixVQUFVO0VBQ1YsUUFBUTtFQUNSLEtBQUs7RUFDTCxLQUFLO0VBQ0wsT0FBTztFQUNQLFFBQVE7RUFDUixJQUFJO0VBQ0osT0FBTztFQUNQLEtBQUs7RUFDTCxNQUFNO0VBQ04sV0FBVztFQUNYLElBQUk7RUFDSixPQUFPO0FBQ1Q7QUFDQSxTQUFTLFNBQVM7QUFDaEIsUUFBTSxXQUFXLENBQUE7QUFDakIsUUFBTSxPQUFPLE9BQU8sS0FBSyxPQUFPO0FBQ2hDLFFBQU0sUUFBUSxPQUFPLEtBQUssR0FBRztBQUM3QixNQUFJLEdBQUcsR0FBRyxHQUFHLElBQUk7QUFDakIsT0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNoQyxTQUFLLEtBQUssS0FBSztBQUNmLFNBQUssSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDakMsVUFBSSxNQUFNO0FBQ1YsV0FBSyxHQUFHLFFBQVEsR0FBRyxJQUFJLEVBQUU7SUFDL0I7QUFDSSxRQUFJLFNBQVMsUUFBUSxLQUFLLEVBQUU7QUFDNUIsYUFBUyxNQUFNLENBQUMsS0FBSyxLQUFLLEtBQU0sS0FBSyxJQUFJLEtBQU0sSUFBSSxHQUFJO0VBQzNEO0FBQ0UsU0FBTztBQUNUO0FBRUEsSUFBSTtBQUNKLFNBQVMsVUFBVSxLQUFLO0FBQ3RCLE1BQUksQ0FBQyxPQUFPO0FBQ1YsWUFBUSxPQUFNO0FBQ2QsVUFBTSxjQUFjLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNuQztBQUNFLFFBQU0sSUFBSSxNQUFNLElBQUksWUFBVztBQUMvQixTQUFPLEtBQUs7SUFDVixHQUFHLEVBQUU7SUFDTCxHQUFHLEVBQUU7SUFDTCxHQUFHLEVBQUU7SUFDTCxHQUFHLEVBQUUsV0FBVyxJQUFJLEVBQUUsS0FBSztFQUMvQjtBQUNBO0FBRUEsSUFBTSxTQUFTO0FBQ2YsU0FBUyxTQUFTLEtBQUs7QUFDckIsUUFBTSxJQUFJLE9BQU8sS0FBSyxHQUFHO0FBQ3pCLE1BQUksSUFBSTtBQUNSLE1BQUksR0FBRyxHQUFHO0FBQ1YsTUFBSSxDQUFDLEdBQUc7QUFDTjtFQUNKO0FBQ0UsTUFBSSxFQUFFLE9BQU8sR0FBRztBQUNkLFVBQU0sSUFBSSxDQUFDLEVBQUU7QUFDYixRQUFJLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksS0FBSyxHQUFHLEdBQUc7RUFDM0M7QUFDRSxNQUFJLENBQUMsRUFBRTtBQUNQLE1BQUksQ0FBQyxFQUFFO0FBQ1AsTUFBSSxDQUFDLEVBQUU7QUFDUCxNQUFJLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUc7QUFDeEMsTUFBSSxPQUFPLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHO0FBQ3hDLE1BQUksT0FBTyxFQUFFLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRztBQUN4QyxTQUFPO0lBQ0w7SUFDQTtJQUNBO0lBQ0E7RUFDSjtBQUNBO0FBQ0EsU0FBUyxVQUFVLEdBQUc7QUFDcEIsU0FBTyxNQUNMLEVBQUUsSUFBSSxNQUNGLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sSUFBSSxFQUFFLENBQUMsT0FDdkMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFFakM7QUFFQSxJQUFNLEtBQUssT0FBSyxLQUFLLFdBQVksSUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLElBQU0sR0FBRyxJQUFJLFFBQVE7QUFDOUUsSUFBTSxPQUFPLE9BQUssS0FBSyxVQUFVLElBQUksUUFBUSxLQUFLLEtBQUssSUFBSSxTQUFTLE9BQU8sR0FBRztBQUM5RSxTQUFTQyxhQUFZLE1BQU0sTUFBTWhELElBQUc7QUFDbEMsUUFBTSxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMxQixRQUFNLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDO0FBQzFCLFFBQU0sSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLENBQUM7QUFDMUIsU0FBTztJQUNMLEdBQUcsSUFBSSxHQUFHLElBQUlBLE1BQUssS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFDLEdBQUcsSUFBSSxHQUFHLElBQUlBLE1BQUssS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFDLEdBQUcsSUFBSSxHQUFHLElBQUlBLE1BQUssS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFDLEdBQUcsS0FBSyxJQUFJQSxNQUFLLEtBQUssSUFBSSxLQUFLO0VBQ25DO0FBQ0E7QUFFQSxTQUFTLE9BQU8sR0FBRyxHQUFHLE9BQU87QUFDM0IsTUFBSSxHQUFHO0FBQ0wsUUFBSSxNQUFNLFFBQVEsQ0FBQztBQUNuQixRQUFJLEtBQUssS0FBSyxJQUFJLEdBQUcsS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssT0FBTyxNQUFNLElBQUksTUFBTSxDQUFDLENBQUM7QUFDekUsVUFBTSxRQUFRLEdBQUc7QUFDakIsTUFBRSxJQUFJLElBQUk7QUFDVixNQUFFLElBQUksSUFBSTtBQUNWLE1BQUUsSUFBSSxJQUFJO0VBQ2Q7QUFDQTtBQUNBLFNBQVMsTUFBTSxHQUFHLE9BQU87QUFDdkIsU0FBTyxJQUFJLE9BQU8sT0FBTyxTQUFTLENBQUEsR0FBSSxDQUFDLElBQUk7QUFDN0M7QUFDQSxTQUFTLFdBQVcsT0FBTztBQUN6QixNQUFJLElBQUksRUFBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDakMsTUFBSSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3hCLFFBQUksTUFBTSxVQUFVLEdBQUc7QUFDckIsVUFBSSxFQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLEdBQUcsSUFBRztBQUNsRCxVQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ3BCLFVBQUUsSUFBSSxJQUFJLE1BQU0sRUFBRTtNQUMxQjtJQUNBO0VBQ0EsT0FBUztBQUNMLFFBQUksTUFBTSxPQUFPLEVBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFDLENBQUM7QUFDekMsTUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0VBQ2pCO0FBQ0UsU0FBTztBQUNUO0FBQ0EsU0FBUyxjQUFjLEtBQUs7QUFDMUIsTUFBSSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDekIsV0FBTyxTQUFTLEdBQUc7RUFDdkI7QUFDRSxTQUFPLFNBQVMsR0FBRztBQUNyQjtBQUNBLElBQU0sUUFBTixNQUFZO0VBQ1YsWUFBWSxPQUFPO0FBQ2pCLFFBQUksaUJBQWlCLE9BQU87QUFDMUIsYUFBTztJQUNiO0FBQ0ksVUFBTSxPQUFPLE9BQU87QUFDcEIsUUFBSTtBQUNKLFFBQUksU0FBUyxVQUFVO0FBQ3JCLFVBQUksV0FBVyxLQUFLO0lBQzFCLFdBQWUsU0FBUyxVQUFVO0FBQzVCLFVBQUksU0FBUyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssY0FBYyxLQUFLO0lBQ3BFO0FBQ0ksU0FBSyxPQUFPO0FBQ1osU0FBSyxTQUFTLENBQUMsQ0FBQztFQUNwQjtFQUNFLElBQUksUUFBUTtBQUNWLFdBQU8sS0FBSztFQUNoQjtFQUNFLElBQUksTUFBTTtBQUNSLFFBQUksSUFBSSxNQUFNLEtBQUssSUFBSTtBQUN2QixRQUFJLEdBQUc7QUFDTCxRQUFFLElBQUksSUFBSSxFQUFFLENBQUM7SUFDbkI7QUFDSSxXQUFPO0VBQ1g7RUFDRSxJQUFJLElBQUksS0FBSztBQUNYLFNBQUssT0FBTyxXQUFXLEdBQUc7RUFDOUI7RUFDRSxZQUFZO0FBQ1YsV0FBTyxLQUFLLFNBQVMsVUFBVSxLQUFLLElBQUksSUFBSTtFQUNoRDtFQUNFLFlBQVk7QUFDVixXQUFPLEtBQUssU0FBUyxVQUFVLEtBQUssSUFBSSxJQUFJO0VBQ2hEO0VBQ0UsWUFBWTtBQUNWLFdBQU8sS0FBSyxTQUFTLFVBQVUsS0FBSyxJQUFJLElBQUk7RUFDaEQ7RUFDRSxJQUFJaUQsUUFBTyxRQUFRO0FBQ2pCLFFBQUlBLFFBQU87QUFDVCxZQUFNLEtBQUssS0FBSztBQUNoQixZQUFNLEtBQUtBLE9BQU07QUFDakIsVUFBSTtBQUNKLFlBQU0sSUFBSSxXQUFXLEtBQUssTUFBTTtBQUNoQyxZQUFNLElBQUksSUFBSSxJQUFJO0FBQ2xCLFlBQU0sSUFBSSxHQUFHLElBQUksR0FBRztBQUNwQixZQUFNLE9BQU8sSUFBSSxNQUFNLEtBQUssS0FBSyxJQUFJLE1BQU0sSUFBSSxJQUFJLE1BQU0sS0FBSztBQUM5RCxXQUFLLElBQUk7QUFDVCxTQUFHLElBQUksTUFBTyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUcsSUFBSTtBQUN0QyxTQUFHLElBQUksTUFBTyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUcsSUFBSTtBQUN0QyxTQUFHLElBQUksTUFBTyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUcsSUFBSTtBQUN0QyxTQUFHLElBQUksSUFBSSxHQUFHLEtBQUssSUFBSSxLQUFLLEdBQUc7QUFDL0IsV0FBSyxNQUFNO0lBQ2pCO0FBQ0ksV0FBTztFQUNYO0VBQ0UsWUFBWUEsUUFBT2pELElBQUc7QUFDcEIsUUFBSWlELFFBQU87QUFDVCxXQUFLLE9BQU9ELGFBQVksS0FBSyxNQUFNQyxPQUFNLE1BQU1qRCxFQUFDO0lBQ3REO0FBQ0ksV0FBTztFQUNYO0VBQ0UsUUFBUTtBQUNOLFdBQU8sSUFBSSxNQUFNLEtBQUssR0FBRztFQUM3QjtFQUNFLE1BQU0sR0FBRztBQUNQLFNBQUssS0FBSyxJQUFJLElBQUksQ0FBQztBQUNuQixXQUFPO0VBQ1g7RUFDRSxRQUFRLE9BQU87QUFDYixVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJLEtBQUssSUFBSTtBQUNiLFdBQU87RUFDWDtFQUNFLFlBQVk7QUFDVixVQUFNLE1BQU0sS0FBSztBQUNqQixVQUFNLE1BQU0sTUFBTSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUksT0FBTyxJQUFJLElBQUksSUFBSTtBQUMzRCxRQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUN4QixXQUFPO0VBQ1g7RUFDRSxRQUFRLE9BQU87QUFDYixVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJLEtBQUssSUFBSTtBQUNiLFdBQU87RUFDWDtFQUNFLFNBQVM7QUFDUCxVQUFNLElBQUksS0FBSztBQUNmLE1BQUUsSUFBSSxNQUFNLEVBQUU7QUFDZCxNQUFFLElBQUksTUFBTSxFQUFFO0FBQ2QsTUFBRSxJQUFJLE1BQU0sRUFBRTtBQUNkLFdBQU87RUFDWDtFQUNFLFFBQVEsT0FBTztBQUNiLFdBQU8sS0FBSyxNQUFNLEdBQUcsS0FBSztBQUMxQixXQUFPO0VBQ1g7RUFDRSxPQUFPLE9BQU87QUFDWixXQUFPLEtBQUssTUFBTSxHQUFHLENBQUMsS0FBSztBQUMzQixXQUFPO0VBQ1g7RUFDRSxTQUFTLE9BQU87QUFDZCxXQUFPLEtBQUssTUFBTSxHQUFHLEtBQUs7QUFDMUIsV0FBTztFQUNYO0VBQ0UsV0FBVyxPQUFPO0FBQ2hCLFdBQU8sS0FBSyxNQUFNLEdBQUcsQ0FBQyxLQUFLO0FBQzNCLFdBQU87RUFDWDtFQUNFLE9BQU8sS0FBSztBQUNWLFdBQU8sS0FBSyxNQUFNLEdBQUc7QUFDckIsV0FBTztFQUNYO0FBQ0E7QUFFQSxTQUFTLFVBQVUsT0FBTztBQUN4QixTQUFPLElBQUksTUFBTSxLQUFLO0FBQ3hCO0FDeGtCTyxTQUFTa0Qsb0JBQW9CQyxPQUF5RDtBQUMzRixNQUFJQSxTQUFTLE9BQU9BLFVBQVUsVUFBVTtBQUN0QyxVQUFNQyxPQUFPRCxNQUFNRSxTQUFRO0FBQzNCLFdBQU9ELFNBQVMsNEJBQTRCQSxTQUFTO0VBQ3REO0FBRUQsU0FBTztBQUNSO0FBV00sU0FBU0gsTUFBTUUsT0FBTztBQUMzQixTQUFPRCxvQkFBb0JDLEtBQUssSUFBSUEsUUFBUUcsVUFBU0gsS0FBSztBQUMzRDtBQUtNLFNBQVNJLGNBQWNKLE9BQU87QUFDbkMsU0FBT0Qsb0JBQW9CQyxLQUFLLElBQzVCQSxRQUNBRyxVQUFTSCxLQUFLLEVBQUVLLFNBQVMsR0FBRyxFQUFFQyxPQUFPLEdBQUcsRUFBRUMsVUFBUztBQUN4RDtBQy9CRCxJQUFNQyxVQUFVO0VBQUM7RUFBSztFQUFLO0VBQWU7RUFBVTs7QUFDcEQsSUFBTUMsU0FBUztFQUFDO0VBQVM7RUFBZTs7QUFFakMsU0FBU0Msd0JBQXdCQyxXQUFVO0FBQ2hEQSxFQUFBQSxVQUFTQyxJQUFJLGFBQWE7SUFDeEJDLE9BQU9DO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxJQUFJSDtJQUNKSSxNQUFNSjtJQUNOSyxNQUFNTDtJQUNOTSxJQUFJTjtJQUNKYixNQUFNYTtFQUNQLENBQUE7QUFFREgsRUFBQUEsVUFBU1UsU0FBUyxhQUFhO0lBQzdCQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsYUFBYSxDQUFDQyxVQUFTQSxVQUFTLGdCQUFnQkEsVUFBUyxnQkFBZ0JBLFVBQVM7RUFDbkYsQ0FBQTtBQUVEZCxFQUFBQSxVQUFTQyxJQUFJLGNBQWM7SUFDekJILFFBQVE7TUFDTlIsTUFBTTtNQUNOeUIsWUFBWWpCO0lBQ2I7SUFDREQsU0FBUztNQUNQUCxNQUFNO01BQ055QixZQUFZbEI7SUFDYjtFQUNGLENBQUE7QUFFREcsRUFBQUEsVUFBU1UsU0FBUyxjQUFjO0lBQzlCQyxXQUFXO0VBQ1osQ0FBQTtBQUVEWCxFQUFBQSxVQUFTQyxJQUFJLGVBQWU7SUFDMUJlLFFBQVE7TUFDTkMsV0FBVztRQUNUYixVQUFVO01BQ1g7SUFDRjtJQUNEYyxRQUFRO01BQ05ELFdBQVc7UUFDVGIsVUFBVTtNQUNYO0lBQ0Y7SUFDRGUsTUFBTTtNQUNKQyxZQUFZO1FBQ1Z0QixRQUFRO1VBQ05TLE1BQU07UUFDUDtRQUNEYyxTQUFTO1VBQ1AvQixNQUFNO1VBQ05jLFVBQVU7UUFDWDtNQUNGO0lBQ0Y7SUFDRGtCLE1BQU07TUFDSkYsWUFBWTtRQUNWdEIsUUFBUTtVQUNOVyxJQUFJO1FBQ0w7UUFDRFksU0FBUztVQUNQL0IsTUFBTTtVQUNOZSxRQUFRO1VBQ1JDLElBQUlpQixDQUFBQSxNQUFLQSxJQUFJO1FBQ2Q7TUFDRjtJQUNGO0VBQ0YsQ0FBQTtBQUNGO0FDdkVNLFNBQVNDLHFCQUFxQnhCLFdBQVU7QUFDN0NBLEVBQUFBLFVBQVNDLElBQUksVUFBVTtJQUNyQndCLGFBQWE7SUFDYkMsU0FBUztNQUNQQyxLQUFLO01BQ0xDLE9BQU87TUFDUEMsUUFBUTtNQUNSQyxNQUFNO0lBQ1A7RUFDRixDQUFBO0FBQ0Y7QUNURCxJQUFNQyxZQUFZLG9CQUFJQyxJQUFHO0FBRXpCLFNBQVNDLGdCQUFnQkMsU0FBZ0JDLFNBQW9DO0FBQzNFQSxZQUFVQSxXQUFXLENBQUE7QUFDckIsUUFBTUMsV0FBV0YsVUFBU0csS0FBS0MsVUFBVUgsT0FBTztBQUNoRCxNQUFJSSxZQUFZUixVQUFVUyxJQUFJSixRQUFRO0FBQ3RDLE1BQUksQ0FBQ0csV0FBVztBQUNkQSxnQkFBWSxJQUFJRSxLQUFLQyxhQUFhUixTQUFRQyxPQUFPO0FBQ2pESixjQUFVOUIsSUFBSW1DLFVBQVVHLFNBQVM7RUFDbEM7QUFDRCxTQUFPQTtBQUNSO0FBRU0sU0FBU0ksYUFBYUMsS0FBYVYsU0FBZ0JDLFNBQW9DO0FBQzVGLFNBQU9GLGdCQUFnQkMsU0FBUUMsT0FBTyxFQUFFVSxPQUFPRCxHQUFHO0FBQ25EO0FDUkQsSUFBTUUsYUFBYTtFQU9qQkMsT0FBTzFELE9BQU87QUFDWixXQUFPMkQsUUFBUTNELEtBQUssSUFBNkJBLFFBQVMsS0FBS0E7RUFDaEU7RUFVRDRELFFBQVFDLFdBQVdDLE9BQU9DLE9BQU87QUFDL0IsUUFBSUYsY0FBYyxHQUFHO0FBQ25CLGFBQU87SUFDUjtBQUVELFVBQU1oQixVQUFTLEtBQUttQixNQUFNbEIsUUFBUUQ7QUFDbEMsUUFBSW9CO0FBQ0osUUFBSUMsUUFBUUw7QUFFWixRQUFJRSxNQUFNSSxTQUFTLEdBQUc7QUFFcEIsWUFBTUMsVUFBVW5ILEtBQUtvSCxJQUFJcEgsS0FBS3FILElBQUlQLE1BQU0sR0FBRy9ELEtBQUssR0FBRy9DLEtBQUtxSCxJQUFJUCxNQUFNQSxNQUFNSSxTQUFTLEdBQUduRSxLQUFLLENBQUM7QUFDMUYsVUFBSW9FLFVBQVUsUUFBUUEsVUFBVSxNQUFPO0FBQ3JDSCxtQkFBVztNQUNaO0FBRURDLGNBQVFLLGVBQWVWLFdBQVdFLEtBQUs7SUFDeEM7QUFFRCxVQUFNUyxXQUFXQyxNQUFNeEgsS0FBS3FILElBQUlKLEtBQUssQ0FBQztBQUN0QyxVQUFNUSxhQUFhekgsS0FBS29ILElBQUlwSCxLQUFLMEgsSUFBSSxLQUFLMUgsS0FBSzJILE1BQU1KLFFBQVEsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUV0RSxVQUFNMUIsVUFBVTtNQUFDbUI7TUFBVVksdUJBQXVCSDtNQUFZSSx1QkFBdUJKOztBQUNyRkssV0FBT0MsT0FBT2xDLFNBQVMsS0FBS0EsUUFBUWlCLE1BQU1QLE1BQU07QUFFaEQsV0FBT0YsYUFBYU8sV0FBV2hCLFNBQVFDLE9BQU87RUFDL0M7RUFXRG1DLFlBQVlwQixXQUFXQyxPQUFPQyxPQUFPO0FBQ25DLFFBQUlGLGNBQWMsR0FBRztBQUNuQixhQUFPO0lBQ1I7QUFDRCxVQUFNcUIsU0FBU25CLE1BQU1ELE9BQU9xQixlQUFnQnRCLFlBQWE1RyxLQUFLQyxJQUFJLElBQUlELEtBQUsySCxNQUFNSCxNQUFNWixTQUFTLENBQUMsQ0FBQztBQUNsRyxRQUFJO01BQUU7TUFBRztNQUFHO01BQUc7TUFBSTtNQUFJO0lBQUMsRUFBQ3VCLFNBQVNGLE1BQU0sS0FBS3BCLFFBQVEsTUFBTUMsTUFBTUksUUFBUTtBQUN2RSxhQUFPVixXQUFXRyxRQUFReUIsS0FBSyxNQUFNeEIsV0FBV0MsT0FBT0MsS0FBSztJQUM3RDtBQUNELFdBQU87RUFDUjs7QUFLSCxTQUFTUSxlQUFlVixXQUFXRSxPQUFPO0FBR3hDLE1BQUlHLFFBQVFILE1BQU1JLFNBQVMsSUFBSUosTUFBTSxHQUFHL0QsUUFBUStELE1BQU0sR0FBRy9ELFFBQVErRCxNQUFNLEdBQUcvRCxRQUFRK0QsTUFBTSxHQUFHL0Q7QUFHM0YsTUFBSS9DLEtBQUtxSCxJQUFJSixLQUFLLEtBQUssS0FBS0wsY0FBYzVHLEtBQUsySCxNQUFNZixTQUFTLEdBQUc7QUFFL0RLLFlBQVFMLFlBQVk1RyxLQUFLMkgsTUFBTWYsU0FBUztFQUN6QztBQUNELFNBQU9LO0FBQ1I7QUFNRCxJQUFBLFFBQWU7RUFBQ1Q7O0FDN0ZULFNBQVM2QixtQkFBbUIzRSxXQUFVO0FBQzNDQSxFQUFBQSxVQUFTQyxJQUFJLFNBQVM7SUFDcEIyRSxTQUFTO0lBQ1RDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxhQUFhO0lBU2JDLFFBQVE7SUFNUkMsT0FBTztJQUdQQyxNQUFNO01BQ0pOLFNBQVM7TUFDVE8sV0FBVztNQUNYQyxpQkFBaUI7TUFDakJDLFdBQVc7TUFDWEMsWUFBWTtNQUNaQyxXQUFXLENBQUNDLE1BQU1yRCxZQUFZQSxRQUFRZ0Q7TUFDdENNLFdBQVcsQ0FBQ0QsTUFBTXJELFlBQVlBLFFBQVFoRDtNQUN0QzBGLFFBQVE7SUFDVDtJQUVEYSxRQUFRO01BQ05kLFNBQVM7TUFDVGUsTUFBTSxDQUFBO01BQ05DLFlBQVk7TUFDWkMsT0FBTztJQUNSO0lBR0RDLE9BQU87TUFFTGxCLFNBQVM7TUFHVG1CLE1BQU07TUFHTnJFLFNBQVM7UUFDUEMsS0FBSztRQUNMRSxRQUFRO01BQ1Q7SUFDRjtJQUdEdUIsT0FBTztNQUNMNEMsYUFBYTtNQUNiQyxhQUFhO01BQ2JDLFFBQVE7TUFDUkMsaUJBQWlCO01BQ2pCQyxpQkFBaUI7TUFDakIxRSxTQUFTO01BQ1RrRCxTQUFTO01BQ1R5QixVQUFVO01BQ1ZDLGlCQUFpQjtNQUNqQkMsYUFBYTtNQUViQyxVQUFVQyxNQUFNM0QsV0FBV0M7TUFDM0IyRCxPQUFPLENBQUE7TUFDUEMsT0FBTyxDQUFBO01BQ1BDLE9BQU87TUFDUEMsWUFBWTtNQUVaQyxtQkFBbUI7TUFDbkJDLGVBQWU7TUFDZkMsaUJBQWlCO0lBQ2xCO0VBQ0YsQ0FBQTtBQUVEaEgsRUFBQUEsVUFBU2lILE1BQU0sZUFBZSxTQUFTLElBQUksT0FBTztBQUNsRGpILEVBQUFBLFVBQVNpSCxNQUFNLGNBQWMsU0FBUyxJQUFJLGFBQWE7QUFDdkRqSCxFQUFBQSxVQUFTaUgsTUFBTSxnQkFBZ0IsU0FBUyxJQUFJLGFBQWE7QUFDekRqSCxFQUFBQSxVQUFTaUgsTUFBTSxlQUFlLFNBQVMsSUFBSSxPQUFPO0FBRWxEakgsRUFBQUEsVUFBU1UsU0FBUyxTQUFTO0lBQ3pCQyxXQUFXO0lBQ1hFLGFBQWEsQ0FBQ0MsVUFBUyxDQUFDQSxNQUFLb0csV0FBVyxRQUFRLEtBQUssQ0FBQ3BHLE1BQUtvRyxXQUFXLE9BQU8sS0FBS3BHLFVBQVMsY0FBY0EsVUFBUztJQUNsSEYsWUFBWSxDQUFDRSxVQUFTQSxVQUFTLGdCQUFnQkEsVUFBUyxvQkFBb0JBLFVBQVM7RUFDdEYsQ0FBQTtBQUVEZCxFQUFBQSxVQUFTVSxTQUFTLFVBQVU7SUFDMUJDLFdBQVc7RUFDWixDQUFBO0FBRURYLEVBQUFBLFVBQVNVLFNBQVMsZUFBZTtJQUMvQkcsYUFBYSxDQUFDQyxVQUFTQSxVQUFTLHFCQUFxQkEsVUFBUztJQUM5REYsWUFBWSxDQUFDRSxVQUFTQSxVQUFTO0VBQ2hDLENBQUE7QUFDRjtBQ2hHTSxJQUFNcUcsWUFBWS9DLHVCQUFPZ0QsT0FBTyxJQUFJO0FBQ3BDLElBQU1DLGNBQWNqRCx1QkFBT2dELE9BQU8sSUFBSTtBQU83QyxTQUFTRSxXQUFTQyxNQUFNQyxLQUFLO0FBQzNCLE1BQUksQ0FBQ0EsS0FBSztBQUNSLFdBQU9EO0VBQ1I7QUFDRCxRQUFNRSxPQUFPRCxJQUFJRSxNQUFNLEdBQUc7QUFDMUIsV0FBU0MsSUFBSSxHQUFHQyxJQUFJSCxLQUFLakUsUUFBUW1FLElBQUlDLEdBQUcsRUFBRUQsR0FBRztBQUMzQyxVQUFNRSxJQUFJSixLQUFLRTtBQUNmSixXQUFPQSxLQUFLTSxPQUFPTixLQUFLTSxLQUFLekQsdUJBQU9nRCxPQUFPLElBQUk7RUFDaEQ7QUFDRCxTQUFPRztBQUNSO0FBRUQsU0FBU3RILElBQUk2SCxNQUFNQyxPQUFPaEYsUUFBUTtBQUNoQyxNQUFJLE9BQU9nRixVQUFVLFVBQVU7QUFDN0IsV0FBT0MsTUFBTVYsV0FBU1EsTUFBTUMsS0FBSyxHQUFHaEYsTUFBTTtFQUMzQztBQUNELFNBQU9pRixNQUFNVixXQUFTUSxNQUFNLEVBQUUsR0FBR0MsS0FBSztBQUN2QztBQU1NLElBQU1FLFdBQU4sTUFBYztFQUNuQkMsWUFBWUMsZUFBY0MsV0FBVztBQUNuQyxTQUFLbkgsWUFBWWQ7QUFDakIsU0FBS2tJLGtCQUFrQjtBQUN2QixTQUFLQyxjQUFjO0FBQ25CLFNBQUtuSixRQUFRO0FBQ2IsU0FBS29KLFdBQVcsQ0FBQTtBQUNoQixTQUFLQyxtQkFBbUIsQ0FBQ0MsWUFBWUEsUUFBUXBGLE1BQU1xRixTQUFTQyxvQkFBbUI7QUFDL0UsU0FBS0MsV0FBVyxDQUFBO0FBQ2hCLFNBQUtDLFNBQVM7TUFDWjtNQUNBO01BQ0E7TUFDQTtNQUNBOztBQUVGLFNBQUtDLE9BQU87TUFDVkMsUUFBUTtNQUNSQyxNQUFNO01BQ05DLE9BQU87TUFDUEMsWUFBWTtNQUNaQyxRQUFROztBQUVWLFNBQUtDLFFBQVEsQ0FBQTtBQUNiLFNBQUtDLHVCQUF1QixDQUFDQyxLQUFLbkgsWUFBWTFDLGNBQWMwQyxRQUFRa0csZUFBZTtBQUNuRixTQUFLa0IsbUJBQW1CLENBQUNELEtBQUtuSCxZQUFZMUMsY0FBYzBDLFFBQVFtRyxXQUFXO0FBQzNFLFNBQUtrQixhQUFhLENBQUNGLEtBQUtuSCxZQUFZMUMsY0FBYzBDLFFBQVFoRCxLQUFLO0FBQy9ELFNBQUtzSyxZQUFZO0FBQ2pCLFNBQUtDLGNBQWM7TUFDakJDLE1BQU07TUFDTkMsV0FBVztNQUNYQyxrQkFBa0I7O0FBRXBCLFNBQUtDLHNCQUFzQjtBQUMzQixTQUFLQyxVQUFVO0FBQ2YsU0FBS0MsVUFBVTtBQUNmLFNBQUtDLFVBQVU7QUFDZixTQUFLQyxVQUFVLENBQUE7QUFDZixTQUFLQyxhQUFhO0FBQ2xCLFNBQUtDLFFBQVFqSztBQUNiLFNBQUtrSyxTQUFTLENBQUE7QUFDZCxTQUFLQyxXQUFXO0FBQ2hCLFNBQUtDLDBCQUEwQjtBQUUvQixTQUFLN0osU0FBU3lILGFBQVk7QUFDMUIsU0FBS3FDLE1BQU1wQyxTQUFTO0VBQ3JCO0VBTURuSSxJQUFJOEgsT0FBT2hGLFFBQVE7QUFDakIsV0FBTzlDLElBQUksTUFBTThILE9BQU9oRixNQUFNO0VBQy9CO0VBS0RQLElBQUl1RixPQUFPO0FBQ1QsV0FBT1QsV0FBUyxNQUFNUyxLQUFLO0VBQzVCO0VBTURySCxTQUFTcUgsT0FBT2hGLFFBQVE7QUFDdEIsV0FBTzlDLElBQUlvSCxhQUFhVSxPQUFPaEYsTUFBTTtFQUN0QztFQUVEMEgsU0FBUzFDLE9BQU9oRixRQUFRO0FBQ3RCLFdBQU85QyxJQUFJa0gsV0FBV1ksT0FBT2hGLE1BQU07RUFDcEM7RUFtQkRrRSxNQUFNYyxPQUFPakgsT0FBTTRKLGFBQWFDLFlBQVk7QUFDMUMsVUFBTUMsY0FBY3RELFdBQVMsTUFBTVMsS0FBSztBQUN4QyxVQUFNOEMsb0JBQW9CdkQsV0FBUyxNQUFNb0QsV0FBVztBQUNwRCxVQUFNSSxjQUFjLE1BQU1oSztBQUUxQnNELFdBQU8yRyxpQkFBaUJILGFBQWE7TUFFbkMsQ0FBQ0UsY0FBYztRQUNiekwsT0FBT3VMLFlBQVk5SjtRQUNuQmtLLFVBQVU7TUFDWDtNQUVELENBQUNsSyxRQUFPO1FBQ05tSyxZQUFZO1FBQ1p6SSxNQUFNO0FBQ0osZ0JBQU0wSSxRQUFRLEtBQUtKO0FBQ25CLGdCQUFNSyxTQUFTTixrQkFBa0JGO0FBQ2pDLGNBQUlTLFNBQVNGLEtBQUssR0FBRztBQUNuQixtQkFBTzlHLE9BQU9DLE9BQU8sQ0FBQSxHQUFJOEcsUUFBUUQsS0FBSztVQUN2QztBQUNELGlCQUFPRyxlQUFlSCxPQUFPQyxNQUFNO1FBQ3BDO1FBQ0RsTCxJQUFJWixPQUFPO0FBQ1QsZUFBS3lMLGVBQWV6TDtRQUNyQjtNQUNGO0lBQ0YsQ0FBQTtFQUNGO0VBRURtTCxNQUFNYyxVQUFVO0FBQ2RBLGFBQVNDLFFBQVEsQ0FBQ2YsVUFBVUEsTUFBTSxJQUFJLENBQUM7RUFDeEM7QUFDRjtBQUdELElBQUEsV0FBK0Isb0JBQUl2QyxTQUFTO0VBQzFDcEgsYUFBYSxDQUFDQyxVQUFTLENBQUNBLE1BQUtvRyxXQUFXLElBQUk7RUFDNUN0RyxZQUFZLENBQUNFLFVBQVNBLFVBQVM7RUFDL0JzSSxPQUFPO0lBQ0x6SSxXQUFXO0VBQ1o7RUFDRCtJLGFBQWE7SUFDWDdJLGFBQWE7SUFDYkQsWUFBWTtFQUNiO0dBQ0E7RUFBQ2I7RUFBeUJ5QjtFQUFzQm1EO0FBQW1CLENBQUE7QUN6Si9ELFNBQVM2RyxhQUFhMUMsTUFBTTtBQUNqQyxNQUFJLENBQUNBLFFBQVEyQyxjQUFjM0MsS0FBS0UsSUFBSSxLQUFLeUMsY0FBYzNDLEtBQUtDLE1BQU0sR0FBRztBQUNuRSxXQUFPO0VBQ1I7QUFFRCxVQUFRRCxLQUFLRyxRQUFRSCxLQUFLRyxRQUFRLE1BQU0sT0FDckNILEtBQUtLLFNBQVNMLEtBQUtLLFNBQVMsTUFBTSxNQUNuQ0wsS0FBS0UsT0FBTyxRQUNaRixLQUFLQztBQUNSO0FBS00sU0FBUzJDLGFBQWFwQyxLQUFLcUMsTUFBTUMsSUFBSUMsU0FBU0MsUUFBUTtBQUMzRCxNQUFJQyxZQUFZSixLQUFLRztBQUNyQixNQUFJLENBQUNDLFdBQVc7QUFDZEEsZ0JBQVlKLEtBQUtHLFVBQVV4QyxJQUFJMEMsWUFBWUYsTUFBTSxFQUFFakc7QUFDbkQrRixPQUFHSyxLQUFLSCxNQUFNO0VBQ2Y7QUFDRCxNQUFJQyxZQUFZRixTQUFTO0FBQ3ZCQSxjQUFVRTtFQUNYO0FBQ0QsU0FBT0Y7QUFDUjtBQUtNLFNBQVNLLGFBQWE1QyxLQUFLUixNQUFNcUQsZUFBZUMsT0FBTztBQUM1REEsVUFBUUEsU0FBUyxDQUFBO0FBQ2pCLE1BQUlULE9BQU9TLE1BQU1ULE9BQU9TLE1BQU1ULFFBQVEsQ0FBQTtBQUN0QyxNQUFJQyxLQUFLUSxNQUFNQyxpQkFBaUJELE1BQU1DLGtCQUFrQixDQUFBO0FBRXhELE1BQUlELE1BQU10RCxTQUFTQSxNQUFNO0FBQ3ZCNkMsV0FBT1MsTUFBTVQsT0FBTyxDQUFBO0FBQ3BCQyxTQUFLUSxNQUFNQyxpQkFBaUIsQ0FBQTtBQUM1QkQsVUFBTXRELE9BQU9BO0VBQ2Q7QUFFRFEsTUFBSWdELEtBQUk7QUFFUmhELE1BQUlSLE9BQU9BO0FBQ1gsTUFBSStDLFVBQVU7QUFDZCxRQUFNVSxPQUFPSixjQUFjM0k7QUFDM0IsTUFBSW1FLEdBQUc2RSxHQUFHQyxNQUFNQyxPQUFPQztBQUN2QixPQUFLaEYsSUFBSSxHQUFHQSxJQUFJNEUsTUFBTTVFLEtBQUs7QUFDekIrRSxZQUFRUCxjQUFjeEU7QUFHdEIsUUFBSStFLFVBQVV2TSxVQUFhdU0sVUFBVSxRQUFRMUosUUFBUTBKLEtBQUssTUFBTSxNQUFNO0FBQ3BFYixnQkFBVUgsYUFBYXBDLEtBQUtxQyxNQUFNQyxJQUFJQyxTQUFTYSxLQUFLO0lBQ3JELFdBQVUxSixRQUFRMEosS0FBSyxHQUFHO0FBR3pCLFdBQUtGLElBQUksR0FBR0MsT0FBT0MsTUFBTWxKLFFBQVFnSixJQUFJQyxNQUFNRCxLQUFLO0FBQzlDRyxzQkFBY0QsTUFBTUY7QUFFcEIsWUFBSUcsZ0JBQWdCeE0sVUFBYXdNLGdCQUFnQixRQUFRLENBQUMzSixRQUFRMkosV0FBVyxHQUFHO0FBQzlFZCxvQkFBVUgsYUFBYXBDLEtBQUtxQyxNQUFNQyxJQUFJQyxTQUFTYyxXQUFXO1FBQzNEO01BQ0Y7SUFDRjtFQUNGO0FBRURyRCxNQUFJc0QsUUFBTztBQUVYLFFBQU1DLFFBQVFqQixHQUFHcEksU0FBUztBQUMxQixNQUFJcUosUUFBUVYsY0FBYzNJLFFBQVE7QUFDaEMsU0FBS21FLElBQUksR0FBR0EsSUFBSWtGLE9BQU9sRixLQUFLO0FBQzFCLGFBQU9nRSxLQUFLQyxHQUFHakU7SUFDaEI7QUFDRGlFLE9BQUdrQixPQUFPLEdBQUdELEtBQUs7RUFDbkI7QUFDRCxTQUFPaEI7QUFDUjtBQVVNLFNBQVNrQixZQUFZMUosT0FBTzJKLE9BQU9uSCxPQUFPO0FBQy9DLFFBQU0yQyxtQkFBbUJuRixNQUFNNEo7QUFDL0IsUUFBTUMsWUFBWXJILFVBQVUsSUFBSXZKLEtBQUtvSCxJQUFJbUMsUUFBUSxHQUFHLEdBQUcsSUFBSTtBQUMzRCxTQUFPdkosS0FBSzZRLE9BQU9ILFFBQVFFLGFBQWExRSxnQkFBZ0IsSUFBSUEsbUJBQW1CMEU7QUFDaEY7QUFPTSxTQUFTRSxZQUFZQyxRQUFRL0QsS0FBSztBQUN2Q0EsUUFBTUEsT0FBTytELE9BQU9DLFdBQVcsSUFBSTtBQUVuQ2hFLE1BQUlnRCxLQUFJO0FBR1JoRCxNQUFJaUUsZUFBYztBQUNsQmpFLE1BQUlrRSxVQUFVLEdBQUcsR0FBR0gsT0FBT3hILE9BQU93SCxPQUFPSSxNQUFNO0FBQy9DbkUsTUFBSXNELFFBQU87QUFDWjtBQUVNLFNBQVNjLFVBQVVwRSxLQUFLbkgsU0FBU3dMLEdBQUdDLEdBQUc7QUFDNUNDLGtCQUFnQnZFLEtBQUtuSCxTQUFTd0wsR0FBR0MsR0FBRyxJQUFJO0FBQ3pDO0FBRU0sU0FBU0MsZ0JBQWdCdkUsS0FBS25ILFNBQVN3TCxHQUFHQyxHQUFHRSxHQUFHO0FBQ3JELE1BQUl4TyxNQUFNeU8sU0FBU0MsU0FBU2hGLE1BQU1pRixjQUFjcEksT0FBT3FJLFVBQVVDO0FBQ2pFLFFBQU1sRixRQUFROUcsUUFBUWlNO0FBQ3RCLFFBQU1DLFdBQVdsTSxRQUFRa007QUFDekIsUUFBTUMsU0FBU25NLFFBQVFtTTtBQUN2QixNQUFJQyxPQUFPRixZQUFZLEtBQUtHO0FBRTVCLE1BQUl2RixTQUFTLE9BQU9BLFVBQVUsVUFBVTtBQUN0QzNKLFdBQU8ySixNQUFNMUosU0FBUTtBQUNyQixRQUFJRCxTQUFTLCtCQUErQkEsU0FBUyw4QkFBOEI7QUFDakZnSyxVQUFJZ0QsS0FBSTtBQUNSaEQsVUFBSW1GLFVBQVVkLEdBQUdDLENBQUM7QUFDbEJ0RSxVQUFJb0YsT0FBT0gsR0FBRztBQUNkakYsVUFBSXFGLFVBQVUxRixPQUFPLENBQUNBLE1BQU1wRCxRQUFRLEdBQUcsQ0FBQ29ELE1BQU13RSxTQUFTLEdBQUd4RSxNQUFNcEQsT0FBT29ELE1BQU13RSxNQUFNO0FBQ25GbkUsVUFBSXNELFFBQU87QUFDWDtJQUNEO0VBQ0Y7QUFFRCxNQUFJZ0MsTUFBTU4sTUFBTSxLQUFLQSxVQUFVLEdBQUc7QUFDaEM7RUFDRDtBQUVEaEYsTUFBSXVGLFVBQVM7QUFFYixVQUFRNUYsT0FBSztJQUViO0FBQ0UsVUFBSTZFLEdBQUc7QUFDTHhFLFlBQUl3RixRQUFRbkIsR0FBR0MsR0FBR0UsSUFBSSxHQUFHUSxRQUFRLEdBQUcsR0FBRzdSLEdBQUc7YUFDckM7QUFDTDZNLFlBQUl5RixJQUFJcEIsR0FBR0MsR0FBR1UsUUFBUSxHQUFHN1IsR0FBRztNQUM3QjtBQUNENk0sVUFBSTBGLFVBQVM7QUFDYjtJQUNGLEtBQUs7QUFDSG5KLGNBQVFpSSxJQUFJQSxJQUFJLElBQUlRO0FBQ3BCaEYsVUFBSTJGLE9BQU90QixJQUFJclIsS0FBS0UsSUFBSStSLEdBQUcsSUFBSTFJLE9BQU8rSCxJQUFJdFIsS0FBS29CLElBQUk2USxHQUFHLElBQUlELE1BQU07QUFDaEVDLGFBQU9XO0FBQ1A1RixVQUFJNkYsT0FBT3hCLElBQUlyUixLQUFLRSxJQUFJK1IsR0FBRyxJQUFJMUksT0FBTytILElBQUl0UixLQUFLb0IsSUFBSTZRLEdBQUcsSUFBSUQsTUFBTTtBQUNoRUMsYUFBT1c7QUFDUDVGLFVBQUk2RixPQUFPeEIsSUFBSXJSLEtBQUtFLElBQUkrUixHQUFHLElBQUkxSSxPQUFPK0gsSUFBSXRSLEtBQUtvQixJQUFJNlEsR0FBRyxJQUFJRCxNQUFNO0FBQ2hFaEYsVUFBSTBGLFVBQVM7QUFDYjtJQUNGLEtBQUs7QUFRSGYscUJBQWVLLFNBQVM7QUFDeEJ0RixhQUFPc0YsU0FBU0w7QUFDaEJGLGdCQUFVelIsS0FBS29CLElBQUk2USxNQUFNYSxVQUFVLElBQUlwRztBQUN2Q2tGLGlCQUFXNVIsS0FBS29CLElBQUk2USxNQUFNYSxVQUFVLEtBQUt0QixJQUFJQSxJQUFJLElBQUlHLGVBQWVqRjtBQUNwRWdGLGdCQUFVMVIsS0FBS0UsSUFBSStSLE1BQU1hLFVBQVUsSUFBSXBHO0FBQ3ZDbUYsaUJBQVc3UixLQUFLRSxJQUFJK1IsTUFBTWEsVUFBVSxLQUFLdEIsSUFBSUEsSUFBSSxJQUFJRyxlQUFlakY7QUFDcEVNLFVBQUl5RixJQUFJcEIsSUFBSU8sVUFBVU4sSUFBSUksU0FBU0MsY0FBY00sTUFBTXpRLElBQUl5USxNQUFNNVEsT0FBTztBQUN4RTJMLFVBQUl5RixJQUFJcEIsSUFBSVEsVUFBVVAsSUFBSUcsU0FBU0UsY0FBY00sTUFBTTVRLFNBQVM0USxHQUFHO0FBQ25FakYsVUFBSXlGLElBQUlwQixJQUFJTyxVQUFVTixJQUFJSSxTQUFTQyxjQUFjTSxLQUFLQSxNQUFNNVEsT0FBTztBQUNuRTJMLFVBQUl5RixJQUFJcEIsSUFBSVEsVUFBVVAsSUFBSUcsU0FBU0UsY0FBY00sTUFBTTVRLFNBQVM0USxNQUFNelEsRUFBRTtBQUN4RXdMLFVBQUkwRixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBQ0gsVUFBSSxDQUFDWCxVQUFVO0FBQ2JyRixlQUFPMU0sS0FBSytTLFVBQVVmO0FBQ3RCekksZ0JBQVFpSSxJQUFJQSxJQUFJLElBQUk5RTtBQUNwQk0sWUFBSWdHLEtBQUszQixJQUFJOUgsT0FBTytILElBQUk1RSxNQUFNLElBQUluRCxPQUFPLElBQUltRCxJQUFJO0FBQ2pEO01BQ0Q7QUFDRHVGLGFBQU9hO0lBRVQsS0FBSztBQUNIbEIsaUJBQVc1UixLQUFLb0IsSUFBSTZRLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q1AsZ0JBQVV6UixLQUFLb0IsSUFBSTZRLEdBQUcsSUFBSUQ7QUFDMUJOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQUcsSUFBSUQ7QUFDMUJILGlCQUFXN1IsS0FBS0UsSUFBSStSLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q2hGLFVBQUkyRixPQUFPdEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUk2RixPQUFPeEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQ3pFLFVBQUk2RixPQUFPeEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUk2RixPQUFPeEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQ3pFLFVBQUkwRixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBQ0hULGFBQU9hO0lBRVQsS0FBSztBQUNIbEIsaUJBQVc1UixLQUFLb0IsSUFBSTZRLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q1AsZ0JBQVV6UixLQUFLb0IsSUFBSTZRLEdBQUcsSUFBSUQ7QUFDMUJOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQUcsSUFBSUQ7QUFDMUJILGlCQUFXN1IsS0FBS0UsSUFBSStSLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q2hGLFVBQUkyRixPQUFPdEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUk2RixPQUFPeEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUkyRixPQUFPdEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQ3pFLFVBQUk2RixPQUFPeEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQztJQUNGLEtBQUs7QUFDSEcsaUJBQVc1UixLQUFLb0IsSUFBSTZRLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q1AsZ0JBQVV6UixLQUFLb0IsSUFBSTZRLEdBQUcsSUFBSUQ7QUFDMUJOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQUcsSUFBSUQ7QUFDMUJILGlCQUFXN1IsS0FBS0UsSUFBSStSLEdBQUcsS0FBS1QsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q2hGLFVBQUkyRixPQUFPdEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUk2RixPQUFPeEIsSUFBSU8sVUFBVU4sSUFBSUksT0FBTztBQUNwQzFFLFVBQUkyRixPQUFPdEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQ3pFLFVBQUk2RixPQUFPeEIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBTztBQUNwQ1EsYUFBT2E7QUFDUGxCLGlCQUFXNVIsS0FBS29CLElBQUk2USxHQUFHLEtBQUtULElBQUlBLElBQUksSUFBSVE7QUFDeENQLGdCQUFVelIsS0FBS29CLElBQUk2USxHQUFHLElBQUlEO0FBQzFCTixnQkFBVTFSLEtBQUtFLElBQUkrUixHQUFHLElBQUlEO0FBQzFCSCxpQkFBVzdSLEtBQUtFLElBQUkrUixHQUFHLEtBQUtULElBQUlBLElBQUksSUFBSVE7QUFDeENoRixVQUFJMkYsT0FBT3RCLElBQUlPLFVBQVVOLElBQUlJLE9BQU87QUFDcEMxRSxVQUFJNkYsT0FBT3hCLElBQUlPLFVBQVVOLElBQUlJLE9BQU87QUFDcEMxRSxVQUFJMkYsT0FBT3RCLElBQUlRLFVBQVVQLElBQUlHLE9BQU87QUFDcEN6RSxVQUFJNkYsT0FBT3hCLElBQUlRLFVBQVVQLElBQUlHLE9BQU87QUFDcEM7SUFDRixLQUFLO0FBQ0hBLGdCQUFVRCxJQUFJQSxJQUFJLElBQUl4UixLQUFLb0IsSUFBSTZRLEdBQUcsSUFBSUQ7QUFDdENOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQUcsSUFBSUQ7QUFDMUJoRixVQUFJMkYsT0FBT3RCLElBQUlJLFNBQVNILElBQUlJLE9BQU87QUFDbkMxRSxVQUFJNkYsT0FBT3hCLElBQUlJLFNBQVNILElBQUlJLE9BQU87QUFDbkM7SUFDRixLQUFLO0FBQ0gxRSxVQUFJMkYsT0FBT3RCLEdBQUdDLENBQUM7QUFDZnRFLFVBQUk2RixPQUFPeEIsSUFBSXJSLEtBQUtvQixJQUFJNlEsR0FBRyxLQUFLVCxJQUFJQSxJQUFJLElBQUlRLFNBQVNWLElBQUl0UixLQUFLRSxJQUFJK1IsR0FBRyxJQUFJRCxNQUFNO0FBQy9FO0VBQ0Q7QUFFRGhGLE1BQUlpRyxLQUFJO0FBQ1IsTUFBSXBOLFFBQVFxTixjQUFjLEdBQUc7QUFDM0JsRyxRQUFJbUcsT0FBTTtFQUNYO0FBQ0Y7QUFVTSxTQUFTQyxlQUFlQyxPQUFPQyxNQUFNQyxRQUFRO0FBQ2xEQSxXQUFTQSxVQUFVO0FBRW5CLFNBQU8sQ0FBQ0QsUUFBU0QsU0FBU0EsTUFBTWhDLElBQUlpQyxLQUFLOU4sT0FBTytOLFVBQVVGLE1BQU1oQyxJQUFJaUMsS0FBS2hPLFFBQVFpTyxVQUNqRkYsTUFBTS9CLElBQUlnQyxLQUFLak8sTUFBTWtPLFVBQVVGLE1BQU0vQixJQUFJZ0MsS0FBSy9OLFNBQVNnTztBQUN4RDtBQUVNLFNBQVNDLFNBQVN4RyxLQUFLc0csTUFBTTtBQUNsQ3RHLE1BQUlnRCxLQUFJO0FBQ1JoRCxNQUFJdUYsVUFBUztBQUNidkYsTUFBSWdHLEtBQUtNLEtBQUs5TixNQUFNOE4sS0FBS2pPLEtBQUtpTyxLQUFLaE8sUUFBUWdPLEtBQUs5TixNQUFNOE4sS0FBSy9OLFNBQVMrTixLQUFLak8sR0FBRztBQUM1RTJILE1BQUl5RyxLQUFJO0FBQ1Q7QUFFTSxTQUFTQyxXQUFXMUcsS0FBSztBQUM5QkEsTUFBSXNELFFBQU87QUFDWjtBQXdDTSxTQUFTcUQsV0FBV0MsS0FBS0MsTUFBTUMsR0FBR0MsR0FBR0MsTUFBTUMsT0FBTyxDQUFBLEdBQUk7QUFDM0QsUUFBTUMsUUFBUUMsUUFBUU4sSUFBSSxJQUFJQSxPQUFPO0lBQUNBOztBQUN0QyxRQUFNTyxTQUFTSCxLQUFLSSxjQUFjLEtBQUtKLEtBQUtLLGdCQUFnQjtBQUM1RCxNQUFJQyxHQUFHQztBQUVQWixNQUFJYSxLQUFJO0FBQ1JiLE1BQUlJLE9BQU9BLEtBQUtVO0FBQ2hCQyxnQkFBY2YsS0FBS0ssSUFBSTtBQUV2QixPQUFLTSxJQUFJLEdBQUdBLElBQUlMLE1BQU1VLFFBQVEsRUFBRUwsR0FBRztBQUNqQ0MsV0FBT04sTUFBTUs7QUFFYixRQUFJTixLQUFLWSxVQUFVO0FBQ2pCQyxtQkFBYWxCLEtBQUtLLEtBQUtZLFFBQVE7SUFDaEM7QUFFRCxRQUFJVCxRQUFRO0FBQ1YsVUFBSUgsS0FBS0ssYUFBYTtBQUNwQlYsWUFBSW1CLGNBQWNkLEtBQUtLO01BQ3hCO0FBRUQsVUFBSSxDQUFDVSxjQUFjZixLQUFLSSxXQUFXLEdBQUc7QUFDcENULFlBQUlxQixZQUFZaEIsS0FBS0k7TUFDdEI7QUFFRFQsVUFBSXNCLFdBQVdWLE1BQU1WLEdBQUdDLEdBQUdFLEtBQUtrQixRQUFRO0lBQ3pDO0FBRUR2QixRQUFJd0IsU0FBU1osTUFBTVYsR0FBR0MsR0FBR0UsS0FBS2tCLFFBQVE7QUFDdENFLGlCQUFhekIsS0FBS0UsR0FBR0MsR0FBR1MsTUFBTVAsSUFBSTtBQUVsQ0YsU0FBS0MsS0FBS3NCO0VBQ1g7QUFFRDFCLE1BQUkyQixRQUFPO0FBQ1o7QUFFRCxTQUFTWixjQUFjZixLQUFLSyxNQUFNO0FBQ2hDLE1BQUlBLEtBQUt1QixhQUFhO0FBQ3BCNUIsUUFBSTZCLFVBQVV4QixLQUFLdUIsWUFBWSxJQUFJdkIsS0FBS3VCLFlBQVksRUFBRTtFQUN2RDtBQUVELE1BQUksQ0FBQ1IsY0FBY2YsS0FBS3lCLFFBQVEsR0FBRztBQUNqQzlCLFFBQUkrQixPQUFPMUIsS0FBS3lCLFFBQVE7RUFDekI7QUFFRCxNQUFJekIsS0FBSzJCLE9BQU87QUFDZGhDLFFBQUlpQyxZQUFZNUIsS0FBSzJCO0VBQ3RCO0FBRUQsTUFBSTNCLEtBQUs2QixXQUFXO0FBQ2xCbEMsUUFBSWtDLFlBQVk3QixLQUFLNkI7RUFDdEI7QUFFRCxNQUFJN0IsS0FBSzhCLGNBQWM7QUFDckJuQyxRQUFJbUMsZUFBZTlCLEtBQUs4QjtFQUN6QjtBQUNGO0FBRUQsU0FBU1YsYUFBYXpCLEtBQUtFLEdBQUdDLEdBQUdTLE1BQU1QLE1BQU07QUFDM0MsTUFBSUEsS0FBSytCLGlCQUFpQi9CLEtBQUtnQyxXQUFXO0FBUXhDLFVBQU1DLFVBQVV0QyxJQUFJdUMsWUFBWTNCLElBQUk7QUFDcEMsVUFBTTRCLE9BQU90QyxJQUFJb0MsUUFBUUc7QUFDekIsVUFBTUMsUUFBUXhDLElBQUlvQyxRQUFRSztBQUMxQixVQUFNQyxNQUFNekMsSUFBSW1DLFFBQVFPO0FBQ3hCLFVBQU1DLFNBQVMzQyxJQUFJbUMsUUFBUVM7QUFDM0IsVUFBTUMsY0FBYzNDLEtBQUsrQixpQkFBaUJRLE1BQU1FLFVBQVUsSUFBSUE7QUFFOUQ5QyxRQUFJbUIsY0FBY25CLElBQUlpQztBQUN0QmpDLFFBQUlpRCxVQUFTO0FBQ2JqRCxRQUFJcUIsWUFBWWhCLEtBQUs2QyxtQkFBbUI7QUFDeENsRCxRQUFJbUQsT0FBT1gsTUFBTVEsV0FBVztBQUM1QmhELFFBQUlvRCxPQUFPVixPQUFPTSxXQUFXO0FBQzdCaEQsUUFBSVEsT0FBTTtFQUNYO0FBQ0Y7QUFFRCxTQUFTVSxhQUFhbEIsS0FBS0ssTUFBTTtBQUMvQixRQUFNZ0QsV0FBV3JELElBQUlpQztBQUVyQmpDLE1BQUlpQyxZQUFZNUIsS0FBSzJCO0FBQ3JCaEMsTUFBSXNELFNBQVNqRCxLQUFLbUMsTUFBTW5DLEtBQUt1QyxLQUFLdkMsS0FBS2tELE9BQU9sRCxLQUFLbUQsTUFBTTtBQUN6RHhELE1BQUlpQyxZQUFZb0I7QUFDakI7QUFPTSxTQUFTSSxtQkFBbUJ6RCxLQUFLMEQsTUFBTTtBQUM1QyxRQUFNLEVBQUN4RCxHQUFHQyxHQUFHd0QsR0FBR0MsR0FBQUEsSUFBR0MsT0FBTSxJQUFJSDtBQUc3QjFELE1BQUk4RCxJQUFJNUQsSUFBSTJELE9BQU9FLFNBQVM1RCxJQUFJMEQsT0FBT0UsU0FBU0YsT0FBT0UsU0FBUyxDQUFDQyxTQUFTQyxJQUFJLElBQUk7QUFHbEZqRSxNQUFJb0QsT0FBT2xELEdBQUdDLElBQUl5RCxLQUFJQyxPQUFPSyxVQUFVO0FBR3ZDbEUsTUFBSThELElBQUk1RCxJQUFJMkQsT0FBT0ssWUFBWS9ELElBQUl5RCxLQUFJQyxPQUFPSyxZQUFZTCxPQUFPSyxZQUFZRCxJQUFJRCxTQUFTLElBQUk7QUFHOUZoRSxNQUFJb0QsT0FBT2xELElBQUl5RCxJQUFJRSxPQUFPTSxhQUFhaEUsSUFBSXlELEVBQUM7QUFHNUM1RCxNQUFJOEQsSUFBSTVELElBQUl5RCxJQUFJRSxPQUFPTSxhQUFhaEUsSUFBSXlELEtBQUlDLE9BQU9NLGFBQWFOLE9BQU9NLGFBQWFILFNBQVMsR0FBRyxJQUFJO0FBR3BHaEUsTUFBSW9ELE9BQU9sRCxJQUFJeUQsR0FBR3hELElBQUkwRCxPQUFPTyxRQUFRO0FBR3JDcEUsTUFBSThELElBQUk1RCxJQUFJeUQsSUFBSUUsT0FBT08sVUFBVWpFLElBQUkwRCxPQUFPTyxVQUFVUCxPQUFPTyxVQUFVLEdBQUcsQ0FBQ0osU0FBUyxJQUFJO0FBR3hGaEUsTUFBSW9ELE9BQU9sRCxJQUFJMkQsT0FBT0UsU0FBUzVELENBQUM7QUFDakM7QUMvYkQsSUFBTWtFLGNBQVc7QUFDakIsSUFBTUMsYUFBVTtBQWNULFNBQVNDLGFBQWFDLE9BQXdCQyxNQUFzQjtBQUN6RSxRQUFNQyxXQUFXLEtBQUtGLE9BQU9HLE1BQU1OLFdBQVc7QUFDOUMsTUFBSSxDQUFDSyxXQUFXQSxRQUFRLE9BQU8sVUFBVTtBQUN2QyxXQUFPRCxPQUFPO0VBQ2Y7QUFFREQsVUFBUSxDQUFDRSxRQUFRO0FBRWpCLFVBQVFBLFFBQVEsSUFBRTtJQUNoQixLQUFLO0FBQ0gsYUFBT0Y7SUFDVCxLQUFLO0FBQ0hBLGVBQVM7QUFDVDtFQUdIO0FBRUQsU0FBT0MsT0FBT0Q7QUFDZjtBQUVELElBQU1JLGVBQWUsQ0FBQ0MsTUFBZSxDQUFDQSxLQUFLO0FBUXBDLFNBQVNDLGtCQUFrQk4sT0FBd0NPLE9BQTBDO0FBQ2xILFFBQU1DLE1BQU0sQ0FBQTtBQUNaLFFBQU1DLFdBQVdDLFNBQVNILEtBQUs7QUFDL0IsUUFBTUksT0FBT0YsV0FBV0csT0FBT0QsS0FBS0osS0FBSyxJQUFJQTtBQUM3QyxRQUFNTSxPQUFPSCxTQUFTVixLQUFLLElBQ3ZCUyxXQUNFSyxDQUFBQSxTQUFRQyxlQUFlZixNQUFNYyxPQUFPZCxNQUFNTyxNQUFNTyxNQUFNLElBQ3REQSxDQUFBQSxTQUFRZCxNQUFNYyxRQUNoQixNQUFNZDtBQUVWLGFBQVdjLFFBQVFILE1BQU07QUFDdkJILFFBQUlNLFFBQVFWLGFBQWFTLEtBQUtDLElBQUksQ0FBQztFQUNwQztBQUNELFNBQU9OO0FBQ1I7QUFVTSxTQUFTUSxPQUFPaEIsT0FBOEI7QUFDbkQsU0FBT00sa0JBQWtCTixPQUFPO0lBQUM1QixLQUFLO0lBQUtGLE9BQU87SUFBS0ksUUFBUTtJQUFLTixNQUFNO0VBQUksQ0FBQTtBQUMvRTtBQVNNLFNBQVNpRCxjQUFjakIsT0FBNkI7QUFDekQsU0FBT00sa0JBQWtCTixPQUFPO0lBQUM7SUFBVztJQUFZO0lBQWM7RUFBYyxDQUFBO0FBQ3JGO0FBVU0sU0FBU2tCLFVBQVVsQixPQUFrQztBQUMxRCxRQUFNbUIsTUFBTUgsT0FBT2hCLEtBQUs7QUFFeEJtQixNQUFJcEMsUUFBUW9DLElBQUluRCxPQUFPbUQsSUFBSWpEO0FBQzNCaUQsTUFBSW5DLFNBQVNtQyxJQUFJL0MsTUFBTStDLElBQUk3QztBQUUzQixTQUFPNkM7QUFDUjtBQWNNLFNBQVNDLE9BQU9DLFNBQTRCQyxVQUE4QjtBQUMvRUQsWUFBVUEsV0FBVyxDQUFBO0FBQ3JCQyxhQUFXQSxZQUFZQyxTQUFTM0Y7QUFFaEMsTUFBSXFFLE9BQU9jLGVBQWVNLFFBQVFwQixNQUFNcUIsU0FBU3JCLElBQUk7QUFFckQsTUFBSSxPQUFPQSxTQUFTLFVBQVU7QUFDNUJBLFdBQU91QixTQUFTdkIsTUFBTSxFQUFFO0VBQ3pCO0FBQ0QsTUFBSXdCLFFBQVFWLGVBQWVNLFFBQVFJLE9BQU9ILFNBQVNHLEtBQUs7QUFDeEQsTUFBSUEsU0FBUyxFQUFFLEtBQUtBLE9BQU90QixNQUFNTCxVQUFVLEdBQUc7QUFDNUM0QixZQUFRQyxLQUFLLG9DQUFvQ0YsUUFBUSxHQUFHO0FBQzVEQSxZQUFRRztFQUNUO0FBRUQsUUFBTWhHLE9BQU87SUFDWGlHLFFBQVFkLGVBQWVNLFFBQVFRLFFBQVFQLFNBQVNPLE1BQU07SUFDdEQzRSxZQUFZNkMsYUFBYWdCLGVBQWVNLFFBQVFuRSxZQUFZb0UsU0FBU3BFLFVBQVUsR0FBRytDLElBQUk7SUFDdEZBO0lBQ0F3QjtJQUNBSyxRQUFRZixlQUFlTSxRQUFRUyxRQUFRUixTQUFTUSxNQUFNO0lBQ3REeEYsUUFBUTs7QUFHVlYsT0FBS1UsU0FBU3lGLGFBQWFuRyxJQUFJO0FBQy9CLFNBQU9BO0FBQ1I7QUFhTSxTQUFTb0csUUFBUUMsUUFBd0JDLFNBQWtCQyxPQUFnQkMsTUFBK0I7QUFDL0csTUFBSUMsWUFBWTtBQUNoQixNQUFJbEcsR0FBV21HLE1BQWN0QztBQUU3QixPQUFLN0QsSUFBSSxHQUFHbUcsT0FBT0wsT0FBT3pGLFFBQVFMLElBQUltRyxNQUFNLEVBQUVuRyxHQUFHO0FBQy9DNkQsWUFBUWlDLE9BQU85RjtBQUNmLFFBQUk2RCxVQUFVNEIsUUFBVztBQUN2QjtJQUNEO0FBQ0QsUUFBSU0sWUFBWU4sVUFBYSxPQUFPNUIsVUFBVSxZQUFZO0FBQ3hEQSxjQUFRQSxNQUFNa0MsT0FBTztBQUNyQkcsa0JBQVk7SUFDYjtBQUNELFFBQUlGLFVBQVVQLFVBQWE3RixRQUFRaUUsS0FBSyxHQUFHO0FBQ3pDQSxjQUFRQSxNQUFNbUMsUUFBUW5DLE1BQU14RDtBQUM1QjZGLGtCQUFZO0lBQ2I7QUFDRCxRQUFJckMsVUFBVTRCLFFBQVc7QUFDdkIsVUFBSVEsUUFBUSxDQUFDQyxXQUFXO0FBQ3RCRCxhQUFLQyxZQUFZO01BQ2xCO0FBQ0QsYUFBT3JDO0lBQ1I7RUFDRjtBQUNGO0FBUU0sU0FBU3VDLFVBQVVDLFFBQXVDQyxPQUF3QkMsYUFBc0I7QUFDN0csUUFBTSxFQUFDQyxLQUFLQyxJQUFHLElBQUlKO0FBQ25CLFFBQU1LLFNBQVNDLFlBQVlMLFFBQVFHLE1BQU1ELE9BQU8sQ0FBQztBQUNqRCxRQUFNSSxXQUFXLENBQUMvQyxPQUFlZ0QsUUFBZ0JOLGVBQWUxQyxVQUFVLElBQUksSUFBSUEsUUFBUWdEO0FBQzFGLFNBQU87SUFDTEwsS0FBS0ksU0FBU0osS0FBSyxDQUFDTSxLQUFLQyxJQUFJTCxNQUFNLENBQUM7SUFDcENELEtBQUtHLFNBQVNILEtBQUtDLE1BQU07O0FBRTVCO0FBUU0sU0FBU00sY0FBNkNDLGVBQWtCbEIsU0FBd0M7QUFDckgsU0FBT3RCLE9BQU95QyxPQUFPekMsT0FBTzBDLE9BQU9GLGFBQWEsR0FBR2xCLE9BQU87QUFDM0Q7QUNuTU0sU0FBU3FCLGdCQUFnQkMsUUFBUUMsV0FBVztFQUFDO0FBQUcsR0FBRUMsYUFBYUYsUUFBUWxDLFVBQVVxQyxZQUFZLE1BQU1ILE9BQU8sSUFBSTtBQUNuSCxNQUFJLENBQUNJLFFBQVF0QyxRQUFRLEdBQUc7QUFDdEJBLGVBQVd1QyxTQUFTLGFBQWFMLE1BQU07RUFDeEM7QUFDRCxRQUFNTSxRQUFRO0lBQ1osQ0FBQ0MsT0FBT0MsY0FBYztJQUN0QkMsWUFBWTtJQUNaQyxTQUFTVjtJQUNUVyxhQUFhVDtJQUNiVSxXQUFXOUM7SUFDWCtDLFlBQVlWO0lBQ1pXLFVBQVUsQ0FBQ0MsVUFBVWhCLGdCQUFnQjtNQUFDZ0I7U0FBVWY7SUFBTyxHQUFFQyxVQUFVQyxZQUFZcEMsUUFBUTs7QUFFekYsU0FBTyxJQUFJa0QsTUFBTVYsT0FBTztJQUl0QlcsZUFBZUMsUUFBUTVELE1BQU07QUFDM0IsYUFBTzRELE9BQU81RDtBQUNkLGFBQU80RCxPQUFPQztBQUNkLGFBQU9uQixPQUFPLEdBQUcxQztBQUNqQixhQUFPO0lBQ1I7SUFLRDhELElBQUlGLFFBQVE1RCxNQUFNO0FBQ2hCLGFBQU8rRCxRQUFRSCxRQUFRNUQsTUFDckIsTUFBTWdFLHFCQUFxQmhFLE1BQU0yQyxVQUFVRCxRQUFRa0IsTUFBTSxDQUFDO0lBQzdEO0lBTURLLHlCQUF5QkwsUUFBUTVELE1BQU07QUFDckMsYUFBT2tFLFFBQVFELHlCQUF5QkwsT0FBT1IsUUFBUSxJQUFJcEQsSUFBSTtJQUNoRTtJQUtEbUUsaUJBQWlCO0FBQ2YsYUFBT0QsUUFBUUMsZUFBZXpCLE9BQU8sRUFBRTtJQUN4QztJQUtEMEIsSUFBSVIsUUFBUTVELE1BQU07QUFDaEIsYUFBT3FFLHFCQUFxQlQsTUFBTSxFQUFFVSxTQUFTdEUsSUFBSTtJQUNsRDtJQUtEdUUsUUFBUVgsUUFBUTtBQUNkLGFBQU9TLHFCQUFxQlQsTUFBTTtJQUNuQztJQUtEWSxJQUFJWixRQUFRNUQsTUFBTWQsT0FBTztBQUN2QixZQUFNdUYsVUFBVWIsT0FBT2MsYUFBYWQsT0FBT2MsV0FBVzdCLFVBQVM7QUFDL0RlLGFBQU81RCxRQUFReUUsUUFBUXpFLFFBQVFkO0FBQy9CLGFBQU8wRSxPQUFPQztBQUNkLGFBQU87SUFDUjtFQUNGLENBQUE7QUFDRjtBQVVNLFNBQVNjLGVBQWVDLE9BQU94RCxTQUFTeUQsVUFBVUMsb0JBQW9CO0FBQzNFLFFBQU05QixRQUFRO0lBQ1pHLFlBQVk7SUFDWjRCLFFBQVFIO0lBQ1JJLFVBQVU1RDtJQUNWNkQsV0FBV0o7SUFDWEssUUFBUSxvQkFBSUMsSUFBRztJQUNmQyxjQUFjQSxhQUFhUixPQUFPRSxrQkFBa0I7SUFDcERPLFlBQVksQ0FBQzNLLFFBQVFpSyxlQUFlQyxPQUFPbEssS0FBS21LLFVBQVVDLGtCQUFrQjtJQUM1RXRCLFVBQVUsQ0FBQ0MsVUFBVWtCLGVBQWVDLE1BQU1wQixTQUFTQyxLQUFLLEdBQUdyQyxTQUFTeUQsVUFBVUMsa0JBQWtCOztBQUVsRyxTQUFPLElBQUlwQixNQUFNVixPQUFPO0lBSXRCVyxlQUFlQyxRQUFRNUQsTUFBTTtBQUMzQixhQUFPNEQsT0FBTzVEO0FBQ2QsYUFBTzRFLE1BQU01RTtBQUNiLGFBQU87SUFDUjtJQUtEOEQsSUFBSUYsUUFBUTVELE1BQU1zRixVQUFVO0FBQzFCLGFBQU92QixRQUFRSCxRQUFRNUQsTUFDckIsTUFBTXVGLG9CQUFvQjNCLFFBQVE1RCxNQUFNc0YsUUFBUSxDQUFDO0lBQ3BEO0lBTURyQix5QkFBeUJMLFFBQVE1RCxNQUFNO0FBQ3JDLGFBQU80RCxPQUFPd0IsYUFBYUksVUFDdkJ0QixRQUFRRSxJQUFJUSxPQUFPNUUsSUFBSSxJQUFJO1FBQUN5RixZQUFZO1FBQU1DLGNBQWM7VUFBUTVFLFNBQ3BFb0QsUUFBUUQseUJBQXlCVyxPQUFPNUUsSUFBSTtJQUNqRDtJQUtEbUUsaUJBQWlCO0FBQ2YsYUFBT0QsUUFBUUMsZUFBZVMsS0FBSztJQUNwQztJQUtEUixJQUFJUixRQUFRNUQsTUFBTTtBQUNoQixhQUFPa0UsUUFBUUUsSUFBSVEsT0FBTzVFLElBQUk7SUFDL0I7SUFLRHVFLFVBQVU7QUFDUixhQUFPTCxRQUFRSyxRQUFRSyxLQUFLO0lBQzdCO0lBS0RKLElBQUlaLFFBQVE1RCxNQUFNZCxPQUFPO0FBQ3ZCMEYsWUFBTTVFLFFBQVFkO0FBQ2QsYUFBTzBFLE9BQU81RDtBQUNkLGFBQU87SUFDUjtFQUNGLENBQUE7QUFDRjtBQUtNLFNBQVNvRixhQUFhUixPQUFPbkUsWUFBVztFQUFDa0YsWUFBWTtFQUFNQyxXQUFXO0dBQU87QUFDbEYsUUFBTSxFQUFDQyxjQUFjcEYsVUFBU2tGLFlBQVlHLGFBQWFyRixVQUFTbUYsV0FBV0csV0FBV3RGLFVBQVMrRSxRQUFPLElBQUlaO0FBQzFHLFNBQU87SUFDTFksU0FBU087SUFDVEosWUFBWUU7SUFDWkQsV0FBV0U7SUFDWEUsY0FBY0MsV0FBV0osV0FBVyxJQUFJQSxjQUFjLE1BQU1BO0lBQzVESyxhQUFhRCxXQUFXSCxVQUFVLElBQUlBLGFBQWEsTUFBTUE7O0FBRTVEO0FBRUQsSUFBTUssVUFBVSxDQUFDQyxRQUFRQyxVQUFTRCxTQUFTQSxTQUFTRSxZQUFZRCxLQUFJLElBQUlBO0FBQ3hFLElBQU1FLG1CQUFtQixDQUFDdkcsTUFBTWQsVUFBVVUsU0FBU1YsS0FBSyxLQUFLYyxTQUFTLGVBQ25FRixPQUFPcUUsZUFBZWpGLEtBQUssTUFBTSxRQUFRQSxNQUFNc0gsZ0JBQWdCMUc7QUFFbEUsU0FBU2lFLFFBQVFILFFBQVE1RCxNQUFNa0IsVUFBUztBQUN0QyxNQUFJcEIsT0FBTzJHLFVBQVVDLGVBQWVDLEtBQUsvQyxRQUFRNUQsSUFBSSxHQUFHO0FBQ3RELFdBQU80RCxPQUFPNUQ7RUFDZjtBQUVELFFBQU1kLFFBQVFnQyxTQUFPO0FBRXJCMEMsU0FBTzVELFFBQVFkO0FBQ2YsU0FBT0E7QUFDUjtBQUVELFNBQVNxRyxvQkFBb0IzQixRQUFRNUQsTUFBTXNGLFVBQVU7QUFDbkQsUUFBTSxFQUFDUCxRQUFRQyxVQUFVQyxXQUFXRyxjQUFjd0IsYUFBVyxJQUFJaEQ7QUFDakUsTUFBSTFFLFFBQVE2RixPQUFPL0U7QUFHbkIsTUFBSWlHLFdBQVcvRyxLQUFLLEtBQUswSCxhQUFZWixhQUFhaEcsSUFBSSxHQUFHO0FBQ3ZEZCxZQUFRMkgsbUJBQW1CN0csTUFBTWQsT0FBTzBFLFFBQVEwQixRQUFRO0VBQ3pEO0FBQ0QsTUFBSXJLLFFBQVFpRSxLQUFLLEtBQUtBLE1BQU14RCxRQUFRO0FBQ2xDd0QsWUFBUTRILGNBQWM5RyxNQUFNZCxPQUFPMEUsUUFBUWdELGFBQVlWLFdBQVc7RUFDbkU7QUFDRCxNQUFJSyxpQkFBaUJ2RyxNQUFNZCxLQUFLLEdBQUc7QUFFakNBLFlBQVF5RixlQUFlekYsT0FBTzhGLFVBQVVDLGFBQWFBLFVBQVVqRixPQUFPNEcsWUFBVztFQUNsRjtBQUNELFNBQU8xSDtBQUNSO0FBRUQsU0FBUzJILG1CQUFtQjdHLE1BQU1kLE9BQU8wRSxRQUFRMEIsVUFBVTtBQUN6RCxRQUFNLEVBQUNQLFFBQVFDLFVBQVVDLFdBQVdDLE9BQU0sSUFBSXRCO0FBQzlDLE1BQUlzQixPQUFPZCxJQUFJcEUsSUFBSSxHQUFHO0FBRXBCLFVBQU0sSUFBSStHLE1BQU0seUJBQXlCQyxNQUFNQyxLQUFLL0IsTUFBTSxFQUFFZ0MsS0FBSyxJQUFJLElBQUksT0FBT2xILElBQUk7RUFDckY7QUFDRGtGLFNBQU9oRCxJQUFJbEMsSUFBSTtBQUNmZCxVQUFRQSxNQUFNOEYsVUFBVUMsYUFBYUssUUFBUTtBQUM3Q0osU0FBT2lDLE9BQU9uSCxJQUFJO0FBQ2xCLE1BQUl1RyxpQkFBaUJ2RyxNQUFNZCxLQUFLLEdBQUc7QUFFakNBLFlBQVFrSSxrQkFBa0JyQyxPQUFPM0IsU0FBUzJCLFFBQVEvRSxNQUFNZCxLQUFLO0VBQzlEO0FBQ0QsU0FBT0E7QUFDUjtBQUVELFNBQVM0SCxjQUFjOUcsTUFBTWQsT0FBTzBFLFFBQVFzQyxhQUFhO0FBQ3ZELFFBQU0sRUFBQ25CLFFBQVFDLFVBQVVDLFdBQVdHLGNBQWN3QixhQUFXLElBQUloRDtBQUVqRSxNQUFJZCxRQUFRa0MsU0FBUzNELEtBQUssS0FBSzZFLFlBQVlsRyxJQUFJLEdBQUc7QUFDaERkLFlBQVFBLE1BQU04RixTQUFTM0QsUUFBUW5DLE1BQU14RDthQUM1QmtFLFNBQVNWLE1BQU0sRUFBRSxHQUFHO0FBRTdCLFVBQU1tSSxNQUFNbkk7QUFDWixVQUFNd0QsU0FBU3FDLE9BQU8zQixRQUFRa0UsT0FBT0MsQ0FBQUEsTUFBS0EsTUFBTUYsR0FBRztBQUNuRG5JLFlBQVEsQ0FBQTtBQUNSLGVBQVdzSSxRQUFRSCxLQUFLO0FBQ3RCLFlBQU1JLFdBQVdMLGtCQUFrQjFFLFFBQVFxQyxRQUFRL0UsTUFBTXdILElBQUk7QUFDN0R0SSxZQUFNd0ksS0FBSy9DLGVBQWU4QyxVQUFVekMsVUFBVUMsYUFBYUEsVUFBVWpGLE9BQU80RyxZQUFXLENBQUM7SUFDekY7RUFDRjtBQUNELFNBQU8xSDtBQUNSO0FBRUQsU0FBU3lJLGdCQUFnQm5ILFVBQVVSLE1BQU1kLE9BQU87QUFDOUMsU0FBTytHLFdBQVd6RixRQUFRLElBQUlBLFNBQVNSLE1BQU1kLEtBQUssSUFBSXNCO0FBQ3ZEO0FBRUQsSUFBTW9ILFdBQVcsQ0FBQ0MsS0FBS0MsV0FBV0QsUUFBUSxPQUFPQyxTQUM3QyxPQUFPRCxRQUFRLFdBQVdFLGlCQUFpQkQsUUFBUUQsR0FBRyxJQUFJL0c7QUFFOUQsU0FBU2tILFVBQVV4RCxNQUFLeUQsY0FBY0osS0FBS0ssZ0JBQWdCaEosT0FBTztBQUNoRSxhQUFXNEksVUFBVUcsY0FBYztBQUNqQyxVQUFNeEUsUUFBUW1FLFNBQVNDLEtBQUtDLE1BQU07QUFDbEMsUUFBSXJFLE9BQU87QUFDVGUsTUFBQUEsS0FBSXRDLElBQUl1QixLQUFLO0FBQ2IsWUFBTWpELFdBQVdtSCxnQkFBZ0JsRSxNQUFNSCxXQUFXdUUsS0FBSzNJLEtBQUs7QUFDNUQsVUFBSTRELFFBQVF0QyxRQUFRLEtBQUtBLGFBQWFxSCxPQUFPckgsYUFBYTBILGdCQUFnQjtBQUd4RSxlQUFPMUg7TUFDUjtJQUNGLFdBQVVpRCxVQUFVLFNBQVNYLFFBQVFvRixjQUFjLEtBQUtMLFFBQVFLLGdCQUFnQjtBQUcvRSxhQUFPO0lBQ1I7RUFDRjtBQUNELFNBQU87QUFDUjtBQUVELFNBQVNkLGtCQUFrQmEsY0FBY1IsVUFBVXpILE1BQU1kLE9BQU87QUFDOUQsUUFBTTBELGFBQWE2RSxTQUFTcEU7QUFDNUIsUUFBTTdDLFdBQVdtSCxnQkFBZ0JGLFNBQVNuRSxXQUFXdEQsTUFBTWQsS0FBSztBQUNoRSxRQUFNaUosWUFBWTtPQUFJRjtPQUFpQnJGOztBQUN2QyxRQUFNNEIsT0FBTSxvQkFBSVcsSUFBRztBQUNuQlgsRUFBQUEsS0FBSXRDLElBQUloRCxLQUFLO0FBQ2IsTUFBSTJJLE1BQU1PLGlCQUFpQjVELE1BQUsyRCxXQUFXbkksTUFBTVEsWUFBWVIsTUFBTWQsS0FBSztBQUN4RSxNQUFJMkksUUFBUSxNQUFNO0FBQ2hCLFdBQU87RUFDUjtBQUNELE1BQUkvRSxRQUFRdEMsUUFBUSxLQUFLQSxhQUFhUixNQUFNO0FBQzFDNkgsVUFBTU8saUJBQWlCNUQsTUFBSzJELFdBQVczSCxVQUFVcUgsS0FBSzNJLEtBQUs7QUFDM0QsUUFBSTJJLFFBQVEsTUFBTTtBQUNoQixhQUFPO0lBQ1I7RUFDRjtBQUNELFNBQU9wRixnQkFBZ0J1RSxNQUFNQyxLQUFLekMsSUFBRyxHQUFHO0lBQUM7RUFBRyxHQUFFNUIsWUFBWXBDLFVBQ3hELE1BQU02SCxhQUFhWixVQUFVekgsTUFBTWQsS0FBSyxDQUFDO0FBQzVDO0FBRUQsU0FBU2tKLGlCQUFpQjVELE1BQUsyRCxXQUFXTixLQUFLckgsVUFBVWdILE1BQU07QUFDN0QsU0FBT0ssS0FBSztBQUNWQSxVQUFNRyxVQUFVeEQsTUFBSzJELFdBQVdOLEtBQUtySCxVQUFVZ0gsSUFBSTtFQUNwRDtBQUNELFNBQU9LO0FBQ1I7QUFFRCxTQUFTUSxhQUFhWixVQUFVekgsTUFBTWQsT0FBTztBQUMzQyxRQUFNNEksU0FBU0wsU0FBU2xFLFdBQVU7QUFDbEMsTUFBSSxFQUFFdkQsUUFBUThILFNBQVM7QUFDckJBLFdBQU85SCxRQUFRLENBQUE7RUFDaEI7QUFDRCxRQUFNNEQsU0FBU2tFLE9BQU85SDtBQUN0QixNQUFJL0UsUUFBUTJJLE1BQU0sS0FBS2hFLFNBQVNWLEtBQUssR0FBRztBQUV0QyxXQUFPQTtFQUNSO0FBQ0QsU0FBTzBFLFVBQVUsQ0FBQTtBQUNsQjtBQUVELFNBQVNJLHFCQUFxQmhFLE1BQU0yQyxVQUFVRCxRQUFRa0MsT0FBTztBQUMzRCxNQUFJMUY7QUFDSixhQUFXa0gsVUFBVXpELFVBQVU7QUFDN0J6RCxZQUFRNkQsU0FBU29ELFFBQVFDLFFBQVFwRyxJQUFJLEdBQUcwQyxNQUFNO0FBQzlDLFFBQUlJLFFBQVE1RCxLQUFLLEdBQUc7QUFDbEIsYUFBT3FILGlCQUFpQnZHLE1BQU1kLEtBQUssSUFDL0JrSSxrQkFBa0IxRSxRQUFRa0MsT0FBTzVFLE1BQU1kLEtBQUssSUFDNUNBO0lBQ0w7RUFDRjtBQUNGO0FBRUQsU0FBUzZELFNBQVM4RSxLQUFLbkYsUUFBUTtBQUM3QixhQUFXZSxTQUFTZixRQUFRO0FBQzFCLFFBQUksQ0FBQ2UsT0FBTztBQUNWO0lBQ0Q7QUFDRCxVQUFNdkUsUUFBUXVFLE1BQU1vRTtBQUNwQixRQUFJL0UsUUFBUTVELEtBQUssR0FBRztBQUNsQixhQUFPQTtJQUNSO0VBQ0Y7QUFDRjtBQUVELFNBQVNtRixxQkFBcUJULFFBQVE7QUFDcEMsTUFBSS9ELE9BQU8rRCxPQUFPQztBQUNsQixNQUFJLENBQUNoRSxNQUFNO0FBQ1RBLFdBQU8rRCxPQUFPQyxRQUFReUUseUJBQXlCMUUsT0FBT1IsT0FBTztFQUM5RDtBQUNELFNBQU92RDtBQUNSO0FBRUQsU0FBU3lJLHlCQUF5QjVGLFFBQVE7QUFDeEMsUUFBTThCLE9BQU0sb0JBQUlXLElBQUc7QUFDbkIsYUFBVzFCLFNBQVNmLFFBQVE7QUFDMUIsZUFBV21GLE9BQU8vSCxPQUFPRCxLQUFLNEQsS0FBSyxFQUFFNkQsT0FBT2lCLENBQUFBLE1BQUssQ0FBQ0EsRUFBRUMsV0FBVyxHQUFHLENBQUMsR0FBRztBQUNwRWhFLE1BQUFBLEtBQUl0QyxJQUFJMkYsR0FBRztJQUNaO0VBQ0Y7QUFDRCxTQUFPYixNQUFNQyxLQUFLekMsSUFBRztBQUN0QjtBQy9VRCxJQUFNaUUsVUFBVUMsT0FBT0QsV0FBVztBQ0QzQixTQUFTRSxrQkFBMkI7QUFDekMsU0FBTyxPQUFPQyxXQUFXLGVBQWUsT0FBT0MsYUFBYTtBQUM3RDtBQUtNLFNBQVNDLGVBQWVDLFNBQStDO0FBQzVFLE1BQUlDLFNBQVNELFFBQVFFO0FBQ3JCLE1BQUlELFVBQVVBLE9BQU9FLFNBQVEsTUFBTyx1QkFBdUI7QUFDekRGLGFBQVVBLE9BQXNCRztFQUNqQztBQUNELFNBQU9IO0FBQ1I7QUFPRCxTQUFTSSxjQUFjQyxZQUE2QkMsTUFBbUJDLGdCQUF3QjtBQUM3RixNQUFJQztBQUNKLE1BQUksT0FBT0gsZUFBZSxVQUFVO0FBQ2xDRyxvQkFBZ0JDLFNBQVNKLFlBQVksRUFBRTtBQUV2QyxRQUFJQSxXQUFXSyxRQUFRLEdBQUcsTUFBTSxJQUFJO0FBRWxDRixzQkFBaUJBLGdCQUFnQixNQUFPRixLQUFLTCxXQUFXTTtJQUN6RDtTQUNJO0FBQ0xDLG9CQUFnQkg7RUFDakI7QUFFRCxTQUFPRztBQUNSO0FBRUQsSUFBTUcsbUJBQW1CLENBQUNDLFlBQ3hCQSxRQUFRQyxjQUFjQyxZQUFZSCxpQkFBaUJDLFNBQVMsSUFBSTtBQUUzRCxTQUFTRyxTQUFTQyxJQUFpQkMsVUFBMEI7QUFDbEUsU0FBT04saUJBQWlCSyxFQUFFLEVBQUVFLGlCQUFpQkQsUUFBUTtBQUN0RDtBQUVELElBQU1FLFlBQVk7RUFBQztFQUFPO0VBQVM7RUFBVTs7QUFDN0MsU0FBU0MsbUJBQW1CQyxRQUE2QkMsT0FBZUMsUUFBNEI7QUFDbEcsUUFBTUMsU0FBUyxDQUFBO0FBQ2ZELFdBQVNBLFNBQVMsTUFBTUEsU0FBUztBQUNqQyxXQUFTRSxJQUFJLEdBQUdBLElBQUksR0FBR0EsS0FBSztBQUMxQixVQUFNQyxNQUFNUCxVQUFVTTtBQUN0QkQsV0FBT0UsT0FBT0MsV0FBV04sT0FBT0MsUUFBUSxNQUFNSSxNQUFNSCxPQUFPLEtBQUs7RUFDakU7QUFDREMsU0FBT0ksUUFBUUosT0FBT0ssT0FBT0wsT0FBT007QUFDcENOLFNBQU9PLFNBQVNQLE9BQU9RLE1BQU1SLE9BQU9TO0FBQ3BDLFNBQU9UO0FBQ1I7QUFFRCxJQUFNVSxlQUFlLENBQUNDLEdBQVdDLEdBQVdDLFlBQ3pDRixJQUFJLEtBQUtDLElBQUksT0FBTyxDQUFDQyxVQUFVLENBQUMsT0FBd0JDO0FBTzNELFNBQVNDLGtCQUNQQyxHQUNBQyxRQUtFO0FBQ0YsUUFBTUMsVUFBV0YsRUFBaUJFO0FBQ2xDLFFBQU1DLFNBQVVELFdBQVdBLFFBQVFFLFNBQVNGLFFBQVEsS0FBS0Y7QUFDekQsUUFBTSxFQUFDSyxTQUFTQyxRQUFPLElBQUlIO0FBQzNCLE1BQUlJLE1BQU07QUFDVixNQUFJWixHQUFHQztBQUNQLE1BQUlGLGFBQWFXLFNBQVNDLFNBQVNOLEVBQUVILE1BQU0sR0FBRztBQUM1Q0YsUUFBSVU7QUFDSlQsUUFBSVU7U0FDQztBQUNMLFVBQU1FLE9BQU9QLE9BQU9RLHNCQUFxQjtBQUN6Q2QsUUFBSVEsT0FBT08sVUFBVUYsS0FBS25CO0FBQzFCTyxRQUFJTyxPQUFPUSxVQUFVSCxLQUFLaEI7QUFDMUJlLFVBQU07RUFDUDtBQUNELFNBQU87SUFBQ1o7SUFBR0M7SUFBR1c7O0FBQ2Y7QUFTTSxTQUFTSyxvQkFDZEMsT0FDQUMsT0FDMEI7QUFDMUIsTUFBSSxZQUFZRCxPQUFPO0FBQ3JCLFdBQU9BO0VBQ1I7QUFFRCxRQUFNLEVBQUNaLFFBQVFjLHdCQUF1QixJQUFJRDtBQUMxQyxRQUFNaEMsUUFBUVgsaUJBQWlCOEIsTUFBTTtBQUNyQyxRQUFNZSxZQUFZbEMsTUFBTW1DLGNBQWM7QUFDdEMsUUFBTUMsV0FBV3RDLG1CQUFtQkUsT0FBTyxTQUFTO0FBQ3BELFFBQU1xQyxVQUFVdkMsbUJBQW1CRSxPQUFPLFVBQVUsT0FBTztBQUMzRCxRQUFNLEVBQUNhLEdBQUdDLEdBQUdXLElBQUcsSUFBSVIsa0JBQWtCYyxPQUFPWixNQUFNO0FBQ25ELFFBQU1tQixVQUFVRixTQUFTN0IsUUFBUWtCLE9BQU9ZLFFBQVE5QjtBQUNoRCxRQUFNZ0MsVUFBVUgsU0FBUzFCLE9BQU9lLE9BQU9ZLFFBQVEzQjtBQUUvQyxNQUFJLEVBQUNKLE9BQU9HLE9BQU0sSUFBSXVCO0FBQ3RCLE1BQUlFLFdBQVc7QUFDYjVCLGFBQVM4QixTQUFTOUIsUUFBUStCLFFBQVEvQjtBQUNsQ0csY0FBVTJCLFNBQVMzQixTQUFTNEIsUUFBUTVCO0VBQ3JDO0FBQ0QsU0FBTztJQUNMSSxHQUFHMkIsS0FBS0MsT0FBTzVCLElBQUl5QixXQUFXaEMsUUFBUWEsT0FBT2IsUUFBUTJCLHVCQUF1QjtJQUM1RW5CLEdBQUcwQixLQUFLQyxPQUFPM0IsSUFBSXlCLFdBQVc5QixTQUFTVSxPQUFPVixTQUFTd0IsdUJBQXVCOztBQUVqRjtBQUVELFNBQVNTLGlCQUFpQnZCLFFBQTJCYixPQUFlRyxRQUFnQztBQUNsRyxNQUFJa0MsVUFBa0JDO0FBRXRCLE1BQUl0QyxVQUFVdUMsVUFBYXBDLFdBQVdvQyxRQUFXO0FBQy9DLFVBQU1DLFlBQVl0RSxlQUFlMkMsTUFBTTtBQUN2QyxRQUFJLENBQUMyQixXQUFXO0FBQ2R4QyxjQUFRYSxPQUFPNEI7QUFDZnRDLGVBQVNVLE9BQU82QjtXQUNYO0FBQ0wsWUFBTXRCLE9BQU9vQixVQUFVbkIsc0JBQXFCO0FBQzVDLFlBQU1zQixpQkFBaUI1RCxpQkFBaUJ5RCxTQUFTO0FBQ2pELFlBQU1JLGtCQUFrQnBELG1CQUFtQm1ELGdCQUFnQixVQUFVLE9BQU87QUFDNUUsWUFBTUUsbUJBQW1CckQsbUJBQW1CbUQsZ0JBQWdCLFNBQVM7QUFDckUzQyxjQUFRb0IsS0FBS3BCLFFBQVE2QyxpQkFBaUI3QyxRQUFRNEMsZ0JBQWdCNUM7QUFDOURHLGVBQVNpQixLQUFLakIsU0FBUzBDLGlCQUFpQjFDLFNBQVN5QyxnQkFBZ0J6QztBQUNqRWtDLGlCQUFXN0QsY0FBY21FLGVBQWVOLFVBQVVHLFdBQVcsYUFBYTtBQUMxRUYsa0JBQVk5RCxjQUFjbUUsZUFBZUwsV0FBV0UsV0FBVyxjQUFjO0lBQzlFO0VBQ0Y7QUFDRCxTQUFPO0lBQ0x4QztJQUNBRztJQUNBa0MsVUFBVUEsWUFBWVM7SUFDdEJSLFdBQVdBLGFBQWFROztBQUUzQjtBQUVELElBQU1DLFNBQVMsQ0FBQ0MsTUFBY2QsS0FBS0MsTUFBTWEsSUFBSSxFQUFFLElBQUk7QUFHNUMsU0FBU0MsZUFDZHBDLFFBQ0FxQyxTQUNBQyxVQUNBQyxhQUNtQztBQUNuQyxRQUFNMUQsUUFBUVgsaUJBQWlCOEIsTUFBTTtBQUNyQyxRQUFNd0MsVUFBVTdELG1CQUFtQkUsT0FBTyxRQUFRO0FBQ2xELFFBQU0yQyxXQUFXN0QsY0FBY2tCLE1BQU0yQyxVQUFVeEIsUUFBUSxhQUFhLEtBQUtpQztBQUN6RSxRQUFNUixZQUFZOUQsY0FBY2tCLE1BQU00QyxXQUFXekIsUUFBUSxjQUFjLEtBQUtpQztBQUM1RSxRQUFNUSxnQkFBZ0JsQixpQkFBaUJ2QixRQUFRcUMsU0FBU0MsUUFBUTtBQUNoRSxNQUFJLEVBQUNuRCxPQUFPRyxPQUFNLElBQUltRDtBQUV0QixNQUFJNUQsTUFBTW1DLGNBQWMsZUFBZTtBQUNyQyxVQUFNRSxVQUFVdkMsbUJBQW1CRSxPQUFPLFVBQVUsT0FBTztBQUMzRCxVQUFNb0MsV0FBV3RDLG1CQUFtQkUsT0FBTyxTQUFTO0FBQ3BETSxhQUFTOEIsU0FBUzlCLFFBQVErQixRQUFRL0I7QUFDbENHLGNBQVUyQixTQUFTM0IsU0FBUzRCLFFBQVE1QjtFQUNyQztBQUNESCxVQUFRa0MsS0FBS3FCLElBQUksR0FBR3ZELFFBQVFxRCxRQUFRckQsS0FBSztBQUN6Q0csV0FBUytCLEtBQUtxQixJQUFJLEdBQUdILGNBQWNsQixLQUFLc0IsTUFBTXhELFFBQVFvRCxXQUFXLElBQUlqRCxTQUFTa0QsUUFBUWxELE1BQU07QUFDNUZILFVBQVErQyxPQUFPYixLQUFLdUIsSUFBSXpELE9BQU9xQyxVQUFVaUIsY0FBY2pCLFFBQVEsQ0FBQztBQUNoRWxDLFdBQVM0QyxPQUFPYixLQUFLdUIsSUFBSXRELFFBQVFtQyxXQUFXZ0IsY0FBY2hCLFNBQVMsQ0FBQztBQUNwRSxNQUFJdEMsU0FBUyxDQUFDRyxRQUFRO0FBR3BCQSxhQUFTNEMsT0FBTy9DLFFBQVEsQ0FBQztFQUMxQjtBQUVELFFBQU0wRCxpQkFBaUJSLFlBQVlYLFVBQWFZLGFBQWFaO0FBRTdELE1BQUltQixrQkFBa0JOLGVBQWVFLGNBQWNuRCxVQUFVQSxTQUFTbUQsY0FBY25ELFFBQVE7QUFDMUZBLGFBQVNtRCxjQUFjbkQ7QUFDdkJILFlBQVErQyxPQUFPYixLQUFLc0IsTUFBTXJELFNBQVNpRCxXQUFXLENBQUM7RUFDaEQ7QUFFRCxTQUFPO0lBQUNwRDtJQUFPRzs7QUFDaEI7QUFRTSxTQUFTd0QsWUFDZGpDLE9BQ0FrQyxZQUNBQyxZQUNnQjtBQUNoQixRQUFNQyxhQUFhRixjQUFjO0FBQ2pDLFFBQU1HLGVBQWU3QixLQUFLc0IsTUFBTTlCLE1BQU12QixTQUFTMkQsVUFBVTtBQUN6RCxRQUFNRSxjQUFjOUIsS0FBS3NCLE1BQU05QixNQUFNMUIsUUFBUThELFVBQVU7QUFFdkRwQyxRQUFNdkIsU0FBUzRELGVBQWVEO0FBQzlCcEMsUUFBTTFCLFFBQVFnRSxjQUFjRjtBQUU1QixRQUFNakQsU0FBU2EsTUFBTWI7QUFLckIsTUFBSUEsT0FBT25CLFVBQVVtRSxjQUFlLENBQUNoRCxPQUFPbkIsTUFBTVMsVUFBVSxDQUFDVSxPQUFPbkIsTUFBTU0sUUFBUztBQUNqRmEsV0FBT25CLE1BQU1TLFNBQVMsR0FBR3VCLE1BQU12QjtBQUMvQlUsV0FBT25CLE1BQU1NLFFBQVEsR0FBRzBCLE1BQU0xQjtFQUMvQjtBQUVELE1BQUkwQixNQUFNQyw0QkFBNEJtQyxjQUMvQmpELE9BQU9WLFdBQVc0RCxnQkFDbEJsRCxPQUFPYixVQUFVZ0UsYUFBYTtBQUNuQ3RDLFVBQU1DLDBCQUEwQm1DO0FBQ2hDakQsV0FBT1YsU0FBUzREO0FBQ2hCbEQsV0FBT2IsUUFBUWdFO0FBQ2Z0QyxVQUFNdUMsSUFBSUMsYUFBYUosWUFBWSxHQUFHLEdBQUdBLFlBQVksR0FBRyxDQUFDO0FBQ3pELFdBQU87RUFDUjtBQUNELFNBQU87QUFDUjtBQU9NLElBQU1LLCtCQUFnQyxXQUFXO0FBQ3RELE1BQUlDLG1CQUFtQjtBQUN2QixNQUFJO0FBQ0YsVUFBTUMsVUFBVTtNQUNkLElBQUlDLFVBQVU7QUFDWkYsMkJBQW1CO0FBQ25CLGVBQU87TUFDUjtJQUNGO0FBRURwRyxXQUFPdUcsaUJBQWlCLFFBQVEsTUFBTUYsT0FBTztBQUM3Q3JHLFdBQU93RyxvQkFBb0IsUUFBUSxNQUFNSCxPQUFPO1dBQ3pDekQsR0FBUDtFQUVEO0FBQ0QsU0FBT3dEO0FBQ1IsRUFBQTtBQVlNLFNBQVNLLGFBQ2R6RixTQUNBSyxVQUNvQjtBQUNwQixRQUFNcUYsUUFBUXZGLFNBQVNILFNBQVNLLFFBQVE7QUFDeEMsUUFBTXNGLFVBQVVELFNBQVNBLE1BQU1FLE1BQUssbUJBQUE7QUFDcEMsU0FBT0QsVUFBVSxDQUFDQSxRQUFRLEtBQUtwQztBQUNoQztBRXpSRCxJQUFNc0Msd0JBQXdCLFNBQVNDLE9BQWVDLE9BQTJCO0FBQy9FLFNBQU87SUFDTEMsRUFBRUEsR0FBRztBQUNILGFBQU9GLFFBQVFBLFFBQVFDLFFBQVFDO0lBQ2hDO0lBQ0RDLFNBQVNDLEdBQUc7QUFDVkgsY0FBUUc7SUFDVDtJQUNEQyxVQUFVQyxPQUFPO0FBQ2YsVUFBSUEsVUFBVSxVQUFVO0FBQ3RCLGVBQU9BO01BQ1I7QUFDRCxhQUFPQSxVQUFVLFVBQVUsU0FBUztJQUNyQztJQUNEQyxNQUFNTCxHQUFHTSxPQUFPO0FBQ2QsYUFBT04sSUFBSU07SUFDWjtJQUNEQyxXQUFXUCxHQUFHUSxXQUFXO0FBQ3ZCLGFBQU9SLElBQUlRO0lBQ1o7OztBQUlMLElBQU1DLHdCQUF3QixXQUF1QjtBQUNuRCxTQUFPO0lBQ0xULEVBQUVBLEdBQUc7QUFDSCxhQUFPQTtJQUNSO0lBQ0RDLFNBQVNDLEdBQUc7SUFBQTtJQUVaQyxVQUFVQyxPQUFPO0FBQ2YsYUFBT0E7SUFDUjtJQUNEQyxNQUFNTCxHQUFHTSxPQUFPO0FBQ2QsYUFBT04sSUFBSU07SUFDWjtJQUNEQyxXQUFXUCxHQUFHVSxZQUFZO0FBQ3hCLGFBQU9WO0lBQ1I7OztBQUlFLFNBQVNXLGNBQWNDLEtBQWNkLE9BQWVDLE9BQWU7QUFDeEUsU0FBT2EsTUFBTWYsc0JBQXNCQyxPQUFPQyxLQUFLLElBQUlVLHNCQUFxQjtBQUN6RTtBQUVNLFNBQVNJLHNCQUFzQkMsS0FBK0JDLFdBQTBCO0FBQzdGLE1BQUlDLE9BQTRCQztBQUNoQyxNQUFJRixjQUFjLFNBQVNBLGNBQWMsT0FBTztBQUM5Q0MsWUFBUUYsSUFBSUksT0FBT0Y7QUFDbkJDLGVBQVc7TUFDVEQsTUFBTUcsaUJBQWlCLFdBQVc7TUFDbENILE1BQU1JLG9CQUFvQixXQUFXOztBQUd2Q0osVUFBTUssWUFBWSxhQUFhTixXQUFXLFdBQVc7QUFDcERELFFBQWlEUSxvQkFBb0JMO0VBQ3ZFO0FBQ0Y7QUFFTSxTQUFTTSxxQkFBcUJULEtBQStCRyxVQUE2QjtBQUMvRixNQUFJQSxhQUFhTyxRQUFXO0FBQzFCLFdBQU8sSUFBa0RGO0FBQ3pEUixRQUFJSSxPQUFPRixNQUFNSyxZQUFZLGFBQWFKLFNBQVMsSUFBSUEsU0FBUyxFQUFFO0VBQ25FO0FBQ0Y7OztBRTlETSxJQUFNUSxXQUFOLE1BQWM7RUFDbkJDLGNBQWM7QUFDWixTQUFLQyxXQUFXO0FBQ2hCLFNBQUtDLFVBQVUsb0JBQUlDLElBQUc7QUFDdEIsU0FBS0MsV0FBVztBQUNoQixTQUFLQyxZQUFZQztFQUNsQjtFQUtEQyxRQUFRQyxPQUFPQyxPQUFPQyxNQUFNQyxNQUFNO0FBQ2hDLFVBQU1DLFlBQVlILE1BQU1JLFVBQVVGO0FBQ2xDLFVBQU1HLFdBQVdMLE1BQU1NO0FBRXZCSCxjQUFVSSxRQUFRQyxDQUFBQSxPQUFNQSxHQUFHO01BQ3pCVDtNQUNBVSxTQUFTVCxNQUFNUztNQUNmSjtNQUNBSyxhQUFhQyxLQUFLQyxJQUFJWCxPQUFPRCxNQUFNYSxPQUFPUixRQUFRO0lBQ25ELENBQUEsQ0FBQztFQUNIO0VBS0RTLFdBQVc7QUFDVCxRQUFJLEtBQUt0QixVQUFVO0FBQ2pCO0lBQ0Q7QUFDRCxTQUFLRyxXQUFXO0FBRWhCLFNBQUtILFdBQVd1QixpQkFBaUJDLEtBQUtDLFFBQVEsTUFBTTtBQUNsRCxXQUFLQyxRQUFPO0FBQ1osV0FBSzFCLFdBQVc7QUFFaEIsVUFBSSxLQUFLRyxVQUFVO0FBQ2pCLGFBQUttQixTQUFRO01BQ2Q7SUFDRixDQUFBO0VBQ0Y7RUFLREksUUFBUWpCLE9BQU9rQixLQUFLQyxJQUFHLEdBQUk7QUFDekIsUUFBSUMsWUFBWTtBQUVoQixTQUFLNUIsUUFBUWMsUUFBUSxDQUFDUCxPQUFPRCxVQUFVO0FBQ3JDLFVBQUksQ0FBQ0MsTUFBTXNCLFdBQVcsQ0FBQ3RCLE1BQU11QixNQUFNQyxRQUFRO0FBQ3pDO01BQ0Q7QUFDRCxZQUFNRCxRQUFRdkIsTUFBTXVCO0FBQ3BCLFVBQUlFLElBQUlGLE1BQU1DLFNBQVM7QUFDdkIsVUFBSUUsT0FBTztBQUNYLFVBQUlDO0FBRUosYUFBT0YsS0FBSyxHQUFHLEVBQUVBLEdBQUc7QUFDbEJFLGVBQU9KLE1BQU1FO0FBRWIsWUFBSUUsS0FBS0MsU0FBUztBQUNoQixjQUFJRCxLQUFLRSxTQUFTN0IsTUFBTU0sVUFBVTtBQUdoQ04sa0JBQU1NLFdBQVdxQixLQUFLRTtVQUN2QjtBQUNERixlQUFLRyxLQUFLN0IsSUFBSTtBQUNkeUIsaUJBQU87ZUFDRjtBQUdMSCxnQkFBTUUsS0FBS0YsTUFBTUEsTUFBTUMsU0FBUztBQUNoQ0QsZ0JBQU1RLElBQUc7UUFDVjtNQUNGO0FBRUQsVUFBSUwsTUFBTTtBQUNSM0IsY0FBTTJCLEtBQUk7QUFDVixhQUFLNUIsUUFBUUMsT0FBT0MsT0FBT0MsTUFBTSxVQUFVO01BQzVDO0FBRUQsVUFBSSxDQUFDc0IsTUFBTUMsUUFBUTtBQUNqQnhCLGNBQU1zQixVQUFVO0FBQ2hCLGFBQUt4QixRQUFRQyxPQUFPQyxPQUFPQyxNQUFNLFVBQVU7QUFDM0NELGNBQU1TLFVBQVU7TUFDakI7QUFFRFksbUJBQWFFLE1BQU1DO0lBQ3BCLENBQUE7QUFFRCxTQUFLNUIsWUFBWUs7QUFFakIsUUFBSW9CLGNBQWMsR0FBRztBQUNuQixXQUFLMUIsV0FBVztJQUNqQjtFQUNGO0VBS0RxQyxVQUFVakMsT0FBTztBQUNmLFVBQU1rQyxTQUFTLEtBQUt4QztBQUNwQixRQUFJTyxRQUFRaUMsT0FBT0MsSUFBSW5DLEtBQUs7QUFDNUIsUUFBSSxDQUFDQyxPQUFPO0FBQ1ZBLGNBQVE7UUFDTnNCLFNBQVM7UUFDVGIsU0FBUztRQUNUYyxPQUFPLENBQUE7UUFDUG5CLFdBQVc7VUFDVCtCLFVBQVUsQ0FBQTtVQUNWQyxVQUFVLENBQUE7UUFDWDs7QUFFSEgsYUFBT0ksSUFBSXRDLE9BQU9DLEtBQUs7SUFDeEI7QUFDRCxXQUFPQTtFQUNSO0VBT0RzQyxPQUFPdkMsT0FBT3dDLE9BQU9DLElBQUk7QUFDdkIsU0FBS1IsVUFBVWpDLEtBQUssRUFBRUssVUFBVW1DLE9BQU9FLEtBQUtELEVBQUU7RUFDL0M7RUFPREUsSUFBSTNDLE9BQU93QixPQUFPO0FBQ2hCLFFBQUksQ0FBQ0EsU0FBUyxDQUFDQSxNQUFNQyxRQUFRO0FBQzNCO0lBQ0Q7QUFDRCxTQUFLUSxVQUFVakMsS0FBSyxFQUFFd0IsTUFBTWtCLEtBQUksR0FBSWxCLEtBQUs7RUFDMUM7RUFNRG9CLElBQUk1QyxPQUFPO0FBQ1QsV0FBTyxLQUFLaUMsVUFBVWpDLEtBQUssRUFBRXdCLE1BQU1DLFNBQVM7RUFDN0M7RUFNRFgsTUFBTWQsT0FBTztBQUNYLFVBQU1DLFFBQVEsS0FBS1AsUUFBUXlDLElBQUluQyxLQUFLO0FBQ3BDLFFBQUksQ0FBQ0MsT0FBTztBQUNWO0lBQ0Q7QUFDREEsVUFBTXNCLFVBQVU7QUFDaEJ0QixVQUFNYSxRQUFRTSxLQUFLQyxJQUFHO0FBQ3RCcEIsVUFBTU0sV0FBV04sTUFBTXVCLE1BQU1xQixPQUFPLENBQUNDLEtBQUtDLFFBQVFuQyxLQUFLb0MsSUFBSUYsS0FBS0MsSUFBSUUsU0FBUyxHQUFHLENBQUM7QUFDakYsU0FBS2xDLFNBQVE7RUFDZDtFQUVEUSxRQUFRdkIsT0FBTztBQUNiLFFBQUksQ0FBQyxLQUFLSixVQUFVO0FBQ2xCLGFBQU87SUFDUjtBQUNELFVBQU1LLFFBQVEsS0FBS1AsUUFBUXlDLElBQUluQyxLQUFLO0FBQ3BDLFFBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNc0IsV0FBVyxDQUFDdEIsTUFBTXVCLE1BQU1DLFFBQVE7QUFDbkQsYUFBTztJQUNSO0FBQ0QsV0FBTztFQUNSO0VBTUR5QixLQUFLbEQsT0FBTztBQUNWLFVBQU1DLFFBQVEsS0FBS1AsUUFBUXlDLElBQUluQyxLQUFLO0FBQ3BDLFFBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNdUIsTUFBTUMsUUFBUTtBQUNqQztJQUNEO0FBQ0QsVUFBTUQsUUFBUXZCLE1BQU11QjtBQUNwQixRQUFJRSxJQUFJRixNQUFNQyxTQUFTO0FBRXZCLFdBQU9DLEtBQUssR0FBRyxFQUFFQSxHQUFHO0FBQ2xCRixZQUFNRSxHQUFHeUIsT0FBTTtJQUNoQjtBQUNEbEQsVUFBTXVCLFFBQVEsQ0FBQTtBQUNkLFNBQUt6QixRQUFRQyxPQUFPQyxPQUFPbUIsS0FBS0MsSUFBRyxHQUFJLFVBQVU7RUFDbEQ7RUFNRCtCLE9BQU9wRCxPQUFPO0FBQ1osV0FBTyxLQUFLTixRQUFRMkQsT0FBT3JELEtBQUs7RUFDakM7QUFDRjtBQUdELElBQUEsV0FBK0Isb0JBQUlULFNBQVE7QUNqTjNDLElBQU0rRCxjQUFjO0FBQ3BCLElBQU1DLGdCQUFnQjtFQUNwQkMsUUFBUUMsT0FBTUMsS0FBSUMsUUFBUTtBQUN4QixXQUFPQSxTQUFTLE1BQU1ELE1BQUtEO0VBQzVCO0VBTURHLE1BQU1ILE9BQU1DLEtBQUlDLFFBQVE7QUFDdEIsVUFBTUUsS0FBS0MsTUFBYUwsU0FBUUgsV0FBVztBQUMzQyxVQUFNUyxLQUFLRixHQUFHRyxTQUFTRixNQUFhSixPQUFNSixXQUFXO0FBQ3JELFdBQU9TLE1BQU1BLEdBQUdDLFFBQ1pELEdBQUdFLElBQUlKLElBQUlGLE1BQU0sRUFBRU8sVUFBUyxJQUM1QlI7RUFDTDtFQUNEUyxPQUFPVixPQUFNQyxLQUFJQyxRQUFRO0FBQ3ZCLFdBQU9GLFNBQVFDLE1BQUtELFNBQVFFO0VBQzdCOztBQUdZLElBQU1TLFlBQU4sTUFBZTtFQUM1QjVFLFlBQVk2RSxLQUFLQyxRQUFRQyxNQUFNYixLQUFJO0FBQ2pDLFVBQU1jLGVBQWVGLE9BQU9DO0FBRTVCYixJQUFBQSxNQUFLZSxRQUFRO01BQUNKLElBQUlYO01BQUlBO01BQUljO01BQWNILElBQUlaO0lBQUssQ0FBQTtBQUNqRCxVQUFNQSxRQUFPZ0IsUUFBUTtNQUFDSixJQUFJWjtNQUFNZTtNQUFjZDtJQUFHLENBQUE7QUFFakQsU0FBSzdCLFVBQVU7QUFDZixTQUFLNkMsTUFBTUwsSUFBSTVELE1BQU04QyxjQUFjYyxJQUFJbEUsUUFBUSxPQUFPc0Q7QUFDdEQsU0FBS2tCLFVBQVVDLFVBQVFQLElBQUlRLFdBQVdELFVBQVFFO0FBQzlDLFNBQUtDLFNBQVNuRSxLQUFLb0UsTUFBTTVELEtBQUtDLElBQUcsS0FBTWdELElBQUlZLFNBQVMsRUFBRTtBQUN0RCxTQUFLaEMsWUFBWSxLQUFLbkIsU0FBU2xCLEtBQUtvRSxNQUFNWCxJQUFJOUQsUUFBUTtBQUN0RCxTQUFLMkUsUUFBUSxDQUFDLENBQUNiLElBQUljO0FBQ25CLFNBQUtDLFVBQVVkO0FBQ2YsU0FBS2UsUUFBUWQ7QUFDYixTQUFLZSxRQUFRN0I7QUFDYixTQUFLOEIsTUFBTTdCO0FBQ1gsU0FBSzhCLFlBQVkxRjtFQUNsQjtFQUVEMkYsU0FBUztBQUNQLFdBQU8sS0FBSzVEO0VBQ2I7RUFFRDZELE9BQU9yQixLQUFLWCxLQUFJeEQsTUFBTTtBQUNwQixRQUFJLEtBQUsyQixTQUFTO0FBQ2hCLFdBQUs5QixRQUFRLEtBQUs7QUFFbEIsWUFBTXlFLGVBQWUsS0FBS1ksUUFBUSxLQUFLQztBQUN2QyxZQUFNTSxVQUFVekYsT0FBTyxLQUFLNkU7QUFDNUIsWUFBTWEsU0FBUyxLQUFLM0MsWUFBWTBDO0FBQ2hDLFdBQUtaLFNBQVM3RTtBQUNkLFdBQUsrQyxZQUFZckMsS0FBS29FLE1BQU1wRSxLQUFLb0MsSUFBSTRDLFFBQVF2QixJQUFJOUQsUUFBUSxDQUFDO0FBQzFELFdBQUt1QixVQUFVNkQ7QUFDZixXQUFLVCxRQUFRLENBQUMsQ0FBQ2IsSUFBSWM7QUFDbkIsV0FBS0ksTUFBTWQsUUFBUTtRQUFDSixJQUFJWDtRQUFJQTtRQUFJYztRQUFjSCxJQUFJWjtNQUFLLENBQUE7QUFDdkQsV0FBSzZCLFFBQVFiLFFBQVE7UUFBQ0osSUFBSVo7UUFBTWU7UUFBY2Q7TUFBRyxDQUFBO0lBQ2xEO0VBQ0Y7RUFFRFAsU0FBUztBQUNQLFFBQUksS0FBS3RCLFNBQVM7QUFFaEIsV0FBS0UsS0FBS1gsS0FBS0MsSUFBRyxDQUFFO0FBQ3BCLFdBQUtRLFVBQVU7QUFDZixXQUFLOUIsUUFBUSxLQUFLO0lBQ25CO0VBQ0Y7RUFFRGdDLEtBQUs3QixNQUFNO0FBQ1QsVUFBTXlGLFVBQVV6RixPQUFPLEtBQUs2RTtBQUM1QixVQUFNeEUsV0FBVyxLQUFLMEM7QUFDdEIsVUFBTXNCLE9BQU8sS0FBS2M7QUFDbEIsVUFBTTVCLFFBQU8sS0FBSzZCO0FBQ2xCLFVBQU1ILE9BQU8sS0FBS0Q7QUFDbEIsVUFBTXhCLE1BQUssS0FBSzZCO0FBQ2hCLFFBQUk1QjtBQUVKLFNBQUs5QixVQUFVNEIsVUFBU0MsUUFBT3lCLFFBQVNRLFVBQVVwRjtBQUVsRCxRQUFJLENBQUMsS0FBS3NCLFNBQVM7QUFDakIsV0FBS3VELFFBQVFiLFFBQVFiO0FBQ3JCLFdBQUszRCxRQUFRLElBQUk7QUFDakI7SUFDRDtBQUVELFFBQUk0RixVQUFVLEdBQUc7QUFDZixXQUFLUCxRQUFRYixRQUFRZDtBQUNyQjtJQUNEO0FBRURFLGFBQVMsVUFBV3BELFdBQVk7QUFDaENvRCxhQUFTd0IsUUFBUXhCLFNBQVMsSUFBSSxJQUFJQSxTQUFTQTtBQUMzQ0EsYUFBUyxLQUFLZ0IsUUFBUS9ELEtBQUtDLElBQUksR0FBR0QsS0FBS29DLElBQUksR0FBR1csTUFBTSxDQUFDLENBQUM7QUFFdEQsU0FBS3lCLFFBQVFiLFFBQVEsS0FBS0csSUFBSWpCLE9BQU1DLEtBQUlDLE1BQU07RUFDL0M7RUFFRGtDLE9BQU87QUFDTCxVQUFNQyxXQUFXLEtBQUtOLGNBQWMsS0FBS0EsWUFBWSxDQUFBO0FBQ3JELFdBQU8sSUFBSU8sUUFBUSxDQUFDQyxLQUFLQyxRQUFRO0FBQy9CSCxlQUFTcEQsS0FBSztRQUFDc0Q7UUFBS0M7TUFBSSxDQUFBO0lBQ3pCLENBQUE7RUFDRjtFQUVEbEcsUUFBUW1HLFVBQVU7QUFDaEIsVUFBTUMsU0FBU0QsV0FBVyxRQUFRO0FBQ2xDLFVBQU1KLFdBQVcsS0FBS04sYUFBYSxDQUFBO0FBQ25DLGFBQVM5RCxJQUFJLEdBQUdBLElBQUlvRSxTQUFTckUsUUFBUUMsS0FBSztBQUN4Q29FLGVBQVNwRSxHQUFHeUUsUUFBTztJQUNwQjtFQUNGOztBQ2hIWSxJQUFNQyxhQUFOLE1BQWdCO0VBQzdCNUcsWUFBWVEsT0FBT3FHLFFBQVE7QUFDekIsU0FBS0MsU0FBU3RHO0FBQ2QsU0FBS3VHLGNBQWMsb0JBQUk1RyxJQUFHO0FBQzFCLFNBQUs2RyxVQUFVSCxNQUFNO0VBQ3RCO0VBRURHLFVBQVVILFFBQVE7QUFDaEIsUUFBSSxDQUFDSSxTQUFTSixNQUFNLEdBQUc7QUFDckI7SUFDRDtBQUVELFVBQU1LLG1CQUFtQkMsT0FBT0MsS0FBS0MsU0FBU0MsU0FBUztBQUN2RCxVQUFNQyxnQkFBZ0IsS0FBS1I7QUFFM0JJLFdBQU9LLG9CQUFvQlgsTUFBTSxFQUFFN0YsUUFBUXlHLENBQUFBLFFBQU87QUFDaEQsWUFBTTVDLE1BQU1nQyxPQUFPWTtBQUNuQixVQUFJLENBQUNSLFNBQVNwQyxHQUFHLEdBQUc7QUFDbEI7TUFDRDtBQUNELFlBQU02QixXQUFXLENBQUE7QUFDakIsaUJBQVdnQixVQUFVUixrQkFBa0I7QUFDckNSLGlCQUFTZ0IsVUFBVTdDLElBQUk2QztNQUN4QjtBQUVELE9BQUNDLFFBQVE5QyxJQUFJK0MsVUFBVSxLQUFLL0MsSUFBSStDLGNBQWM7UUFBQ0g7TUFBSSxHQUFFekcsUUFBUSxDQUFDK0QsU0FBUztBQUNyRSxZQUFJQSxTQUFTMEMsT0FBTyxDQUFDRixjQUFjbkUsSUFBSTJCLElBQUksR0FBRztBQUM1Q3dDLHdCQUFjekUsSUFBSWlDLE1BQU0yQixRQUFRO1FBQ2pDO01BQ0YsQ0FBQTtJQUNGLENBQUE7RUFDRjtFQU1EbUIsZ0JBQWdCL0MsUUFBUWdELFFBQVE7QUFDOUIsVUFBTUMsYUFBYUQsT0FBT0U7QUFDMUIsVUFBTUEsVUFBVUMscUJBQXFCbkQsUUFBUWlELFVBQVU7QUFDdkQsUUFBSSxDQUFDQyxTQUFTO0FBQ1osYUFBTyxDQUFBO0lBQ1I7QUFFRCxVQUFNRSxhQUFhLEtBQUtDLGtCQUFrQkgsU0FBU0QsVUFBVTtBQUM3RCxRQUFJQSxXQUFXSyxTQUFTO0FBSXRCQyxlQUFTdkQsT0FBT2tELFFBQVFNLGFBQWFQLFVBQVUsRUFBRVEsS0FBSyxNQUFNO0FBQzFEekQsZUFBT2tELFVBQVVEO01BQ2xCLEdBQUUsTUFBTTtNQUVSLENBQUE7SUFDRjtBQUVELFdBQU9HO0VBQ1I7RUFLREMsa0JBQWtCckQsUUFBUWdELFFBQVE7QUFDaEMsVUFBTVAsZ0JBQWdCLEtBQUtSO0FBQzNCLFVBQU1tQixhQUFhLENBQUE7QUFDbkIsVUFBTW5HLFVBQVUrQyxPQUFPd0QsZ0JBQWdCeEQsT0FBT3dELGNBQWMsQ0FBQTtBQUM1RCxVQUFNRSxRQUFRckIsT0FBT0MsS0FBS1UsTUFBTTtBQUNoQyxVQUFNcEgsT0FBT2tCLEtBQUtDLElBQUc7QUFDckIsUUFBSUs7QUFFSixTQUFLQSxJQUFJc0csTUFBTXZHLFNBQVMsR0FBR0MsS0FBSyxHQUFHLEVBQUVBLEdBQUc7QUFDdEMsWUFBTTZDLE9BQU95RCxNQUFNdEc7QUFDbkIsVUFBSTZDLEtBQUswRCxPQUFPLENBQUMsTUFBTSxLQUFLO0FBQzFCO01BQ0Q7QUFFRCxVQUFJMUQsU0FBUyxXQUFXO0FBQ3RCbUQsbUJBQVdoRixLQUFRLEdBQUEsS0FBSzJFLGdCQUFnQi9DLFFBQVFnRCxNQUFNLENBQUM7QUFDdkQ7TUFDRDtBQUNELFlBQU1ZLFFBQVFaLE9BQU8vQztBQUNyQixVQUFJdUMsWUFBWXZGLFFBQVFnRDtBQUN4QixZQUFNRixNQUFNMEMsY0FBYzVFLElBQUlvQyxJQUFJO0FBRWxDLFVBQUl1QyxXQUFXO0FBQ2IsWUFBSXpDLE9BQU95QyxVQUFVckIsT0FBTSxHQUFJO0FBRTdCcUIsb0JBQVVwQixPQUFPckIsS0FBSzZELE9BQU9oSSxJQUFJO0FBQ2pDO2VBQ0s7QUFDTDRHLG9CQUFVM0QsT0FBTTtRQUNqQjtNQUNGO0FBQ0QsVUFBSSxDQUFDa0IsT0FBTyxDQUFDQSxJQUFJOUQsVUFBVTtBQUV6QitELGVBQU9DLFFBQVEyRDtBQUNmO01BQ0Q7QUFFRDNHLGNBQVFnRCxRQUFRdUMsWUFBWSxJQUFJMUMsVUFBVUMsS0FBS0MsUUFBUUMsTUFBTTJELEtBQUs7QUFDbEVSLGlCQUFXaEYsS0FBS29FLFNBQVM7SUFDMUI7QUFDRCxXQUFPWTtFQUNSO0VBU0RoQyxPQUFPcEIsUUFBUWdELFFBQVE7QUFDckIsUUFBSSxLQUFLZixZQUFZNEIsU0FBUyxHQUFHO0FBRS9CeEIsYUFBT3lCLE9BQU85RCxRQUFRZ0QsTUFBTTtBQUM1QjtJQUNEO0FBRUQsVUFBTUksYUFBYSxLQUFLQyxrQkFBa0JyRCxRQUFRZ0QsTUFBTTtBQUV4RCxRQUFJSSxXQUFXakcsUUFBUTtBQUNyQjRHLGVBQVMxRixJQUFJLEtBQUsyRCxRQUFRb0IsVUFBVTtBQUNwQyxhQUFPO0lBQ1I7RUFDRjs7QUFHSCxTQUFTRyxTQUFTSCxZQUFZTixZQUFZO0FBQ3hDLFFBQU03RixVQUFVLENBQUE7QUFDaEIsUUFBTXFGLE9BQU9ELE9BQU9DLEtBQUtRLFVBQVU7QUFDbkMsV0FBUzFGLElBQUksR0FBR0EsSUFBSWtGLEtBQUtuRixRQUFRQyxLQUFLO0FBQ3BDLFVBQU00RyxPQUFPWixXQUFXZCxLQUFLbEY7QUFDN0IsUUFBSTRHLFFBQVFBLEtBQUs3QyxPQUFNLEdBQUk7QUFDekJsRSxjQUFRbUIsS0FBSzRGLEtBQUt6QyxLQUFJLENBQUU7SUFDekI7RUFDRjtBQUVELFNBQU9FLFFBQVF3QyxJQUFJaEgsT0FBTztBQUMzQjtBQUVELFNBQVNrRyxxQkFBcUJuRCxRQUFRaUQsWUFBWTtBQUNoRCxNQUFJLENBQUNBLFlBQVk7QUFDZjtFQUNEO0FBQ0QsTUFBSUMsVUFBVWxELE9BQU9rRDtBQUNyQixNQUFJLENBQUNBLFNBQVM7QUFDWmxELFdBQU9rRCxVQUFVRDtBQUNqQjtFQUNEO0FBQ0QsTUFBSUMsUUFBUUksU0FBUztBQUduQnRELFdBQU9rRCxVQUFVQSxVQUFVYixPQUFPeUIsT0FBTyxDQUFBLEdBQUlaLFNBQVM7TUFBQ0ksU0FBUztNQUFPRSxhQUFhLENBQUE7SUFBRyxDQUFBO0VBQ3hGO0FBQ0QsU0FBT047QUFDUjtBQ3RKRCxTQUFTZ0IsVUFBVUMsT0FBT0MsaUJBQWlCO0FBQ3pDLFFBQU1DLE9BQU9GLFNBQVNBLE1BQU1qQixXQUFXLENBQUE7QUFDdkMsUUFBTW9CLFVBQVVELEtBQUtDO0FBQ3JCLFFBQU0vSCxNQUFNOEgsS0FBSzlILFFBQVFmLFNBQVk0SSxrQkFBa0I7QUFDdkQsUUFBTTFGLE1BQU0yRixLQUFLM0YsUUFBUWxELFNBQVk0SSxrQkFBa0I7QUFDdkQsU0FBTztJQUNMNUgsT0FBTzhILFVBQVU1RixNQUFNbkM7SUFDdkJnSSxLQUFLRCxVQUFVL0gsTUFBTW1DOztBQUV4QjtBQUVELFNBQVM4RixZQUFZQyxRQUFRQyxRQUFRTixpQkFBaUI7QUFDcEQsTUFBSUEsb0JBQW9CLE9BQU87QUFDN0IsV0FBTztFQUNSO0FBQ0QsUUFBTU8sSUFBSVQsVUFBVU8sUUFBUUwsZUFBZTtBQUMzQyxRQUFNUSxJQUFJVixVQUFVUSxRQUFRTixlQUFlO0FBRTNDLFNBQU87SUFDTFMsS0FBS0QsRUFBRUw7SUFDUE8sT0FBT0gsRUFBRUo7SUFDVFEsUUFBUUgsRUFBRXBJO0lBQ1Z3SSxNQUFNTCxFQUFFbkk7O0FBRVg7QUFFRCxTQUFTeUksT0FBT3JCLE9BQU87QUFDckIsTUFBSXNCLElBQUdDLEdBQUdDLEdBQUdDO0FBRWIsTUFBSWxELFNBQVN5QixLQUFLLEdBQUc7QUFDbkJzQixJQUFBQSxLQUFJdEIsTUFBTWlCO0FBQ1ZNLFFBQUl2QixNQUFNa0I7QUFDVk0sUUFBSXhCLE1BQU1tQjtBQUNWTSxRQUFJekIsTUFBTW9CO1NBQ0w7QUFDTEUsSUFBQUEsS0FBSUMsSUFBSUMsSUFBSUMsSUFBSXpCO0VBQ2pCO0FBRUQsU0FBTztJQUNMaUIsS0FBS0s7SUFDTEosT0FBT0s7SUFDUEosUUFBUUs7SUFDUkosTUFBTUs7SUFDTkMsVUFBVTFCLFVBQVU7O0FBRXZCO0FBRUQsU0FBUzJCLHdCQUF3QjdKLE9BQU84SixlQUFlO0FBQ3JELFFBQU1sRCxPQUFPLENBQUE7QUFDYixRQUFNbUQsV0FBVy9KLE1BQU1nSyx1QkFBdUJGLGFBQWE7QUFDM0QsTUFBSXBJLEdBQUd1STtBQUVQLE9BQUt2SSxJQUFJLEdBQUd1SSxPQUFPRixTQUFTdEksUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDakRrRixTQUFLbEUsS0FBS3FILFNBQVNySSxHQUFHd0ksS0FBSztFQUM1QjtBQUNELFNBQU90RDtBQUNSO0FBRUQsU0FBU3VELFdBQVdDLE9BQU9sQyxPQUFPbUMsU0FBUzdDLFVBQVUsQ0FBQSxHQUFJO0FBQ3ZELFFBQU1aLE9BQU93RCxNQUFNeEQ7QUFDbkIsUUFBTTBELGFBQWE5QyxRQUFRK0MsU0FBUztBQUNwQyxNQUFJN0ksR0FBR3VJLE1BQU1PLGNBQWNDO0FBRTNCLE1BQUl2QyxVQUFVLE1BQU07QUFDbEI7RUFDRDtBQUVELE9BQUt4RyxJQUFJLEdBQUd1SSxPQUFPckQsS0FBS25GLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzdDOEksbUJBQWUsQ0FBQzVELEtBQUtsRjtBQUNyQixRQUFJOEksaUJBQWlCSCxTQUFTO0FBQzVCLFVBQUk3QyxRQUFRZSxLQUFLO0FBQ2Y7TUFDRDtBQUNEO0lBQ0Q7QUFDRGtDLGlCQUFhTCxNQUFNOUMsT0FBT2tEO0FBQzFCLFFBQUlFLGVBQVNELFVBQVUsTUFBTUgsY0FBZXBDLFVBQVUsS0FBS3lDLEtBQUt6QyxLQUFLLE1BQU15QyxLQUFLRixVQUFVLElBQUs7QUFDN0Z2QyxlQUFTdUM7SUFDVjtFQUNGO0FBQ0QsU0FBT3ZDO0FBQ1I7QUFFRCxTQUFTMEMseUJBQXlCQyxNQUFNO0FBQ3RDLFFBQU1qRSxPQUFPRCxPQUFPQyxLQUFLaUUsSUFBSTtBQUM3QixRQUFNQyxRQUFRLElBQUlDLE1BQU1uRSxLQUFLbkYsTUFBTTtBQUNuQyxNQUFJQyxHQUFHdUksTUFBTWhEO0FBQ2IsT0FBS3ZGLElBQUksR0FBR3VJLE9BQU9yRCxLQUFLbkYsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDN0N1RixVQUFNTCxLQUFLbEY7QUFDWG9KLFVBQU1wSixLQUFLO01BQ1R1SCxHQUFHaEM7TUFDSGlDLEdBQUcyQixLQUFLNUQ7O0VBRVg7QUFDRCxTQUFPNkQ7QUFDUjtBQUVELFNBQVNFLFVBQVV2QyxPQUFPd0MsTUFBTTtBQUM5QixRQUFNQyxVQUFVekMsU0FBU0EsTUFBTWpCLFFBQVEwRDtBQUN2QyxTQUFPQSxXQUFZQSxZQUFZcEwsVUFBYW1MLEtBQUtiLFVBQVV0SztBQUM1RDtBQUVELFNBQVNxTCxZQUFZQyxZQUFZQyxZQUFZSixNQUFNO0FBQ2pELFNBQU8sR0FBR0csV0FBV0UsTUFBTUQsV0FBV0MsTUFBTUwsS0FBS2IsU0FBU2EsS0FBSzlLO0FBQ2hFO0FBRUQsU0FBU29MLGNBQWM5QyxPQUFPO0FBQzVCLFFBQU0sRUFBQzVILEtBQUttQyxLQUFLd0ksWUFBWUMsV0FBVSxJQUFJaEQsTUFBTThDLGNBQWE7QUFDOUQsU0FBTztJQUNMMUssS0FBSzJLLGFBQWEzSyxNQUFNNkssT0FBT0M7SUFDL0IzSSxLQUFLeUksYUFBYXpJLE1BQU0wSSxPQUFPRTs7QUFFbEM7QUFFRCxTQUFTQyxpQkFBaUJDLFFBQVFDLFVBQVVDLFlBQVk7QUFDdEQsUUFBTUMsV0FBV0gsT0FBT0MsY0FBY0QsT0FBT0MsWUFBWSxDQUFBO0FBQ3pELFNBQU9FLFNBQVNELGdCQUFnQkMsU0FBU0QsY0FBYyxDQUFBO0FBQ3hEO0FBRUQsU0FBU0Usb0JBQW9COUIsT0FBTytCLFFBQVFDLFVBQVVqTSxNQUFNO0FBQzFELGFBQVc4SyxRQUFRa0IsT0FBT0Usd0JBQXdCbE0sSUFBSSxFQUFFeUksUUFBTyxHQUFJO0FBQ2pFLFVBQU1WLFFBQVFrQyxNQUFNYSxLQUFLZjtBQUN6QixRQUFJLFlBQWFoQyxRQUFRLEtBQU8sQ0FBQ2tFLFlBQVlsRSxRQUFRLEdBQUk7QUFDdkQsYUFBTytDLEtBQUtmO0lBQ2I7RUFDRjtBQUVELFNBQU87QUFDUjtBQUVELFNBQVNvQyxhQUFhQyxZQUFZQyxRQUFRO0FBQ3hDLFFBQU0sRUFBQ3hNLE9BQU95TSxhQUFheEIsS0FBSSxJQUFJc0I7QUFDbkMsUUFBTVQsU0FBUzlMLE1BQU0wTSxZQUFZMU0sTUFBTTBNLFVBQVUsQ0FBQTtBQUNqRCxRQUFNLEVBQUNDLFFBQVFSLFFBQVFqQyxPQUFPTSxhQUFZLElBQUlTO0FBQzlDLFFBQU0yQixRQUFRRCxPQUFPRTtBQUNyQixRQUFNQyxRQUFRWCxPQUFPVTtBQUNyQixRQUFNNUYsTUFBTWtFLFlBQVl3QixRQUFRUixRQUFRbEIsSUFBSTtBQUM1QyxRQUFNaEIsT0FBT3VDLE9BQU8vSztBQUNwQixNQUFJMkk7QUFFSixXQUFTMUksSUFBSSxHQUFHQSxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUM3QixVQUFNRSxPQUFPNEssT0FBTzlLO0FBQ3BCLFVBQU0sR0FBRWtMLFFBQVExQyxRQUFRNEMsUUFBUTVFLE1BQUssSUFBSXRHO0FBQ3pDLFVBQU1tTCxhQUFhbkwsS0FBSzhLLFlBQVk5SyxLQUFLOEssVUFBVSxDQUFBO0FBQ25EdEMsWUFBUTJDLFdBQVdELFNBQVNqQixpQkFBaUJDLFFBQVE3RSxLQUFLaUQsS0FBSztBQUMvREUsVUFBTUksZ0JBQWdCdEM7QUFFdEJrQyxVQUFNNEMsT0FBT2Qsb0JBQW9COUIsT0FBTytCLFFBQVEsTUFBTWxCLEtBQUs5SyxJQUFJO0FBQy9EaUssVUFBTTZDLFVBQVVmLG9CQUFvQjlCLE9BQU8rQixRQUFRLE9BQU9sQixLQUFLOUssSUFBSTtFQUNwRTtBQUNGO0FBRUQsU0FBUytNLGdCQUFnQmxOLE9BQU82TSxNQUFNO0FBQ3BDLFFBQU1NLFNBQVNuTixNQUFNbU47QUFDckIsU0FBT3hHLE9BQU9DLEtBQUt1RyxNQUFNLEVBQUVDLE9BQU9uRyxDQUFBQSxRQUFPa0csT0FBT2xHLEtBQUs0RixTQUFTQSxJQUFJLEVBQUVRLE1BQUs7QUFDMUU7QUFFRCxTQUFTQyxxQkFBcUJDLFFBQVFyRCxPQUFPO0FBQzNDLFNBQU9zRCxjQUFjRCxRQUNuQjtJQUNFOUgsUUFBUTtJQUNSZ0ksU0FBUzNOO0lBQ1QwSyxjQUFjTjtJQUNkQTtJQUNBSyxNQUFNO0lBQ05wSyxNQUFNO0VBQ1AsQ0FBQTtBQUVKO0FBRUQsU0FBU3VOLGtCQUFrQkgsUUFBUXJELE9BQU95RCxTQUFTO0FBQ2pELFNBQU9ILGNBQWNELFFBQVE7SUFDM0I5SCxRQUFRO0lBQ1JtSSxXQUFXMUQ7SUFDWHNDLFFBQVExTTtJQUNSK04sS0FBSy9OO0lBQ0w2TjtJQUNBekQ7SUFDQUssTUFBTTtJQUNOcEssTUFBTTtFQUNQLENBQUE7QUFDRjtBQUVELFNBQVMyTixZQUFZN0MsTUFBTXpKLE9BQU87QUFFaEMsUUFBTWdKLGVBQWVTLEtBQUtzQixXQUFXckM7QUFDckMsUUFBTTJDLE9BQU81QixLQUFLa0IsVUFBVWxCLEtBQUtrQixPQUFPVTtBQUN4QyxNQUFJLENBQUNBLE1BQU07QUFDVDtFQUNEO0FBRURyTCxVQUFRQSxTQUFTeUosS0FBSzhDO0FBQ3RCLGFBQVd2QixVQUFVaEwsT0FBTztBQUMxQixVQUFNc0ssU0FBU1UsT0FBT0U7QUFDdEIsUUFBSSxDQUFDWixVQUFVQSxPQUFPZSxVQUFVL00sVUFBYWdNLE9BQU9lLE1BQU1yQyxrQkFBa0IxSyxRQUFXO0FBQ3JGO0lBQ0Q7QUFDRCxXQUFPZ00sT0FBT2UsTUFBTXJDO0VBQ3JCO0FBQ0Y7QUFFRCxJQUFNd0QscUJBQXFCLENBQUN6RCxTQUFTQSxTQUFTLFdBQVdBLFNBQVM7QUFDbEUsSUFBTTBELG1CQUFtQixDQUFDQyxRQUFRQyxXQUFXQSxTQUFTRCxTQUFTdkgsT0FBT3lCLE9BQU8sQ0FBQSxHQUFJOEYsTUFBTTtBQUN2RixJQUFNRSxjQUFjLENBQUNDLFVBQVVwRCxNQUFNakwsVUFBVXFPLFlBQVksQ0FBQ3BELEtBQUtxRCxVQUFVckQsS0FBS3NELFlBQzNFO0VBQUMzSCxNQUFNaUQsd0JBQXdCN0osT0FBTyxJQUFJO0VBQUdzSCxRQUFROztBQUUzQyxJQUFNa0gsb0JBQU4sTUFBdUI7RUFxQnBDaFAsWUFBWVEsT0FBT3dLLGNBQWM7QUFDL0IsU0FBS3hLLFFBQVFBO0FBQ2IsU0FBS3lPLE9BQU96TyxNQUFNME87QUFDbEIsU0FBS3hFLFFBQVFNO0FBQ2IsU0FBS21FLGtCQUFrQixDQUFBO0FBQ3ZCLFNBQUtsQyxjQUFjLEtBQUttQyxRQUFPO0FBQy9CLFNBQUtDLFFBQVEsS0FBS3BDLFlBQVl0TTtBQUM5QixTQUFLcUgsVUFBVTFIO0FBRWYsU0FBS2dQLFdBQVc7QUFDaEIsU0FBS0MsUUFBUWpQO0FBQ2IsU0FBS2tQLGNBQWNsUDtBQUNuQixTQUFLbVAsaUJBQWlCblA7QUFDdEIsU0FBS29QLGFBQWFwUDtBQUNsQixTQUFLcVAsYUFBYXJQO0FBQ2xCLFNBQUtzUCxzQkFBc0I7QUFDM0IsU0FBS0MscUJBQXFCO0FBQzFCLFNBQUtDLFdBQVd4UDtBQUNoQixTQUFLeVAsWUFBWSxDQUFBO0FBQ2pCLFNBQUtDLHFCQUFxQixXQUFXQTtBQUNyQyxTQUFLQyxrQkFBa0IsV0FBV0E7QUFFbEMsU0FBS0MsV0FBVTtFQUNoQjtFQUVEQSxhQUFhO0FBQ1gsVUFBTXpFLE9BQU8sS0FBS3dCO0FBQ2xCLFNBQUtqRyxVQUFTO0FBQ2QsU0FBS21KLFdBQVU7QUFDZjFFLFNBQUtzRCxXQUFXdkQsVUFBVUMsS0FBS2tCLFFBQVFsQixJQUFJO0FBQzNDLFNBQUsyRSxZQUFXO0FBRWhCLFFBQUksS0FBS3BJLFFBQVFxSSxRQUFRLENBQUMsS0FBSzdQLE1BQU04UCxnQkFBZ0IsUUFBUSxHQUFHO0FBQzlEQyxjQUFRQyxLQUFLLG9LQUFvSztJQUNsTDtFQUNGO0VBRURDLFlBQVl6RixjQUFjO0FBQ3hCLFFBQUksS0FBS04sVUFBVU0sY0FBYztBQUMvQnNELGtCQUFZLEtBQUtyQixXQUFXO0lBQzdCO0FBQ0QsU0FBS3ZDLFFBQVFNO0VBQ2Q7RUFFRG1GLGFBQWE7QUFDWCxVQUFNM1AsUUFBUSxLQUFLQTtBQUNuQixVQUFNaUwsT0FBTyxLQUFLd0I7QUFDbEIsVUFBTWdCLFVBQVUsS0FBS3lDLFdBQVU7QUFFL0IsVUFBTUMsV0FBVyxDQUFDdEQsTUFBTTVELEdBQUdDLEdBQUdPLE1BQU1vRCxTQUFTLE1BQU01RCxJQUFJNEQsU0FBUyxNQUFNcEQsSUFBSVA7QUFFMUUsVUFBTWtILE1BQU1uRixLQUFLb0YsVUFBVUMsZUFBZTdDLFFBQVE0QyxTQUFTbkQsZ0JBQWdCbE4sT0FBTyxHQUFHLENBQUM7QUFDdEYsVUFBTXVRLE1BQU10RixLQUFLdUYsVUFBVUYsZUFBZTdDLFFBQVErQyxTQUFTdEQsZ0JBQWdCbE4sT0FBTyxHQUFHLENBQUM7QUFDdEYsVUFBTXlRLE1BQU14RixLQUFLeUYsVUFBVUosZUFBZTdDLFFBQVFpRCxTQUFTeEQsZ0JBQWdCbE4sT0FBTyxHQUFHLENBQUM7QUFDdEYsVUFBTTJRLFlBQVkxRixLQUFLMEY7QUFDdkIsVUFBTUMsTUFBTTNGLEtBQUs0RixVQUFVVixTQUFTUSxXQUFXUCxLQUFLRyxLQUFLRSxHQUFHO0FBQzVELFVBQU1LLE1BQU03RixLQUFLOEYsVUFBVVosU0FBU1EsV0FBV0osS0FBS0gsS0FBS0ssR0FBRztBQUM1RHhGLFNBQUtsQyxTQUFTLEtBQUtpSSxjQUFjWixHQUFHO0FBQ3BDbkYsU0FBS2pDLFNBQVMsS0FBS2dJLGNBQWNULEdBQUc7QUFDcEN0RixTQUFLZ0csU0FBUyxLQUFLRCxjQUFjUCxHQUFHO0FBQ3BDeEYsU0FBSzBCLFNBQVMsS0FBS3FFLGNBQWNKLEdBQUc7QUFDcEMzRixTQUFLa0IsU0FBUyxLQUFLNkUsY0FBY0YsR0FBRztFQUNyQztFQUVEWixhQUFhO0FBQ1gsV0FBTyxLQUFLbFEsTUFBTTZLLEtBQUtxRyxTQUFTLEtBQUtoSDtFQUN0QztFQUVEMEUsVUFBVTtBQUNSLFdBQU8sS0FBSzVPLE1BQU1tUixlQUFlLEtBQUtqSCxLQUFLO0VBQzVDO0VBTUQ4RyxjQUFjSSxTQUFTO0FBQ3JCLFdBQU8sS0FBS3BSLE1BQU1tTixPQUFPaUU7RUFDMUI7RUFLREMsZUFBZTVJLE9BQU87QUFDcEIsVUFBTXdDLE9BQU8sS0FBS3dCO0FBQ2xCLFdBQU9oRSxVQUFVd0MsS0FBSzBCLFNBQ2xCMUIsS0FBS2tCLFNBQ0xsQixLQUFLMEI7RUFDVjtFQUVEMkUsUUFBUTtBQUNOLFNBQUtuUSxRQUFRLE9BQU87RUFDckI7RUFLRG9RLFdBQVc7QUFDVCxVQUFNdEcsT0FBTyxLQUFLd0I7QUFDbEIsUUFBSSxLQUFLc0MsT0FBTztBQUNkeUMsMEJBQW9CLEtBQUt6QyxPQUFPLElBQUk7SUFDckM7QUFDRCxRQUFJOUQsS0FBS3NELFVBQVU7QUFDakJULGtCQUFZN0MsSUFBSTtJQUNqQjtFQUNGO0VBS0R3RyxhQUFhO0FBQ1gsVUFBTWhFLFVBQVUsS0FBS3lDLFdBQVU7QUFDL0IsVUFBTXJGLE9BQU80QyxRQUFRNUMsU0FBUzRDLFFBQVE1QyxPQUFPLENBQUE7QUFDN0MsVUFBTWtFLFFBQVEsS0FBS0E7QUFNbkIsUUFBSXRJLFNBQVNvRSxJQUFJLEdBQUc7QUFDbEIsV0FBS2tFLFFBQVFuRSx5QkFBeUJDLElBQUk7SUFDM0MsV0FBVWtFLFVBQVVsRSxNQUFNO0FBQ3pCLFVBQUlrRSxPQUFPO0FBRVR5Qyw0QkFBb0J6QyxPQUFPLElBQUk7QUFFL0IsY0FBTTlELE9BQU8sS0FBS3dCO0FBQ2xCcUIsb0JBQVk3QyxJQUFJO0FBQ2hCQSxhQUFLOEMsVUFBVSxDQUFBO01BQ2hCO0FBQ0QsVUFBSWxELFFBQVFsRSxPQUFPK0ssYUFBYTdHLElBQUksR0FBRztBQUNyQzhHLDBCQUFrQjlHLE1BQU0sSUFBSTtNQUM3QjtBQUNELFdBQUswRSxZQUFZLENBQUE7QUFDakIsV0FBS1IsUUFBUWxFO0lBQ2Q7RUFDRjtFQUVEK0UsY0FBYztBQUNaLFVBQU0zRSxPQUFPLEtBQUt3QjtBQUVsQixTQUFLZ0YsV0FBVTtBQUVmLFFBQUksS0FBS2pDLG9CQUFvQjtBQUMzQnZFLFdBQUt3QyxVQUFVLElBQUksS0FBSytCLG1CQUFrQjtJQUMzQztFQUNGO0VBRURvQyxzQkFBc0JDLGtCQUFrQjtBQUN0QyxVQUFNNUcsT0FBTyxLQUFLd0I7QUFDbEIsVUFBTWdCLFVBQVUsS0FBS3lDLFdBQVU7QUFDL0IsUUFBSTRCLGVBQWU7QUFFbkIsU0FBS0wsV0FBVTtBQUdmLFVBQU1NLGFBQWE5RyxLQUFLc0Q7QUFDeEJ0RCxTQUFLc0QsV0FBV3ZELFVBQVVDLEtBQUtrQixRQUFRbEIsSUFBSTtBQUczQyxRQUFJQSxLQUFLYixVQUFVcUQsUUFBUXJELE9BQU87QUFDaEMwSCxxQkFBZTtBQUVmaEUsa0JBQVk3QyxJQUFJO0FBQ2hCQSxXQUFLYixRQUFRcUQsUUFBUXJEO0lBQ3RCO0FBSUQsU0FBSzRILGdCQUFnQkgsZ0JBQWdCO0FBR3JDLFFBQUlDLGdCQUFnQkMsZUFBZTlHLEtBQUtzRCxVQUFVO0FBQ2hEakMsbUJBQWEsTUFBTXJCLEtBQUs4QyxPQUFPO0lBQ2hDO0VBQ0Y7RUFNRHZILFlBQVk7QUFDVixVQUFNSCxTQUFTLEtBQUtyRyxNQUFNcUc7QUFDMUIsVUFBTTRMLFlBQVk1TCxPQUFPNkwsaUJBQWlCLEtBQUtyRCxLQUFLO0FBQ3BELFVBQU1zRCxTQUFTOUwsT0FBTytMLGdCQUFnQixLQUFLbEMsV0FBVSxHQUFJK0IsV0FBVyxJQUFJO0FBQ3hFLFNBQUt6SyxVQUFVbkIsT0FBT2dNLGVBQWVGLFFBQVEsS0FBS0csV0FBVSxDQUFFO0FBQzlELFNBQUt4RCxXQUFXLEtBQUt0SCxRQUFRK0s7QUFDN0IsU0FBSzVELGtCQUFrQixDQUFBO0VBQ3hCO0VBTUQ2RCxNQUFNMVIsT0FBTzJSLE9BQU87QUFDbEIsVUFBTSxFQUFDaEcsYUFBYXhCLE1BQU04RCxPQUFPbEUsS0FBSSxJQUFJO0FBQ3pDLFVBQU0sRUFBQzhCLFFBQVE0QixTQUFRLElBQUl0RDtBQUMzQixVQUFNMkIsUUFBUUQsT0FBT0U7QUFFckIsUUFBSTZGLFNBQVM1UixVQUFVLEtBQUsyUixVQUFVNUgsS0FBS3BKLFNBQVMsT0FBT3dKLEtBQUswSDtBQUNoRSxRQUFJQyxPQUFPOVIsUUFBUSxLQUFLbUssS0FBSzhDLFFBQVFqTixRQUFRO0FBQzdDLFFBQUlZLEdBQUdxQixLQUFLeUo7QUFFWixRQUFJLEtBQUtzQyxhQUFhLE9BQU87QUFDM0I3RCxXQUFLOEMsVUFBVWxEO0FBQ2ZJLFdBQUswSCxVQUFVO0FBQ2ZuRyxlQUFTM0I7V0FDSjtBQUNMLFVBQUkxRCxRQUFRMEQsS0FBSy9KLE1BQU0sR0FBRztBQUN4QjBMLGlCQUFTLEtBQUtxRyxlQUFlNUgsTUFBTUosTUFBTS9KLE9BQU8yUixLQUFLO2lCQUM1Q2hNLFNBQVNvRSxLQUFLL0osTUFBTSxHQUFHO0FBQ2hDMEwsaUJBQVMsS0FBS3NHLGdCQUFnQjdILE1BQU1KLE1BQU0vSixPQUFPMlIsS0FBSzthQUNqRDtBQUNMakcsaUJBQVMsS0FBS3VHLG1CQUFtQjlILE1BQU1KLE1BQU0vSixPQUFPMlIsS0FBSztNQUMxRDtBQUVELFlBQU1PLDZCQUE2QixNQUFNalEsSUFBSTZKLFdBQVcsUUFBU2dHLFFBQVE3UCxJQUFJNkosU0FBU2dHLEtBQUtoRztBQUMzRixXQUFLbEwsSUFBSSxHQUFHQSxJQUFJK1EsT0FBTyxFQUFFL1EsR0FBRztBQUMxQnVKLGFBQUs4QyxRQUFRck0sSUFBSVosU0FBU2lDLE1BQU15SixPQUFPOUs7QUFDdkMsWUFBSWdSLFFBQVE7QUFDVixjQUFJTSwyQkFBMEIsR0FBSTtBQUNoQ04scUJBQVM7VUFDVjtBQUNERSxpQkFBTzdQO1FBQ1I7TUFDRjtBQUNEa0ksV0FBSzBILFVBQVVEO0lBQ2hCO0FBRUQsUUFBSW5FLFVBQVU7QUFDWmpDLG1CQUFhLE1BQU1FLE1BQU07SUFDMUI7RUFDRjtFQWFEdUcsbUJBQW1COUgsTUFBTUosTUFBTS9KLE9BQU8yUixPQUFPO0FBQzNDLFVBQU0sRUFBQzlGLFFBQVFSLE9BQU0sSUFBSWxCO0FBQ3pCLFVBQU0yQixRQUFRRCxPQUFPRTtBQUNyQixVQUFNQyxRQUFRWCxPQUFPVTtBQUNyQixVQUFNb0csU0FBU3RHLE9BQU91RyxVQUFTO0FBQy9CLFVBQU1DLGNBQWN4RyxXQUFXUjtBQUMvQixVQUFNSyxTQUFTLElBQUl6QixNQUFNMEgsS0FBSztBQUM5QixRQUFJL1EsR0FBR3VJLE1BQU1DO0FBRWIsU0FBS3hJLElBQUksR0FBR3VJLE9BQU93SSxPQUFPL1EsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDdkN3SSxjQUFReEksSUFBSVo7QUFDWjBMLGFBQU85SyxLQUFLO1FBQ1YsQ0FBQ2tMLFFBQVF1RyxlQUFleEcsT0FBTzZGLE1BQU1TLE9BQU8vSSxRQUFRQSxLQUFLO1FBQ3pELENBQUM0QyxRQUFRWCxPQUFPcUcsTUFBTTNILEtBQUtYLFFBQVFBLEtBQUs7O0lBRTNDO0FBQ0QsV0FBT3NDO0VBQ1I7RUFhRHFHLGVBQWU1SCxNQUFNSixNQUFNL0osT0FBTzJSLE9BQU87QUFDdkMsVUFBTSxFQUFDMUosUUFBUUMsT0FBTSxJQUFJaUM7QUFDekIsVUFBTXVCLFNBQVMsSUFBSXpCLE1BQU0wSCxLQUFLO0FBQzlCLFFBQUkvUSxHQUFHdUksTUFBTUMsT0FBT3RJO0FBRXBCLFNBQUtGLElBQUksR0FBR3VJLE9BQU93SSxPQUFPL1EsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDdkN3SSxjQUFReEksSUFBSVo7QUFDWmMsYUFBT2lKLEtBQUtYO0FBQ1pzQyxhQUFPOUssS0FBSztRQUNWdUgsR0FBR0YsT0FBT3lKLE1BQU01USxLQUFLLElBQUlzSSxLQUFLO1FBQzlCaEIsR0FBR0YsT0FBT3dKLE1BQU01USxLQUFLLElBQUlzSSxLQUFLOztJQUVqQztBQUNELFdBQU9zQztFQUNSO0VBYURzRyxnQkFBZ0I3SCxNQUFNSixNQUFNL0osT0FBTzJSLE9BQU87QUFDeEMsVUFBTSxFQUFDMUosUUFBUUMsT0FBTSxJQUFJaUM7QUFDekIsVUFBTSxFQUFDbUksV0FBVyxLQUFLQyxXQUFXLElBQUcsSUFBSSxLQUFLdkU7QUFDOUMsVUFBTXRDLFNBQVMsSUFBSXpCLE1BQU0wSCxLQUFLO0FBQzlCLFFBQUkvUSxHQUFHdUksTUFBTUMsT0FBT3RJO0FBRXBCLFNBQUtGLElBQUksR0FBR3VJLE9BQU93SSxPQUFPL1EsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDdkN3SSxjQUFReEksSUFBSVo7QUFDWmMsYUFBT2lKLEtBQUtYO0FBQ1pzQyxhQUFPOUssS0FBSztRQUNWdUgsR0FBR0YsT0FBT3lKLE1BQU1jLGlCQUFpQjFSLE1BQU13UixRQUFRLEdBQUdsSixLQUFLO1FBQ3ZEaEIsR0FBR0YsT0FBT3dKLE1BQU1jLGlCQUFpQjFSLE1BQU15UixRQUFRLEdBQUduSixLQUFLOztJQUUxRDtBQUNELFdBQU9zQztFQUNSO0VBS0QrRyxVQUFVckosT0FBTztBQUNmLFdBQU8sS0FBS3VDLFlBQVlzQixRQUFRN0Q7RUFDakM7RUFLRHNKLGVBQWV0SixPQUFPO0FBQ3BCLFdBQU8sS0FBS3VDLFlBQVk1QixLQUFLWDtFQUM5QjtFQUtEQyxXQUFXMUIsT0FBTytELFFBQVFqQyxNQUFNO0FBQzlCLFVBQU12SyxRQUFRLEtBQUtBO0FBQ25CLFVBQU1pTCxPQUFPLEtBQUt3QjtBQUNsQixVQUFNdkUsUUFBUXNFLE9BQU8vRCxNQUFNb0U7QUFDM0IsVUFBTXpDLFFBQVE7TUFDWnhELE1BQU1pRCx3QkFBd0I3SixPQUFPLElBQUk7TUFDekNzSCxRQUFRa0YsT0FBT0UsUUFBUWpFLE1BQU1vRTs7QUFFL0IsV0FBTzFDLFdBQVdDLE9BQU9sQyxPQUFPK0MsS0FBS2YsT0FBTztNQUFDSztJQUFLLENBQUE7RUFDbkQ7RUFLRGtKLHNCQUFzQkMsT0FBT2pMLE9BQU8rRCxRQUFRcEMsT0FBTztBQUNqRCxVQUFNdUosY0FBY25ILE9BQU8vRCxNQUFNb0U7QUFDakMsUUFBSTNFLFFBQVF5TCxnQkFBZ0IsT0FBT0MsTUFBTUQ7QUFDekMsVUFBTXJNLFNBQVM4QyxTQUFTb0MsT0FBT0UsUUFBUWpFLE1BQU1vRTtBQUM3QyxRQUFJekMsU0FBUzlDLFFBQVE7QUFDbkI4QyxZQUFNOUMsU0FBU0E7QUFDZlksY0FBUWlDLFdBQVdDLE9BQU91SixhQUFhLEtBQUtsSCxZQUFZdkMsS0FBSztJQUM5RDtBQUNEd0osVUFBTTdTLE1BQU1ELEtBQUtDLElBQUk2UyxNQUFNN1MsS0FBS3FILEtBQUs7QUFDckN3TCxVQUFNMVEsTUFBTXBDLEtBQUtvQyxJQUFJMFEsTUFBTTFRLEtBQUtrRixLQUFLO0VBQ3RDO0VBS0QyTCxVQUFVcEwsT0FBTzRGLFVBQVU7QUFDekIsVUFBTXBELE9BQU8sS0FBS3dCO0FBQ2xCLFVBQU1zQixVQUFVOUMsS0FBSzhDO0FBQ3JCLFVBQU0yRSxTQUFTekgsS0FBSzBILFdBQVdsSyxVQUFVd0MsS0FBSzBCO0FBQzlDLFVBQU0xQyxPQUFPOEQsUUFBUXRNO0FBQ3JCLFVBQU1xUyxhQUFhLEtBQUt6QyxlQUFlNUksS0FBSztBQUM1QyxVQUFNMkIsUUFBUWdFLFlBQVlDLFVBQVVwRCxNQUFNLEtBQUtqTCxLQUFLO0FBQ3BELFVBQU0wVCxRQUFRO01BQUM3UyxLQUFLNkssT0FBT0U7TUFBbUI1SSxLQUFLMEksT0FBT0M7O0FBQzFELFVBQU0sRUFBQzlLLEtBQUtrVCxVQUFVL1EsS0FBS2dSLFNBQVEsSUFBSXpJLGNBQWN1SSxVQUFVO0FBQy9ELFFBQUlwUyxHQUFHOEs7QUFFUCxhQUFTeUgsUUFBUTtBQUNmekgsZUFBU3VCLFFBQVFyTTtBQUNqQixZQUFNK0ksYUFBYStCLE9BQU9zSCxXQUFXakg7QUFDckMsYUFBTyxDQUFDbkMsZUFBUzhCLE9BQU8vRCxNQUFNb0UsS0FBSyxLQUFLa0gsV0FBV3RKLGNBQWN1SixXQUFXdko7SUFDN0U7QUFFRCxTQUFLL0ksSUFBSSxHQUFHQSxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUN6QixVQUFJdVMsTUFBSyxHQUFJO0FBQ1g7TUFDRDtBQUNELFdBQUtSLHNCQUFzQkMsT0FBT2pMLE9BQU8rRCxRQUFRcEMsS0FBSztBQUN0RCxVQUFJc0ksUUFBUTtBQUVWO01BQ0Q7SUFDRjtBQUNELFFBQUlBLFFBQVE7QUFFVixXQUFLaFIsSUFBSXVJLE9BQU8sR0FBR3ZJLEtBQUssR0FBRyxFQUFFQSxHQUFHO0FBQzlCLFlBQUl1UyxNQUFLLEdBQUk7QUFDWDtRQUNEO0FBQ0QsYUFBS1Isc0JBQXNCQyxPQUFPakwsT0FBTytELFFBQVFwQyxLQUFLO0FBQ3REO01BQ0Q7SUFDRjtBQUNELFdBQU9zSjtFQUNSO0VBRURRLG1CQUFtQnpMLE9BQU87QUFDeEIsVUFBTStELFNBQVMsS0FBS0MsWUFBWXNCO0FBQ2hDLFVBQU16RyxTQUFTLENBQUE7QUFDZixRQUFJNUYsR0FBR3VJLE1BQU0vQjtBQUViLFNBQUt4RyxJQUFJLEdBQUd1SSxPQUFPdUMsT0FBTy9LLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQy9Dd0csY0FBUXNFLE9BQU85SyxHQUFHK0csTUFBTW9FO0FBQ3hCLFVBQUluQyxlQUFTeEMsS0FBSyxHQUFHO0FBQ25CWixlQUFPNUUsS0FBS3dGLEtBQUs7TUFDbEI7SUFDRjtBQUNELFdBQU9aO0VBQ1I7RUFNRDZNLGlCQUFpQjtBQUNmLFdBQU87RUFDUjtFQUtEQyxpQkFBaUJsSyxPQUFPO0FBQ3RCLFVBQU1lLE9BQU8sS0FBS3dCO0FBQ2xCLFVBQU1FLFNBQVMxQixLQUFLMEI7QUFDcEIsVUFBTVIsU0FBU2xCLEtBQUtrQjtBQUNwQixVQUFNSyxTQUFTLEtBQUsrRyxVQUFVckosS0FBSztBQUNuQyxXQUFPO01BQ0xtSyxPQUFPMUgsU0FBUyxLQUFLQSxPQUFPMkgsaUJBQWlCOUgsT0FBT0csT0FBT0UsS0FBSyxJQUFJO01BQ3BFM0UsT0FBT2lFLFNBQVMsS0FBS0EsT0FBT21JLGlCQUFpQjlILE9BQU9MLE9BQU9VLEtBQUssSUFBSTs7RUFFdkU7RUFLRDFMLFFBQVFvSixNQUFNO0FBQ1osVUFBTVUsT0FBTyxLQUFLd0I7QUFDbEIsU0FBSy9HLE9BQU82RSxRQUFRLFNBQVM7QUFDN0JVLFNBQUtzSixRQUFRaEwsT0FBTytHLGVBQWUsS0FBSzlJLFFBQVFnTixNQUFNMUwsWUFBWW1DLEtBQUtsQyxRQUFRa0MsS0FBS2pDLFFBQVEsS0FBS21MLGVBQWMsQ0FBRSxDQUFDLENBQUM7RUFDcEg7RUFLRHpPLE9BQU82RSxNQUFNO0VBQUE7RUFFYjVJLE9BQU87QUFDTCxVQUFNK00sTUFBTSxLQUFLRDtBQUNqQixVQUFNek8sUUFBUSxLQUFLQTtBQUNuQixVQUFNaUwsT0FBTyxLQUFLd0I7QUFDbEIsVUFBTWdJLFdBQVd4SixLQUFLSixRQUFRLENBQUE7QUFDOUIsVUFBTTZKLE9BQU8xVSxNQUFNMlU7QUFDbkIsVUFBTWxQLFNBQVMsQ0FBQTtBQUNmLFVBQU0zRSxRQUFRLEtBQUtvTyxjQUFjO0FBQ2pDLFVBQU11RCxRQUFRLEtBQUt0RCxjQUFlc0YsU0FBU2hULFNBQVNYO0FBQ3BELFVBQU04VCwwQkFBMEIsS0FBS3BOLFFBQVFvTjtBQUM3QyxRQUFJbFQ7QUFFSixRQUFJdUosS0FBS3dDLFNBQVM7QUFDaEJ4QyxXQUFLd0MsUUFBUTlMLEtBQUsrTSxLQUFLZ0csTUFBTTVULE9BQU8yUixLQUFLO0lBQzFDO0FBRUQsU0FBSy9RLElBQUlaLE9BQU9ZLElBQUlaLFFBQVEyUixPQUFPLEVBQUUvUSxHQUFHO0FBQ3RDLFlBQU1pTSxVQUFVOEcsU0FBUy9TO0FBQ3pCLFVBQUlpTSxRQUFRVyxRQUFRO0FBQ2xCO01BQ0Q7QUFDRCxVQUFJWCxRQUFRbEksVUFBVW1QLHlCQUF5QjtBQUM3Q25QLGVBQU8vQyxLQUFLaUwsT0FBTzthQUNkO0FBQ0xBLGdCQUFRaE0sS0FBSytNLEtBQUtnRyxJQUFJO01BQ3ZCO0lBQ0Y7QUFFRCxTQUFLaFQsSUFBSSxHQUFHQSxJQUFJK0QsT0FBT2hFLFFBQVEsRUFBRUMsR0FBRztBQUNsQytELGFBQU8vRCxHQUFHQyxLQUFLK00sS0FBS2dHLElBQUk7SUFDekI7RUFDRjtFQVNERyxTQUFTM0ssT0FBT3pFLFFBQVE7QUFDdEIsVUFBTThFLE9BQU85RSxTQUFTLFdBQVc7QUFDakMsV0FBT3lFLFVBQVVwSyxVQUFhLEtBQUsyTSxZQUFZZ0IsVUFDM0MsS0FBS3FILDZCQUE2QnZLLElBQUksSUFDdEMsS0FBS3dLLDBCQUEwQjdLLFNBQVMsR0FBR0ssSUFBSTtFQUNwRDtFQUtEK0gsV0FBV3BJLE9BQU96RSxRQUFROEUsTUFBTTtBQUM5QixVQUFNa0QsVUFBVSxLQUFLeUMsV0FBVTtBQUMvQixRQUFJOEU7QUFDSixRQUFJOUssU0FBUyxLQUFLQSxRQUFRLEtBQUt1QyxZQUFZNUIsS0FBS3BKLFFBQVE7QUFDdEQsWUFBTWtNLFVBQVUsS0FBS2xCLFlBQVk1QixLQUFLWDtBQUN0QzhLLGdCQUFVckgsUUFBUTJCLGFBQ2YzQixRQUFRMkIsV0FBVzVCLGtCQUFrQixLQUFLNEUsV0FBVSxHQUFJcEksT0FBT3lELE9BQU87QUFDekVxSCxjQUFReEksU0FBUyxLQUFLK0csVUFBVXJKLEtBQUs7QUFDckM4SyxjQUFRbkgsTUFBTUosUUFBUTVDLEtBQUtYO0FBQzNCOEssY0FBUTlLLFFBQVE4SyxRQUFRcEgsWUFBWTFEO1dBQy9CO0FBQ0w4SyxnQkFBVSxLQUFLMUYsYUFDWixLQUFLQSxXQUFXaEMscUJBQXFCLEtBQUt0TixNQUFNc1MsV0FBVSxHQUFJLEtBQUtwSSxLQUFLO0FBQzNFOEssY0FBUXZILFVBQVVBO0FBQ2xCdUgsY0FBUTlLLFFBQVE4SyxRQUFReEssZUFBZSxLQUFLTjtJQUM3QztBQUVEOEssWUFBUXZQLFNBQVMsQ0FBQyxDQUFDQTtBQUNuQnVQLFlBQVF6SyxPQUFPQTtBQUNmLFdBQU95SztFQUNSO0VBTURGLDZCQUE2QnZLLE1BQU07QUFDakMsV0FBTyxLQUFLMEssdUJBQXVCLEtBQUt6RixtQkFBbUJsRSxJQUFJZixJQUFJO0VBQ3BFO0VBT0R3SywwQkFBMEI3SyxPQUFPSyxNQUFNO0FBQ3JDLFdBQU8sS0FBSzBLLHVCQUF1QixLQUFLeEYsZ0JBQWdCbkUsSUFBSWYsTUFBTUwsS0FBSztFQUN4RTtFQUtEK0ssdUJBQXVCQyxhQUFhM0ssT0FBTyxXQUFXTCxPQUFPO0FBQzNELFVBQU16RSxTQUFTOEUsU0FBUztBQUN4QixVQUFNNEssUUFBUSxLQUFLeEc7QUFDbkIsVUFBTXlHLFdBQVdGLGNBQWMsTUFBTTNLO0FBQ3JDLFVBQU0yRCxTQUFTaUgsTUFBTUM7QUFDckIsVUFBTUMsVUFBVSxLQUFLakcsdUJBQXVCa0csUUFBUXBMLEtBQUs7QUFDekQsUUFBSWdFLFFBQVE7QUFDVixhQUFPRCxpQkFBaUJDLFFBQVFtSCxPQUFPO0lBQ3hDO0FBQ0QsVUFBTWhQLFNBQVMsS0FBS3JHLE1BQU1xRztBQUMxQixVQUFNNEwsWUFBWTVMLE9BQU9rUCx3QkFBd0IsS0FBSzFHLE9BQU9xRyxXQUFXO0FBQ3hFLFVBQU1NLFdBQVcvUCxTQUFTO01BQUMsR0FBR3lQO01BQW9CO01BQVNBO01BQWE7UUFBTTtNQUFDQTtNQUFhOztBQUM1RixVQUFNL0MsU0FBUzlMLE9BQU8rTCxnQkFBZ0IsS0FBS2xDLFdBQVUsR0FBSStCLFNBQVM7QUFDbEUsVUFBTXdELFNBQVE5TyxPQUFPQyxLQUFLQyxTQUFTNE4sU0FBU1MsWUFBWTtBQUd4RCxVQUFNRixVQUFVLE1BQU0sS0FBSzFDLFdBQVdwSSxPQUFPekUsTUFBTTtBQUNuRCxVQUFNNkIsU0FBU2pCLE9BQU9xUCxvQkFBb0J2RCxRQUFRc0QsUUFBT1QsU0FBU1EsUUFBUTtBQUUxRSxRQUFJbE8sT0FBT00sU0FBUztBQUdsQk4sYUFBT00sVUFBVXlOO0FBS2pCRixZQUFNQyxZQUFZek8sT0FBT2dQLE9BQU8xSCxpQkFBaUIzRyxRQUFRK04sT0FBTyxDQUFDO0lBQ2xFO0FBRUQsV0FBTy9OO0VBQ1I7RUFNRHNPLG1CQUFtQjFMLE9BQU8yTCxZQUFZcFEsUUFBUTtBQUM1QyxVQUFNekYsUUFBUSxLQUFLQTtBQUNuQixVQUFNbVYsUUFBUSxLQUFLeEc7QUFDbkIsVUFBTXlHLFdBQVcsYUFBYVM7QUFDOUIsVUFBTTNILFNBQVNpSCxNQUFNQztBQUNyQixRQUFJbEgsUUFBUTtBQUNWLGFBQU9BO0lBQ1I7QUFDRCxRQUFJMUc7QUFDSixRQUFJeEgsTUFBTXdILFFBQVFWLGNBQWMsT0FBTztBQUNyQyxZQUFNVCxTQUFTLEtBQUtyRyxNQUFNcUc7QUFDMUIsWUFBTTRMLFlBQVk1TCxPQUFPeVAsMEJBQTBCLEtBQUtqSCxPQUFPZ0gsVUFBVTtBQUN6RSxZQUFNMUQsU0FBUzlMLE9BQU8rTCxnQkFBZ0IsS0FBS2xDLFdBQVUsR0FBSStCLFNBQVM7QUFDbEV6SyxnQkFBVW5CLE9BQU9nTSxlQUFlRixRQUFRLEtBQUtHLFdBQVdwSSxPQUFPekUsUUFBUW9RLFVBQVUsQ0FBQztJQUNuRjtBQUNELFVBQU1uTyxhQUFhLElBQUl0QixXQUFXcEcsT0FBT3dILFdBQVdBLFFBQVFFLFVBQVU7QUFDdEUsUUFBSUYsV0FBV0EsUUFBUXVPLFlBQVk7QUFDakNaLFlBQU1DLFlBQVl6TyxPQUFPZ1AsT0FBT2pPLFVBQVU7SUFDM0M7QUFDRCxXQUFPQTtFQUNSO0VBTURzTyxpQkFBaUJ4TyxTQUFTO0FBQ3hCLFFBQUksQ0FBQ0EsUUFBUUksU0FBUztBQUNwQjtJQUNEO0FBQ0QsV0FBTyxLQUFLcUgsbUJBQW1CLEtBQUtBLGlCQUFpQnRJLE9BQU95QixPQUFPLENBQUEsR0FBSVosT0FBTztFQUMvRTtFQU1EeU8sZUFBZTFMLE1BQU0yTCxlQUFlO0FBQ2xDLFdBQU8sQ0FBQ0EsaUJBQWlCbEksbUJBQW1CekQsSUFBSSxLQUFLLEtBQUt2SyxNQUFNbVc7RUFDakU7RUFLREMsa0JBQWtCdFYsT0FBT3lKLE1BQU07QUFDN0IsVUFBTThMLFlBQVksS0FBS3RCLDBCQUEwQmpVLE9BQU95SixJQUFJO0FBQzVELFVBQU0rTCwwQkFBMEIsS0FBS3JIO0FBQ3JDLFVBQU1pSCxnQkFBZ0IsS0FBS0YsaUJBQWlCSyxTQUFTO0FBQ3JELFVBQU1KLGlCQUFpQixLQUFLQSxlQUFlMUwsTUFBTTJMLGFBQWEsS0FBTUEsa0JBQWtCSTtBQUN0RixTQUFLQyxvQkFBb0JMLGVBQWUzTCxNQUFNOEwsU0FBUztBQUN2RCxXQUFPO01BQUNIO01BQWVEOztFQUN4QjtFQU1ETyxjQUFjN0ksU0FBU3pELE9BQU85QyxZQUFZbUQsTUFBTTtBQUM5QyxRQUFJeUQsbUJBQW1CekQsSUFBSSxHQUFHO0FBQzVCNUQsYUFBT3lCLE9BQU91RixTQUFTdkcsVUFBVTtXQUM1QjtBQUNMLFdBQUt3TyxtQkFBbUIxTCxPQUFPSyxJQUFJLEVBQUU3RSxPQUFPaUksU0FBU3ZHLFVBQVU7SUFDaEU7RUFDRjtFQU1EbVAsb0JBQW9CTCxlQUFlM0wsTUFBTWhELFlBQVk7QUFDbkQsUUFBSTJPLGlCQUFpQixDQUFDbEksbUJBQW1CekQsSUFBSSxHQUFHO0FBQzlDLFdBQUtxTCxtQkFBbUI5VixRQUFXeUssSUFBSSxFQUFFN0UsT0FBT3dRLGVBQWUzTyxVQUFVO0lBQzFFO0VBQ0Y7RUFLRGtQLFVBQVU5SSxTQUFTekQsT0FBT0ssTUFBTTlFLFFBQVE7QUFDdENrSSxZQUFRbEksU0FBU0E7QUFDakIsVUFBTStCLFVBQVUsS0FBS3FOLFNBQVMzSyxPQUFPekUsTUFBTTtBQUMzQyxTQUFLbVEsbUJBQW1CMUwsT0FBT0ssTUFBTTlFLE1BQU0sRUFBRUMsT0FBT2lJLFNBQVM7TUFHM0RuRyxTQUFVLENBQUMvQixVQUFVLEtBQUt1USxpQkFBaUJ4TyxPQUFPLEtBQU1BO0lBQ3pELENBQUE7RUFDRjtFQUVEa1AsaUJBQWlCL0ksU0FBU25ELGNBQWNOLE9BQU87QUFDN0MsU0FBS3VNLFVBQVU5SSxTQUFTekQsT0FBTyxVQUFVLEtBQUs7RUFDL0M7RUFFRHlNLGNBQWNoSixTQUFTbkQsY0FBY04sT0FBTztBQUMxQyxTQUFLdU0sVUFBVTlJLFNBQVN6RCxPQUFPLFVBQVUsSUFBSTtFQUM5QztFQUtEME0sMkJBQTJCO0FBQ3pCLFVBQU1qSixVQUFVLEtBQUtsQixZQUFZZ0I7QUFFakMsUUFBSUUsU0FBUztBQUNYLFdBQUs4SSxVQUFVOUksU0FBUzdOLFFBQVcsVUFBVSxLQUFLO0lBQ25EO0VBQ0Y7RUFLRCtXLHdCQUF3QjtBQUN0QixVQUFNbEosVUFBVSxLQUFLbEIsWUFBWWdCO0FBRWpDLFFBQUlFLFNBQVM7QUFDWCxXQUFLOEksVUFBVTlJLFNBQVM3TixRQUFXLFVBQVUsSUFBSTtJQUNsRDtFQUNGO0VBS0RrUyxnQkFBZ0JILGtCQUFrQjtBQUNoQyxVQUFNaEgsT0FBTyxLQUFLa0U7QUFDbEIsVUFBTTBGLFdBQVcsS0FBS2hJLFlBQVk1QjtBQUdsQyxlQUFXLENBQUMxRSxRQUFRMlEsTUFBTUMsSUFBSSxLQUFLLEtBQUt4SCxXQUFXO0FBQ2pELFdBQUtwSixRQUFRMlEsTUFBTUMsSUFBSTtJQUN4QjtBQUNELFNBQUt4SCxZQUFZLENBQUE7QUFFakIsVUFBTXlILFVBQVV2QyxTQUFTaFQ7QUFDekIsVUFBTXdWLFVBQVVwTSxLQUFLcEo7QUFDckIsVUFBTWdSLFFBQVE3UixLQUFLQyxJQUFJb1csU0FBU0QsT0FBTztBQUV2QyxRQUFJdkUsT0FBTztBQUtULFdBQUtELE1BQU0sR0FBR0MsS0FBSztJQUNwQjtBQUVELFFBQUl3RSxVQUFVRCxTQUFTO0FBQ3JCLFdBQUtFLGdCQUFnQkYsU0FBU0MsVUFBVUQsU0FBU25GLGdCQUFnQjtJQUNsRSxXQUFVb0YsVUFBVUQsU0FBUztBQUM1QixXQUFLRyxnQkFBZ0JGLFNBQVNELFVBQVVDLE9BQU87SUFDaEQ7RUFDRjtFQUtEQyxnQkFBZ0JwVyxPQUFPMlIsT0FBT1osbUJBQW1CLE1BQU07QUFDckQsVUFBTTVHLE9BQU8sS0FBS3dCO0FBQ2xCLFVBQU01QixPQUFPSSxLQUFLSjtBQUNsQixVQUFNaEMsTUFBTS9ILFFBQVEyUjtBQUNwQixRQUFJL1E7QUFFSixVQUFNMFYsT0FBTyxDQUFDQyxRQUFRO0FBQ3BCQSxVQUFJNVYsVUFBVWdSO0FBQ2QsV0FBSy9RLElBQUkyVixJQUFJNVYsU0FBUyxHQUFHQyxLQUFLbUgsS0FBS25ILEtBQUs7QUFDdEMyVixZQUFJM1YsS0FBSzJWLElBQUkzVixJQUFJK1E7TUFDbEI7O0FBRUgyRSxTQUFLdk0sSUFBSTtBQUVULFNBQUtuSixJQUFJWixPQUFPWSxJQUFJbUgsS0FBSyxFQUFFbkgsR0FBRztBQUM1Qm1KLFdBQUtuSixLQUFLLElBQUksS0FBSytOLGdCQUFlO0lBQ25DO0FBRUQsUUFBSSxLQUFLWCxVQUFVO0FBQ2pCc0ksV0FBS25NLEtBQUs4QyxPQUFPO0lBQ2xCO0FBQ0QsU0FBS3lFLE1BQU0xUixPQUFPMlIsS0FBSztBQUV2QixRQUFJWixrQkFBa0I7QUFDcEIsV0FBS3lGLGVBQWV6TSxNQUFNL0osT0FBTzJSLE9BQU8sT0FBTztJQUNoRDtFQUNGO0VBRUQ2RSxlQUFlM0osU0FBUzdNLE9BQU8yUixPQUFPbEksTUFBTTtFQUFBO0VBSzVDNE0sZ0JBQWdCclcsT0FBTzJSLE9BQU87QUFDNUIsVUFBTXhILE9BQU8sS0FBS3dCO0FBQ2xCLFFBQUksS0FBS3FDLFVBQVU7QUFDakIsWUFBTXlJLFVBQVV0TSxLQUFLOEMsUUFBUXlKLE9BQU8xVyxPQUFPMlIsS0FBSztBQUNoRCxVQUFJeEgsS0FBS3NELFVBQVU7QUFDakJULG9CQUFZN0MsTUFBTXNNLE9BQU87TUFDMUI7SUFDRjtBQUNEdE0sU0FBS0osS0FBSzJNLE9BQU8xVyxPQUFPMlIsS0FBSztFQUM5QjtFQUtEZ0YsTUFBTUMsTUFBTTtBQUNWLFFBQUksS0FBSzVJLFVBQVU7QUFDakIsV0FBS1MsVUFBVTdNLEtBQUtnVixJQUFJO1dBQ25CO0FBQ0wsWUFBTSxDQUFDdlIsUUFBUTJRLE1BQU1DLElBQUksSUFBSVc7QUFDN0IsV0FBS3ZSLFFBQVEyUSxNQUFNQyxJQUFJO0lBQ3hCO0FBQ0QsU0FBSy9XLE1BQU0yWCxhQUFhalYsS0FBSztNQUFDLEtBQUt3SDtTQUFVd047SUFBSyxDQUFBO0VBQ25EO0VBRURFLGNBQWM7QUFDWixVQUFNbkYsUUFBUW9GLFVBQVVwVztBQUN4QixTQUFLZ1csTUFBTTtNQUFDO01BQW1CLEtBQUt2SCxXQUFVLEVBQUdyRixLQUFLcEosU0FBU2dSO01BQU9BO0lBQU0sQ0FBQTtFQUM3RTtFQUVEcUYsYUFBYTtBQUNYLFNBQUtMLE1BQU07TUFBQztNQUFtQixLQUFLaEwsWUFBWTVCLEtBQUtwSixTQUFTO01BQUk7SUFBQyxDQUFBO0VBQ3BFO0VBRURzVyxlQUFlO0FBQ2IsU0FBS04sTUFBTTtNQUFDO01BQW9CO01BQUc7SUFBQyxDQUFBO0VBQ3JDO0VBRURPLGNBQWNsWCxPQUFPMlIsT0FBTztBQUMxQixRQUFJQSxPQUFPO0FBQ1QsV0FBS2dGLE1BQU07UUFBQztRQUFtQjNXO1FBQU8yUjtNQUFNLENBQUE7SUFDN0M7QUFDRCxVQUFNd0YsV0FBV0osVUFBVXBXLFNBQVM7QUFDcEMsUUFBSXdXLFVBQVU7QUFDWixXQUFLUixNQUFNO1FBQUM7UUFBbUIzVztRQUFPbVg7TUFBUyxDQUFBO0lBQ2hEO0VBQ0Y7RUFFREMsaUJBQWlCO0FBQ2YsU0FBS1QsTUFBTTtNQUFDO01BQW9CO01BQUVJLFVBQVVwVztJQUFPLENBQUE7RUFDcEQ7O0FBbjBCRCxjQUxtQitNLG1CQUtaM0gsWUFBVyxDQUFBO0FBS2xCLGNBVm1CMkgsbUJBVVpnQixzQkFBcUI7QUFLNUIsY0FmbUJoQixtQkFlWmlCLG1CQUFrQjtBQ2xPM0IsU0FBUzBJLGtCQUFrQjFQLE9BQU90SSxNQUFNO0FBQ3RDLE1BQUksQ0FBQ3NJLE1BQU0yUCxPQUFPQyxNQUFNO0FBQ3RCLFVBQU1DLGVBQWU3UCxNQUFNNEQsd0JBQXdCbE0sSUFBSTtBQUN2RCxRQUFJbUgsU0FBUyxDQUFBO0FBRWIsYUFBUzVGLElBQUksR0FBR3VJLE9BQU9xTyxhQUFhN1csUUFBUUMsSUFBSXVJLE1BQU12SSxLQUFLO0FBQ3pENEYsZUFBU0EsT0FBT2lSLE9BQU9ELGFBQWE1VyxHQUFHNkssV0FBVzJILG1CQUFtQnpMLEtBQUssQ0FBQztJQUM1RTtBQUNEQSxVQUFNMlAsT0FBT0MsT0FBT0csYUFBYWxSLE9BQU9tUixLQUFLLENBQUNDLEdBQUdoUCxNQUFNZ1AsSUFBSWhQLENBQUMsQ0FBQztFQUM5RDtBQUNELFNBQU9qQixNQUFNMlAsT0FBT0M7QUFDckI7QUFNRCxTQUFTTSxxQkFBcUIxTixNQUFNO0FBQ2xDLFFBQU14QyxRQUFRd0MsS0FBSzBCO0FBQ25CLFFBQU1yRixTQUFTNlEsa0JBQWtCMVAsT0FBT3dDLEtBQUs5SyxJQUFJO0FBQ2pELE1BQUlVLE1BQU00SCxNQUFNbVE7QUFDaEIsTUFBSWxYLEdBQUd1SSxNQUFNNE8sTUFBTWpHO0FBQ25CLFFBQU1rRyxtQkFBbUIsTUFBTTtBQUM3QixRQUFJRCxTQUFTLFNBQVNBLFNBQVMsUUFBUTtBQUVyQztJQUNEO0FBQ0QsUUFBSXZELFFBQVExQyxJQUFJLEdBQUc7QUFFakIvUixZQUFNRCxLQUFLQyxJQUFJQSxLQUFLRCxLQUFLbVksSUFBSUYsT0FBT2pHLElBQUksS0FBSy9SLEdBQUc7SUFDakQ7QUFDRCtSLFdBQU9pRzs7QUFHVCxPQUFLblgsSUFBSSxHQUFHdUksT0FBTzNDLE9BQU83RixRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUMvQ21YLFdBQU9wUSxNQUFNdVEsaUJBQWlCMVIsT0FBTzVGLEVBQUU7QUFDdkNvWCxxQkFBZ0I7RUFDakI7QUFFRGxHLFNBQU85UztBQUNQLE9BQUs0QixJQUFJLEdBQUd1SSxPQUFPeEIsTUFBTXdRLE1BQU14WCxRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUNwRG1YLFdBQU9wUSxNQUFNeVEsZ0JBQWdCeFgsQ0FBQztBQUM5Qm9YLHFCQUFnQjtFQUNqQjtBQUVELFNBQU9qWTtBQUNSO0FBUUQsU0FBU3NZLHlCQUF5QmpQLE9BQU9rUCxPQUFPNVIsU0FBUzZSLFlBQVk7QUFDbkUsUUFBTUMsWUFBWTlSLFFBQVErUjtBQUMxQixNQUFJcFIsTUFBTXFSO0FBRVYsTUFBSUMsY0FBY0gsU0FBUyxHQUFHO0FBQzVCblIsV0FBT2lSLE1BQU12WSxNQUFNMkcsUUFBUWtTO0FBQzNCRixZQUFRaFMsUUFBUW1TO1NBQ1g7QUFJTHhSLFdBQU9tUixZQUFZRDtBQUNuQkcsWUFBUTtFQUNUO0FBRUQsU0FBTztJQUNMSSxPQUFPelIsT0FBT2tSO0lBQ2RHO0lBQ0ExWSxPQUFPc1ksTUFBTVMsT0FBTzNQLFNBQVUvQixPQUFPOztBQUV4QztBQVFELFNBQVMyUiwwQkFBMEI1UCxPQUFPa1AsT0FBTzVSLFNBQVM2UixZQUFZO0FBQ3BFLFFBQU1RLFNBQVNULE1BQU1TO0FBQ3JCLFFBQU1oQixPQUFPZ0IsT0FBTzNQO0FBQ3BCLE1BQUkwSSxPQUFPMUksUUFBUSxJQUFJMlAsT0FBTzNQLFFBQVEsS0FBSztBQUMzQyxNQUFJNlAsT0FBTzdQLFFBQVEyUCxPQUFPcFksU0FBUyxJQUFJb1ksT0FBTzNQLFFBQVEsS0FBSztBQUMzRCxRQUFNOFAsVUFBVXhTLFFBQVFrUztBQUV4QixNQUFJOUcsU0FBUyxNQUFNO0FBR2pCQSxXQUFPaUcsUUFBUWtCLFNBQVMsT0FBT1gsTUFBTXZRLE1BQU11USxNQUFNdFksUUFBUWlaLE9BQU9sQjtFQUNqRTtBQUVELE1BQUlrQixTQUFTLE1BQU07QUFFakJBLFdBQU9sQixPQUFPQSxPQUFPakc7RUFDdEI7QUFFRCxRQUFNOVIsUUFBUStYLFFBQVFBLE9BQU9qWSxLQUFLQyxJQUFJK1IsTUFBTW1ILElBQUksS0FBSyxJQUFJQztBQUN6RCxRQUFNN1IsT0FBT3ZILEtBQUttWSxJQUFJZ0IsT0FBT25ILElBQUksSUFBSSxJQUFJb0g7QUFFekMsU0FBTztJQUNMSixPQUFPelIsT0FBT2tSO0lBQ2RHLE9BQU9oUyxRQUFRbVM7SUFDZjdZOztBQUVIO0FBRUQsU0FBU21aLGNBQWNDLE9BQU90WSxNQUFNdUssUUFBUXpLLEdBQUc7QUFDN0MsUUFBTXlZLGFBQWFoTyxPQUFPcUcsTUFBTTBILE1BQU0sSUFBSXhZLENBQUM7QUFDM0MsUUFBTTBZLFdBQVdqTyxPQUFPcUcsTUFBTTBILE1BQU0sSUFBSXhZLENBQUM7QUFDekMsUUFBTWIsTUFBTUQsS0FBS0MsSUFBSXNaLFlBQVlDLFFBQVE7QUFDekMsUUFBTXBYLE1BQU1wQyxLQUFLb0MsSUFBSW1YLFlBQVlDLFFBQVE7QUFDekMsTUFBSUMsV0FBV3haO0FBQ2YsTUFBSXlaLFNBQVN0WDtBQUViLE1BQUlwQyxLQUFLbVksSUFBSWxZLEdBQUcsSUFBSUQsS0FBS21ZLElBQUkvVixHQUFHLEdBQUc7QUFDakNxWCxlQUFXclg7QUFDWHNYLGFBQVN6WjtFQUNWO0FBSURlLE9BQUt1SyxPQUFPVSxRQUFReU47QUFFcEIxWSxPQUFLMlksVUFBVTtJQUNiRjtJQUNBQztJQUNBeFosT0FBT3FaO0lBQ1B0UixLQUFLdVI7SUFDTHZaO0lBQ0FtQzs7QUFFSDtBQUVELFNBQVN3WCxXQUFXTixPQUFPdFksTUFBTXVLLFFBQVF6SyxHQUFHO0FBQzFDLE1BQUl5RixRQUFRK1MsS0FBSyxHQUFHO0FBQ2xCRCxrQkFBY0MsT0FBT3RZLE1BQU11SyxRQUFRekssQ0FBQztTQUMvQjtBQUNMRSxTQUFLdUssT0FBT1UsUUFBUVYsT0FBT3FHLE1BQU0wSCxPQUFPeFksQ0FBQztFQUMxQztBQUNELFNBQU9FO0FBQ1I7QUFFRCxTQUFTNlksc0JBQXNCeFAsTUFBTUosTUFBTS9KLE9BQU8yUixPQUFPO0FBQ3ZELFFBQU05RixTQUFTMUIsS0FBSzBCO0FBQ3BCLFFBQU1SLFNBQVNsQixLQUFLa0I7QUFDcEIsUUFBTThHLFNBQVN0RyxPQUFPdUcsVUFBUztBQUMvQixRQUFNQyxjQUFjeEcsV0FBV1I7QUFDL0IsUUFBTUssU0FBUyxDQUFBO0FBQ2YsTUFBSTlLLEdBQUd1SSxNQUFNckksTUFBTXNZO0FBRW5CLE9BQUt4WSxJQUFJWixPQUFPbUosT0FBT25KLFFBQVEyUixPQUFPL1EsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDbkR3WSxZQUFRclAsS0FBS25KO0FBQ2JFLFdBQU8sQ0FBQTtBQUNQQSxTQUFLK0ssT0FBT0UsUUFBUXNHLGVBQWV4RyxPQUFPNkYsTUFBTVMsT0FBT3ZSLElBQUlBLENBQUM7QUFDNUQ4SyxXQUFPOUosS0FBSzhYLFdBQVdOLE9BQU90WSxNQUFNdUssUUFBUXpLLENBQUMsQ0FBQztFQUMvQztBQUNELFNBQU84SztBQUNSO0FBRUQsU0FBU2tPLFdBQVdDLFFBQVE7QUFDMUIsU0FBT0EsVUFBVUEsT0FBT04sYUFBYXZhLFVBQWE2YSxPQUFPTCxXQUFXeGE7QUFDckU7QUFFRCxTQUFTOGEsUUFBUXpTLE1BQU1nRSxRQUFRME8sWUFBWTtBQUN6QyxNQUFJMVMsU0FBUyxHQUFHO0FBQ2QsV0FBT3dDLEtBQUt4QyxJQUFJO0VBQ2pCO0FBQ0QsVUFBUWdFLE9BQU8yTyxhQUFZLElBQUssSUFBSSxPQUFPM08sT0FBT3RMLE9BQU9nYSxhQUFhLElBQUk7QUFDM0U7QUFFRCxTQUFTRSxZQUFZM1QsWUFBWTtBQUMvQixNQUFJd0IsU0FBUzlILE9BQU8rSCxLQUFLTSxLQUFLRTtBQUM5QixNQUFJakMsV0FBVzRULFlBQVk7QUFDekJwUyxjQUFVeEIsV0FBVzZULE9BQU83VCxXQUFXNkI7QUFDdkNuSSxZQUFRO0FBQ1IrSCxVQUFNO1NBQ0Q7QUFDTEQsY0FBVXhCLFdBQVc2VCxPQUFPN1QsV0FBVzhCO0FBQ3ZDcEksWUFBUTtBQUNSK0gsVUFBTTtFQUNQO0FBQ0QsTUFBSUQsU0FBUztBQUNYTyxVQUFNO0FBQ05FLGFBQVM7U0FDSjtBQUNMRixVQUFNO0FBQ05FLGFBQVM7RUFDVjtBQUNELFNBQU87SUFBQ3ZJO0lBQU8rSDtJQUFLRDtJQUFTTztJQUFLRTs7QUFDbkM7QUFFRCxTQUFTNlIsaUJBQWlCOVQsWUFBWUksU0FBUzRDLE9BQU9GLE9BQU87QUFDM0QsTUFBSWlSLE9BQU8zVCxRQUFRNFQ7QUFDbkIsUUFBTXBWLE1BQU0sQ0FBQTtBQUVaLE1BQUksQ0FBQ21WLE1BQU07QUFDVC9ULGVBQVdnVSxnQkFBZ0JwVjtBQUMzQjtFQUNEO0FBRUQsTUFBSW1WLFNBQVMsTUFBTTtBQUNqQi9ULGVBQVdnVSxnQkFBZ0I7TUFBQ2pTLEtBQUs7TUFBTUMsT0FBTztNQUFNQyxRQUFRO01BQU1DLE1BQU07O0FBQ3hFO0VBQ0Q7QUFFRCxRQUFNLEVBQUN4SSxPQUFPK0gsS0FBS0QsU0FBU08sS0FBS0UsT0FBTSxJQUFJMFIsWUFBWTNULFVBQVU7QUFFakUsTUFBSStULFNBQVMsWUFBWS9RLE9BQU87QUFDOUJoRCxlQUFXaVUscUJBQXFCO0FBQ2hDLFNBQUtqUixNQUFNNEMsUUFBUSxPQUFPOUMsT0FBTztBQUMvQmlSLGFBQU9oUztnQkFDR2lCLE1BQU02QyxXQUFXLE9BQU8vQyxPQUFPO0FBQ3pDaVIsYUFBTzlSO1dBQ0Y7QUFDTHJELFVBQUlzVixVQUFValMsUUFBUXZJLE9BQU8rSCxLQUFLRCxPQUFPLEtBQUs7QUFDOUN1UyxhQUFPaFM7SUFDUjtFQUNGO0FBRURuRCxNQUFJc1YsVUFBVUgsTUFBTXJhLE9BQU8rSCxLQUFLRCxPQUFPLEtBQUs7QUFDNUN4QixhQUFXZ1UsZ0JBQWdCcFY7QUFDNUI7QUFFRCxTQUFTc1YsVUFBVUgsTUFBTXpDLEdBQUdoUCxHQUFHZCxTQUFTO0FBQ3RDLE1BQUlBLFNBQVM7QUFDWHVTLFdBQU9JLEtBQUtKLE1BQU16QyxHQUFHaFAsQ0FBQztBQUN0QnlSLFdBQU9LLFNBQVNMLE1BQU16UixHQUFHZ1AsQ0FBQztTQUNyQjtBQUNMeUMsV0FBT0ssU0FBU0wsTUFBTXpDLEdBQUdoUCxDQUFDO0VBQzNCO0FBQ0QsU0FBT3lSO0FBQ1I7QUFFRCxTQUFTSSxLQUFLRSxNQUFNQyxJQUFJQyxJQUFJO0FBQzFCLFNBQU9GLFNBQVNDLEtBQUtDLEtBQUtGLFNBQVNFLEtBQUtELEtBQUtEO0FBQzlDO0FBRUQsU0FBU0QsU0FBU0ksR0FBRzlhLE9BQU8rSCxLQUFLO0FBQy9CLFNBQU8rUyxNQUFNLFVBQVU5YSxRQUFROGEsTUFBTSxRQUFRL1MsTUFBTStTO0FBQ3BEO0FBRUQsU0FBU0MsaUJBQWlCelUsWUFBWSxFQUFDMFUsY0FBYSxHQUFHdEMsT0FBTztBQUM1RHBTLGFBQVcwVSxnQkFBZ0JBLGtCQUFrQixTQUN6Q3RDLFVBQVUsSUFBSSxPQUFPLElBQ3JCc0M7QUFDTDtBQUVjLElBQU1DLGdCQUFOLGNBQTRCdk4sa0JBQWlCO0VBZ0QxRHVFLG1CQUFtQjlILE1BQU1KLE1BQU0vSixPQUFPMlIsT0FBTztBQUMzQyxXQUFPZ0ksc0JBQXNCeFAsTUFBTUosTUFBTS9KLE9BQU8yUixLQUFLO0VBQ3REO0VBT0RJLGVBQWU1SCxNQUFNSixNQUFNL0osT0FBTzJSLE9BQU87QUFDdkMsV0FBT2dJLHNCQUFzQnhQLE1BQU1KLE1BQU0vSixPQUFPMlIsS0FBSztFQUN0RDtFQU9ESyxnQkFBZ0I3SCxNQUFNSixNQUFNL0osT0FBTzJSLE9BQU87QUFDeEMsVUFBTSxFQUFDOUYsUUFBUVIsT0FBTSxJQUFJbEI7QUFDekIsVUFBTSxFQUFDbUksV0FBVyxLQUFLQyxXQUFXLElBQUcsSUFBSSxLQUFLdkU7QUFDOUMsVUFBTWtOLFdBQVdyUCxPQUFPRSxTQUFTLE1BQU11RyxXQUFXQztBQUNsRCxVQUFNNEksV0FBVzlQLE9BQU9VLFNBQVMsTUFBTXVHLFdBQVdDO0FBQ2xELFVBQU03RyxTQUFTLENBQUE7QUFDZixRQUFJOUssR0FBR3VJLE1BQU1ySSxNQUFNc2E7QUFDbkIsU0FBS3hhLElBQUlaLE9BQU9tSixPQUFPbkosUUFBUTJSLE9BQU8vUSxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUNuRHdhLFlBQU1yUixLQUFLbko7QUFDWEUsYUFBTyxDQUFBO0FBQ1BBLFdBQUsrSyxPQUFPRSxRQUFRRixPQUFPNkYsTUFBTWMsaUJBQWlCNEksS0FBS0YsUUFBUSxHQUFHdGEsQ0FBQztBQUNuRThLLGFBQU85SixLQUFLOFgsV0FBV2xILGlCQUFpQjRJLEtBQUtELFFBQVEsR0FBR3JhLE1BQU11SyxRQUFRekssQ0FBQyxDQUFDO0lBQ3pFO0FBQ0QsV0FBTzhLO0VBQ1I7RUFLRGlILHNCQUFzQkMsT0FBT2pMLE9BQU8rRCxRQUFRcEMsT0FBTztBQUNqRCxVQUFNcUosc0JBQXNCQyxPQUFPakwsT0FBTytELFFBQVFwQyxLQUFLO0FBQ3ZELFVBQU11USxTQUFTbk8sT0FBTytOO0FBQ3RCLFFBQUlJLFVBQVVsUyxVQUFVLEtBQUtnRSxZQUFZTixRQUFRO0FBRS9DdUgsWUFBTTdTLE1BQU1ELEtBQUtDLElBQUk2UyxNQUFNN1MsS0FBSzhaLE9BQU85WixHQUFHO0FBQzFDNlMsWUFBTTFRLE1BQU1wQyxLQUFLb0MsSUFBSTBRLE1BQU0xUSxLQUFLMlgsT0FBTzNYLEdBQUc7SUFDM0M7RUFDRjtFQU1EbVIsaUJBQWlCO0FBQ2YsV0FBTztFQUNSO0VBS0RDLGlCQUFpQmxLLE9BQU87QUFDdEIsVUFBTWUsT0FBTyxLQUFLd0I7QUFDbEIsVUFBTSxFQUFDRSxRQUFRUixPQUFNLElBQUlsQjtBQUN6QixVQUFNdUIsU0FBUyxLQUFLK0csVUFBVXJKLEtBQUs7QUFDbkMsVUFBTXlRLFNBQVNuTyxPQUFPK047QUFDdEIsVUFBTXJTLFFBQVF3UyxXQUFXQyxNQUFNLElBQzNCLE1BQU1BLE9BQU83WixRQUFRLE9BQU82WixPQUFPOVIsTUFBTSxNQUN6QyxLQUFLc0QsT0FBT21JLGlCQUFpQjlILE9BQU9MLE9BQU9VLEtBQUs7QUFFcEQsV0FBTztNQUNMd0gsT0FBTyxLQUFLMUgsT0FBTzJILGlCQUFpQjlILE9BQU9HLE9BQU9FLEtBQUs7TUFDdkQzRTs7RUFFSDtFQUVEd0gsYUFBYTtBQUNYLFNBQUtOLHNCQUFzQjtBQUUzQixVQUFNTSxXQUFVO0FBRWhCLFVBQU16RSxPQUFPLEtBQUt3QjtBQUNsQnhCLFNBQUtiLFFBQVEsS0FBSzhGLFdBQVUsRUFBRzlGO0VBQ2hDO0VBRUQxRSxPQUFPNkUsTUFBTTtBQUNYLFVBQU1VLE9BQU8sS0FBS3dCO0FBQ2xCLFNBQUs2SyxlQUFlck0sS0FBS0osTUFBTSxHQUFHSSxLQUFLSixLQUFLcEosUUFBUThJLElBQUk7RUFDekQ7RUFFRCtNLGVBQWU2RSxNQUFNcmIsT0FBTzJSLE9BQU9sSSxNQUFNO0FBQ3ZDLFVBQU0rRyxTQUFRL0csU0FBUztBQUN2QixVQUFNLEVBQUNMLE9BQU91QyxhQUFhLEVBQUNOLE9BQU0sRUFBQyxJQUFJO0FBQ3ZDLFVBQU04TyxPQUFPOU8sT0FBT2lRLGFBQVk7QUFDaEMsVUFBTXBCLGFBQWE3TyxPQUFPMk8sYUFBWTtBQUN0QyxVQUFNMUIsUUFBUSxLQUFLaUQsVUFBUztBQUM1QixVQUFNLEVBQUNuRyxlQUFlRCxlQUFjLElBQUksS0FBS0csa0JBQWtCdFYsT0FBT3lKLElBQUk7QUFFMUUsYUFBUzdJLElBQUlaLE9BQU9ZLElBQUlaLFFBQVEyUixPQUFPL1EsS0FBSztBQUMxQyxZQUFNOEssU0FBUyxLQUFLK0csVUFBVTdSLENBQUM7QUFDL0IsWUFBTTRhLFVBQVVoTCxVQUFTbUksY0FBY2pOLE9BQU9MLE9BQU9VLEtBQUssSUFBSTtRQUFDb087UUFBTXNCLE1BQU10QjtNQUFLLElBQUcsS0FBS3VCLHlCQUF5QjlhLENBQUM7QUFDbEgsWUFBTSthLFVBQVUsS0FBS0MseUJBQXlCaGIsR0FBRzBYLEtBQUs7QUFDdEQsWUFBTWhQLFNBQVNvQyxPQUFPRSxXQUFXLENBQUEsR0FBSVAsT0FBT1U7QUFFNUMsWUFBTXpGLGFBQWE7UUFDakI0VDtRQUNBQyxNQUFNcUIsUUFBUXJCO1FBQ2RJLG9CQUFvQixDQUFDalIsU0FBU3NRLFdBQVdsTyxPQUFPK04sT0FBTyxLQUFNclEsVUFBVUUsTUFBTTRDLFFBQVE5QyxVQUFVRSxNQUFNNkM7UUFDckdoRSxHQUFHK1IsYUFBYXNCLFFBQVFDLE9BQU9FLFFBQVFFO1FBQ3ZDelQsR0FBRzhSLGFBQWF5QixRQUFRRSxTQUFTTCxRQUFRQztRQUN6Q0ssUUFBUTVCLGFBQWF5QixRQUFRdFUsT0FBT3ZILEtBQUttWSxJQUFJdUQsUUFBUW5VLElBQUk7UUFDekQwVSxPQUFPN0IsYUFBYXBhLEtBQUttWSxJQUFJdUQsUUFBUW5VLElBQUksSUFBSXNVLFFBQVF0VTs7QUFHdkQsVUFBSThOLGdCQUFnQjtBQUNsQjdPLG1CQUFXSSxVQUFVME8saUJBQWlCLEtBQUtuQiwwQkFBMEJyVCxHQUFHeWEsS0FBS3phLEdBQUcrRCxTQUFTLFdBQVc4RSxJQUFJO01BQ3pHO0FBQ0QsWUFBTS9DLFVBQVVKLFdBQVdJLFdBQVcyVSxLQUFLemEsR0FBRzhGO0FBQzlDMFQsdUJBQWlCOVQsWUFBWUksU0FBUzRDLE9BQU9GLEtBQUs7QUFDbEQyUix1QkFBaUJ6VSxZQUFZSSxTQUFTNFIsTUFBTUksS0FBSztBQUNqRCxXQUFLaEQsY0FBYzJGLEtBQUt6YSxJQUFJQSxHQUFHMEYsWUFBWW1ELElBQUk7SUFDaEQ7RUFDRjtFQVNEdVMsV0FBV0MsTUFBTW5QLFdBQVc7QUFDMUIsVUFBTSxFQUFDakIsT0FBTSxJQUFJLEtBQUtGO0FBQ3RCLFVBQU0xQyxXQUFXNEMsT0FBT04sd0JBQXdCLEtBQUt3QyxLQUFLLEVBQ3ZEekIsT0FBT25DLENBQUFBLFNBQVFBLEtBQUtzQixXQUFXL0UsUUFBUXdWLE9BQU87QUFDakQsVUFBTTlSLFVBQVV5QixPQUFPbkYsUUFBUTBEO0FBQy9CLFVBQU1ZLFNBQVMsQ0FBQTtBQUVmLFVBQU1tUixXQUFXLENBQUNoUyxTQUFTO0FBQ3pCLFlBQU11QixTQUFTdkIsS0FBS3NCLFdBQVdnSCxVQUFVM0YsU0FBUztBQUNsRCxZQUFNc1AsTUFBTTFRLFVBQVVBLE9BQU92QixLQUFLa0IsT0FBT1U7QUFFekMsVUFBSTRNLGNBQWN5RCxHQUFHLEtBQUtDLE1BQU1ELEdBQUcsR0FBRztBQUNwQyxlQUFPO01BQ1I7O0FBR0gsZUFBV2pTLFFBQVFsQixVQUFVO0FBQzNCLFVBQUk2RCxjQUFjOU4sVUFBYW1kLFNBQVNoUyxJQUFJLEdBQUc7QUFDN0M7TUFDRDtBQU9ELFVBQUlDLFlBQVksU0FBU1ksT0FBT3NSLFFBQVFuUyxLQUFLYixLQUFLLE1BQU0sTUFDekRjLFlBQVlwTCxVQUFhbUwsS0FBS2IsVUFBVXRLLFFBQVk7QUFDakRnTSxlQUFPcEosS0FBS3VJLEtBQUtiLEtBQUs7TUFDdkI7QUFDRCxVQUFJYSxLQUFLZixVQUFVNlMsTUFBTTtBQUN2QjtNQUNEO0lBQ0Y7QUFLRCxRQUFJLENBQUNqUixPQUFPckssUUFBUTtBQUNsQnFLLGFBQU9wSixLQUFLNUMsTUFBUztJQUN0QjtBQUVELFdBQU9nTTtFQUNSO0VBTUR1UixlQUFlblQsT0FBTztBQUNwQixXQUFPLEtBQUs0UyxXQUFXaGQsUUFBV29LLEtBQUssRUFBRXpJO0VBQzFDO0VBVUQ2YixlQUFlOVMsY0FBYytTLE9BQU0zUCxXQUFXO0FBQzVDLFVBQU05QixTQUFTLEtBQUtnUixXQUFXdFMsY0FBY29ELFNBQVM7QUFDdEQsVUFBTTFELFFBQVNxVCxVQUFTemQsU0FDcEJnTSxPQUFPc1IsUUFBUUcsS0FBSSxJQUNuQjtBQUVKLFdBQU8sVUFBVyxLQUNkelIsT0FBT3JLLFNBQVMsSUFDaEJ5STtFQUNMO0VBS0RtUyxZQUFZO0FBQ1YsVUFBTTFULE9BQU8sS0FBS25CO0FBQ2xCLFVBQU15RCxPQUFPLEtBQUt3QjtBQUNsQixVQUFNRSxTQUFTMUIsS0FBSzBCO0FBQ3BCLFVBQU1rTixTQUFTLENBQUE7QUFDZixRQUFJblksR0FBR3VJO0FBRVAsU0FBS3ZJLElBQUksR0FBR3VJLE9BQU9nQixLQUFLSixLQUFLcEosUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDbERtWSxhQUFPblgsS0FBS2lLLE9BQU9xTSxpQkFBaUIsS0FBS3pGLFVBQVU3UixDQUFDLEVBQUVpTCxPQUFPRSxPQUFPbkwsQ0FBQyxDQUFDO0lBQ3ZFO0FBRUQsVUFBTTZYLGVBQWU1USxLQUFLNFE7QUFDMUIsVUFBTTFZLE1BQU0wWSxnQkFBZ0JaLHFCQUFxQjFOLElBQUk7QUFFckQsV0FBTztNQUNMcEs7TUFDQWdaO01BQ0EvWSxPQUFPNkwsT0FBTzZRO01BQ2QzVSxLQUFLOEQsT0FBTzhRO01BQ1pwRSxZQUFZLEtBQUtnRSxlQUFjO01BQy9CNVUsT0FBT2tFO01BQ1BxUSxTQUFTclUsS0FBS3FVO01BRWR4RCxPQUFPRCxlQUFlLElBQUk1USxLQUFLK1EscUJBQXFCL1EsS0FBS2dSOztFQUU1RDtFQU1ENkMseUJBQXlCdFMsT0FBTztBQUM5QixVQUFNLEVBQUN1QyxhQUFhLEVBQUNOLFFBQVFvQyxTQUFRLEdBQUcvRyxTQUFTLEVBQUN5VCxNQUFNeUMsV0FBV0MsYUFBWSxFQUFDLElBQUk7QUFDcEYsVUFBTTlDLGFBQWE2QyxhQUFhO0FBQ2hDLFVBQU1sUixTQUFTLEtBQUsrRyxVQUFVckosS0FBSztBQUNuQyxVQUFNeVEsU0FBU25PLE9BQU8rTjtBQUN0QixVQUFNcUQsV0FBV2xELFdBQVdDLE1BQU07QUFDbEMsUUFBSXpTLFFBQVFzRSxPQUFPTCxPQUFPVTtBQUMxQixRQUFJL0wsUUFBUTtBQUNaLFFBQUlXLFNBQVM4TSxXQUFXLEtBQUtwRSxXQUFXZ0MsUUFBUUssUUFBUStCLFFBQVEsSUFBSXJHO0FBQ3BFLFFBQUlxVSxNQUFNcFU7QUFFVixRQUFJMUcsV0FBV3lHLE9BQU87QUFDcEJwSCxjQUFRVyxTQUFTeUc7QUFDakJ6RyxlQUFTeUc7SUFDVjtBQUVELFFBQUkwVixVQUFVO0FBQ1oxVixjQUFReVMsT0FBT047QUFDZjVZLGVBQVNrWixPQUFPTCxTQUFTSyxPQUFPTjtBQUVoQyxVQUFJblMsVUFBVSxLQUFLeUMsS0FBS3pDLEtBQUssTUFBTXlDLEtBQUtnUSxPQUFPTCxNQUFNLEdBQUc7QUFDdER4WixnQkFBUTtNQUNUO0FBQ0RBLGVBQVNvSDtJQUNWO0FBRUQsVUFBTWlTLGFBQWEsQ0FBQ1YsY0FBY2lFLFNBQVMsS0FBSyxDQUFDRSxXQUFXRixZQUFZNWM7QUFDeEUsUUFBSW1hLE9BQU85TyxPQUFPNk0saUJBQWlCbUIsVUFBVTtBQUU3QyxRQUFJLEtBQUtuYSxNQUFNNmQsa0JBQWtCM1QsS0FBSyxHQUFHO0FBQ3ZDcVMsYUFBT3BRLE9BQU82TSxpQkFBaUJsWSxRQUFRVyxNQUFNO1dBQ3hDO0FBRUw4YSxhQUFPdEI7SUFDUjtBQUVEOVMsV0FBT29VLE9BQU90QjtBQUVkLFFBQUlyYSxLQUFLbVksSUFBSTVRLElBQUksSUFBSXdWLGNBQWM7QUFDakN4VixhQUFPeVMsUUFBUXpTLE1BQU1nRSxRQUFRME8sVUFBVSxJQUFJOEM7QUFDM0MsVUFBSXpWLFVBQVUyUyxZQUFZO0FBQ3hCSSxnQkFBUTlTLE9BQU87TUFDaEI7QUFDRCxZQUFNMlYsYUFBYTNSLE9BQU80UixtQkFBbUIsQ0FBQztBQUM5QyxZQUFNQyxXQUFXN1IsT0FBTzRSLG1CQUFtQixDQUFDO0FBQzVDLFlBQU1sZCxNQUFNRCxLQUFLQyxJQUFJaWQsWUFBWUUsUUFBUTtBQUN6QyxZQUFNaGIsTUFBTXBDLEtBQUtvQyxJQUFJOGEsWUFBWUUsUUFBUTtBQUN6Qy9DLGFBQU9yYSxLQUFLb0MsSUFBSXBDLEtBQUtDLElBQUlvYSxNQUFNalksR0FBRyxHQUFHbkMsR0FBRztBQUN4QzBiLGFBQU90QixPQUFPOVM7SUFDZjtBQUVELFFBQUk4UyxTQUFTOU8sT0FBTzZNLGlCQUFpQjZCLFVBQVUsR0FBRztBQUNoRCxZQUFNb0QsV0FBV3RULEtBQUt4QyxJQUFJLElBQUlnRSxPQUFPK1IscUJBQXFCckQsVUFBVSxJQUFJO0FBQ3hFSSxjQUFRZ0Q7QUFDUjlWLGNBQVE4VjtJQUNUO0FBRUQsV0FBTztNQUNMOVY7TUFDQThTO01BQ0FzQjtNQUNBSSxRQUFRSixPQUFPcFUsT0FBTzs7RUFFekI7RUFLRHVVLHlCQUF5QnhTLE9BQU9rUCxPQUFPO0FBQ3JDLFVBQU0zUSxRQUFRMlEsTUFBTTNRO0FBQ3BCLFVBQU1qQixVQUFVLEtBQUtBO0FBQ3JCLFVBQU15VixXQUFXelYsUUFBUXlWO0FBQ3pCLFVBQU1rQixrQkFBa0I3TixlQUFlOUksUUFBUTJXLGlCQUFpQkMsUUFBUTtBQUN4RSxRQUFJekIsUUFBUXhVO0FBQ1osUUFBSWlSLE1BQU00RCxTQUFTO0FBQ2pCLFlBQU0zRCxhQUFhNEQsV0FBVyxLQUFLSSxlQUFlblQsS0FBSyxJQUFJa1AsTUFBTUM7QUFDakUsWUFBTTNGLFFBQVFsTSxRQUFRK1IsaUJBQWlCLFNBQ25DTywwQkFBMEI1UCxPQUFPa1AsT0FBTzVSLFNBQVM2UixVQUFVLElBQzNERix5QkFBeUJqUCxPQUFPa1AsT0FBTzVSLFNBQVM2UixVQUFVO0FBRTlELFlBQU1nRixhQUFhLEtBQUtmLGVBQWUsS0FBS3BULE9BQU8sS0FBS3VDLFlBQVlyQyxPQUFPNlMsV0FBVy9TLFFBQVFwSyxNQUFTO0FBQ3ZHNmMsZUFBU2pKLE1BQU01UyxRQUFTNFMsTUFBTWtHLFFBQVF5RSxhQUFlM0ssTUFBTWtHLFFBQVE7QUFDbkV6UixhQUFPdkgsS0FBS0MsSUFBSXNkLGlCQUFpQnpLLE1BQU1rRyxRQUFRbEcsTUFBTThGLEtBQUs7V0FDckQ7QUFFTG1ELGVBQVNsVSxNQUFNdVEsaUJBQWlCLEtBQUt6RixVQUFVckosS0FBSyxFQUFFekIsTUFBTW9FLE9BQU8zQyxLQUFLO0FBQ3hFL0IsYUFBT3ZILEtBQUtDLElBQUlzZCxpQkFBaUIvRSxNQUFNdlksTUFBTXVZLE1BQU1JLEtBQUs7SUFDekQ7QUFFRCxXQUFPO01BQ0x5QixNQUFNMEIsU0FBU3hVLE9BQU87TUFDdEJvVSxNQUFNSSxTQUFTeFUsT0FBTztNQUN0QndVO01BQ0F4VTs7RUFFSDtFQUVEeEcsT0FBTztBQUNMLFVBQU1zSixPQUFPLEtBQUt3QjtBQUNsQixVQUFNTixTQUFTbEIsS0FBS2tCO0FBQ3BCLFVBQU1tUyxRQUFRclQsS0FBS0o7QUFDbkIsVUFBTVosT0FBT3FVLE1BQU03YztBQUNuQixRQUFJQyxJQUFJO0FBRVIsV0FBT0EsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDcEIsVUFBSSxLQUFLNlIsVUFBVTdSLENBQUMsRUFBRXlLLE9BQU9VLFVBQVUsTUFBTTtBQUMzQ3lSLGNBQU01YyxHQUFHQyxLQUFLLEtBQUs4TSxJQUFJO01BQ3hCO0lBQ0Y7RUFDRjs7QUFyWUQsY0FGbUJzTixlQUVaelEsTUFBSztBQUtaLGNBUG1CeVEsZUFPWmxWLFlBQVc7RUFDaEIySSxvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUVqQmlLLG9CQUFvQjtFQUNwQkMsZUFBZTtFQUNmcUQsU0FBUztFQUVUdFYsWUFBWTtJQUNWNlcsU0FBUztNQUNQcGUsTUFBTTtNQUNOaUgsWUFBWTtRQUFDO1FBQUs7UUFBSztRQUFRO1FBQVM7TUFBUztJQUNsRDtFQUNGOztBQU1ILGNBMUJtQjJVLGVBMEJaeUMsYUFBWTtFQUNqQnJSLFFBQVE7SUFDTnNSLFNBQVM7TUFDUHRlLE1BQU07TUFDTnVlLFFBQVE7TUFDUkMsTUFBTTtRQUNKRCxRQUFRO01BQ1Q7SUFDRjtJQUNERSxTQUFTO01BQ1B6ZSxNQUFNO01BQ04wZSxhQUFhO0lBQ2Q7RUFDRjs7QUUvUkwsU0FBU0Msa0JBQWtCQyxVQUFVQyxlQUFlQyxRQUFRO0FBQzFELE1BQUlDLFNBQVM7QUFDYixNQUFJQyxTQUFTO0FBQ2IsTUFBSUMsVUFBVTtBQUNkLE1BQUlDLFVBQVU7QUFFZCxNQUFJTCxnQkFBZ0JNLEtBQUs7QUFDdkIsVUFBTUMsYUFBYVI7QUFDbkIsVUFBTVMsV0FBV0QsYUFBYVA7QUFDOUIsVUFBTVMsU0FBU0MsS0FBS0MsSUFBSUosVUFBVTtBQUNsQyxVQUFNSyxTQUFTRixLQUFLRyxJQUFJTixVQUFVO0FBQ2xDLFVBQU1PLE9BQU9KLEtBQUtDLElBQUlILFFBQVE7QUFDOUIsVUFBTU8sT0FBT0wsS0FBS0csSUFBSUwsUUFBUTtBQUM5QixVQUFNUSxVQUFVLENBQUNDLE9BQU9DLEdBQUdDLE1BQU1DLGNBQWNILE9BQU9WLFlBQVlDLFVBQVUsSUFBSSxJQUFJLElBQUlFLEtBQUtXLElBQUlILEdBQUdBLElBQUlqQixRQUFRa0IsR0FBR0EsSUFBSWxCLE1BQU07QUFDN0gsVUFBTXFCLFVBQVUsQ0FBQ0wsT0FBT0MsR0FBR0MsTUFBTUMsY0FBY0gsT0FBT1YsWUFBWUMsVUFBVSxJQUFJLElBQUksS0FBS0UsS0FBS2EsSUFBSUwsR0FBR0EsSUFBSWpCLFFBQVFrQixHQUFHQSxJQUFJbEIsTUFBTTtBQUM5SCxVQUFNdUIsT0FBT1IsUUFBUSxHQUFHUCxRQUFRSyxJQUFJO0FBQ3BDLFVBQU1XLE9BQU9ULFFBQVFVLFNBQVNkLFFBQVFHLElBQUk7QUFDMUMsVUFBTVksT0FBT0wsUUFBUU0sSUFBSW5CLFFBQVFLLElBQUk7QUFDckMsVUFBTWUsT0FBT1AsUUFBUU0sS0FBS0YsU0FBU2QsUUFBUUcsSUFBSTtBQUMvQ2IsY0FBVXNCLE9BQU9HLFFBQVE7QUFDekJ4QixjQUFVc0IsT0FBT0ksUUFBUTtBQUN6QnpCLGNBQVUsRUFBRW9CLE9BQU9HLFFBQVE7QUFDM0J0QixjQUFVLEVBQUVvQixPQUFPSSxRQUFRO0VBQzVCO0FBQ0QsU0FBTztJQUFDM0I7SUFBUUM7SUFBUUM7SUFBU0M7O0FBQ2xDO0FBRWMsSUFBTXlCLHFCQUFOLGNBQWlDQyxrQkFBaUI7RUEwRi9EQyxZQUFZQyxPQUFPQyxjQUFjO0FBQy9CLFVBQU1ELE9BQU9DLFlBQVk7QUFFekIsU0FBS0Msc0JBQXNCO0FBQzNCLFNBQUtDLGNBQWNDO0FBQ25CLFNBQUtDLGNBQWNEO0FBQ25CLFNBQUtqQyxVQUFVaUM7QUFDZixTQUFLaEMsVUFBVWdDO0VBQ2hCO0VBRURFLGFBQWE7RUFBQTtFQUtiQyxNQUFNQyxPQUFPQyxPQUFPO0FBQ2xCLFVBQU1DLE9BQU8sS0FBS0MsV0FBVSxFQUFHRDtBQUMvQixVQUFNRSxPQUFPLEtBQUtDO0FBRWxCLFFBQUksS0FBS0MsYUFBYSxPQUFPO0FBQzNCRixXQUFLRyxVQUFVTDtXQUNWO0FBQ0wsVUFBSU0sU0FBUyxDQUFDQyxPQUFNLENBQUNQLEtBQUtPO0FBRTFCLFVBQUlDLFNBQVNSLEtBQUtGLE1BQU0sR0FBRztBQUN6QixjQUFNLEVBQUNXLE1BQU0sUUFBTyxJQUFJLEtBQUtMO0FBQzdCRSxpQkFBUyxDQUFDQyxPQUFNLENBQUNHLGlCQUFpQlYsS0FBS08sS0FBSUUsR0FBRztNQUMvQztBQUVELFVBQUlGLEdBQUdJO0FBQ1AsV0FBS0osSUFBSVQsT0FBT2EsT0FBT2IsUUFBUUMsT0FBT1EsSUFBSUksTUFBTSxFQUFFSixHQUFHO0FBQ25ETCxhQUFLRyxRQUFRRSxLQUFLRCxPQUFPQyxDQUFDO01BQzNCO0lBQ0Y7RUFDRjtFQUtESyxlQUFlO0FBQ2IsV0FBT0MsVUFBVSxLQUFLQyxRQUFRMUQsV0FBVyxFQUFFO0VBQzVDO0VBS0QyRCxvQkFBb0I7QUFDbEIsV0FBT0YsVUFBVSxLQUFLQyxRQUFRekQsYUFBYTtFQUM1QztFQU1EMkQsc0JBQXNCO0FBQ3BCLFFBQUlwQyxNQUFNakI7QUFDVixRQUFJZSxNQUFNLENBQUNmO0FBRVgsYUFBUzRDLElBQUksR0FBR0EsSUFBSSxLQUFLakIsTUFBTVUsS0FBS2lCLFNBQVNDLFFBQVEsRUFBRVgsR0FBRztBQUN4RCxVQUFJLEtBQUtqQixNQUFNNkIsaUJBQWlCWixDQUFDLEtBQUssS0FBS2pCLE1BQU04QixlQUFlYixDQUFDLEVBQUVjLFNBQVMsS0FBS0MsT0FBTztBQUN0RixjQUFNQyxhQUFhLEtBQUtqQyxNQUFNOEIsZUFBZWIsQ0FBQyxFQUFFZ0I7QUFDaEQsY0FBTW5FLFdBQVdtRSxXQUFXWCxhQUFZO0FBQ3hDLGNBQU12RCxnQkFBZ0JrRSxXQUFXUixrQkFBaUI7QUFFbERuQyxjQUFNYixLQUFLYSxJQUFJQSxLQUFLeEIsUUFBUTtBQUM1QnNCLGNBQU1YLEtBQUtXLElBQUlBLEtBQUt0QixXQUFXQyxhQUFhO01BQzdDO0lBQ0Y7QUFFRCxXQUFPO01BQ0xELFVBQVV3QjtNQUNWdkIsZUFBZXFCLE1BQU1FOztFQUV4QjtFQUtENEMsT0FBT0MsTUFBTTtBQUNYLFVBQU1uQyxRQUFRLEtBQUtBO0FBQ25CLFVBQU0sRUFBQ29DLFVBQVMsSUFBSXBDO0FBQ3BCLFVBQU1ZLE9BQU8sS0FBS0M7QUFDbEIsVUFBTXdCLE9BQU96QixLQUFLRjtBQUNsQixVQUFNNEIsVUFBVSxLQUFLQyxrQkFBaUIsSUFBSyxLQUFLQyxhQUFhSCxJQUFJLElBQUksS0FBS2IsUUFBUWM7QUFDbEYsVUFBTUcsVUFBVWhFLEtBQUtXLEtBQUtYLEtBQUthLElBQUk4QyxVQUFVTSxPQUFPTixVQUFVTyxNQUFNLElBQUlMLFdBQVcsR0FBRyxDQUFDO0FBQ3ZGLFVBQU10RSxTQUFTUyxLQUFLYSxJQUFJc0QsYUFBYSxLQUFLcEIsUUFBUXhELFFBQVF5RSxPQUFPLEdBQUcsQ0FBQztBQUNyRSxVQUFNSSxjQUFjLEtBQUtDLGVBQWUsS0FBS0MsS0FBSztBQUtsRCxVQUFNLEVBQUNoRixlQUFlRCxTQUFRLElBQUksS0FBSzRELG9CQUFtQjtBQUMxRCxVQUFNLEVBQUN6RCxRQUFRQyxRQUFRQyxTQUFTQyxRQUFPLElBQUlQLGtCQUFrQkMsVUFBVUMsZUFBZUMsTUFBTTtBQUM1RixVQUFNZ0YsWUFBWVosVUFBVU0sUUFBUUosV0FBV3JFO0FBQy9DLFVBQU1nRixhQUFhYixVQUFVTyxTQUFTTCxXQUFXcEU7QUFDakQsVUFBTWdGLFlBQVl6RSxLQUFLVyxJQUFJWCxLQUFLYSxJQUFJMEQsVUFBVUMsU0FBUyxJQUFJLEdBQUcsQ0FBQztBQUMvRCxVQUFNNUMsY0FBYzhDLFlBQVksS0FBSzNCLFFBQVE0QixRQUFRRixTQUFTO0FBQzlELFVBQU0vQyxjQUFjMUIsS0FBS1csSUFBSWlCLGNBQWNyQyxRQUFRLENBQUM7QUFDcEQsVUFBTXFGLGdCQUFnQmhELGNBQWNGLGVBQWUsS0FBS21ELDhCQUE2QjtBQUNyRixTQUFLbkYsVUFBVUEsVUFBVWtDO0FBQ3pCLFNBQUtqQyxVQUFVQSxVQUFVaUM7QUFFekJPLFNBQUsyQyxRQUFRLEtBQUtDLGVBQWM7QUFFaEMsU0FBS25ELGNBQWNBLGNBQWNnRCxlQUFlLEtBQUtJLHFCQUFxQixLQUFLVixLQUFLO0FBQ3BGLFNBQUs1QyxjQUFjMUIsS0FBS1csSUFBSSxLQUFLaUIsY0FBY2dELGVBQWVSLGFBQWEsQ0FBQztBQUU1RSxTQUFLYSxlQUFlckIsTUFBTSxHQUFHQSxLQUFLVCxRQUFRTyxJQUFJO0VBQy9DO0VBS0R3QixlQUFlMUMsR0FBRzJDLFFBQU87QUFDdkIsVUFBTUMsT0FBTyxLQUFLckM7QUFDbEIsVUFBTVosT0FBTyxLQUFLQztBQUNsQixVQUFNOUMsZ0JBQWdCLEtBQUswRCxrQkFBaUI7QUFDNUMsUUFBSW1DLFVBQVVDLEtBQUtDLFVBQVVDLGlCQUFrQixDQUFDLEtBQUsvRCxNQUFNZ0Usa0JBQWtCL0MsQ0FBQyxLQUFLTCxLQUFLRyxRQUFRRSxPQUFPLFFBQVFMLEtBQUtGLEtBQUtPLEdBQUdnRCxRQUFRO0FBQ2xJLGFBQU87SUFDUjtBQUNELFdBQU8sS0FBS0MsdUJBQXVCdEQsS0FBS0csUUFBUUUsS0FBS2xELGdCQUFnQk0sR0FBRztFQUN6RTtFQUVEcUYsZUFBZXJCLE1BQU03QixPQUFPQyxPQUFPMEIsTUFBTTtBQUN2QyxVQUFNeUIsU0FBUXpCLFNBQVM7QUFDdkIsVUFBTW5DLFFBQVEsS0FBS0E7QUFDbkIsVUFBTW9DLFlBQVlwQyxNQUFNb0M7QUFDeEIsVUFBTXlCLE9BQU83RCxNQUFNd0I7QUFDbkIsVUFBTTJDLGdCQUFnQk4sS0FBS0M7QUFDM0IsVUFBTU0sV0FBV2hDLFVBQVVpQyxPQUFPakMsVUFBVWtDLFNBQVM7QUFDckQsVUFBTUMsV0FBV25DLFVBQVVvQyxNQUFNcEMsVUFBVXFDLFVBQVU7QUFDckQsVUFBTUMsZUFBZWQsVUFBU08sY0FBY087QUFDNUMsVUFBTXZFLGNBQWN1RSxlQUFlLElBQUksS0FBS3ZFO0FBQzVDLFVBQU1FLGNBQWNxRSxlQUFlLElBQUksS0FBS3JFO0FBQzVDLFVBQU0sRUFBQ3NFLGVBQWVDLGVBQWMsSUFBSSxLQUFLQyxrQkFBa0JyRSxPQUFPMkIsSUFBSTtBQUMxRSxRQUFJN0QsYUFBYSxLQUFLZ0QsYUFBWTtBQUNsQyxRQUFJTDtBQUVKLFNBQUtBLElBQUksR0FBR0EsSUFBSVQsT0FBTyxFQUFFUyxHQUFHO0FBQzFCM0Msb0JBQWMsS0FBS3FGLGVBQWUxQyxHQUFHMkMsTUFBSztJQUMzQztBQUVELFNBQUszQyxJQUFJVCxPQUFPUyxJQUFJVCxRQUFRQyxPQUFPLEVBQUVRLEdBQUc7QUFDdEMsWUFBTWxELGdCQUFnQixLQUFLNEYsZUFBZTFDLEdBQUcyQyxNQUFLO0FBQ2xELFlBQU1rQixNQUFNekMsS0FBS3BCO0FBQ2pCLFlBQU04RCxhQUFhO1FBQ2pCQyxHQUFHWixVQUFVLEtBQUtqRztRQUNsQjhHLEdBQUdWLFVBQVUsS0FBS25HO1FBQ2xCRTtRQUNBQyxVQUFVRCxhQUFhUDtRQUN2QkE7UUFDQXNDO1FBQ0FGOztBQUVGLFVBQUl5RSxnQkFBZ0I7QUFDbEJHLG1CQUFXdkQsVUFBVW1ELGlCQUFpQixLQUFLTywwQkFBMEJqRSxHQUFHNkQsSUFBSUssU0FBUyxXQUFXaEQsSUFBSTtNQUNyRztBQUNEN0Qsb0JBQWNQO0FBRWQsV0FBS3FILGNBQWNOLEtBQUs3RCxHQUFHOEQsWUFBWTVDLElBQUk7SUFDNUM7RUFDRjtFQUVEcUIsaUJBQWlCO0FBQ2YsVUFBTTVDLE9BQU8sS0FBS0M7QUFDbEIsVUFBTXdFLFdBQVd6RSxLQUFLRjtBQUN0QixRQUFJNkMsUUFBUTtBQUNaLFFBQUl0QztBQUVKLFNBQUtBLElBQUksR0FBR0EsSUFBSW9FLFNBQVN6RCxRQUFRWCxLQUFLO0FBQ3BDLFlBQU1xRSxRQUFRMUUsS0FBS0csUUFBUUU7QUFDM0IsVUFBSXFFLFVBQVUsUUFBUSxDQUFDQyxNQUFNRCxLQUFLLEtBQUssS0FBS3RGLE1BQU1nRSxrQkFBa0IvQyxDQUFDLEtBQUssQ0FBQ29FLFNBQVNwRSxHQUFHZ0QsUUFBUTtBQUM3RlYsaUJBQVM5RSxLQUFLK0csSUFBSUYsS0FBSztNQUN4QjtJQUNGO0FBRUQsV0FBTy9CO0VBQ1I7RUFFRFcsdUJBQXVCb0IsT0FBTztBQUM1QixVQUFNL0IsUUFBUSxLQUFLMUMsWUFBWTBDO0FBQy9CLFFBQUlBLFFBQVEsS0FBSyxDQUFDZ0MsTUFBTUQsS0FBSyxHQUFHO0FBQzlCLGFBQU9qSCxPQUFPSSxLQUFLK0csSUFBSUYsS0FBSyxJQUFJL0I7SUFDakM7QUFDRCxXQUFPO0VBQ1I7RUFFRGtDLGlCQUFpQjFDLE9BQU87QUFDdEIsVUFBTW5DLE9BQU8sS0FBS0M7QUFDbEIsVUFBTWIsUUFBUSxLQUFLQTtBQUNuQixVQUFNMEYsU0FBUzFGLE1BQU1VLEtBQUtnRixVQUFVLENBQUE7QUFDcEMsVUFBTUosUUFBUUssYUFBYS9FLEtBQUtHLFFBQVFnQyxRQUFRL0MsTUFBTXdCLFFBQVFvRSxNQUFNO0FBRXBFLFdBQU87TUFDTEMsT0FBT0gsT0FBTzNDLFVBQVU7TUFDeEJ1Qzs7RUFFSDtFQUVEL0Msa0JBQWtCRixNQUFNO0FBQ3RCLFFBQUlqRCxNQUFNO0FBQ1YsVUFBTVksUUFBUSxLQUFLQTtBQUNuQixRQUFJaUIsR0FBR0ksTUFBTVQsTUFBTXFCLFlBQVlUO0FBRS9CLFFBQUksQ0FBQ2EsTUFBTTtBQUVULFdBQUtwQixJQUFJLEdBQUdJLE9BQU9yQixNQUFNVSxLQUFLaUIsU0FBU0MsUUFBUVgsSUFBSUksTUFBTSxFQUFFSixHQUFHO0FBQzVELFlBQUlqQixNQUFNNkIsaUJBQWlCWixDQUFDLEdBQUc7QUFDN0JMLGlCQUFPWixNQUFNOEIsZUFBZWIsQ0FBQztBQUM3Qm9CLGlCQUFPekIsS0FBS0Y7QUFDWnVCLHVCQUFhckIsS0FBS3FCO0FBQ2xCO1FBQ0Q7TUFDRjtJQUNGO0FBRUQsUUFBSSxDQUFDSSxNQUFNO0FBQ1QsYUFBTztJQUNSO0FBRUQsU0FBS3BCLElBQUksR0FBR0ksT0FBT2dCLEtBQUtULFFBQVFYLElBQUlJLE1BQU0sRUFBRUosR0FBRztBQUM3Q08sZ0JBQVVTLFdBQVdpRCwwQkFBMEJqRSxDQUFDO0FBQ2hELFVBQUlPLFFBQVFzRSxnQkFBZ0IsU0FBUztBQUNuQzFHLGNBQU1YLEtBQUtXLElBQUlBLEtBQUtvQyxRQUFRdUUsZUFBZSxHQUFHdkUsUUFBUXdFLG9CQUFvQixDQUFDO01BQzVFO0lBQ0Y7QUFDRCxXQUFPNUc7RUFDUjtFQUVEb0QsYUFBYUgsTUFBTTtBQUNqQixRQUFJakQsTUFBTTtBQUVWLGFBQVM2QixJQUFJLEdBQUdJLE9BQU9nQixLQUFLVCxRQUFRWCxJQUFJSSxNQUFNLEVBQUVKLEdBQUc7QUFDakQsWUFBTU8sVUFBVSxLQUFLMEQsMEJBQTBCakUsQ0FBQztBQUNoRDdCLFlBQU1YLEtBQUtXLElBQUlBLEtBQUtvQyxRQUFReUUsVUFBVSxHQUFHekUsUUFBUTBFLGVBQWUsQ0FBQztJQUNsRTtBQUNELFdBQU85RztFQUNSO0VBTURxRSxxQkFBcUJ4RCxjQUFjO0FBQ2pDLFFBQUlrRyxtQkFBbUI7QUFFdkIsYUFBU2xGLElBQUksR0FBR0EsSUFBSWhCLGNBQWMsRUFBRWdCLEdBQUc7QUFDckMsVUFBSSxLQUFLakIsTUFBTTZCLGlCQUFpQlosQ0FBQyxHQUFHO0FBQ2xDa0YsNEJBQW9CLEtBQUtyRCxlQUFlN0IsQ0FBQztNQUMxQztJQUNGO0FBRUQsV0FBT2tGO0VBQ1I7RUFLRHJELGVBQWU3QyxjQUFjO0FBQzNCLFdBQU94QixLQUFLVyxJQUFJZ0gsZUFBZSxLQUFLcEcsTUFBTVUsS0FBS2lCLFNBQVMxQixjQUFjb0csUUFBUSxDQUFDLEdBQUcsQ0FBQztFQUNwRjtFQU1EL0MsZ0NBQWdDO0FBQzlCLFdBQU8sS0FBS0cscUJBQXFCLEtBQUt6RCxNQUFNVSxLQUFLaUIsU0FBU0MsTUFBTSxLQUFLO0VBQ3RFOztBQXBXRCxjQUZtQi9CLG9CQUVaeUcsTUFBSztBQUtaLGNBUG1Cekcsb0JBT1owRyxZQUFXO0VBQ2hCQyxvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUNqQjNDLFdBQVc7SUFFVEMsZUFBZTtJQUVmVyxjQUFjO0VBQ2Y7RUFDRGdDLFlBQVk7SUFDVkMsU0FBUztNQUNQNUUsTUFBTTtNQUNOZ0QsWUFBWTtRQUFDO1FBQWlCO1FBQVk7UUFBZTtRQUFlO1FBQWM7UUFBSztRQUFLO1FBQVU7UUFBZTtNQUFVO0lBQ3BJO0VBQ0Y7RUFFRC9HLFFBQVE7RUFHUkYsVUFBVTtFQUdWQyxlQUFlO0VBR2ZxRixRQUFRO0VBR1JkLFNBQVM7RUFFVHNFLFdBQVc7O0FBR2IsY0F4Q21CL0csb0JBd0NaZ0gsZUFBYztFQUNuQkMsYUFBYSxDQUFDQyxVQUFTQSxVQUFTO0VBQ2hDQyxZQUFZLENBQUNELFVBQVNBLFVBQVM7O0FBTWpDLGNBaERtQmxILG9CQWdEWm9ILGFBQVk7RUFDakJDLGFBQWE7RUFHYkMsU0FBUztJQUNQQyxRQUFRO01BQ04xQixRQUFRO1FBQ04yQixlQUFlckgsT0FBTztBQUNwQixnQkFBTVUsT0FBT1YsTUFBTVU7QUFDbkIsY0FBSUEsS0FBS2dGLE9BQU85RCxVQUFVbEIsS0FBS2lCLFNBQVNDLFFBQVE7QUFDOUMsa0JBQU0sRUFBQzhELFFBQVEsRUFBQzRCLFlBQVlDLE9BQUFBLE9BQUssRUFBQyxJQUFJdkgsTUFBTW9ILE9BQU81RjtBQUVuRCxtQkFBT2QsS0FBS2dGLE9BQU84QixJQUFJLENBQUMzQixPQUFPNUUsTUFBTTtBQUNuQyxvQkFBTUwsT0FBT1osTUFBTThCLGVBQWUsQ0FBQztBQUNuQyxvQkFBTTJGLFFBQVE3RyxLQUFLcUIsV0FBV3lGLFNBQVN6RyxDQUFDO0FBRXhDLHFCQUFPO2dCQUNMMEcsTUFBTTlCO2dCQUNOK0IsV0FBV0gsTUFBTUk7Z0JBQ2pCQyxhQUFhTCxNQUFNTTtnQkFDbkJDLFdBQVdUO2dCQUNYVSxXQUFXUixNQUFNMUI7Z0JBQ2pCdUI7Z0JBQ0FyRCxRQUFRLENBQUNqRSxNQUFNZ0Usa0JBQWtCL0MsQ0FBQztnQkFHbEM4QixPQUFPOUI7O1lBRVYsQ0FBQTtVQUNGO0FBQ0QsaUJBQU8sQ0FBQTtRQUNSO01BQ0Y7TUFFRGlILFFBQVFDLEdBQUdDLFlBQVloQixRQUFRO0FBQzdCQSxlQUFPcEgsTUFBTXFJLHFCQUFxQkQsV0FBV3JGLEtBQUs7QUFDbERxRSxlQUFPcEgsTUFBTWtDLE9BQU07TUFDcEI7SUFDRjtFQUNGOztBR3hIVSxJQUFNb0csZ0JBQU4sY0FBNEJDLG1CQUFrQjs7QUFFM0QsY0FGbUJELGVBRVpFLE1BQUs7QUFLWixjQVBtQkYsZUFPWkcsWUFBVztFQUVoQkMsUUFBUTtFQUdSQyxVQUFVO0VBR1ZDLGVBQWU7RUFHZkMsUUFBUTs7QUcyQ1osU0FBU0MsV0FBd0I7QUFDL0IsUUFBTSxJQUFJQyxNQUFNLGlGQUFpRjtBQUNsRztBQVFELElBQU1DLGtCQUFOLE1BQXFCO0VBWW5CLE9BQU9DLFNBQ0xDLFNBQ0E7QUFDQUMsV0FBT0MsT0FBT0osZ0JBQWdCSyxXQUFXSCxPQUFPO0VBQ2pEO0VBSURJLFlBQVlDLFNBQW9CO0FBQzlCLFNBQUtBLFVBQVVBLFdBQVcsQ0FBQTtFQUMzQjtFQUdEQyxPQUFPO0VBQUE7RUFFUEMsVUFBa0M7QUFDaEMsV0FBT1gsU0FBUTtFQUNoQjtFQUVEWSxRQUF1QjtBQUNyQixXQUFPWixTQUFRO0VBQ2hCO0VBRURhLFNBQWlCO0FBQ2YsV0FBT2IsU0FBUTtFQUNoQjtFQUVEYyxNQUFjO0FBQ1osV0FBT2QsU0FBUTtFQUNoQjtFQUVEZSxPQUFlO0FBQ2IsV0FBT2YsU0FBUTtFQUNoQjtFQUVEZ0IsVUFBa0I7QUFDaEIsV0FBT2hCLFNBQVE7RUFDaEI7RUFFRGlCLFFBQWdCO0FBQ2QsV0FBT2pCLFNBQVE7RUFDaEI7QUFDRjtBQUVELElBQUEsV0FBZTtFQUNia0IsT0FBT2hCOztBQzlHVCxTQUFTaUIsYUFBYUMsU0FBU0MsTUFBTUMsT0FBT0MsV0FBVztBQUNyRCxRQUFNLEVBQUNDLFlBQVlDLE1BQU1DLFFBQU8sSUFBSU47QUFDcEMsUUFBTU8sU0FBU0gsV0FBV0ksWUFBWUQ7QUFDdEMsTUFBSUEsVUFBVU4sU0FBU00sT0FBT04sUUFBUUEsU0FBUyxPQUFPSyxXQUFXRCxLQUFLSSxRQUFRO0FBQzVFLFVBQU1DLGVBQWVILE9BQU9JLGlCQUFpQkMsZ0JBQWdCQztBQUM3RCxRQUFJLENBQUNWLFdBQVc7QUFDZCxhQUFPTyxhQUFhTCxNQUFNSixNQUFNQyxLQUFLO0lBQ3RDLFdBQVVFLFdBQVdVLGdCQUFnQjtBQUlwQyxZQUFNQyxLQUFLVixLQUFLO0FBQ2hCLFlBQU1XLFFBQVEsT0FBT0QsR0FBR0UsYUFBYSxjQUFjRixHQUFHRSxTQUFTaEIsSUFBSTtBQUNuRSxVQUFJZSxPQUFPO0FBQ1QsY0FBTUUsUUFBUVIsYUFBYUwsTUFBTUosTUFBTUMsUUFBUWMsS0FBSztBQUNwRCxjQUFNRyxNQUFNVCxhQUFhTCxNQUFNSixNQUFNQyxRQUFRYyxLQUFLO0FBQ2xELGVBQU87VUFBQ0ksSUFBSUYsTUFBTUU7VUFBSUMsSUFBSUYsSUFBSUU7O01BQy9CO0lBQ0Y7RUFDRjtBQUVELFNBQU87SUFBQ0QsSUFBSTtJQUFHQyxJQUFJaEIsS0FBS0ksU0FBUzs7QUFDbEM7QUFVRCxTQUFTYSx5QkFBeUJDLE9BQU90QixNQUFNdUIsVUFBVUMsU0FBU3RCLFdBQVc7QUFDM0UsUUFBTXVCLFdBQVdILE1BQU1JLDZCQUE0QjtBQUNuRCxRQUFNekIsUUFBUXNCLFNBQVN2QjtBQUN2QixXQUFTMkIsSUFBSSxHQUFHQyxPQUFPSCxTQUFTakIsUUFBUW1CLElBQUlDLE1BQU0sRUFBRUQsR0FBRztBQUNyRCxVQUFNLEVBQUNFLE9BQU96QixLQUFJLElBQUlxQixTQUFTRTtBQUMvQixVQUFNLEVBQUNSLElBQUlDLEdBQUUsSUFBSXRCLGFBQWEyQixTQUFTRSxJQUFJM0IsTUFBTUMsT0FBT0MsU0FBUztBQUNqRSxhQUFTNEIsSUFBSVgsSUFBSVcsS0FBS1YsSUFBSSxFQUFFVSxHQUFHO0FBQzdCLFlBQU1DLFVBQVUzQixLQUFLMEI7QUFDckIsVUFBSSxDQUFDQyxRQUFRQyxNQUFNO0FBQ2pCUixnQkFBUU8sU0FBU0YsT0FBT0MsQ0FBQztNQUMxQjtJQUNGO0VBQ0Y7QUFDRjtBQU9ELFNBQVNHLHlCQUF5QmpDLE1BQU07QUFDdEMsUUFBTWtDLE9BQU9sQyxLQUFLbUMsUUFBUSxHQUFHLE1BQU07QUFDbkMsUUFBTUMsT0FBT3BDLEtBQUttQyxRQUFRLEdBQUcsTUFBTTtBQUVuQyxTQUFPLFNBQVNFLEtBQUtDLEtBQUs7QUFDeEIsVUFBTUMsU0FBU0wsT0FBT00sS0FBS0MsSUFBSUosSUFBSUssSUFBSUosSUFBSUksQ0FBQyxJQUFJO0FBQ2hELFVBQU1DLFNBQVNQLE9BQU9JLEtBQUtDLElBQUlKLElBQUlPLElBQUlOLElBQUlNLENBQUMsSUFBSTtBQUNoRCxXQUFPSixLQUFLSyxLQUFLTCxLQUFLTSxJQUFJUCxRQUFRLENBQUMsSUFBSUMsS0FBS00sSUFBSUgsUUFBUSxDQUFDLENBQUM7O0FBRTdEO0FBV0QsU0FBU0ksa0JBQWtCekIsT0FBT0MsVUFBVXZCLE1BQU1nRCxrQkFBa0JDLGtCQUFrQjtBQUNwRixRQUFNQyxRQUFRLENBQUE7QUFFZCxNQUFJLENBQUNELG9CQUFvQixDQUFDM0IsTUFBTTZCLGNBQWM1QixRQUFRLEdBQUc7QUFDdkQsV0FBTzJCO0VBQ1I7QUFFRCxRQUFNRSxpQkFBaUIsU0FBU3JCLFNBQVNzQixjQUFjeEIsT0FBTztBQUM1RCxRQUFJLENBQUNvQixvQkFBb0IsQ0FBQ0ssZUFBZXZCLFNBQVNULE1BQU1pQyxXQUFXLENBQUMsR0FBRztBQUNyRTtJQUNEO0FBQ0QsUUFBSXhCLFFBQVF5QixRQUFRakMsU0FBU21CLEdBQUduQixTQUFTcUIsR0FBR0ksZ0JBQWdCLEdBQUc7QUFDN0RFLFlBQU1PLEtBQUs7UUFBQzFCO1FBQVNzQjtRQUFjeEI7TUFBTSxDQUFBO0lBQzFDOztBQUdIUiwyQkFBeUJDLE9BQU90QixNQUFNdUIsVUFBVTZCLGdCQUFnQixJQUFJO0FBQ3BFLFNBQU9GO0FBQ1I7QUFVRCxTQUFTUSxzQkFBc0JwQyxPQUFPQyxVQUFVdkIsTUFBTWdELGtCQUFrQjtBQUN0RSxNQUFJRSxRQUFRLENBQUE7QUFFWixXQUFTRSxlQUFlckIsU0FBU3NCLGNBQWN4QixPQUFPO0FBQ3BELFVBQU0sRUFBQzhCLFlBQVlDLFNBQVEsSUFBSTdCLFFBQVE4QixTQUFTO01BQUM7TUFBYztPQUFhYixnQkFBZ0I7QUFDNUYsVUFBTSxFQUFDYyxNQUFLLElBQUlDLGtCQUFrQmhDLFNBQVM7TUFBQ1csR0FBR25CLFNBQVNtQjtNQUFHRSxHQUFHckIsU0FBU3FCO0lBQUUsQ0FBQTtBQUV6RSxRQUFJb0IsY0FBY0YsT0FBT0gsWUFBWUMsUUFBUSxHQUFHO0FBQzlDVixZQUFNTyxLQUFLO1FBQUMxQjtRQUFTc0I7UUFBY3hCO01BQU0sQ0FBQTtJQUMxQztFQUNGO0FBRURSLDJCQUF5QkMsT0FBT3RCLE1BQU11QixVQUFVNkIsY0FBYztBQUM5RCxTQUFPRjtBQUNSO0FBWUQsU0FBU2UseUJBQXlCM0MsT0FBT0MsVUFBVXZCLE1BQU1FLFdBQVc4QyxrQkFBa0JDLGtCQUFrQjtBQUN0RyxNQUFJQyxRQUFRLENBQUE7QUFDWixRQUFNZ0IsaUJBQWlCakMseUJBQXlCakMsSUFBSTtBQUNwRCxNQUFJbUUsY0FBY0MsT0FBT0M7QUFFekIsV0FBU2pCLGVBQWVyQixTQUFTc0IsY0FBY3hCLE9BQU87QUFDcEQsVUFBTTJCLFdBQVV6QixRQUFReUIsUUFBUWpDLFNBQVNtQixHQUFHbkIsU0FBU3FCLEdBQUdJLGdCQUFnQjtBQUN4RSxRQUFJOUMsYUFBYSxDQUFDc0QsVUFBUztBQUN6QjtJQUNEO0FBRUQsVUFBTWMsU0FBU3ZDLFFBQVF3QyxlQUFldkIsZ0JBQWdCO0FBQ3RELFVBQU13QixjQUFjLENBQUMsQ0FBQ3ZCLG9CQUFvQjNCLE1BQU02QixjQUFjbUIsTUFBTTtBQUNwRSxRQUFJLENBQUNFLGVBQWUsQ0FBQ2hCLFVBQVM7QUFDNUI7SUFDRDtBQUVELFVBQU1pQixXQUFXUCxlQUFlM0MsVUFBVStDLE1BQU07QUFDaEQsUUFBSUcsV0FBV04sYUFBYTtBQUMxQmpCLGNBQVE7UUFBQztVQUFDbkI7VUFBU3NCO1VBQWN4QjtRQUFNOztBQUN2Q3NDLG9CQUFjTTtJQUNmLFdBQVVBLGFBQWFOLGFBQWE7QUFFbkNqQixZQUFNTyxLQUFLO1FBQUMxQjtRQUFTc0I7UUFBY3hCO01BQU0sQ0FBQTtJQUMxQztFQUNGO0FBRURSLDJCQUF5QkMsT0FBT3RCLE1BQU11QixVQUFVNkIsY0FBYztBQUM5RCxTQUFPRjtBQUNSO0FBWUQsU0FBU3dCLGdCQUFnQnBELE9BQU9DLFVBQVV2QixNQUFNRSxXQUFXOEMsa0JBQWtCQyxrQkFBa0I7QUFDN0YsTUFBSSxDQUFDQSxvQkFBb0IsQ0FBQzNCLE1BQU02QixjQUFjNUIsUUFBUSxHQUFHO0FBQ3ZELFdBQU8sQ0FBQTtFQUNSO0FBRUQsU0FBT3ZCLFNBQVMsT0FBTyxDQUFDRSxZQUNwQndELHNCQUFzQnBDLE9BQU9DLFVBQVV2QixNQUFNZ0QsZ0JBQWdCLElBQzdEaUIseUJBQXlCM0MsT0FBT0MsVUFBVXZCLE1BQU1FLFdBQVc4QyxrQkFBa0JDLGdCQUFnQjtBQUNsRztBQVdELFNBQVMwQixhQUFhckQsT0FBT0MsVUFBVXZCLE1BQU1FLFdBQVc4QyxrQkFBa0I7QUFDeEUsUUFBTUUsUUFBUSxDQUFBO0FBQ2QsUUFBTTBCLGNBQWM1RSxTQUFTLE1BQU0sYUFBYTtBQUNoRCxNQUFJNkUsaUJBQWlCO0FBRXJCeEQsMkJBQXlCQyxPQUFPdEIsTUFBTXVCLFVBQVUsQ0FBQ1EsU0FBU3NCLGNBQWN4QixVQUFVO0FBQ2hGLFFBQUlFLFFBQVE2QyxhQUFhckQsU0FBU3ZCLE9BQU9nRCxnQkFBZ0IsR0FBRztBQUMxREUsWUFBTU8sS0FBSztRQUFDMUI7UUFBU3NCO1FBQWN4QjtNQUFNLENBQUE7QUFDekNnRCx1QkFBaUJBLGtCQUFrQjlDLFFBQVF5QixRQUFRakMsU0FBU21CLEdBQUduQixTQUFTcUIsR0FBR0ksZ0JBQWdCO0lBQzVGO0VBQ0YsQ0FBQTtBQUlELE1BQUk5QyxhQUFhLENBQUMyRSxnQkFBZ0I7QUFDaEMsV0FBTyxDQUFBO0VBQ1I7QUFDRCxTQUFPM0I7QUFDUjtBQU1ELElBQUEsY0FBZTtFQUViN0I7RUFHQXlELE9BQU87SUFZTGpELE1BQU1QLE9BQU95RCxHQUFHM0YsU0FBUzRELGtCQUFrQjtBQUN6QyxZQUFNekIsV0FBV3lELG9CQUFvQkQsR0FBR3pELEtBQUs7QUFFN0MsWUFBTXRCLE9BQU9aLFFBQVFZLFFBQVE7QUFDN0IsWUFBTWlELG1CQUFtQjdELFFBQVE2RCxvQkFBb0I7QUFDckQsWUFBTUMsUUFBUTlELFFBQVFjLFlBQ2xCNkMsa0JBQWtCekIsT0FBT0MsVUFBVXZCLE1BQU1nRCxrQkFBa0JDLGdCQUFnQixJQUMzRXlCLGdCQUFnQnBELE9BQU9DLFVBQVV2QixNQUFNLE9BQU9nRCxrQkFBa0JDLGdCQUFnQjtBQUNwRixZQUFNZ0MsV0FBVyxDQUFBO0FBRWpCLFVBQUksQ0FBQy9CLE1BQU0xQyxRQUFRO0FBQ2pCLGVBQU8sQ0FBQTtNQUNSO0FBRURjLFlBQU1JLDZCQUE0QixFQUFHd0QsUUFBUSxDQUFDQyxTQUFTO0FBQ3JELGNBQU10RCxRQUFRcUIsTUFBTSxHQUFHckI7QUFDdkIsY0FBTUUsVUFBVW9ELEtBQUsvRSxLQUFLeUI7QUFHMUIsWUFBSUUsV0FBVyxDQUFDQSxRQUFRQyxNQUFNO0FBQzVCaUQsbUJBQVN4QixLQUFLO1lBQUMxQjtZQUFTc0IsY0FBYzhCLEtBQUt0RDtZQUFPQTtVQUFNLENBQUE7UUFDekQ7TUFDRixDQUFBO0FBRUQsYUFBT29EO0lBQ1I7SUFZREcsUUFBUTlELE9BQU95RCxHQUFHM0YsU0FBUzRELGtCQUFrQjtBQUMzQyxZQUFNekIsV0FBV3lELG9CQUFvQkQsR0FBR3pELEtBQUs7QUFDN0MsWUFBTXRCLE9BQU9aLFFBQVFZLFFBQVE7QUFDN0IsWUFBTWlELG1CQUFtQjdELFFBQVE2RCxvQkFBb0I7QUFDckQsVUFBSUMsUUFBUTlELFFBQVFjLFlBQ2hCNkMsa0JBQWtCekIsT0FBT0MsVUFBVXZCLE1BQU1nRCxrQkFBa0JDLGdCQUFnQixJQUM3RXlCLGdCQUFnQnBELE9BQU9DLFVBQVV2QixNQUFNLE9BQU9nRCxrQkFBa0JDLGdCQUFnQjtBQUVsRixVQUFJQyxNQUFNMUMsU0FBUyxHQUFHO0FBQ3BCLGNBQU02QyxlQUFlSCxNQUFNLEdBQUdHO0FBQzlCLGNBQU1qRCxPQUFPa0IsTUFBTStELGVBQWVoQyxZQUFZLEVBQUVqRDtBQUNoRDhDLGdCQUFRLENBQUE7QUFDUixpQkFBU3ZCLElBQUksR0FBR0EsSUFBSXZCLEtBQUtJLFFBQVEsRUFBRW1CLEdBQUc7QUFDcEN1QixnQkFBTU8sS0FBSztZQUFDMUIsU0FBUzNCLEtBQUt1QjtZQUFJMEI7WUFBY3hCLE9BQU9GO1VBQUUsQ0FBQTtRQUN0RDtNQUNGO0FBRUQsYUFBT3VCO0lBQ1I7SUFZRG9DLE1BQU1oRSxPQUFPeUQsR0FBRzNGLFNBQVM0RCxrQkFBa0I7QUFDekMsWUFBTXpCLFdBQVd5RCxvQkFBb0JELEdBQUd6RCxLQUFLO0FBQzdDLFlBQU10QixPQUFPWixRQUFRWSxRQUFRO0FBQzdCLFlBQU1pRCxtQkFBbUI3RCxRQUFRNkQsb0JBQW9CO0FBQ3JELGFBQU9GLGtCQUFrQnpCLE9BQU9DLFVBQVV2QixNQUFNZ0Qsa0JBQWtCQyxnQkFBZ0I7SUFDbkY7SUFXRHNDLFFBQVFqRSxPQUFPeUQsR0FBRzNGLFNBQVM0RCxrQkFBa0I7QUFDM0MsWUFBTXpCLFdBQVd5RCxvQkFBb0JELEdBQUd6RCxLQUFLO0FBQzdDLFlBQU10QixPQUFPWixRQUFRWSxRQUFRO0FBQzdCLFlBQU1pRCxtQkFBbUI3RCxRQUFRNkQsb0JBQW9CO0FBQ3JELGFBQU95QixnQkFBZ0JwRCxPQUFPQyxVQUFVdkIsTUFBTVosUUFBUWMsV0FBVzhDLGtCQUFrQkMsZ0JBQWdCO0lBQ3BHO0lBV0RQLEVBQUVwQixPQUFPeUQsR0FBRzNGLFNBQVM0RCxrQkFBa0I7QUFDckMsWUFBTXpCLFdBQVd5RCxvQkFBb0JELEdBQUd6RCxLQUFLO0FBQzdDLGFBQU9xRCxhQUFhckQsT0FBT0MsVUFBVSxLQUFLbkMsUUFBUWMsV0FBVzhDLGdCQUFnQjtJQUM5RTtJQVdESixFQUFFdEIsT0FBT3lELEdBQUczRixTQUFTNEQsa0JBQWtCO0FBQ3JDLFlBQU16QixXQUFXeUQsb0JBQW9CRCxHQUFHekQsS0FBSztBQUM3QyxhQUFPcUQsYUFBYXJELE9BQU9DLFVBQVUsS0FBS25DLFFBQVFjLFdBQVc4QyxnQkFBZ0I7SUFDOUU7RUFDRjs7QUN0V0gsSUFBTXdDLG1CQUFtQjtFQUFDO0VBQVE7RUFBTztFQUFTOztBQUVsRCxTQUFTQyxpQkFBaUJDLE9BQU9uRSxVQUFVO0FBQ3pDLFNBQU9tRSxNQUFNQyxPQUFPQyxDQUFBQSxNQUFLQSxFQUFFQyxRQUFRdEUsUUFBUTtBQUM1QztBQUVELFNBQVN1RSw0QkFBNEJKLE9BQU8xRixNQUFNO0FBQ2hELFNBQU8wRixNQUFNQyxPQUFPQyxDQUFBQSxNQUFLSixpQkFBaUJyRCxRQUFReUQsRUFBRUMsR0FBRyxNQUFNLE1BQU1ELEVBQUVHLElBQUkvRixTQUFTQSxJQUFJO0FBQ3ZGO0FBRUQsU0FBU2dHLGFBQWFOLE9BQU9PLFNBQVM7QUFDcEMsU0FBT1AsTUFBTVEsS0FBSyxDQUFDQyxHQUFHQyxNQUFNO0FBQzFCLFVBQU1DLEtBQUtKLFVBQVVHLElBQUlEO0FBQ3pCLFVBQU1HLEtBQUtMLFVBQVVFLElBQUlDO0FBQ3pCLFdBQU9DLEdBQUdFLFdBQVdELEdBQUdDLFNBQ3RCRixHQUFHeEUsUUFBUXlFLEdBQUd6RSxRQUNkd0UsR0FBR0UsU0FBU0QsR0FBR0M7RUFDbEIsQ0FBQTtBQUNGO0FBRUQsU0FBU0MsVUFBVUMsT0FBTztBQUN4QixRQUFNQyxjQUFjLENBQUE7QUFDcEIsTUFBSS9FLEdBQUdDLE1BQU1tRSxLQUFLRixLQUFLYyxPQUFPQztBQUU5QixPQUFLakYsSUFBSSxHQUFHQyxRQUFRNkUsU0FBUyxDQUFBLEdBQUlqRyxRQUFRbUIsSUFBSUMsTUFBTSxFQUFFRCxHQUFHO0FBQ3REb0UsVUFBTVUsTUFBTTlFO0FBQ1osS0FBQyxFQUFDSixVQUFVc0UsS0FBS3pHLFNBQVMsRUFBQ3VILE9BQU9DLGNBQWMsRUFBQyxFQUFDLElBQUliO0FBQ3REVyxnQkFBWWpELEtBQUs7TUFDZjVCLE9BQU9GO01BQ1BvRTtNQUNBRjtNQUNBZ0IsWUFBWWQsSUFBSWUsYUFBWTtNQUM1QlAsUUFBUVIsSUFBSVE7TUFDWkksT0FBT0EsU0FBVWQsTUFBTWM7TUFDdkJDO0lBQ0QsQ0FBQTtFQUNGO0FBQ0QsU0FBT0Y7QUFDUjtBQUVELFNBQVNLLFlBQVlDLFVBQVM7QUFDNUIsUUFBTUMsU0FBUyxDQUFBO0FBQ2YsYUFBV0MsUUFBUUYsVUFBUztBQUMxQixVQUFNLEVBQUNMLE9BQU9kLEtBQUtlLFlBQVcsSUFBSU07QUFDbEMsUUFBSSxDQUFDUCxTQUFTLENBQUNuQixpQkFBaUIyQixTQUFTdEIsR0FBRyxHQUFHO0FBQzdDO0lBQ0Q7QUFDRCxVQUFNdUIsU0FBU0gsT0FBT04sV0FBV00sT0FBT04sU0FBUztNQUFDVSxPQUFPO01BQUdDLFFBQVE7TUFBR2YsUUFBUTtNQUFHZ0IsTUFBTTtJQUFFO0FBQzFGSCxXQUFPQztBQUNQRCxXQUFPYixVQUFVSztFQUNsQjtBQUNELFNBQU9LO0FBQ1I7QUFLRCxTQUFTTyxjQUFjUixVQUFTUyxRQUFRO0FBQ3RDLFFBQU1SLFNBQVNGLFlBQVlDLFFBQU87QUFDbEMsUUFBTSxFQUFDVSxjQUFjQyxjQUFhLElBQUlGO0FBQ3RDLE1BQUk5RixHQUFHQyxNQUFNZ0c7QUFDYixPQUFLakcsSUFBSSxHQUFHQyxPQUFPb0YsU0FBUXhHLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDaERpRyxhQUFTWixTQUFRckY7QUFDakIsVUFBTSxFQUFDa0csU0FBUSxJQUFJRCxPQUFPN0I7QUFDMUIsVUFBTVksUUFBUU0sT0FBT1csT0FBT2pCO0FBQzVCLFVBQU1tQixTQUFTbkIsU0FBU2lCLE9BQU9oQixjQUFjRCxNQUFNSjtBQUNuRCxRQUFJcUIsT0FBT2YsWUFBWTtBQUNyQmUsYUFBT0csUUFBUUQsU0FBU0EsU0FBU0osZUFBZUcsWUFBWUosT0FBT087QUFDbkVKLGFBQU9LLFNBQVNOO1dBQ1g7QUFDTEMsYUFBT0csUUFBUUw7QUFDZkUsYUFBT0ssU0FBU0gsU0FBU0EsU0FBU0gsZ0JBQWdCRSxZQUFZSixPQUFPUztJQUN0RTtFQUNGO0FBQ0QsU0FBT2pCO0FBQ1I7QUFFRCxTQUFTa0IsaUJBQWlCMUIsT0FBTztBQUMvQixRQUFNQyxjQUFjRixVQUFVQyxLQUFLO0FBQ25DLFFBQU1vQixXQUFXN0IsYUFBYVUsWUFBWWYsT0FBT3VCLENBQUFBLFNBQVFBLEtBQUtuQixJQUFJOEIsUUFBUSxHQUFHLElBQUk7QUFDakYsUUFBTU8sT0FBT3BDLGFBQWFQLGlCQUFpQmlCLGFBQWEsTUFBTSxHQUFHLElBQUk7QUFDckUsUUFBTTJCLFFBQVFyQyxhQUFhUCxpQkFBaUJpQixhQUFhLE9BQU8sQ0FBQztBQUNqRSxRQUFNNEIsTUFBTXRDLGFBQWFQLGlCQUFpQmlCLGFBQWEsS0FBSyxHQUFHLElBQUk7QUFDbkUsUUFBTTZCLFNBQVN2QyxhQUFhUCxpQkFBaUJpQixhQUFhLFFBQVEsQ0FBQztBQUNuRSxRQUFNOEIsbUJBQW1CMUMsNEJBQTRCWSxhQUFhLEdBQUc7QUFDckUsUUFBTStCLGlCQUFpQjNDLDRCQUE0QlksYUFBYSxHQUFHO0FBRW5FLFNBQU87SUFDTG1CO0lBQ0FhLFlBQVlOLEtBQUtPLE9BQU9MLEdBQUc7SUFDM0JNLGdCQUFnQlAsTUFBTU0sT0FBT0YsY0FBYyxFQUFFRSxPQUFPSixNQUFNLEVBQUVJLE9BQU9ILGdCQUFnQjtJQUNuRmpGLFdBQVdrQyxpQkFBaUJpQixhQUFhLFdBQVc7SUFDcERtQyxVQUFVVCxLQUFLTyxPQUFPTixLQUFLLEVBQUVNLE9BQU9GLGNBQWM7SUFDbEQ1QixZQUFZeUIsSUFBSUssT0FBT0osTUFBTSxFQUFFSSxPQUFPSCxnQkFBZ0I7O0FBRXpEO0FBRUQsU0FBU00sZUFBZUMsWUFBWXhGLFdBQVc0QyxHQUFHQyxHQUFHO0FBQ25ELFNBQU81RCxLQUFLd0csSUFBSUQsV0FBVzVDLElBQUk1QyxVQUFVNEMsRUFBRSxJQUFJM0QsS0FBS3dHLElBQUlELFdBQVczQyxJQUFJN0MsVUFBVTZDLEVBQUU7QUFDcEY7QUFFRCxTQUFTNkMsaUJBQWlCRixZQUFZRyxZQUFZO0FBQ2hESCxhQUFXVCxNQUFNOUYsS0FBS3dHLElBQUlELFdBQVdULEtBQUtZLFdBQVdaLEdBQUc7QUFDeERTLGFBQVdYLE9BQU81RixLQUFLd0csSUFBSUQsV0FBV1gsTUFBTWMsV0FBV2QsSUFBSTtBQUMzRFcsYUFBV1IsU0FBUy9GLEtBQUt3RyxJQUFJRCxXQUFXUixRQUFRVyxXQUFXWCxNQUFNO0FBQ2pFUSxhQUFXVixRQUFRN0YsS0FBS3dHLElBQUlELFdBQVdWLE9BQU9hLFdBQVdiLEtBQUs7QUFDL0Q7QUFFRCxTQUFTYyxXQUFXNUYsV0FBV2tFLFFBQVFHLFFBQVFYLFFBQVE7QUFDckQsUUFBTSxFQUFDcEIsS0FBS0UsSUFBRyxJQUFJNkI7QUFDbkIsUUFBTW1CLGFBQWF4RixVQUFVd0Y7QUFHN0IsTUFBSSxDQUFDSyxTQUFTdkQsR0FBRyxHQUFHO0FBQ2xCLFFBQUkrQixPQUFPTCxNQUFNO0FBRWZoRSxnQkFBVXNDLFFBQVErQixPQUFPTDtJQUMxQjtBQUNELFVBQU1aLFFBQVFNLE9BQU9XLE9BQU9qQixVQUFVO01BQUNZLE1BQU07TUFBR0YsT0FBTzs7QUFDdkRWLFVBQU1ZLE9BQU8vRSxLQUFLd0csSUFBSXJDLE1BQU1ZLE1BQU1LLE9BQU9mLGFBQWFkLElBQUlrQyxTQUFTbEMsSUFBSWdDLEtBQUs7QUFDNUVILFdBQU9MLE9BQU9aLE1BQU1ZLE9BQU9aLE1BQU1VO0FBQ2pDOUQsY0FBVXNDLFFBQVErQixPQUFPTDtFQUMxQjtBQUVELE1BQUl4QixJQUFJc0QsWUFBWTtBQUNsQkoscUJBQWlCRixZQUFZaEQsSUFBSXNELFdBQVUsQ0FBRTtFQUM5QztBQUVELFFBQU1DLFdBQVc5RyxLQUFLd0csSUFBSSxHQUFHdkIsT0FBTzhCLGFBQWFULGVBQWVDLFlBQVl4RixXQUFXLFFBQVEsT0FBTyxDQUFDO0FBQ3ZHLFFBQU1pRyxZQUFZaEgsS0FBS3dHLElBQUksR0FBR3ZCLE9BQU9nQyxjQUFjWCxlQUFlQyxZQUFZeEYsV0FBVyxPQUFPLFFBQVEsQ0FBQztBQUN6RyxRQUFNbUcsZUFBZUosYUFBYS9GLFVBQVVvRztBQUM1QyxRQUFNQyxnQkFBZ0JKLGNBQWNqRyxVQUFVc0c7QUFDOUN0RyxZQUFVb0csSUFBSUw7QUFDZC9GLFlBQVVzRyxJQUFJTDtBQUdkLFNBQU81QixPQUFPZixhQUNWO0lBQUNpRCxNQUFNSjtJQUFjSyxPQUFPSDtNQUM1QjtJQUFDRSxNQUFNRjtJQUFlRyxPQUFPTDs7QUFDbEM7QUFFRCxTQUFTTSxpQkFBaUJ6RyxXQUFXO0FBQ25DLFFBQU13RixhQUFheEYsVUFBVXdGO0FBRTdCLFdBQVNrQixVQUFVcEUsS0FBSztBQUN0QixVQUFNcUUsU0FBUzFILEtBQUt3RyxJQUFJRCxXQUFXbEQsT0FBT3RDLFVBQVVzQyxNQUFNLENBQUM7QUFDM0R0QyxjQUFVc0MsUUFBUXFFO0FBQ2xCLFdBQU9BO0VBQ1I7QUFDRDNHLFlBQVVYLEtBQUtxSCxVQUFVLEtBQUs7QUFDOUIxRyxZQUFVYixLQUFLdUgsVUFBVSxNQUFNO0FBQy9CQSxZQUFVLE9BQU87QUFDakJBLFlBQVUsUUFBUTtBQUNuQjtBQUVELFNBQVNFLFdBQVd0RCxZQUFZdEQsV0FBVztBQUN6QyxRQUFNd0YsYUFBYXhGLFVBQVV3RjtBQUU3QixXQUFTcUIsbUJBQW1CQyxZQUFXO0FBQ3JDLFVBQU1DLFNBQVM7TUFBQ2xDLE1BQU07TUFBR0UsS0FBSztNQUFHRCxPQUFPO01BQUdFLFFBQVE7O0FBQ25EOEIsSUFBQUEsV0FBVW5GLFFBQVEsQ0FBQ1csUUFBUTtBQUN6QnlFLGFBQU96RSxPQUFPckQsS0FBS3dHLElBQUl6RixVQUFVc0MsTUFBTWtELFdBQVdsRCxJQUFJO0lBQ3ZELENBQUE7QUFDRCxXQUFPeUU7RUFDUjtBQUVELFNBQU96RCxhQUNIdUQsbUJBQW1CO0lBQUM7SUFBUTtHQUFRLElBQ3BDQSxtQkFBbUI7SUFBQztJQUFPO0VBQVMsQ0FBQTtBQUN6QztBQUVELFNBQVNHLFNBQVM5RCxPQUFPbEQsV0FBV2tFLFFBQVFSLFFBQVE7QUFDbEQsUUFBTXVELGFBQWEsQ0FBQTtBQUNuQixNQUFJN0ksR0FBR0MsTUFBTWdHLFFBQVE3QixLQUFLMEUsT0FBT0M7QUFFakMsT0FBSy9JLElBQUksR0FBR0MsT0FBTzZFLE1BQU1qRyxRQUFRaUssUUFBUSxHQUFHOUksSUFBSUMsTUFBTSxFQUFFRCxHQUFHO0FBQ3pEaUcsYUFBU25CLE1BQU05RTtBQUNmb0UsVUFBTTZCLE9BQU83QjtBQUViQSxRQUFJNEUsT0FDRi9DLE9BQU9HLFNBQVN4RSxVQUFVb0csR0FDMUIvQixPQUFPSyxVQUFVMUUsVUFBVXNHLEdBQzNCTSxXQUFXdkMsT0FBT2YsWUFBWXRELFNBQVMsQ0FBQztBQUUxQyxVQUFNLEVBQUN1RyxNQUFNQyxNQUFLLElBQUlaLFdBQVc1RixXQUFXa0UsUUFBUUcsUUFBUVgsTUFBTTtBQUlsRXdELGFBQVNYLFFBQVFVLFdBQVdoSztBQUc1QmtLLGNBQVVBLFdBQVdYO0FBRXJCLFFBQUksQ0FBQ2hFLElBQUk4QixVQUFVO0FBQ2pCMkMsaUJBQVcvRyxLQUFLbUUsTUFBTTtJQUN2QjtFQUNGO0FBRUQsU0FBTzZDLFNBQVNGLFNBQVNDLFlBQVlqSCxXQUFXa0UsUUFBUVIsTUFBTSxLQUFLeUQ7QUFDcEU7QUFFRCxTQUFTRSxXQUFXN0UsS0FBS3FDLE1BQU1FLEtBQUtQLE9BQU9FLFFBQVE7QUFDakRsQyxNQUFJdUMsTUFBTUE7QUFDVnZDLE1BQUlxQyxPQUFPQTtBQUNYckMsTUFBSXNDLFFBQVFELE9BQU9MO0FBQ25CaEMsTUFBSXdDLFNBQVNELE1BQU1MO0FBQ25CbEMsTUFBSWdDLFFBQVFBO0FBQ1poQyxNQUFJa0MsU0FBU0E7QUFDZDtBQUVELFNBQVM0QyxXQUFXcEUsT0FBT2xELFdBQVdrRSxRQUFRUixRQUFRO0FBQ3BELFFBQU02RCxjQUFjckQsT0FBT3NEO0FBQzNCLE1BQUksRUFBQ3JJLEdBQUdFLEVBQUMsSUFBSVc7QUFFYixhQUFXcUUsVUFBVW5CLE9BQU87QUFDMUIsVUFBTVYsTUFBTTZCLE9BQU83QjtBQUNuQixVQUFNWSxRQUFRTSxPQUFPVyxPQUFPakIsVUFBVTtNQUFDVSxPQUFPO01BQUdDLFFBQVE7TUFBR2YsUUFBUTs7QUFDcEUsVUFBTUEsU0FBUyxPQUFRSyxjQUFjRCxNQUFNSixVQUFXO0FBQ3RELFFBQUlxQixPQUFPZixZQUFZO0FBQ3JCLFlBQU1rQixRQUFReEUsVUFBVW9HLElBQUlwRDtBQUM1QixZQUFNMEIsU0FBU3RCLE1BQU1ZLFFBQVF4QixJQUFJa0M7QUFDakMsVUFBSStDLFFBQVFyRSxNQUFNMUYsS0FBSyxHQUFHO0FBQ3hCMkIsWUFBSStELE1BQU0xRjtNQUNYO0FBQ0QsVUFBSThFLElBQUk4QixVQUFVO0FBQ2hCK0MsbUJBQVc3RSxLQUFLK0UsWUFBWTFDLE1BQU14RixHQUFHNkUsT0FBTzhCLGFBQWF1QixZQUFZekMsUUFBUXlDLFlBQVkxQyxNQUFNSCxNQUFNO2FBQ2hHO0FBQ0wyQyxtQkFBVzdFLEtBQUt4QyxVQUFVNkUsT0FBT3pCLE1BQU1XLFFBQVExRSxHQUFHbUYsT0FBT0UsTUFBTTtNQUNoRTtBQUNEdEIsWUFBTTFGLFFBQVEyQjtBQUNkK0QsWUFBTVcsVUFBVVM7QUFDaEJuRixVQUFJbUQsSUFBSXdDO1dBQ0g7QUFDTCxZQUFNTixVQUFTMUUsVUFBVXNHLElBQUl0RDtBQUM3QixZQUFNd0IsU0FBUXBCLE1BQU1ZLFFBQVF4QixJQUFJZ0M7QUFDaEMsVUFBSWlELFFBQVFyRSxNQUFNMUYsS0FBSyxHQUFHO0FBQ3hCeUIsWUFBSWlFLE1BQU0xRjtNQUNYO0FBQ0QsVUFBSThFLElBQUk4QixVQUFVO0FBQ2hCK0MsbUJBQVc3RSxLQUFLckQsR0FBR29JLFlBQVl4QyxLQUFLUCxRQUFPTixPQUFPZ0MsY0FBY3FCLFlBQVl2QyxTQUFTdUMsWUFBWXhDLEdBQUc7YUFDL0Y7QUFDTHNDLG1CQUFXN0UsS0FBS3JELEdBQUdhLFVBQVUrRSxNQUFNM0IsTUFBTVcsUUFBUVMsUUFBT0UsT0FBTTtNQUMvRDtBQUNEdEIsWUFBTTFGLFFBQVF5QjtBQUNkaUUsWUFBTVcsVUFBVVc7QUFDaEJ2RixVQUFJcUQsSUFBSXNDO0lBQ1Q7RUFDRjtBQUVEOUUsWUFBVWIsSUFBSUE7QUFDZGEsWUFBVVgsSUFBSUE7QUFDZjtBQXdCRCxJQUFBLFVBQWU7RUFRYnFJLE9BQU8zSixPQUFPNEosTUFBTTtBQUNsQixRQUFJLENBQUM1SixNQUFNbUYsT0FBTztBQUNoQm5GLFlBQU1tRixRQUFRLENBQUE7SUFDZjtBQUdEeUUsU0FBS3JELFdBQVdxRCxLQUFLckQsWUFBWTtBQUNqQ3FELFNBQUszSixXQUFXMkosS0FBSzNKLFlBQVk7QUFDakMySixTQUFLM0UsU0FBUzJFLEtBQUszRSxVQUFVO0FBRTdCMkUsU0FBS0MsVUFBVUQsS0FBS0MsV0FBVyxXQUFXO0FBQ3hDLGFBQU87UUFBQztVQUNOQyxHQUFHO1VBQ0hDLEtBQUs5SCxXQUFXO0FBQ2QySCxpQkFBS0csS0FBSzlILFNBQVM7VUFDcEI7UUFDRjs7O0FBR0hqQyxVQUFNbUYsTUFBTWhELEtBQUt5SCxJQUFJO0VBQ3RCO0VBT0RJLFVBQVVoSyxPQUFPaUssWUFBWTtBQUMzQixVQUFNMUosUUFBUVAsTUFBTW1GLFFBQVFuRixNQUFNbUYsTUFBTXRFLFFBQVFvSixVQUFVLElBQUk7QUFDOUQsUUFBSTFKLFVBQVUsSUFBSTtBQUNoQlAsWUFBTW1GLE1BQU0rRSxPQUFPM0osT0FBTyxDQUFDO0lBQzVCO0VBQ0Y7RUFRRDRKLFVBQVVuSyxPQUFPNEosTUFBTTlMLFNBQVM7QUFDOUI4TCxTQUFLckQsV0FBV3pJLFFBQVF5STtBQUN4QnFELFNBQUszSixXQUFXbkMsUUFBUW1DO0FBQ3hCMkosU0FBSzNFLFNBQVNuSCxRQUFRbUg7RUFDdkI7RUFVRG9FLE9BQU9ySixPQUFPeUcsT0FBT0UsUUFBUXlELFlBQVk7QUFDdkMsUUFBSSxDQUFDcEssT0FBTztBQUNWO0lBQ0Q7QUFFRCxVQUFNeUosVUFBVVksVUFBVXJLLE1BQU1sQyxRQUFRd0ksT0FBT21ELE9BQU87QUFDdEQsVUFBTS9DLGlCQUFpQnhGLEtBQUt3RyxJQUFJakIsUUFBUWdELFFBQVFoRCxPQUFPLENBQUM7QUFDeEQsVUFBTUcsa0JBQWtCMUYsS0FBS3dHLElBQUlmLFNBQVM4QyxRQUFROUMsUUFBUSxDQUFDO0FBQzNELFVBQU14QixRQUFRMEIsaUJBQWlCN0csTUFBTW1GLEtBQUs7QUFDMUMsVUFBTW1GLGdCQUFnQm5GLE1BQU1vQztBQUM1QixVQUFNZ0Qsa0JBQWtCcEYsTUFBTUk7QUFJOUJpRixTQUFLeEssTUFBTW1GLE9BQU9WLENBQUFBLFFBQU87QUFDdkIsVUFBSSxPQUFPQSxJQUFJZ0csaUJBQWlCLFlBQVk7QUFDMUNoRyxZQUFJZ0csYUFBWTtNQUNqQjtJQUNGLENBQUE7QUE2QkQsVUFBTUMsMEJBQTBCSixjQUFjSyxPQUFPLENBQUNDLE9BQU9oRixTQUMzREEsS0FBS25CLElBQUkzRyxXQUFXOEgsS0FBS25CLElBQUkzRyxRQUFRK00sWUFBWSxRQUFRRCxRQUFRQSxRQUFRLEdBQUcsQ0FBQyxLQUFLO0FBRXBGLFVBQU16RSxTQUFTekksT0FBT29OLE9BQU87TUFDM0I3QyxZQUFZeEI7TUFDWjBCLGFBQWF4QjtNQUNiOEM7TUFDQS9DO01BQ0FFO01BQ0FSLGNBQWNNLGlCQUFpQixJQUFJZ0U7TUFDbkNyRSxlQUFlTyxrQkFBa0I7SUFDbEMsQ0FBQTtBQUNELFVBQU1hLGFBQWEvSixPQUFPQyxPQUFPLENBQUEsR0FBSThMLE9BQU87QUFDNUM5QixxQkFBaUJGLFlBQVk0QyxVQUFVRCxVQUFVLENBQUM7QUFDbEQsVUFBTW5JLFlBQVl2RSxPQUFPQyxPQUFPO01BQzlCOEo7TUFDQVksR0FBRzNCO01BQ0g2QixHQUFHM0I7TUFDSHhGLEdBQUdxSSxRQUFRM0M7TUFDWHhGLEdBQUdtSSxRQUFRekM7T0FDVnlDLE9BQU87QUFFVixVQUFNOUQsU0FBU08sY0FBY29FLGNBQWNqRCxPQUFPa0QsZUFBZSxHQUFHcEUsTUFBTTtBQUcxRThDLGFBQVM5RCxNQUFNb0IsVUFBVXRFLFdBQVdrRSxRQUFRUixNQUFNO0FBR2xEc0QsYUFBU3FCLGVBQWVySSxXQUFXa0UsUUFBUVIsTUFBTTtBQUdqRCxRQUFJc0QsU0FBU3NCLGlCQUFpQnRJLFdBQVdrRSxRQUFRUixNQUFNLEdBQUc7QUFFeERzRCxlQUFTcUIsZUFBZXJJLFdBQVdrRSxRQUFRUixNQUFNO0lBQ2xEO0FBRUQrQyxxQkFBaUJ6RyxTQUFTO0FBRzFCc0gsZUFBV3BFLE1BQU1pQyxZQUFZbkYsV0FBV2tFLFFBQVFSLE1BQU07QUFHdEQxRCxjQUFVYixLQUFLYSxVQUFVb0c7QUFDekJwRyxjQUFVWCxLQUFLVyxVQUFVc0c7QUFFekJnQixlQUFXcEUsTUFBTW1DLGdCQUFnQnJGLFdBQVdrRSxRQUFRUixNQUFNO0FBRTFEM0YsVUFBTWlDLFlBQVk7TUFDaEI2RSxNQUFNN0UsVUFBVTZFO01BQ2hCRSxLQUFLL0UsVUFBVStFO01BQ2ZELE9BQU85RSxVQUFVNkUsT0FBTzdFLFVBQVVvRztNQUNsQ3BCLFFBQVFoRixVQUFVK0UsTUFBTS9FLFVBQVVzRztNQUNsQzVCLFFBQVExRSxVQUFVc0c7TUFDbEI5QixPQUFPeEUsVUFBVW9HOztBQUluQm1DLFNBQUtyRixNQUFNbEQsV0FBVyxDQUFDcUUsV0FBVztBQUNoQyxZQUFNN0IsTUFBTTZCLE9BQU83QjtBQUNuQi9HLGFBQU9DLE9BQU84RyxLQUFLekUsTUFBTWlDLFNBQVM7QUFDbEN3QyxVQUFJNEUsT0FBT3BILFVBQVVvRyxHQUFHcEcsVUFBVXNHLEdBQUc7UUFBQ3pCLE1BQU07UUFBR0UsS0FBSztRQUFHRCxPQUFPO1FBQUdFLFFBQVE7TUFBRSxDQUFBO0lBQzVFLENBQUE7RUFDRjs7QUM3YlksSUFBTThELGVBQU4sTUFBa0I7RUFPL0JDLGVBQWVDLFFBQVFDLGFBQWE7RUFBQTtFQVFwQ0MsZUFBZUMsU0FBUztBQUN0QixXQUFPO0VBQ1I7RUFTREMsaUJBQWlCckwsT0FBT3NMLE1BQU1DLFVBQVU7RUFBQTtFQVF4Q0Msb0JBQW9CeEwsT0FBT3NMLE1BQU1DLFVBQVU7RUFBQTtFQUszQ0Usc0JBQXNCO0FBQ3BCLFdBQU87RUFDUjtFQVNEQyxlQUFlakwsU0FBU2dHLE9BQU9FLFFBQVF1RSxhQUFhO0FBQ2xEekUsWUFBUXZGLEtBQUt3RyxJQUFJLEdBQUdqQixTQUFTaEcsUUFBUWdHLEtBQUs7QUFDMUNFLGFBQVNBLFVBQVVsRyxRQUFRa0c7QUFDM0IsV0FBTztNQUNMRjtNQUNBRSxRQUFRekYsS0FBS3dHLElBQUksR0FBR3dELGNBQWNoSyxLQUFLeUssTUFBTWxGLFFBQVF5RSxXQUFXLElBQUl2RSxNQUFNOztFQUU3RTtFQU1EaUYsV0FBV1gsUUFBUTtBQUNqQixXQUFPO0VBQ1I7RUFNRFksYUFBYUMsUUFBUTtFQUVwQjs7QUNyRVksSUFBTUMsZ0JBQU4sY0FBNEJoQixhQUFZO0VBQ3JEQyxlQUFlcEIsTUFBTTtBQUluQixXQUFPQSxRQUFRQSxLQUFLb0MsY0FBY3BDLEtBQUtvQyxXQUFXLElBQUksS0FBSztFQUM1RDtFQUNESCxhQUFhQyxRQUFRO0FBQ25CQSxXQUFPaE8sUUFBUW1PLFlBQVk7RUFDNUI7O0FDUkgsSUFBTUMsY0FBYztBQU9wQixJQUFNQyxjQUFjO0VBQ2xCQyxZQUFZO0VBQ1pDLFdBQVc7RUFDWEMsVUFBVTtFQUNWQyxjQUFjO0VBQ2RDLGFBQWE7RUFDYkMsYUFBYTtFQUNiQyxXQUFXO0VBQ1hDLGNBQWM7RUFDZEMsWUFBWTs7QUFHZCxJQUFNQyxnQkFBZ0JsTyxDQUFBQSxVQUFTQSxVQUFVLFFBQVFBLFVBQVU7QUFRM0QsU0FBU21PLFdBQVc3QixRQUFRQyxhQUFhO0FBQ3ZDLFFBQU02QixRQUFROUIsT0FBTzhCO0FBSXJCLFFBQU1DLGVBQWUvQixPQUFPZ0MsYUFBYSxRQUFRO0FBQ2pELFFBQU1DLGNBQWNqQyxPQUFPZ0MsYUFBYSxPQUFPO0FBRy9DaEMsU0FBT2lCLGVBQWU7SUFDcEJpQixTQUFTO01BQ1B4RyxRQUFRcUc7TUFDUnZHLE9BQU95RztNQUNQSCxPQUFPO1FBQ0xsQyxTQUFTa0MsTUFBTWxDO1FBQ2ZsRSxRQUFRb0csTUFBTXBHO1FBQ2RGLE9BQU9zRyxNQUFNdEc7TUFDZDtJQUNGOztBQU1Ic0csUUFBTWxDLFVBQVVrQyxNQUFNbEMsV0FBVztBQUVqQ2tDLFFBQU1LLFlBQVlMLE1BQU1LLGFBQWE7QUFFckMsTUFBSVAsY0FBY0ssV0FBVyxHQUFHO0FBQzlCLFVBQU1HLGVBQWVDLGFBQWFyQyxRQUFRLE9BQU87QUFDakQsUUFBSW9DLGlCQUFpQkUsUUFBVztBQUM5QnRDLGFBQU94RSxRQUFRNEc7SUFDaEI7RUFDRjtBQUVELE1BQUlSLGNBQWNHLFlBQVksR0FBRztBQUMvQixRQUFJL0IsT0FBTzhCLE1BQU1wRyxXQUFXLElBQUk7QUFJOUJzRSxhQUFPdEUsU0FBU3NFLE9BQU94RSxTQUFTeUUsZUFBZTtXQUMxQztBQUNMLFlBQU1zQyxnQkFBZ0JGLGFBQWFyQyxRQUFRLFFBQVE7QUFDbkQsVUFBSXVDLGtCQUFrQkQsUUFBVztBQUMvQnRDLGVBQU90RSxTQUFTNkc7TUFDakI7SUFDRjtFQUNGO0FBRUQsU0FBT3ZDO0FBQ1I7QUFJRCxJQUFNd0MsdUJBQXVCQywrQkFBK0I7RUFBQ0MsU0FBUztBQUFLLElBQUc7QUFFOUUsU0FBU0MsWUFBWUMsTUFBTXZDLE1BQU1DLFVBQVU7QUFDekNzQyxPQUFLeEMsaUJBQWlCQyxNQUFNQyxVQUFVa0Msb0JBQW9CO0FBQzNEO0FBRUQsU0FBU0ssZUFBZTlOLE9BQU9zTCxNQUFNQyxVQUFVO0FBQzdDdkwsUUFBTWlMLE9BQU9PLG9CQUFvQkYsTUFBTUMsVUFBVWtDLG9CQUFvQjtBQUN0RTtBQUVELFNBQVNNLGdCQUFnQkMsT0FBT2hPLE9BQU87QUFDckMsUUFBTXNMLE9BQU9hLFlBQVk2QixNQUFNMUMsU0FBUzBDLE1BQU0xQztBQUM5QyxRQUFNLEVBQUNsSyxHQUFHRSxFQUFDLElBQUlvQyxvQkFBb0JzSyxPQUFPaE8sS0FBSztBQUMvQyxTQUFPO0lBQ0xzTDtJQUNBdEw7SUFDQWlPLFFBQVFEO0lBQ1I1TSxHQUFHQSxNQUFNbU0sU0FBWW5NLElBQUk7SUFDekJFLEdBQUdBLE1BQU1pTSxTQUFZak0sSUFBSTs7QUFFNUI7QUFFRCxTQUFTNE0saUJBQWlCQyxVQUFVbEQsUUFBUTtBQUMxQyxhQUFXNEMsUUFBUU0sVUFBVTtBQUMzQixRQUFJTixTQUFTNUMsVUFBVTRDLEtBQUtPLFNBQVNuRCxNQUFNLEdBQUc7QUFDNUMsYUFBTztJQUNSO0VBQ0Y7QUFDRjtBQUVELFNBQVNvRCxxQkFBcUJyTyxPQUFPc0wsTUFBTUMsVUFBVTtBQUNuRCxRQUFNTixTQUFTakwsTUFBTWlMO0FBQ3JCLFFBQU1xRCxXQUFXLElBQUlDLGlCQUFpQkMsQ0FBQUEsWUFBVztBQUMvQyxRQUFJQyxVQUFVO0FBQ2QsZUFBV0MsU0FBU0YsU0FBUztBQUMzQkMsZ0JBQVVBLFdBQVdQLGlCQUFpQlEsTUFBTUMsWUFBWTFELE1BQU07QUFDOUR3RCxnQkFBVUEsV0FBVyxDQUFDUCxpQkFBaUJRLE1BQU1FLGNBQWMzRCxNQUFNO0lBQ2xFO0FBQ0QsUUFBSXdELFNBQVM7QUFDWGxELGVBQVE7SUFDVDtFQUNGLENBQUE7QUFDRCtDLFdBQVNPLFFBQVFDLFVBQVU7SUFBQ0MsV0FBVztJQUFNQyxTQUFTO0VBQUssQ0FBQTtBQUMzRCxTQUFPVjtBQUNSO0FBRUQsU0FBU1cscUJBQXFCalAsT0FBT3NMLE1BQU1DLFVBQVU7QUFDbkQsUUFBTU4sU0FBU2pMLE1BQU1pTDtBQUNyQixRQUFNcUQsV0FBVyxJQUFJQyxpQkFBaUJDLENBQUFBLFlBQVc7QUFDL0MsUUFBSUMsVUFBVTtBQUNkLGVBQVdDLFNBQVNGLFNBQVM7QUFDM0JDLGdCQUFVQSxXQUFXUCxpQkFBaUJRLE1BQU1FLGNBQWMzRCxNQUFNO0FBQ2hFd0QsZ0JBQVVBLFdBQVcsQ0FBQ1AsaUJBQWlCUSxNQUFNQyxZQUFZMUQsTUFBTTtJQUNoRTtBQUNELFFBQUl3RCxTQUFTO0FBQ1hsRCxlQUFRO0lBQ1Q7RUFDRixDQUFBO0FBQ0QrQyxXQUFTTyxRQUFRQyxVQUFVO0lBQUNDLFdBQVc7SUFBTUMsU0FBUztFQUFLLENBQUE7QUFDM0QsU0FBT1Y7QUFDUjtBQUVELElBQU1ZLHFCQUFxQixvQkFBSUMsSUFBRztBQUNsQyxJQUFJQyxzQkFBc0I7QUFFMUIsU0FBU0MsaUJBQWlCO0FBQ3hCLFFBQU1DLE1BQU1DLE9BQU9DO0FBQ25CLE1BQUlGLFFBQVFGLHFCQUFxQjtBQUMvQjtFQUNEO0FBQ0RBLHdCQUFzQkU7QUFDdEJKLHFCQUFtQnRMLFFBQVEsQ0FBQzZMLFFBQVF6UCxVQUFVO0FBQzVDLFFBQUlBLE1BQU0wUCw0QkFBNEJKLEtBQUs7QUFDekNHLGFBQU07SUFDUDtFQUNGLENBQUE7QUFDRjtBQUVELFNBQVNFLDhCQUE4QjNQLE9BQU95UCxRQUFRO0FBQ3BELE1BQUksQ0FBQ1AsbUJBQW1CakosTUFBTTtBQUM1QnNKLFdBQU9sRSxpQkFBaUIsVUFBVWdFLGNBQWM7RUFDakQ7QUFDREgscUJBQW1CVSxJQUFJNVAsT0FBT3lQLE1BQU07QUFDckM7QUFFRCxTQUFTSSxnQ0FBZ0M3UCxPQUFPO0FBQzlDa1AscUJBQW1CWSxPQUFPOVAsS0FBSztBQUMvQixNQUFJLENBQUNrUCxtQkFBbUJqSixNQUFNO0FBQzVCc0osV0FBTy9ELG9CQUFvQixVQUFVNkQsY0FBYztFQUNwRDtBQUNGO0FBRUQsU0FBU1UscUJBQXFCL1AsT0FBT3NMLE1BQU1DLFVBQVU7QUFDbkQsUUFBTU4sU0FBU2pMLE1BQU1pTDtBQUNyQixRQUFNK0UsWUFBWS9FLFVBQVVnRixlQUFlaEYsTUFBTTtBQUNqRCxNQUFJLENBQUMrRSxXQUFXO0FBQ2Q7RUFDRDtBQUNELFFBQU1QLFNBQVNTLFVBQVUsQ0FBQ3pKLE9BQU9FLFdBQVc7QUFDMUMsVUFBTTBCLElBQUkySCxVQUFVRztBQUNwQjVFLGFBQVM5RSxPQUFPRSxNQUFNO0FBQ3RCLFFBQUkwQixJQUFJMkgsVUFBVUcsYUFBYTtBQVE3QjVFLGVBQVE7SUFDVDtLQUNBZ0UsTUFBTTtBQUdULFFBQU1qQixXQUFXLElBQUk4QixlQUFlNUIsQ0FBQUEsWUFBVztBQUM3QyxVQUFNRSxRQUFRRixRQUFRO0FBQ3RCLFVBQU0vSCxRQUFRaUksTUFBTTJCLFlBQVk1SjtBQUNoQyxVQUFNRSxTQUFTK0gsTUFBTTJCLFlBQVkxSjtBQUlqQyxRQUFJRixVQUFVLEtBQUtFLFdBQVcsR0FBRztBQUMvQjtJQUNEO0FBQ0Q4SSxXQUFPaEosT0FBT0UsTUFBTTtFQUNyQixDQUFBO0FBQ0QySCxXQUFTTyxRQUFRbUIsU0FBUztBQUMxQkwsZ0NBQThCM1AsT0FBT3lQLE1BQU07QUFFM0MsU0FBT25CO0FBQ1I7QUFFRCxTQUFTZ0MsZ0JBQWdCdFEsT0FBT3NMLE1BQU1nRCxVQUFVO0FBQzlDLE1BQUlBLFVBQVU7QUFDWkEsYUFBU2lDLFdBQVU7RUFDcEI7QUFDRCxNQUFJakYsU0FBUyxVQUFVO0FBQ3JCdUUsb0NBQWdDN1AsS0FBSztFQUN0QztBQUNGO0FBRUQsU0FBU3dRLHFCQUFxQnhRLE9BQU9zTCxNQUFNQyxVQUFVO0FBQ25ELFFBQU1OLFNBQVNqTCxNQUFNaUw7QUFDckIsUUFBTXdGLFFBQVFQLFVBQVUsQ0FBQ2xDLFVBQVU7QUFJakMsUUFBSWhPLE1BQU0wUSxRQUFRLE1BQU07QUFDdEJuRixlQUFTd0MsZ0JBQWdCQyxPQUFPaE8sS0FBSyxDQUFDO0lBQ3ZDO0tBQ0FBLEtBQUs7QUFFUjROLGNBQVkzQyxRQUFRSyxNQUFNbUYsS0FBSztBQUUvQixTQUFPQTtBQUNSO0FBTWMsSUFBTUUsY0FBTixjQUEwQjVGLGFBQVk7RUFPbkRDLGVBQWVDLFFBQVFDLGFBQWE7QUFJbEMsVUFBTUUsVUFBVUgsVUFBVUEsT0FBT2UsY0FBY2YsT0FBT2UsV0FBVyxJQUFJO0FBU3JFLFFBQUlaLFdBQVdBLFFBQVFILFdBQVdBLFFBQVE7QUFHeEM2QixpQkFBVzdCLFFBQVFDLFdBQVc7QUFDOUIsYUFBT0U7SUFDUjtBQUVELFdBQU87RUFDUjtFQUtERCxlQUFlQyxTQUFTO0FBQ3RCLFVBQU1ILFNBQVNHLFFBQVFIO0FBQ3ZCLFFBQUksQ0FBQ0EsT0FBT2lCLGNBQWM7QUFDeEIsYUFBTztJQUNSO0FBRUQsVUFBTWlCLFVBQVVsQyxPQUFPaUIsYUFBYWlCO0FBQ3BDO01BQUM7TUFBVTtJQUFRLEVBQUN2SixRQUFRLENBQUNnTixTQUFTO0FBQ3BDLFlBQU1qUyxRQUFRd08sUUFBUXlEO0FBQ3RCLFVBQUlDLGNBQWNsUyxLQUFLLEdBQUc7QUFDeEJzTSxlQUFPNkYsZ0JBQWdCRixJQUFJO2FBQ3RCO0FBQ0wzRixlQUFPOEYsYUFBYUgsTUFBTWpTLEtBQUs7TUFDaEM7SUFDRixDQUFBO0FBRUQsVUFBTW9PLFFBQVFJLFFBQVFKLFNBQVMsQ0FBQTtBQUMvQnJQLFdBQU9zVCxLQUFLakUsS0FBSyxFQUFFbkosUUFBUSxDQUFDcU4sUUFBUTtBQUNsQ2hHLGFBQU84QixNQUFNa0UsT0FBT2xFLE1BQU1rRTtJQUMzQixDQUFBO0FBT0RoRyxXQUFPeEUsUUFBUXdFLE9BQU94RTtBQUV0QixXQUFPd0UsT0FBT2lCO0FBQ2QsV0FBTztFQUNSO0VBUURiLGlCQUFpQnJMLE9BQU9zTCxNQUFNQyxVQUFVO0FBRXRDLFNBQUtDLG9CQUFvQnhMLE9BQU9zTCxJQUFJO0FBRXBDLFVBQU00RixVQUFVbFIsTUFBTW1SLGFBQWFuUixNQUFNbVIsV0FBVyxDQUFBO0FBQ3BELFVBQU1DLFdBQVc7TUFDZkMsUUFBUWhEO01BQ1JpRCxRQUFRckM7TUFDUlEsUUFBUU07O0FBRVYsVUFBTTdQLFVBQVVrUixTQUFTOUYsU0FBU2tGO0FBQ2xDVSxZQUFRNUYsUUFBUXBMLFFBQVFGLE9BQU9zTCxNQUFNQyxRQUFRO0VBQzlDO0VBT0RDLG9CQUFvQnhMLE9BQU9zTCxNQUFNO0FBQy9CLFVBQU00RixVQUFVbFIsTUFBTW1SLGFBQWFuUixNQUFNbVIsV0FBVyxDQUFBO0FBQ3BELFVBQU1WLFFBQVFTLFFBQVE1RjtBQUV0QixRQUFJLENBQUNtRixPQUFPO0FBQ1Y7SUFDRDtBQUVELFVBQU1XLFdBQVc7TUFDZkMsUUFBUWY7TUFDUmdCLFFBQVFoQjtNQUNSYixRQUFRYTs7QUFFVixVQUFNcFEsVUFBVWtSLFNBQVM5RixTQUFTd0M7QUFDbEM1TixZQUFRRixPQUFPc0wsTUFBTW1GLEtBQUs7QUFDMUJTLFlBQVE1RixRQUFRaUM7RUFDakI7RUFFRDlCLHNCQUFzQjtBQUNwQixXQUFPOEQsT0FBT0M7RUFDZjtFQVFEOUQsZUFBZVQsUUFBUXhFLE9BQU9FLFFBQVF1RSxhQUFhO0FBQ2pELFdBQU9RLGVBQWVULFFBQVF4RSxPQUFPRSxRQUFRdUUsV0FBVztFQUN6RDtFQUtEVSxXQUFXWCxRQUFRO0FBQ2pCLFVBQU0rRSxZQUFZQyxlQUFlaEYsTUFBTTtBQUN2QyxXQUFPLENBQUMsRUFBRStFLGFBQWFBLFVBQVV1QjtFQUNsQzs7QUMxWEksU0FBU0MsZ0JBQWdCdkcsUUFBUTtBQUN0QyxNQUFJLENBQUN3RyxnQkFBZSxLQUFPLE9BQU9DLG9CQUFvQixlQUFlekcsa0JBQWtCeUcsaUJBQWtCO0FBQ3ZHLFdBQU8zRjtFQUNSO0FBQ0QsU0FBTzRFO0FBQ1I7QUNMYyxJQUFNZ0IsVUFBTixNQUFhO0VBQWI7QUFPYkMsa0NBQVM7O0VBSVRDLGdCQUFnQm5RLGtCQUFrQztBQUNoRCxVQUFNLEVBQUNOLEdBQUdFLEVBQUMsSUFBSSxLQUFLaUIsU0FBUztNQUFDO01BQUs7T0FBTWIsZ0JBQWdCO0FBQ3pELFdBQU87TUFBQ047TUFBR0U7O0VBQ1o7RUFFRHdRLFdBQVc7QUFDVCxXQUFPQyxTQUFTLEtBQUszUSxDQUFDLEtBQUsyUSxTQUFTLEtBQUt6USxDQUFDO0VBQzNDO0VBU0RpQixTQUFTeVAsT0FBaUJDLE9BQW1EO0FBQzNFLFVBQU1DLFFBQVEsS0FBS0M7QUFDbkIsUUFBSSxDQUFDRixTQUFTLENBQUNDLE9BQU87QUFFcEIsYUFBTztJQUNSO0FBQ0QsVUFBTUUsTUFBK0IsQ0FBQTtBQUNyQ0osVUFBTXBPLFFBQVEsQ0FBQ2dOLFNBQVM7QUFDdEJ3QixVQUFJeEIsUUFBUXNCLE1BQU10QixTQUFTc0IsTUFBTXRCLE1BQU1nQixPQUFNLElBQUtNLE1BQU10QixNQUFNeUIsTUFBTSxLQUFLekI7SUFDMUUsQ0FBQTtBQUNELFdBQU93QjtFQUNSOztBQXBDRCxjQUZtQlQsU0FFWlcsWUFBVyxDQUFBO0FBQ2xCLGNBSG1CWCxTQUdaWTtBQ1FGLFNBQVNDLFNBQVNDLE9BQU9DLE9BQU87QUFDckMsUUFBTUMsV0FBV0YsTUFBTTNVLFFBQVE0VTtBQUMvQixRQUFNRSxxQkFBcUJDLGtCQUFrQkosS0FBSztBQUNsRCxRQUFNSyxhQUFhNVIsS0FBSzZSLElBQUlKLFNBQVNLLGlCQUFpQkosb0JBQW9CQSxrQkFBa0I7QUFDNUYsUUFBTUssZUFBZU4sU0FBU08sTUFBTUMsVUFBVUMsZ0JBQWdCVixLQUFLLElBQUksQ0FBQTtBQUN2RSxRQUFNVyxrQkFBa0JKLGFBQWEvVDtBQUNyQyxRQUFNb1UsUUFBUUwsYUFBYTtBQUMzQixRQUFNTSxPQUFPTixhQUFhSSxrQkFBa0I7QUFDNUMsUUFBTUcsV0FBVyxDQUFBO0FBR2pCLE1BQUlILGtCQUFrQlAsWUFBWTtBQUNoQ1csZUFBV2YsT0FBT2MsVUFBVVAsY0FBY0ksa0JBQWtCUCxVQUFVO0FBQ3RFLFdBQU9VO0VBQ1I7QUFFRCxRQUFNRSxVQUFVQyxpQkFBaUJWLGNBQWNQLE9BQU9JLFVBQVU7QUFFaEUsTUFBSU8sa0JBQWtCLEdBQUc7QUFDdkIsUUFBSWhULEdBQUdDO0FBQ1AsVUFBTXNULGtCQUFrQlAsa0JBQWtCLElBQUluUyxLQUFLMlMsT0FBT04sT0FBT0QsVUFBVUQsa0JBQWtCLEVBQUUsSUFBSTtBQUNuRzNTLFNBQUtnUyxPQUFPYyxVQUFVRSxTQUFTN0MsY0FBYytDLGVBQWUsSUFBSSxJQUFJTixRQUFRTSxpQkFBaUJOLEtBQUs7QUFDbEcsU0FBS2pULElBQUksR0FBR0MsT0FBTytTLGtCQUFrQixHQUFHaFQsSUFBSUMsTUFBTUQsS0FBSztBQUNyREssV0FBS2dTLE9BQU9jLFVBQVVFLFNBQVNULGFBQWE1UyxJQUFJNFMsYUFBYTVTLElBQUksRUFBRTtJQUNwRTtBQUNESyxTQUFLZ1MsT0FBT2MsVUFBVUUsU0FBU0gsTUFBTTFDLGNBQWMrQyxlQUFlLElBQUlsQixNQUFNeFQsU0FBU3FVLE9BQU9LLGVBQWU7QUFDM0csV0FBT0o7RUFDUjtBQUNEOVMsT0FBS2dTLE9BQU9jLFVBQVVFLE9BQU87QUFDN0IsU0FBT0Y7QUFDUjtBQUVELFNBQVNYLGtCQUFrQkosT0FBTztBQUNoQyxRQUFNcUIsU0FBU3JCLE1BQU0zVSxRQUFRZ1c7QUFDN0IsUUFBTUMsYUFBYXRCLE1BQU11QixVQUFTO0FBQ2xDLFFBQU1DLFdBQVd4QixNQUFNeUIsVUFBVUgsY0FBY0QsU0FBUyxJQUFJO0FBQzVELFFBQU1LLFdBQVcxQixNQUFNMkIsYUFBYUw7QUFDcEMsU0FBTzdTLEtBQUt5SyxNQUFNekssS0FBSzZSLElBQUlrQixVQUFVRSxRQUFRLENBQUM7QUFDL0M7QUFPRCxTQUFTUixpQkFBaUJWLGNBQWNQLE9BQU9JLFlBQVk7QUFDekQsUUFBTXVCLG1CQUFtQkMsZUFBZXJCLFlBQVk7QUFDcEQsUUFBTVMsVUFBVWhCLE1BQU14VCxTQUFTNFQ7QUFJL0IsTUFBSSxDQUFDdUIsa0JBQWtCO0FBQ3JCLFdBQU9uVCxLQUFLd0csSUFBSWdNLFNBQVMsQ0FBQztFQUMzQjtBQUVELFFBQU1hLFVBQVVDLFdBQVdILGdCQUFnQjtBQUMzQyxXQUFTaFUsSUFBSSxHQUFHQyxPQUFPaVUsUUFBUXJWLFNBQVMsR0FBR21CLElBQUlDLE1BQU1ELEtBQUs7QUFDeEQsVUFBTW1HLFNBQVMrTixRQUFRbFU7QUFDdkIsUUFBSW1HLFNBQVNrTixTQUFTO0FBQ3BCLGFBQU9sTjtJQUNSO0VBQ0Y7QUFDRCxTQUFPdEYsS0FBS3dHLElBQUlnTSxTQUFTLENBQUM7QUFDM0I7QUFLRCxTQUFTTixnQkFBZ0JWLE9BQU87QUFDOUIsUUFBTStCLFNBQVMsQ0FBQTtBQUNmLE1BQUlwVSxHQUFHQztBQUNQLE9BQUtELElBQUksR0FBR0MsT0FBT29TLE1BQU14VCxRQUFRbUIsSUFBSUMsTUFBTUQsS0FBSztBQUM5QyxRQUFJcVMsTUFBTXJTLEdBQUc2UyxPQUFPO0FBQ2xCdUIsYUFBT3RTLEtBQUs5QixDQUFDO0lBQ2Q7RUFDRjtBQUNELFNBQU9vVTtBQUNSO0FBUUQsU0FBU2hCLFdBQVdmLE9BQU9jLFVBQVVQLGNBQWNTLFNBQVM7QUFDMUQsTUFBSTNOLFFBQVE7QUFDWixNQUFJMk8sT0FBT3pCLGFBQWE7QUFDeEIsTUFBSTVTO0FBRUpxVCxZQUFVeFMsS0FBS3lULEtBQUtqQixPQUFPO0FBQzNCLE9BQUtyVCxJQUFJLEdBQUdBLElBQUlxUyxNQUFNeFQsUUFBUW1CLEtBQUs7QUFDakMsUUFBSUEsTUFBTXFVLE1BQU07QUFDZGxCLGVBQVNyUixLQUFLdVEsTUFBTXJTLEVBQUU7QUFDdEIwRjtBQUNBMk8sYUFBT3pCLGFBQWFsTixRQUFRMk47SUFDN0I7RUFDRjtBQUNGO0FBU0QsU0FBU2hULEtBQUtnUyxPQUFPYyxVQUFVRSxTQUFTa0IsWUFBWUMsVUFBVTtBQUM1RCxRQUFNbFYsUUFBUW1WLGVBQWVGLFlBQVksQ0FBQztBQUMxQyxRQUFNaFYsTUFBTXNCLEtBQUs2UixJQUFJK0IsZUFBZUQsVUFBVW5DLE1BQU14VCxNQUFNLEdBQUd3VCxNQUFNeFQsTUFBTTtBQUN6RSxNQUFJNkcsUUFBUTtBQUNaLE1BQUk3RyxRQUFRbUIsR0FBR3FVO0FBRWZoQixZQUFVeFMsS0FBS3lULEtBQUtqQixPQUFPO0FBQzNCLE1BQUltQixVQUFVO0FBQ1ozVixhQUFTMlYsV0FBV0Q7QUFDcEJsQixjQUFVeFUsU0FBU2dDLEtBQUt5SyxNQUFNek0sU0FBU3dVLE9BQU87RUFDL0M7QUFFRGdCLFNBQU8vVTtBQUVQLFNBQU8rVSxPQUFPLEdBQUc7QUFDZjNPO0FBQ0EyTyxXQUFPeFQsS0FBSzJTLE1BQU1sVSxRQUFRb0csUUFBUTJOLE9BQU87RUFDMUM7QUFFRCxPQUFLclQsSUFBSWEsS0FBS3dHLElBQUkvSCxPQUFPLENBQUMsR0FBR1UsSUFBSVQsS0FBS1MsS0FBSztBQUN6QyxRQUFJQSxNQUFNcVUsTUFBTTtBQUNkbEIsZUFBU3JSLEtBQUt1USxNQUFNclMsRUFBRTtBQUN0QjBGO0FBQ0EyTyxhQUFPeFQsS0FBSzJTLE1BQU1sVSxRQUFRb0csUUFBUTJOLE9BQU87SUFDMUM7RUFDRjtBQUNGO0FBTUQsU0FBU1ksZUFBZVMsS0FBSztBQUMzQixRQUFNQyxNQUFNRCxJQUFJN1Y7QUFDaEIsTUFBSW1CLEdBQUdqQztBQUVQLE1BQUk0VyxNQUFNLEdBQUc7QUFDWCxXQUFPO0VBQ1I7QUFFRCxPQUFLNVcsT0FBTzJXLElBQUksSUFBSTFVLElBQUksR0FBR0EsSUFBSTJVLEtBQUssRUFBRTNVLEdBQUc7QUFDdkMsUUFBSTBVLElBQUkxVSxLQUFLMFUsSUFBSTFVLElBQUksT0FBT2pDLE1BQU07QUFDaEMsYUFBTztJQUNSO0VBQ0Y7QUFDRCxTQUFPQTtBQUNSO0FDaktELElBQU02VyxlQUFlLENBQUNDLFVBQVVBLFVBQVUsU0FBUyxVQUFVQSxVQUFVLFVBQVUsU0FBU0E7QUFDMUYsSUFBTUMsaUJBQWlCLENBQUMxQyxPQUFPMkMsTUFBTXRCLFdBQVdzQixTQUFTLFNBQVNBLFNBQVMsU0FBUzNDLE1BQU0yQyxRQUFRdEIsU0FBU3JCLE1BQU0yQyxRQUFRdEI7QUFZekgsU0FBU3VCLE9BQU9OLEtBQUtPLFVBQVU7QUFDN0IsUUFBTWIsU0FBUyxDQUFBO0FBQ2YsUUFBTWMsWUFBWVIsSUFBSTdWLFNBQVNvVztBQUMvQixRQUFNTixNQUFNRCxJQUFJN1Y7QUFDaEIsTUFBSW1CLElBQUk7QUFFUixTQUFPQSxJQUFJMlUsS0FBSzNVLEtBQUtrVixXQUFXO0FBQzlCZCxXQUFPdFMsS0FBSzRTLElBQUk3VCxLQUFLeUssTUFBTXRMLENBQUMsRUFBRTtFQUMvQjtBQUNELFNBQU9vVTtBQUNSO0FBT0QsU0FBU2Usb0JBQW9CL0MsT0FBT2xTLE9BQU9rVixpQkFBaUI7QUFDMUQsUUFBTXZXLFNBQVN1VCxNQUFNQyxNQUFNeFQ7QUFDM0IsUUFBTXdXLGNBQWF4VSxLQUFLNlIsSUFBSXhTLE9BQU9yQixTQUFTLENBQUM7QUFDN0MsUUFBTVMsUUFBUThTLE1BQU1rRDtBQUNwQixRQUFNL1YsTUFBTTZTLE1BQU1tRDtBQUNsQixRQUFNQyxVQUFVO0FBQ2hCLE1BQUlDLFlBQVlyRCxNQUFNc0QsZ0JBQWdCTCxXQUFVO0FBQ2hELE1BQUk1QjtBQUVKLE1BQUkyQixpQkFBaUI7QUFDbkIsUUFBSXZXLFdBQVcsR0FBRztBQUNoQjRVLGVBQVM1UyxLQUFLd0csSUFBSW9PLFlBQVluVyxPQUFPQyxNQUFNa1csU0FBUztJQUNyRCxXQUFVdlYsVUFBVSxHQUFHO0FBQ3RCdVQsZ0JBQVVyQixNQUFNc0QsZ0JBQWdCLENBQUMsSUFBSUQsYUFBYTtXQUM3QztBQUNMaEMsZ0JBQVVnQyxZQUFZckQsTUFBTXNELGdCQUFnQkwsY0FBYSxDQUFDLEtBQUs7SUFDaEU7QUFDREksaUJBQWFKLGNBQWFuVixRQUFRdVQsU0FBUyxDQUFDQTtBQUc1QyxRQUFJZ0MsWUFBWW5XLFFBQVFrVyxXQUFXQyxZQUFZbFcsTUFBTWlXLFNBQVM7QUFDNUQ7SUFDRDtFQUNGO0FBQ0QsU0FBT0M7QUFDUjtBQU1ELFNBQVNFLGVBQWVDLFFBQVEvVyxRQUFRO0FBQ3RDc0wsT0FBS3lMLFFBQVEsQ0FBQ0MsVUFBVTtBQUN0QixVQUFNQyxLQUFLRCxNQUFNQztBQUNqQixVQUFNQyxRQUFRRCxHQUFHalgsU0FBUztBQUMxQixRQUFJbUI7QUFDSixRQUFJK1YsUUFBUWxYLFFBQVE7QUFDbEIsV0FBS21CLElBQUksR0FBR0EsSUFBSStWLE9BQU8sRUFBRS9WLEdBQUc7QUFDMUIsZUFBTzZWLE1BQU1wWCxLQUFLcVgsR0FBRzlWO01BQ3RCO0FBQ0Q4VixTQUFHak0sT0FBTyxHQUFHa00sS0FBSztJQUNuQjtFQUNGLENBQUE7QUFDRjtBQUtELFNBQVNDLGtCQUFrQnZZLFNBQVM7QUFDbEMsU0FBT0EsUUFBUXdZLFlBQVl4WSxRQUFRaVcsYUFBYTtBQUNqRDtBQUtELFNBQVN3QyxlQUFlelksU0FBUzBZLFVBQVU7QUFDekMsTUFBSSxDQUFDMVksUUFBUStNLFNBQVM7QUFDcEIsV0FBTztFQUNSO0FBRUQsUUFBTTRMLE9BQU9DLE9BQU81WSxRQUFRMlksTUFBTUQsUUFBUTtBQUMxQyxRQUFNL00sVUFBVVksVUFBVXZNLFFBQVEyTCxPQUFPO0FBQ3pDLFFBQU1rTixRQUFRQyxRQUFROVksUUFBUStZLElBQUksSUFBSS9ZLFFBQVErWSxLQUFLM1gsU0FBUztBQUU1RCxTQUFReVgsUUFBUUYsS0FBS0ssYUFBY3JOLFFBQVE5QztBQUM1QztBQUVELFNBQVNvUSxtQkFBbUJDLFFBQVF2RSxPQUFPO0FBQ3pDLFNBQU93RSxjQUFjRCxRQUFRO0lBQzNCdkU7SUFDQW5ILE1BQU07RUFDUCxDQUFBO0FBQ0Y7QUFFRCxTQUFTNEwsa0JBQWtCRixRQUFRelcsT0FBTzRXLE1BQU07QUFDOUMsU0FBT0YsY0FBY0QsUUFBUTtJQUMzQkc7SUFDQTVXO0lBQ0ErSyxNQUFNO0VBQ1AsQ0FBQTtBQUNGO0FBRUQsU0FBUzhMLFdBQVdsQyxPQUFPalYsVUFBVTBFLFNBQVM7QUFDNUMsTUFBSXlOLE1BQU1pRixtQkFBbUJuQyxLQUFLO0FBQ2xDLE1BQUksV0FBWWpWLGFBQWEsV0FBYSxDQUFDMEUsV0FBVzFFLGFBQWEsU0FBVTtBQUMzRW1TLFVBQU02QyxhQUFhN0MsR0FBRztFQUN2QjtBQUNELFNBQU9BO0FBQ1I7QUFFRCxTQUFTa0YsVUFBVTdFLE9BQU9xQixRQUFRN1QsVUFBVWlWLE9BQU87QUFDakQsUUFBTSxFQUFDbE8sS0FBS0YsTUFBTUcsUUFBUUYsT0FBTy9HLE1BQUssSUFBSXlTO0FBQzFDLFFBQU0sRUFBQ3hRLFdBQVdzVixPQUFNLElBQUl2WDtBQUM1QixNQUFJd1gsV0FBVztBQUNmLE1BQUlDLFVBQVVDLFFBQVFDO0FBQ3RCLFFBQU1oUixTQUFTTSxTQUFTRDtBQUN4QixRQUFNUCxRQUFRTSxRQUFRRDtBQUV0QixNQUFJMkwsTUFBTWpOLGFBQVksR0FBSTtBQUN4QmtTLGFBQVNFLGVBQWUxQyxPQUFPcE8sTUFBTUMsS0FBSztBQUUxQyxRQUFJZSxTQUFTN0gsUUFBUSxHQUFHO0FBQ3RCLFlBQU00WCxpQkFBaUJuYSxPQUFPc1QsS0FBSy9RLFFBQVEsRUFBRTtBQUM3QyxZQUFNdEIsUUFBUXNCLFNBQVM0WDtBQUN2QkYsZUFBU0osT0FBT00sZ0JBQWdCQyxpQkFBaUJuWixLQUFLLElBQUlnSSxTQUFTbU47SUFDcEUsV0FBVTdULGFBQWEsVUFBVTtBQUNoQzBYLGdCQUFVMVYsVUFBVWdGLFNBQVNoRixVQUFVK0UsT0FBTyxJQUFJTCxTQUFTbU47V0FDdEQ7QUFDTDZELGVBQVN4QyxlQUFlMUMsT0FBT3hTLFVBQVU2VCxNQUFNO0lBQ2hEO0FBQ0QyRCxlQUFXMVEsUUFBUUQ7U0FDZDtBQUNMLFFBQUlnQixTQUFTN0gsUUFBUSxHQUFHO0FBQ3RCLFlBQU00WCxrQkFBaUJuYSxPQUFPc1QsS0FBSy9RLFFBQVEsRUFBRTtBQUM3QyxZQUFNdEIsU0FBUXNCLFNBQVM0WDtBQUN2QkgsZUFBU0gsT0FBT00saUJBQWdCQyxpQkFBaUJuWixNQUFLLElBQUk4SCxRQUFRcU47SUFDbkUsV0FBVTdULGFBQWEsVUFBVTtBQUNoQ3lYLGdCQUFVelYsVUFBVTZFLE9BQU83RSxVQUFVOEUsU0FBUyxJQUFJTixRQUFRcU47V0FDckQ7QUFDTDRELGVBQVN2QyxlQUFlMUMsT0FBT3hTLFVBQVU2VCxNQUFNO0lBQ2hEO0FBQ0Q2RCxhQUFTQyxlQUFlMUMsT0FBT2pPLFFBQVFELEdBQUc7QUFDMUN3USxlQUFXdlgsYUFBYSxTQUFTLENBQUM4WCxVQUFVQTtFQUM3QztBQUNELFNBQU87SUFBQ0w7SUFBUUM7SUFBUUY7SUFBVUQ7O0FBQ25DO0FBRWMsSUFBTVEsUUFBTixjQUFvQnJHLFFBQU87RUFHeEM5VCxZQUFZb2EsS0FBSztBQUNmLFVBQUs7QUFHTCxTQUFLQyxLQUFLRCxJQUFJQztBQUVkLFNBQUs1TSxPQUFPMk0sSUFBSTNNO0FBRWhCLFNBQUt4TixVQUFVeVA7QUFFZixTQUFLbUQsTUFBTXVILElBQUl2SDtBQUVmLFNBQUsxUSxRQUFRaVksSUFBSWpZO0FBSWpCLFNBQUtnSCxNQUFNdUc7QUFFWCxTQUFLdEcsU0FBU3NHO0FBRWQsU0FBS3pHLE9BQU95RztBQUVaLFNBQUt4RyxRQUFRd0c7QUFFYixTQUFLOUcsUUFBUThHO0FBRWIsU0FBSzVHLFNBQVM0RztBQUNkLFNBQUs0SyxXQUFXO01BQ2RyUixNQUFNO01BQ05DLE9BQU87TUFDUEMsS0FBSztNQUNMQyxRQUFROztBQUdWLFNBQUt3USxXQUFXbEs7QUFFaEIsU0FBSzZLLFlBQVk3SztBQUVqQixTQUFLOEssYUFBYTlLO0FBRWxCLFNBQUsrSyxnQkFBZ0IvSztBQUVyQixTQUFLZ0wsY0FBY2hMO0FBRW5CLFNBQUtpTCxlQUFlakw7QUFJcEIsU0FBSzdPLE9BQU82TztBQUVaLFNBQUtrTCxnQkFBZ0JsTDtBQUNyQixTQUFLd0YsTUFBTXhGO0FBQ1gsU0FBSzdGLE1BQU02RjtBQUNYLFNBQUttTCxTQUFTbkw7QUFFZCxTQUFLbUYsUUFBUSxDQUFBO0FBRWIsU0FBS2lHLGlCQUFpQjtBQUV0QixTQUFLQyxjQUFjO0FBRW5CLFNBQUtDLGNBQWM7QUFDbkIsU0FBSzNFLFVBQVU7QUFDZixTQUFLRSxhQUFhO0FBQ2xCLFNBQUswRSxvQkFBb0IsQ0FBQTtBQUV6QixTQUFLbkQsY0FBY3BJO0FBRW5CLFNBQUtxSSxZQUFZckk7QUFDakIsU0FBS25PLGlCQUFpQjtBQUN0QixTQUFLMlosV0FBV3hMO0FBQ2hCLFNBQUt5TCxXQUFXekw7QUFDaEIsU0FBSzBMLGdCQUFnQjFMO0FBQ3JCLFNBQUsyTCxnQkFBZ0IzTDtBQUNyQixTQUFLNEwsZUFBZTtBQUNwQixTQUFLQyxlQUFlO0FBQ3BCLFNBQUtDLFNBQVMsQ0FBQTtBQUNkLFNBQUtDLG9CQUFvQjtBQUN6QixTQUFLQyxXQUFXaE07RUFDakI7RUFNRHhQLEtBQUtELFNBQVM7QUFDWixTQUFLQSxVQUFVQSxRQUFRMGIsV0FBVyxLQUFLeE4sV0FBVSxDQUFFO0FBRW5ELFNBQUt0TixPQUFPWixRQUFRWTtBQUdwQixTQUFLc2EsV0FBVyxLQUFLL2EsTUFBTUgsUUFBUWlWLEdBQUc7QUFDdEMsU0FBS2dHLFdBQVcsS0FBSzlhLE1BQU1ILFFBQVE0SixHQUFHO0FBQ3RDLFNBQUt3UixnQkFBZ0IsS0FBS2piLE1BQU1ILFFBQVEyYixZQUFZO0FBQ3BELFNBQUtSLGdCQUFnQixLQUFLaGIsTUFBTUgsUUFBUTRiLFlBQVk7RUFDckQ7RUFRRHpiLE1BQU0wYixLQUFLcFosT0FBTztBQUNoQixXQUFPb1o7RUFDUjtFQU9EQyxnQkFBZ0I7QUFDZCxRQUFJLEVBQUNaLFVBQVVELFVBQVVHLGVBQWVELGNBQWEsSUFBSTtBQUN6REQsZUFBV2EsZ0JBQWdCYixVQUFVbFcsT0FBT0MsaUJBQWlCO0FBQzdEZ1csZUFBV2MsZ0JBQWdCZCxVQUFValcsT0FBT2dYLGlCQUFpQjtBQUM3RFosb0JBQWdCVyxnQkFBZ0JYLGVBQWVwVyxPQUFPQyxpQkFBaUI7QUFDdkVrVyxvQkFBZ0JZLGdCQUFnQlosZUFBZW5XLE9BQU9nWCxpQkFBaUI7QUFDdkUsV0FBTztNQUNML0csS0FBSzhHLGdCQUFnQmIsVUFBVUUsYUFBYTtNQUM1Q3hSLEtBQUttUyxnQkFBZ0JkLFVBQVVFLGFBQWE7TUFDNUNjLFlBQVlDLGVBQVNoQixRQUFRO01BQzdCaUIsWUFBWUQsZUFBU2pCLFFBQVE7O0VBRWhDO0VBUURtQixVQUFVQyxVQUFVO0FBRWxCLFFBQUksRUFBQ3BILEtBQUtyTCxLQUFLcVMsWUFBWUUsV0FBVSxJQUFJLEtBQUtMLGNBQWE7QUFDM0QsUUFBSW5hO0FBRUosUUFBSXNhLGNBQWNFLFlBQVk7QUFDNUIsYUFBTztRQUFDbEg7UUFBS3JMOztJQUNkO0FBRUQsVUFBTTBTLFFBQVEsS0FBS0Msd0JBQXVCO0FBQzFDLGFBQVNoYSxJQUFJLEdBQUdDLE9BQU84WixNQUFNbGIsUUFBUW1CLElBQUlDLE1BQU0sRUFBRUQsR0FBRztBQUNsRFosY0FBUTJhLE1BQU0vWixHQUFHeEIsV0FBV3FiLFVBQVUsTUFBTUMsUUFBUTtBQUNwRCxVQUFJLENBQUNKLFlBQVk7QUFDZmhILGNBQU03UixLQUFLNlIsSUFBSUEsS0FBS3RULE1BQU1zVCxHQUFHO01BQzlCO0FBQ0QsVUFBSSxDQUFDa0gsWUFBWTtBQUNmdlMsY0FBTXhHLEtBQUt3RyxJQUFJQSxLQUFLakksTUFBTWlJLEdBQUc7TUFDOUI7SUFDRjtBQUdEcUwsVUFBTWtILGNBQWNsSCxNQUFNckwsTUFBTUEsTUFBTXFMO0FBQ3RDckwsVUFBTXFTLGNBQWNoSCxNQUFNckwsTUFBTXFMLE1BQU1yTDtBQUV0QyxXQUFPO01BQ0xxTCxLQUFLOEcsZ0JBQWdCOUcsS0FBSzhHLGdCQUFnQm5TLEtBQUtxTCxHQUFHLENBQUM7TUFDbkRyTCxLQUFLbVMsZ0JBQWdCblMsS0FBS21TLGdCQUFnQjlHLEtBQUtyTCxHQUFHLENBQUM7O0VBRXREO0VBT0RLLGFBQWE7QUFDWCxXQUFPO01BQ0xqQixNQUFNLEtBQUt5UixlQUFlO01BQzFCdlIsS0FBSyxLQUFLcVIsY0FBYztNQUN4QnRSLE9BQU8sS0FBS3lSLGdCQUFnQjtNQUM1QnZSLFFBQVEsS0FBS3FSLGlCQUFpQjs7RUFFakM7RUFPRGdDLFdBQVc7QUFDVCxXQUFPLEtBQUs1SDtFQUNiO0VBS0Q2SCxZQUFZO0FBQ1YsVUFBTXpiLE9BQU8sS0FBS2tCLE1BQU1sQjtBQUN4QixXQUFPLEtBQUtoQixRQUFRMGMsV0FBVyxLQUFLaFYsYUFBWSxJQUFLMUcsS0FBSzJiLFVBQVUzYixLQUFLNGIsWUFBWTViLEtBQUswYixVQUFVLENBQUE7RUFDckc7RUFHRC9QLGVBQWU7QUFDYixTQUFLNE8sU0FBUyxDQUFBO0FBQ2QsU0FBS0Msb0JBQW9CO0VBQzFCO0VBTURxQixlQUFlO0FBQ2JDLGFBQUssS0FBSzljLFFBQVE2YyxjQUFjO01BQUM7SUFBSyxDQUFBO0VBQ3ZDO0VBVUR0UixPQUFPb08sVUFBVVcsV0FBV3lDLFNBQVM7QUFDbkMsVUFBTSxFQUFDQyxhQUFhQyxPQUFPckksT0FBT0MsU0FBUSxJQUFJLEtBQUs3VTtBQUNuRCxVQUFNa2QsYUFBYXJJLFNBQVNxSTtBQUc1QixTQUFLTCxhQUFZO0FBR2pCLFNBQUtsRCxXQUFXQTtBQUNoQixTQUFLVyxZQUFZQTtBQUNqQixTQUFLRCxXQUFXMEMsVUFBVW5kLE9BQU9DLE9BQU87TUFDdENtSixNQUFNO01BQ05DLE9BQU87TUFDUEMsS0FBSztNQUNMQyxRQUFRO09BQ1A0VCxPQUFPO0FBRVYsU0FBS25JLFFBQVE7QUFDYixTQUFLbUcsY0FBYztBQUNuQixTQUFLRixpQkFBaUI7QUFDdEIsU0FBS0MsY0FBYztBQUduQixTQUFLcUMsb0JBQW1CO0FBQ3hCLFNBQUtDLGNBQWE7QUFDbEIsU0FBS0MsbUJBQWtCO0FBRXZCLFNBQUsvRyxhQUFhLEtBQUs1TyxhQUFZLElBQy9CLEtBQUtpQixRQUFRb1UsUUFBUS9ULE9BQU8rVCxRQUFROVQsUUFDcEMsS0FBS0osU0FBU2tVLFFBQVE3VCxNQUFNNlQsUUFBUTVUO0FBR3hDLFFBQUksQ0FBQyxLQUFLcVMsbUJBQW1CO0FBQzNCLFdBQUs4QixpQkFBZ0I7QUFDckIsV0FBS0Msb0JBQW1CO0FBQ3hCLFdBQUtDLGdCQUFlO0FBQ3BCLFdBQUs1QyxTQUFTNkMsVUFBVSxNQUFNUixPQUFPRCxXQUFXO0FBQ2hELFdBQUt4QixvQkFBb0I7SUFDMUI7QUFFRCxTQUFLa0MsaUJBQWdCO0FBRXJCLFNBQUs5SSxRQUFRLEtBQUsrSSxXQUFVLEtBQU0sQ0FBQTtBQUdsQyxTQUFLQyxnQkFBZTtBQUlwQixVQUFNQyxrQkFBa0JYLGFBQWEsS0FBS3RJLE1BQU14VDtBQUNoRCxTQUFLMGMsc0JBQXNCRCxrQkFBa0J0RyxPQUFPLEtBQUszQyxPQUFPc0ksVUFBVSxJQUFJLEtBQUt0SSxLQUFLO0FBTXhGLFNBQUt2SSxVQUFTO0FBR2QsU0FBSzBSLDZCQUE0QjtBQUNqQyxTQUFLQyx1QkFBc0I7QUFDM0IsU0FBS0MsNEJBQTJCO0FBR2hDLFFBQUlwSixTQUFTOUgsWUFBWThILFNBQVNILFlBQVlHLFNBQVNxSixXQUFXLFNBQVM7QUFDekUsV0FBS3RKLFFBQVFGLFNBQVMsTUFBTSxLQUFLRSxLQUFLO0FBQ3RDLFdBQUttRyxjQUFjO0FBQ25CLFdBQUtvRCxjQUFhO0lBQ25CO0FBRUQsUUFBSU4saUJBQWlCO0FBRW5CLFdBQUtDLHNCQUFzQixLQUFLbEosS0FBSztJQUN0QztBQUVELFNBQUt3SixVQUFTO0FBQ2QsU0FBS0MsSUFBRztBQUNSLFNBQUtDLFNBQVE7QUFJYixTQUFLQyxZQUFXO0VBQ2pCO0VBS0RsUyxZQUFZO0FBQ1YsUUFBSW1TLGdCQUFnQixLQUFLeGUsUUFBUTZHO0FBQ2pDLFFBQUk0WCxZQUFZQztBQUVoQixRQUFJLEtBQUtoWCxhQUFZLEdBQUk7QUFDdkIrVyxtQkFBYSxLQUFLelY7QUFDbEIwVixpQkFBVyxLQUFLelY7V0FDWDtBQUNMd1YsbUJBQWEsS0FBS3ZWO0FBQ2xCd1YsaUJBQVcsS0FBS3ZWO0FBRWhCcVYsc0JBQWdCLENBQUNBO0lBQ2xCO0FBQ0QsU0FBSzNHLGNBQWM0RztBQUNuQixTQUFLM0csWUFBWTRHO0FBQ2pCLFNBQUtwZCxpQkFBaUJrZDtBQUN0QixTQUFLcEksVUFBVXNJLFdBQVdEO0FBQzFCLFNBQUtFLGlCQUFpQixLQUFLM2UsUUFBUTRlO0VBQ3BDO0VBRURMLGNBQWM7QUFDWnpCLGFBQUssS0FBSzljLFFBQVF1ZSxhQUFhO01BQUM7SUFBSyxDQUFBO0VBQ3RDO0VBSURwQixzQkFBc0I7QUFDcEJMLGFBQUssS0FBSzljLFFBQVFtZCxxQkFBcUI7TUFBQztJQUFLLENBQUE7RUFDOUM7RUFDREMsZ0JBQWdCO0FBRWQsUUFBSSxLQUFLMVYsYUFBWSxHQUFJO0FBRXZCLFdBQUtpQixRQUFRLEtBQUtnUjtBQUNsQixXQUFLM1EsT0FBTztBQUNaLFdBQUtDLFFBQVEsS0FBS047V0FDYjtBQUNMLFdBQUtFLFNBQVMsS0FBS3lSO0FBR25CLFdBQUtwUixNQUFNO0FBQ1gsV0FBS0MsU0FBUyxLQUFLTjtJQUNwQjtBQUdELFNBQUs0UixjQUFjO0FBQ25CLFNBQUtGLGFBQWE7QUFDbEIsU0FBS0csZUFBZTtBQUNwQixTQUFLRixnQkFBZ0I7RUFDdEI7RUFDRDZDLHFCQUFxQjtBQUNuQlAsYUFBSyxLQUFLOWMsUUFBUXFkLG9CQUFvQjtNQUFDO0lBQUssQ0FBQTtFQUM3QztFQUVEd0IsV0FBV0MsT0FBTTtBQUNmLFNBQUs1YyxNQUFNNmMsY0FBY0QsT0FBTSxLQUFLNVEsV0FBVSxDQUFFO0FBQ2hENE8sYUFBSyxLQUFLOWMsUUFBUThlLFFBQU87TUFBQztJQUFLLENBQUE7RUFDaEM7RUFHRHhCLG1CQUFtQjtBQUNqQixTQUFLdUIsV0FBVyxrQkFBa0I7RUFDbkM7RUFDRHRCLHNCQUFzQjtFQUFBO0VBQ3RCQyxrQkFBa0I7QUFDaEIsU0FBS3FCLFdBQVcsaUJBQWlCO0VBQ2xDO0VBR0RuQixtQkFBbUI7QUFDakIsU0FBS21CLFdBQVcsa0JBQWtCO0VBQ25DO0VBSURsQixhQUFhO0FBQ1gsV0FBTyxDQUFBO0VBQ1I7RUFDREMsa0JBQWtCO0FBQ2hCLFNBQUtpQixXQUFXLGlCQUFpQjtFQUNsQztFQUVERyw4QkFBOEI7QUFDNUJsQyxhQUFLLEtBQUs5YyxRQUFRZ2YsNkJBQTZCO01BQUM7SUFBSyxDQUFBO0VBQ3REO0VBS0RDLG1CQUFtQnJLLE9BQU87QUFDeEIsVUFBTUMsV0FBVyxLQUFLN1UsUUFBUTRVO0FBQzlCLFFBQUlyUyxHQUFHQyxNQUFNNlc7QUFDYixTQUFLOVcsSUFBSSxHQUFHQyxPQUFPb1MsTUFBTXhULFFBQVFtQixJQUFJQyxNQUFNRCxLQUFLO0FBQzlDOFcsYUFBT3pFLE1BQU1yUztBQUNiOFcsV0FBSzZGLFFBQVFwQyxTQUFLakksU0FBU3NLLFVBQVU7UUFBQzlGLEtBQUt4WTtRQUFPMEI7UUFBR3FTO1NBQVEsSUFBSTtJQUNsRTtFQUNGO0VBQ0R3Syw2QkFBNkI7QUFDM0J0QyxhQUFLLEtBQUs5YyxRQUFRb2YsNEJBQTRCO01BQUM7SUFBSyxDQUFBO0VBQ3JEO0VBSURyQiwrQkFBK0I7QUFDN0JqQixhQUFLLEtBQUs5YyxRQUFRK2QsOEJBQThCO01BQUM7SUFBSyxDQUFBO0VBQ3ZEO0VBQ0RDLHlCQUF5QjtBQUN2QixVQUFNaGUsVUFBVSxLQUFLQTtBQUNyQixVQUFNNlUsV0FBVzdVLFFBQVE0VTtBQUN6QixVQUFNeUssV0FBVyxLQUFLekssTUFBTXhUO0FBQzVCLFVBQU1rZSxjQUFjekssU0FBU3lLLGVBQWU7QUFDNUMsVUFBTUMsY0FBYzFLLFNBQVMwSztBQUM3QixRQUFJNUUsZ0JBQWdCMkU7QUFDcEIsUUFBSUUsV0FBV2xGLFdBQVdtRjtBQUUxQixRQUFJLENBQUMsS0FBS0MsV0FBVSxLQUFNLENBQUM3SyxTQUFTOUgsV0FBV3VTLGVBQWVDLGVBQWVGLFlBQVksS0FBSyxDQUFDLEtBQUszWCxhQUFZLEdBQUk7QUFDbEgsV0FBS2lULGdCQUFnQjJFO0FBQ3JCO0lBQ0Q7QUFFRCxVQUFNSyxhQUFhLEtBQUtDLGVBQWM7QUFDdEMsVUFBTUMsZ0JBQWdCRixXQUFXRyxPQUFPblg7QUFDeEMsVUFBTW9YLGlCQUFpQkosV0FBV0ssUUFBUW5YO0FBSTFDLFVBQU04USxXQUFXc0csWUFBWSxLQUFLL2QsTUFBTXlHLFFBQVFrWCxlQUFlLEdBQUcsS0FBS2xHLFFBQVE7QUFDL0U2RixnQkFBWXhmLFFBQVFnVyxTQUFTLEtBQUsyRCxXQUFXMEYsV0FBVzFGLFlBQVkwRixXQUFXO0FBRy9FLFFBQUlRLGdCQUFnQixJQUFJTCxXQUFXO0FBQ2pDQSxrQkFBWTdGLFlBQVkwRixZQUFZcmYsUUFBUWdXLFNBQVMsTUFBTTtBQUMzRHNFLGtCQUFZLEtBQUtBLFlBQVkvQixrQkFBa0J2WSxRQUFRa2dCLElBQUksSUFDM0RyTCxTQUFTbEosVUFBVThNLGVBQWV6WSxRQUFRbWdCLE9BQU8sS0FBS2plLE1BQU1sQyxRQUFRMlksSUFBSTtBQUN4RThHLHlCQUFtQnJjLEtBQUtLLEtBQUtvYyxnQkFBZ0JBLGdCQUFnQkUsaUJBQWlCQSxjQUFjO0FBQzVGcEYsc0JBQWdCeUYsVUFBVWhkLEtBQUs2UixJQUM3QjdSLEtBQUtpZCxLQUFLSixhQUFhTixXQUFXSyxRQUFRblgsU0FBUyxLQUFLMlcsV0FBVyxJQUFJLENBQUMsQ0FBQyxHQUN6RXBjLEtBQUtpZCxLQUFLSixZQUFZM0YsWUFBWW1GLGtCQUFrQixJQUFJLENBQUMsQ0FBQyxJQUFJcmMsS0FBS2lkLEtBQUtKLFlBQVlGLGlCQUFpQk4sa0JBQWtCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FDL0g7QUFDRDlFLHNCQUFnQnZYLEtBQUt3RyxJQUFJMFYsYUFBYWxjLEtBQUs2UixJQUFJc0ssYUFBYTVFLGFBQWEsQ0FBQztJQUMzRTtBQUVELFNBQUtBLGdCQUFnQkE7RUFDdEI7RUFDRHNELDhCQUE4QjtBQUM1Qm5CLGFBQUssS0FBSzljLFFBQVFpZSw2QkFBNkI7TUFBQztJQUFLLENBQUE7RUFDdEQ7RUFDREUsZ0JBQWdCO0VBQUE7RUFJaEJDLFlBQVk7QUFDVnRCLGFBQUssS0FBSzljLFFBQVFvZSxXQUFXO01BQUM7SUFBSyxDQUFBO0VBQ3BDO0VBQ0RDLE1BQU07QUFFSixVQUFNaUMsVUFBVTtNQUNkM1gsT0FBTztNQUNQRSxRQUFROztBQUdWLFVBQU0sRUFBQzNHLE9BQU9sQyxTQUFTLEVBQUM0VSxPQUFPQyxVQUFVc0wsT0FBT0ksV0FBV0wsTUFBTU0sU0FBUSxFQUFDLElBQUk7QUFDOUUsVUFBTXpULFVBQVUsS0FBSzJTLFdBQVU7QUFDL0IsVUFBTWhZLGVBQWUsS0FBS0EsYUFBWTtBQUV0QyxRQUFJcUYsU0FBUztBQUNYLFlBQU0wVCxjQUFjaEksZUFBZThILFdBQVdyZSxNQUFNbEMsUUFBUTJZLElBQUk7QUFDaEUsVUFBSWpSLGNBQWM7QUFDaEI0WSxnQkFBUTNYLFFBQVEsS0FBS2dSO0FBQ3JCMkcsZ0JBQVF6WCxTQUFTMFAsa0JBQWtCaUksUUFBUSxJQUFJQzthQUMxQztBQUNMSCxnQkFBUXpYLFNBQVMsS0FBS3lSO0FBQ3RCZ0csZ0JBQVEzWCxRQUFRNFAsa0JBQWtCaUksUUFBUSxJQUFJQztNQUMvQztBQUdELFVBQUk1TCxTQUFTOUgsV0FBVyxLQUFLNkgsTUFBTXhULFFBQVE7QUFDekMsY0FBTSxFQUFDb1UsT0FBT0MsTUFBTXFLLFFBQVFFLFFBQU8sSUFBSSxLQUFLSixlQUFjO0FBQzFELGNBQU1jLGNBQWM3TCxTQUFTbEosVUFBVTtBQUN2QyxjQUFNZ1YsZUFBZUMsVUFBVSxLQUFLakcsYUFBYTtBQUNqRCxjQUFNa0csTUFBTXpkLEtBQUt5ZCxJQUFJRixZQUFZO0FBQ2pDLGNBQU1HLE1BQU0xZCxLQUFLMGQsSUFBSUgsWUFBWTtBQUVqQyxZQUFJalosY0FBYztBQUVoQixnQkFBTXFaLGNBQWNsTSxTQUFTbU0sU0FBUyxJQUFJRixNQUFNaEIsT0FBT25YLFFBQVFrWSxNQUFNYixRQUFRblg7QUFDN0V5WCxrQkFBUXpYLFNBQVN6RixLQUFLNlIsSUFBSSxLQUFLcUYsV0FBV2dHLFFBQVF6WCxTQUFTa1ksY0FBY0wsV0FBVztlQUMvRTtBQUdMLGdCQUFNTyxhQUFhcE0sU0FBU21NLFNBQVMsSUFBSUgsTUFBTWYsT0FBT25YLFFBQVFtWSxNQUFNZCxRQUFRblg7QUFFNUV5WCxrQkFBUTNYLFFBQVF2RixLQUFLNlIsSUFBSSxLQUFLMEUsVUFBVTJHLFFBQVEzWCxRQUFRc1ksYUFBYVAsV0FBVztRQUNqRjtBQUNELGFBQUtRLGtCQUFrQjFMLE9BQU9DLE1BQU1xTCxLQUFLRCxHQUFHO01BQzdDO0lBQ0Y7QUFFRCxTQUFLTSxlQUFjO0FBRW5CLFFBQUl6WixjQUFjO0FBQ2hCLFdBQUtpQixRQUFRLEtBQUt5TixVQUFVbFUsTUFBTXlHLFFBQVEsS0FBSzBSLFNBQVNyUixPQUFPLEtBQUtxUixTQUFTcFI7QUFDN0UsV0FBS0osU0FBU3lYLFFBQVF6WDtXQUNqQjtBQUNMLFdBQUtGLFFBQVEyWCxRQUFRM1g7QUFDckIsV0FBS0UsU0FBUyxLQUFLdU4sVUFBVWxVLE1BQU0yRyxTQUFTLEtBQUt3UixTQUFTblIsTUFBTSxLQUFLbVIsU0FBU2xSO0lBQy9FO0VBQ0Y7RUFFRCtYLGtCQUFrQjFMLE9BQU9DLE1BQU1xTCxLQUFLRCxLQUFLO0FBQ3ZDLFVBQU0sRUFBQ2pNLE9BQU8sRUFBQ3dDLE9BQU96TCxRQUFPLEdBQUd4SixTQUFRLElBQUksS0FBS25DO0FBQ2pELFVBQU1vaEIsWUFBWSxLQUFLekcsa0JBQWtCO0FBQ3pDLFVBQU0wRyxtQkFBbUJsZixhQUFhLFNBQVMsS0FBS3ZCLFNBQVM7QUFFN0QsUUFBSSxLQUFLOEcsYUFBWSxHQUFJO0FBQ3ZCLFlBQU00WixhQUFhLEtBQUtySixnQkFBZ0IsQ0FBQyxJQUFJLEtBQUtqUDtBQUNsRCxZQUFNdVksY0FBYyxLQUFLdFksUUFBUSxLQUFLZ1AsZ0JBQWdCLEtBQUtyRCxNQUFNeFQsU0FBUyxDQUFDO0FBQzNFLFVBQUlxWixjQUFjO0FBQ2xCLFVBQUlDLGVBQWU7QUFJbkIsVUFBSTBHLFdBQVc7QUFDYixZQUFJQyxrQkFBa0I7QUFDcEI1Ryx3QkFBY29HLE1BQU1yTCxNQUFNN007QUFDMUIrUix5QkFBZW9HLE1BQU1yTCxLQUFLNU07ZUFDckI7QUFDTDRSLHdCQUFjcUcsTUFBTXRMLE1BQU0zTTtBQUMxQjZSLHlCQUFlbUcsTUFBTXBMLEtBQUs5TTtRQUMzQjtNQUNGLFdBQVV5TyxVQUFVLFNBQVM7QUFDNUJzRCx1QkFBZWpGLEtBQUs5TTtNQUNyQixXQUFVeU8sVUFBVSxPQUFPO0FBQzFCcUQsc0JBQWNqRixNQUFNN007TUFDckIsV0FBVXlPLFVBQVUsU0FBUztBQUM1QnFELHNCQUFjakYsTUFBTTdNLFFBQVE7QUFDNUIrUix1QkFBZWpGLEtBQUs5TSxRQUFRO01BQzdCO0FBR0QsV0FBSzhSLGNBQWNyWCxLQUFLd0csS0FBSzZRLGNBQWM2RyxhQUFhM1YsV0FBVyxLQUFLaEQsU0FBUyxLQUFLQSxRQUFRMlksYUFBYSxDQUFDO0FBQzVHLFdBQUs1RyxlQUFldFgsS0FBS3dHLEtBQUs4USxlQUFlNkcsY0FBYzVWLFdBQVcsS0FBS2hELFNBQVMsS0FBS0EsUUFBUTRZLGNBQWMsQ0FBQztXQUMzRztBQUNMLFVBQUloSCxhQUFhOUUsS0FBSzVNLFNBQVM7QUFDL0IsVUFBSTJSLGdCQUFnQmhGLE1BQU0zTSxTQUFTO0FBRW5DLFVBQUl1TyxVQUFVLFNBQVM7QUFDckJtRCxxQkFBYTtBQUNiQyx3QkFBZ0JoRixNQUFNM007TUFDdkIsV0FBVXVPLFVBQVUsT0FBTztBQUMxQm1ELHFCQUFhOUUsS0FBSzVNO0FBQ2xCMlIsd0JBQWdCO01BQ2pCO0FBRUQsV0FBS0QsYUFBYUEsYUFBYTVPO0FBQy9CLFdBQUs2TyxnQkFBZ0JBLGdCQUFnQjdPO0lBQ3RDO0VBQ0Y7RUFNRHdWLGlCQUFpQjtBQUNmLFFBQUksS0FBSzlHLFVBQVU7QUFDakIsV0FBS0EsU0FBU3JSLE9BQU81RixLQUFLd0csSUFBSSxLQUFLNlEsYUFBYSxLQUFLSixTQUFTclIsSUFBSTtBQUNsRSxXQUFLcVIsU0FBU25SLE1BQU05RixLQUFLd0csSUFBSSxLQUFLMlEsWUFBWSxLQUFLRixTQUFTblIsR0FBRztBQUMvRCxXQUFLbVIsU0FBU3BSLFFBQVE3RixLQUFLd0csSUFBSSxLQUFLOFEsY0FBYyxLQUFLTCxTQUFTcFIsS0FBSztBQUNyRSxXQUFLb1IsU0FBU2xSLFNBQVMvRixLQUFLd0csSUFBSSxLQUFLNFEsZUFBZSxLQUFLSCxTQUFTbFIsTUFBTTtJQUN6RTtFQUNGO0VBRURtVixXQUFXO0FBQ1R4QixhQUFLLEtBQUs5YyxRQUFRc2UsVUFBVTtNQUFDO0lBQUssQ0FBQTtFQUNuQztFQU1ENVcsZUFBZTtBQUNiLFVBQU0sRUFBQzlHLE1BQU11QixTQUFRLElBQUksS0FBS25DO0FBQzlCLFdBQU9tQyxhQUFhLFNBQVNBLGFBQWEsWUFBWXZCLFNBQVM7RUFDaEU7RUFJRDRnQixhQUFhO0FBQ1gsV0FBTyxLQUFLeGhCLFFBQVF5STtFQUNyQjtFQU1EcVYsc0JBQXNCbEosT0FBTztBQUMzQixTQUFLb0ssNEJBQTJCO0FBRWhDLFNBQUtDLG1CQUFtQnJLLEtBQUs7QUFHN0IsUUFBSXJTLEdBQUdDO0FBQ1AsU0FBS0QsSUFBSSxHQUFHQyxPQUFPb1MsTUFBTXhULFFBQVFtQixJQUFJQyxNQUFNRCxLQUFLO0FBQzlDLFVBQUl3USxjQUFjNkIsTUFBTXJTLEdBQUcyYyxLQUFLLEdBQUc7QUFDakN0SyxjQUFNeEksT0FBTzdKLEdBQUcsQ0FBQztBQUNqQkM7QUFDQUQ7TUFDRDtJQUNGO0FBRUQsU0FBSzZjLDJCQUEwQjtFQUNoQztFQU1EUSxpQkFBaUI7QUFDZixRQUFJRCxhQUFhLEtBQUs1RTtBQUV0QixRQUFJLENBQUM0RSxZQUFZO0FBQ2YsWUFBTXpDLGFBQWEsS0FBS2xkLFFBQVE0VSxNQUFNc0k7QUFDdEMsVUFBSXRJLFFBQVEsS0FBS0E7QUFDakIsVUFBSXNJLGFBQWF0SSxNQUFNeFQsUUFBUTtBQUM3QndULGdCQUFRMkMsT0FBTzNDLE9BQU9zSSxVQUFVO01BQ2pDO0FBRUQsV0FBS25DLGNBQWM0RSxhQUFhLEtBQUs4QixtQkFBbUI3TSxPQUFPQSxNQUFNeFQsTUFBTTtJQUM1RTtBQUVELFdBQU91ZTtFQUNSO0VBUUQ4QixtQkFBbUI3TSxPQUFPeFQsUUFBUTtBQUNoQyxVQUFNLEVBQUN3UixLQUFLb0ksbUJBQW1CN0MsT0FBTSxJQUFJO0FBQ3pDLFVBQU11SixTQUFTLENBQUE7QUFDZixVQUFNQyxVQUFVLENBQUE7QUFDaEIsUUFBSUMsa0JBQWtCO0FBQ3RCLFFBQUlDLG1CQUFtQjtBQUN2QixRQUFJdGYsR0FBR0csR0FBR29mLE1BQU01QyxPQUFPNkMsVUFBVUMsWUFBWTVKLE9BQU9ZLFlBQVlyUSxPQUFPRSxRQUFRb1o7QUFFL0UsU0FBSzFmLElBQUksR0FBR0EsSUFBSW5CLFFBQVEsRUFBRW1CLEdBQUc7QUFDM0IyYyxjQUFRdEssTUFBTXJTLEdBQUcyYztBQUNqQjZDLGlCQUFXLEtBQUtHLHdCQUF3QjNmLENBQUM7QUFDekNxUSxVQUFJK0YsT0FBT3FKLGFBQWFELFNBQVNJO0FBQ2pDL0osY0FBUUQsT0FBTzZKLGNBQWM3SixPQUFPNkosZUFBZTtRQUFDaGhCLE1BQU0sQ0FBQTtRQUFJcVgsSUFBSSxDQUFBOztBQUNsRVcsbUJBQWErSSxTQUFTL0k7QUFDdEJyUSxjQUFRRSxTQUFTO0FBRWpCLFVBQUksQ0FBQ2tLLGNBQWNtTSxLQUFLLEtBQUssQ0FBQ3BHLFFBQVFvRyxLQUFLLEdBQUc7QUFDNUN2VyxnQkFBUXlaLGFBQWF4UCxLQUFLd0YsTUFBTXBYLE1BQU1vWCxNQUFNQyxJQUFJMVAsT0FBT3VXLEtBQUs7QUFDNURyVyxpQkFBU21RO01BQ1YsV0FBVUYsUUFBUW9HLEtBQUssR0FBRztBQUV6QixhQUFLeGMsSUFBSSxHQUFHb2YsT0FBTzVDLE1BQU05ZCxRQUFRc0IsSUFBSW9mLE1BQU0sRUFBRXBmLEdBQUc7QUFDOUN1Zix3QkFBYy9DLE1BQU14YztBQUVwQixjQUFJLENBQUNxUSxjQUFja1AsV0FBVyxLQUFLLENBQUNuSixRQUFRbUosV0FBVyxHQUFHO0FBQ3hEdFosb0JBQVF5WixhQUFheFAsS0FBS3dGLE1BQU1wWCxNQUFNb1gsTUFBTUMsSUFBSTFQLE9BQU9zWixXQUFXO0FBQ2xFcFosc0JBQVVtUTtVQUNYO1FBQ0Y7TUFDRjtBQUNEMEksYUFBT3JkLEtBQUtzRSxLQUFLO0FBQ2pCZ1osY0FBUXRkLEtBQUt3RSxNQUFNO0FBQ25CK1ksd0JBQWtCeGUsS0FBS3dHLElBQUlqQixPQUFPaVosZUFBZTtBQUNqREMseUJBQW1CemUsS0FBS3dHLElBQUlmLFFBQVFnWixnQkFBZ0I7SUFDckQ7QUFDRDNKLG1CQUFlQyxRQUFRL1csTUFBTTtBQUU3QixVQUFNMGUsU0FBUzRCLE9BQU8zZSxRQUFRNmUsZUFBZTtBQUM3QyxVQUFNNUIsVUFBVTJCLFFBQVE1ZSxRQUFROGUsZ0JBQWdCO0FBRWhELFVBQU1RLFVBQVUsQ0FBQ0MsU0FBUztNQUFDM1osT0FBTytZLE9BQU9ZLFFBQVE7TUFBR3paLFFBQVE4WSxRQUFRVyxRQUFRO0lBQUU7QUFFOUUsV0FBTztNQUNMOU0sT0FBTzZNLFFBQVEsQ0FBQztNQUNoQjVNLE1BQU00TSxRQUFRamhCLFNBQVMsQ0FBQztNQUN4QjBlLFFBQVF1QyxRQUFRdkMsTUFBTTtNQUN0QkUsU0FBU3FDLFFBQVFyQyxPQUFPO01BQ3hCMEI7TUFDQUM7O0VBRUg7RUFPRFksaUJBQWlCMWhCLE9BQU87QUFDdEIsV0FBT0E7RUFDUjtFQVNEbVosaUJBQWlCblosT0FBTzRCLE9BQU87QUFDN0IsV0FBTytmO0VBQ1I7RUFRREMsaUJBQWlCQyxPQUFPO0VBQUE7RUFReEJ6SyxnQkFBZ0J4VixPQUFPO0FBQ3JCLFVBQU1tUyxRQUFRLEtBQUtBO0FBQ25CLFFBQUluUyxRQUFRLEtBQUtBLFFBQVFtUyxNQUFNeFQsU0FBUyxHQUFHO0FBQ3pDLGFBQU87SUFDUjtBQUNELFdBQU8sS0FBSzRZLGlCQUFpQnBGLE1BQU1uUyxPQUFPNUIsS0FBSztFQUNoRDtFQVFEOGhCLG1CQUFtQkMsU0FBUztBQUMxQixRQUFJLEtBQUt0aEIsZ0JBQWdCO0FBQ3ZCc2hCLGdCQUFVLElBQUlBO0lBQ2Y7QUFFRCxVQUFNRixRQUFRLEtBQUs3SyxjQUFjK0ssVUFBVSxLQUFLeE07QUFDaEQsV0FBT3lNLFlBQVksS0FBS2xFLGlCQUFpQm1FLFlBQVksS0FBSzVnQixPQUFPd2dCLE9BQU8sQ0FBQyxJQUFJQSxLQUFLO0VBQ25GO0VBTURLLG1CQUFtQkwsT0FBTztBQUN4QixVQUFNRSxXQUFXRixRQUFRLEtBQUs3SyxlQUFlLEtBQUt6QjtBQUNsRCxXQUFPLEtBQUs5VSxpQkFBaUIsSUFBSXNoQixVQUFVQTtFQUM1QztFQU9ESSxlQUFlO0FBQ2IsV0FBTyxLQUFLaEosaUJBQWlCLEtBQUtpSixhQUFZLENBQUU7RUFDakQ7RUFLREEsZUFBZTtBQUNiLFVBQU0sRUFBQ2hPLEtBQUtyTCxJQUFHLElBQUk7QUFFbkIsV0FBT3FMLE1BQU0sS0FBS3JMLE1BQU0sSUFBSUEsTUFDMUJxTCxNQUFNLEtBQUtyTCxNQUFNLElBQUlxTCxNQUNyQjtFQUNIO0VBS0QvRyxXQUFXekwsT0FBTztBQUNoQixVQUFNbVMsUUFBUSxLQUFLQSxTQUFTLENBQUE7QUFFNUIsUUFBSW5TLFNBQVMsS0FBS0EsUUFBUW1TLE1BQU14VCxRQUFRO0FBQ3RDLFlBQU1pWSxPQUFPekUsTUFBTW5TO0FBQ25CLGFBQU80VyxLQUFLb0MsYUFDYnBDLEtBQUtvQyxXQUFXckMsa0JBQWtCLEtBQUtsTCxXQUFVLEdBQUl6TCxPQUFPNFcsSUFBSTtJQUNoRTtBQUNELFdBQU8sS0FBS29DLGFBQ1osS0FBS0EsV0FBV3hDLG1CQUFtQixLQUFLL1csTUFBTWdNLFdBQVUsR0FBSSxJQUFJO0VBQ2pFO0VBTURnSSxZQUFZO0FBQ1YsVUFBTWdOLGNBQWMsS0FBS2xqQixRQUFRNFU7QUFHakMsVUFBTXVPLE1BQU12QyxVQUFVLEtBQUtqRyxhQUFhO0FBQ3hDLFVBQU1rRyxNQUFNemQsS0FBS0MsSUFBSUQsS0FBS3lkLElBQUlzQyxHQUFHLENBQUM7QUFDbEMsVUFBTXJDLE1BQU0xZCxLQUFLQyxJQUFJRCxLQUFLMGQsSUFBSXFDLEdBQUcsQ0FBQztBQUVsQyxVQUFNeEQsYUFBYSxLQUFLQyxlQUFjO0FBQ3RDLFVBQU1qVSxVQUFVdVgsWUFBWUUsbUJBQW1CO0FBQy9DLFVBQU03WSxJQUFJb1YsYUFBYUEsV0FBV0csT0FBT25YLFFBQVFnRCxVQUFVO0FBQzNELFVBQU1sQixLQUFJa1YsYUFBYUEsV0FBV0ssUUFBUW5YLFNBQVM4QyxVQUFVO0FBRzdELFdBQU8sS0FBS2pFLGFBQVksSUFDcEIrQyxLQUFJb1csTUFBTXRXLElBQUl1VyxNQUFNdlcsSUFBSXNXLE1BQU1wVyxLQUFJcVcsTUFDbENyVyxLQUFJcVcsTUFBTXZXLElBQUlzVyxNQUFNcFcsS0FBSW9XLE1BQU10VyxJQUFJdVc7RUFDdkM7RUFNRHBCLGFBQWE7QUFDWCxVQUFNM1MsVUFBVSxLQUFLL00sUUFBUStNO0FBRTdCLFFBQUlBLFlBQVksUUFBUTtBQUN0QixhQUFPLENBQUMsQ0FBQ0E7SUFDVjtBQUVELFdBQU8sS0FBS3dQLHdCQUF1QixFQUFHbmIsU0FBUztFQUNoRDtFQUtEaWlCLHNCQUFzQmxmLFdBQVc7QUFDL0IsVUFBTXZELE9BQU8sS0FBS0E7QUFDbEIsVUFBTXNCLFFBQVEsS0FBS0E7QUFDbkIsVUFBTWxDLFVBQVUsS0FBS0E7QUFDckIsVUFBTSxFQUFDa2dCLE1BQU0vZCxVQUFVbWhCLE9BQU0sSUFBSXRqQjtBQUNqQyxVQUFNZ1csU0FBU2tLLEtBQUtsSztBQUNwQixVQUFNdE8sZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU1rTixRQUFRLEtBQUtBO0FBQ25CLFVBQU0yTyxjQUFjM08sTUFBTXhULFVBQVU0VSxTQUFTLElBQUk7QUFDakQsVUFBTXdOLEtBQUtqTCxrQkFBa0IySCxJQUFJO0FBQ2pDLFVBQU1wYyxRQUFRLENBQUE7QUFFZCxVQUFNMmYsYUFBYUgsT0FBTzVILFdBQVcsS0FBS3hOLFdBQVUsQ0FBRTtBQUN0RCxVQUFNd1YsWUFBWUQsV0FBVzFXLFVBQVUwVyxXQUFXOWEsUUFBUTtBQUMxRCxVQUFNZ2IsZ0JBQWdCRCxZQUFZO0FBQ2xDLFVBQU1FLG1CQUFtQixTQUFTbEIsT0FBTztBQUN2QyxhQUFPSSxZQUFZNWdCLE9BQU93Z0IsT0FBT2dCLFNBQVM7O0FBRTVDLFFBQUlHLGFBQWF0aEIsR0FBR3lWLFdBQVc4TDtBQUMvQixRQUFJQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQyxJQUFJQyxJQUFJQyxJQUFJQztBQUVwQyxRQUFJbmlCLGFBQWEsT0FBTztBQUN0QjBoQixvQkFBY0QsaUJBQWlCLEtBQUt6YSxNQUFNO0FBQzFDNmEsWUFBTSxLQUFLN2EsU0FBU3FhO0FBQ3BCVSxZQUFNTCxjQUFjRjtBQUNwQlMsV0FBS1IsaUJBQWlCemYsVUFBVStFLEdBQUcsSUFBSXlhO0FBQ3ZDVyxXQUFLbmdCLFVBQVVnRjtJQUNoQixXQUFVaEgsYUFBYSxVQUFVO0FBQ2hDMGhCLG9CQUFjRCxpQkFBaUIsS0FBSzFhLEdBQUc7QUFDdkNrYixXQUFLamdCLFVBQVUrRTtBQUNmb2IsV0FBS1YsaUJBQWlCemYsVUFBVWdGLE1BQU0sSUFBSXdhO0FBQzFDSyxZQUFNSCxjQUFjRjtBQUNwQk8sWUFBTSxLQUFLaGIsTUFBTXNhO0lBQ2xCLFdBQVVyaEIsYUFBYSxRQUFRO0FBQzlCMGhCLG9CQUFjRCxpQkFBaUIsS0FBSzNhLEtBQUs7QUFDekM4YSxZQUFNLEtBQUs5YSxRQUFRdWE7QUFDbkJTLFlBQU1KLGNBQWNGO0FBQ3BCUSxXQUFLUCxpQkFBaUJ6ZixVQUFVNkUsSUFBSSxJQUFJMmE7QUFDeENVLFdBQUtsZ0IsVUFBVThFO0lBQ2hCLFdBQVU5RyxhQUFhLFNBQVM7QUFDL0IwaEIsb0JBQWNELGlCQUFpQixLQUFLNWEsSUFBSTtBQUN4Q21iLFdBQUtoZ0IsVUFBVTZFO0FBQ2ZxYixXQUFLVCxpQkFBaUJ6ZixVQUFVOEUsS0FBSyxJQUFJMGE7QUFDekNJLFlBQU1GLGNBQWNGO0FBQ3BCTSxZQUFNLEtBQUtqYixPQUFPd2E7SUFDbkIsV0FBVTVpQixTQUFTLEtBQUs7QUFDdkIsVUFBSXVCLGFBQWEsVUFBVTtBQUN6QjBoQixzQkFBY0Qsa0JBQWtCemYsVUFBVStFLE1BQU0vRSxVQUFVZ0YsVUFBVSxJQUFJLEdBQUc7TUFDNUUsV0FBVWEsU0FBUzdILFFBQVEsR0FBRztBQUM3QixjQUFNNFgsaUJBQWlCbmEsT0FBT3NULEtBQUsvUSxRQUFRLEVBQUU7QUFDN0MsY0FBTXRCLFFBQVFzQixTQUFTNFg7QUFDdkI4SixzQkFBY0QsaUJBQWlCLEtBQUsxaEIsTUFBTXVYLE9BQU9NLGdCQUFnQkMsaUJBQWlCblosS0FBSyxDQUFDO01BQ3pGO0FBRUR1akIsV0FBS2pnQixVQUFVK0U7QUFDZm9iLFdBQUtuZ0IsVUFBVWdGO0FBQ2Y2YSxZQUFNSCxjQUFjRjtBQUNwQk8sWUFBTUYsTUFBTVI7SUFDYixXQUFVNWlCLFNBQVMsS0FBSztBQUN2QixVQUFJdUIsYUFBYSxVQUFVO0FBQ3pCMGhCLHNCQUFjRCxrQkFBa0J6ZixVQUFVNkUsT0FBTzdFLFVBQVU4RSxTQUFTLENBQUM7TUFDdEUsV0FBVWUsU0FBUzdILFFBQVEsR0FBRztBQUM3QixjQUFNNFgsa0JBQWlCbmEsT0FBT3NULEtBQUsvUSxRQUFRLEVBQUU7QUFDN0MsY0FBTXRCLFNBQVFzQixTQUFTNFg7QUFDdkI4SixzQkFBY0QsaUJBQWlCLEtBQUsxaEIsTUFBTXVYLE9BQU9NLGlCQUFnQkMsaUJBQWlCblosTUFBSyxDQUFDO01BQ3pGO0FBRURrakIsWUFBTUYsY0FBY0Y7QUFDcEJNLFlBQU1GLE1BQU1QO0FBQ1pXLFdBQUtoZ0IsVUFBVTZFO0FBQ2ZxYixXQUFLbGdCLFVBQVU4RTtJQUNoQjtBQUVELFVBQU1zYixRQUFRdk4sZUFBZWhYLFFBQVE0VSxNQUFNTSxlQUFlcU8sV0FBVztBQUNyRSxVQUFNaUIsT0FBT3BoQixLQUFLd0csSUFBSSxHQUFHeEcsS0FBS3lULEtBQUswTSxjQUFjZ0IsS0FBSyxDQUFDO0FBQ3ZELFNBQUtoaUIsSUFBSSxHQUFHQSxJQUFJZ2hCLGFBQWFoaEIsS0FBS2lpQixNQUFNO0FBQ3RDLFlBQU1sWCxVQUFVLEtBQUtZLFdBQVczTCxDQUFDO0FBQ2pDLFlBQU1raUIsY0FBY3ZFLEtBQUt4RSxXQUFXcE8sT0FBTztBQUMzQyxZQUFNb1gsb0JBQW9CcEIsT0FBTzVILFdBQVdwTyxPQUFPO0FBRW5ELFlBQU1xWCxZQUFZRixZQUFZRTtBQUM5QixZQUFNQyxZQUFZSCxZQUFZSTtBQUM5QixZQUFNQyxhQUFhSixrQkFBa0JLLFFBQVEsQ0FBQTtBQUM3QyxZQUFNQyxtQkFBbUJOLGtCQUFrQk87QUFFM0MsWUFBTXpGLFlBQVlpRixZQUFZakY7QUFDOUIsWUFBTTBGLFlBQVlULFlBQVlTO0FBQzlCLFlBQU1DLGlCQUFpQlYsWUFBWVUsa0JBQWtCLENBQUE7QUFDckQsWUFBTUMsdUJBQXVCWCxZQUFZVztBQUV6Q3BOLGtCQUFZTixvQkFBb0IsTUFBTW5WLEdBQUd5VCxNQUFNO0FBRy9DLFVBQUlnQyxjQUFjdkksUUFBVztBQUMzQjtNQUNEO0FBRURxVSx5QkFBbUJoQixZQUFZNWdCLE9BQU84VixXQUFXMk0sU0FBUztBQUUxRCxVQUFJamQsY0FBYztBQUNoQnFjLGNBQU1FLE1BQU1FLEtBQUtFLEtBQUtQO2FBQ2pCO0FBQ0xFLGNBQU1FLE1BQU1FLEtBQUtFLEtBQUtSO01BQ3ZCO0FBRURoZ0IsWUFBTU8sS0FBSztRQUNUMGY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQTNiLE9BQU9nYztRQUNQRSxPQUFPRDtRQUNQRTtRQUNBRTtRQUNBeEY7UUFDQTBGO1FBQ0FDO1FBQ0FDO01BQ0QsQ0FBQTtJQUNGO0FBRUQsU0FBSy9KLGVBQWVrSTtBQUNwQixTQUFLakksZUFBZXVJO0FBRXBCLFdBQU8vZjtFQUNSO0VBS0R1aEIsbUJBQW1CbGhCLFdBQVc7QUFDNUIsVUFBTXZELE9BQU8sS0FBS0E7QUFDbEIsVUFBTVosVUFBVSxLQUFLQTtBQUNyQixVQUFNLEVBQUNtQyxVQUFVeVMsT0FBT3NPLFlBQVcsSUFBSWxqQjtBQUN2QyxVQUFNMEgsZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU1rTixRQUFRLEtBQUtBO0FBQ25CLFVBQU0sRUFBQ3dDLE9BQU9rTyxZQUFZM1osU0FBU3FWLE9BQU0sSUFBSWtDO0FBQzdDLFVBQU1NLEtBQUtqTCxrQkFBa0J2WSxRQUFRa2dCLElBQUk7QUFDekMsVUFBTXFGLGlCQUFpQi9CLEtBQUs3WDtBQUM1QixVQUFNNlosa0JBQWtCeEUsU0FBUyxDQUFDclYsVUFBVTRaO0FBQzVDLFVBQU03TCxXQUFXLENBQUNrSCxVQUFVLEtBQUtqRyxhQUFhO0FBQzlDLFVBQU03VyxRQUFRLENBQUE7QUFDZCxRQUFJdkIsR0FBR0MsTUFBTTZXLE1BQU02RixPQUFPNWIsR0FBR0UsR0FBR2lpQixXQUFXL0MsT0FBTy9KLE1BQU1LLFlBQVkwTSxXQUFXQztBQUMvRSxRQUFJQyxlQUFlO0FBRW5CLFFBQUl6akIsYUFBYSxPQUFPO0FBQ3RCcUIsVUFBSSxLQUFLMkYsU0FBU3FjO0FBQ2xCQyxrQkFBWSxLQUFLSSx3QkFBdUI7SUFDekMsV0FBVTFqQixhQUFhLFVBQVU7QUFDaENxQixVQUFJLEtBQUswRixNQUFNc2M7QUFDZkMsa0JBQVksS0FBS0ksd0JBQXVCO0lBQ3pDLFdBQVUxakIsYUFBYSxRQUFRO0FBQzlCLFlBQU1tUyxNQUFNLEtBQUt3Uix3QkFBd0J0QyxFQUFFO0FBQzNDaUMsa0JBQVluUixJQUFJbVI7QUFDaEJuaUIsVUFBSWdSLElBQUloUjtJQUNULFdBQVVuQixhQUFhLFNBQVM7QUFDL0IsWUFBTW1TLE9BQU0sS0FBS3dSLHdCQUF3QnRDLEVBQUU7QUFDM0NpQyxrQkFBWW5SLEtBQUltUjtBQUNoQm5pQixVQUFJZ1IsS0FBSWhSO0lBQ1QsV0FBVTFDLFNBQVMsS0FBSztBQUN2QixVQUFJdUIsYUFBYSxVQUFVO0FBQ3pCcUIsYUFBTVcsVUFBVStFLE1BQU0vRSxVQUFVZ0YsVUFBVSxJQUFLb2M7TUFDaEQsV0FBVXZiLFNBQVM3SCxRQUFRLEdBQUc7QUFDN0IsY0FBTTRYLGlCQUFpQm5hLE9BQU9zVCxLQUFLL1EsUUFBUSxFQUFFO0FBQzdDLGNBQU10QixRQUFRc0IsU0FBUzRYO0FBQ3ZCdlcsWUFBSSxLQUFLdEIsTUFBTXVYLE9BQU9NLGdCQUFnQkMsaUJBQWlCblosS0FBSyxJQUFJMGtCO01BQ2pFO0FBQ0RFLGtCQUFZLEtBQUtJLHdCQUF1QjtJQUN6QyxXQUFVamxCLFNBQVMsS0FBSztBQUN2QixVQUFJdUIsYUFBYSxVQUFVO0FBQ3pCbUIsYUFBTWEsVUFBVTZFLE9BQU83RSxVQUFVOEUsU0FBUyxJQUFLc2M7TUFDaEQsV0FBVXZiLFNBQVM3SCxRQUFRLEdBQUc7QUFDN0IsY0FBTTRYLGtCQUFpQm5hLE9BQU9zVCxLQUFLL1EsUUFBUSxFQUFFO0FBQzdDLGNBQU10QixTQUFRc0IsU0FBUzRYO0FBQ3ZCelcsWUFBSSxLQUFLcEIsTUFBTXVYLE9BQU9NLGlCQUFnQkMsaUJBQWlCblosTUFBSztNQUM3RDtBQUNENGtCLGtCQUFZLEtBQUtLLHdCQUF3QnRDLEVBQUUsRUFBRWlDO0lBQzlDO0FBRUQsUUFBSTdrQixTQUFTLEtBQUs7QUFDaEIsVUFBSXdXLFVBQVUsU0FBUztBQUNyQndPLHVCQUFlO01BQ2hCLFdBQVV4TyxVQUFVLE9BQU87QUFDMUJ3Tyx1QkFBZTtNQUNoQjtJQUNGO0FBRUQsVUFBTWpHLGFBQWEsS0FBS0MsZUFBYztBQUN0QyxTQUFLcmQsSUFBSSxHQUFHQyxPQUFPb1MsTUFBTXhULFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDOUM4VyxhQUFPekUsTUFBTXJTO0FBQ2IyYyxjQUFRN0YsS0FBSzZGO0FBRWIsWUFBTXVGLGNBQWN2QixZQUFZeEgsV0FBVyxLQUFLeE4sV0FBVzNMLENBQUMsQ0FBQztBQUM3RG1nQixjQUFRLEtBQUt6SyxnQkFBZ0IxVixDQUFDLElBQUkyZ0IsWUFBWTZDO0FBQzlDcE4sYUFBTyxLQUFLdUosd0JBQXdCM2YsQ0FBQztBQUNyQ3lXLG1CQUFhTCxLQUFLSztBQUNsQjBNLGtCQUFZNU0sUUFBUW9HLEtBQUssSUFBSUEsTUFBTTlkLFNBQVM7QUFDNUMsWUFBTTRrQixZQUFZTixZQUFZO0FBQzlCLFlBQU1iLFNBQVFKLFlBQVlJO0FBQzFCLFlBQU1vQixjQUFjeEIsWUFBWXlCO0FBQ2hDLFlBQU1DLGNBQWMxQixZQUFZMkI7QUFDaEMsVUFBSUMsZ0JBQWdCWjtBQUVwQixVQUFJL2QsY0FBYztBQUNoQnBFLFlBQUlvZjtBQUVKLFlBQUkrQyxjQUFjLFNBQVM7QUFDekIsY0FBSWxqQixNQUFNQyxPQUFPLEdBQUc7QUFDbEI2akIsNEJBQWdCLENBQUMsS0FBS3JtQixRQUFRNkcsVUFBVSxVQUFVO1VBQ25ELFdBQVV0RSxNQUFNLEdBQUc7QUFDbEI4akIsNEJBQWdCLENBQUMsS0FBS3JtQixRQUFRNkcsVUFBVSxTQUFTO2lCQUM1QztBQUNMd2YsNEJBQWdCO1VBQ2pCO1FBQ0Y7QUFFRCxZQUFJbGtCLGFBQWEsT0FBTztBQUN0QixjQUFJbWpCLGVBQWUsVUFBVTVMLGFBQWEsR0FBRztBQUMzQ2lNLHlCQUFhLENBQUNELFlBQVkxTSxhQUFhQSxhQUFhO1VBQ3JELFdBQVVzTSxlQUFlLFVBQVU7QUFDbENLLHlCQUFhLENBQUNoRyxXQUFXSyxRQUFRblgsU0FBUyxJQUFJbWQsWUFBWWhOLGFBQWFBO2lCQUNsRTtBQUNMMk0seUJBQWEsQ0FBQ2hHLFdBQVdLLFFBQVFuWCxTQUFTbVEsYUFBYTtVQUN4RDtlQUNJO0FBRUwsY0FBSXNNLGVBQWUsVUFBVTVMLGFBQWEsR0FBRztBQUMzQ2lNLHlCQUFhM00sYUFBYTtVQUMzQixXQUFVc00sZUFBZSxVQUFVO0FBQ2xDSyx5QkFBYWhHLFdBQVdLLFFBQVFuWCxTQUFTLElBQUltZCxZQUFZaE47aUJBQ3BEO0FBQ0wyTSx5QkFBYWhHLFdBQVdLLFFBQVFuWCxTQUFTNmMsWUFBWTFNO1VBQ3REO1FBQ0Y7QUFDRCxZQUFJZ0ksUUFBUTtBQUNWMkUsd0JBQWM7UUFDZjtBQUNELFlBQUlqTSxhQUFhLEtBQUssQ0FBQytLLFlBQVk2QixtQkFBbUI7QUFDcERoakIsZUFBTTBWLGFBQWEsSUFBSzVWLEtBQUswZCxJQUFJcEgsUUFBUTtRQUMxQzthQUNJO0FBQ0xsVyxZQUFJa2Y7QUFDSmlELHNCQUFjLElBQUlELGFBQWExTSxhQUFhO01BQzdDO0FBRUQsVUFBSXVOO0FBRUosVUFBSTlCLFlBQVk2QixtQkFBbUI7QUFDakMsY0FBTUUsZUFBZWphLFVBQVVrWSxZQUFZZ0MsZUFBZTtBQUMxRCxjQUFNNWQsU0FBUzhXLFdBQVdnQyxRQUFRcGY7QUFDbEMsY0FBTW9HLFFBQVFnWCxXQUFXK0IsT0FBT25mO0FBRWhDLFlBQUkyRyxNQUFNeWMsYUFBYWEsYUFBYXRkO0FBQ3BDLFlBQUlGLE9BQU8sSUFBSXdkLGFBQWF4ZDtBQUU1QixnQkFBUTRjLGNBQVk7VUFDcEIsS0FBSztBQUNIMWMsbUJBQU9MLFNBQVM7QUFDaEI7VUFDRixLQUFLO0FBQ0hLLG1CQUFPTDtBQUNQO1FBR0Q7QUFFRCxnQkFBUTRjLFdBQVM7VUFDakIsS0FBSztBQUNIemMsb0JBQVFMLFFBQVE7QUFDaEI7VUFDRixLQUFLO0FBQ0hLLG9CQUFRTDtBQUNSO1FBR0Q7QUFFRDRkLG1CQUFXO1VBQ1R2ZDtVQUNBRTtVQUNBUCxPQUFPQSxRQUFRNmQsYUFBYTdkO1VBQzVCRSxRQUFRQSxTQUFTMmQsYUFBYTNkO1VBRTlCZ2MsT0FBT0osWUFBWWlDOztNQUV0QjtBQUVENWlCLFlBQU1PLEtBQUs7UUFDVHFWO1FBQ0F3RjtRQUNBdkc7UUFDQWtNLE9BQUFBO1FBQ0FvQjtRQUNBRTtRQUNBUjtRQUNBRixXQUFXWTtRQUNYVDtRQUNBZSxhQUFhO1VBQUNyakI7VUFBR0U7UUFBRTtRQUNuQitpQjtNQUNELENBQUE7SUFDRjtBQUVELFdBQU96aUI7RUFDUjtFQUVEK2hCLDBCQUEwQjtBQUN4QixVQUFNLEVBQUMxakIsVUFBVXlTLE1BQUssSUFBSSxLQUFLNVU7QUFDL0IsVUFBTTBaLFdBQVcsQ0FBQ2tILFVBQVUsS0FBS2pHLGFBQWE7QUFFOUMsUUFBSWpCLFVBQVU7QUFDWixhQUFPdlgsYUFBYSxRQUFRLFNBQVM7SUFDdEM7QUFFRCxRQUFJaVYsUUFBUTtBQUVaLFFBQUl4QyxNQUFNd0MsVUFBVSxTQUFTO0FBQzNCQSxjQUFRO0lBQ1QsV0FBVXhDLE1BQU13QyxVQUFVLE9BQU87QUFDaENBLGNBQVE7SUFDVCxXQUFVeEMsTUFBTXdDLFVBQVUsU0FBUztBQUNsQ0EsY0FBUTtJQUNUO0FBRUQsV0FBT0E7RUFDUjtFQUVEME8sd0JBQXdCdEMsSUFBSTtBQUMxQixVQUFNLEVBQUNyaEIsVUFBVXlTLE9BQU8sRUFBQzBRLFlBQVl0RSxRQUFRclYsUUFBTyxFQUFDLElBQUksS0FBSzNMO0FBQzlELFVBQU0yZixhQUFhLEtBQUtDLGVBQWM7QUFDdEMsVUFBTTJGLGlCQUFpQi9CLEtBQUs3WDtBQUM1QixVQUFNbVUsU0FBU0gsV0FBV0csT0FBT25YO0FBRWpDLFFBQUk4YztBQUNKLFFBQUluaUI7QUFFSixRQUFJbkIsYUFBYSxRQUFRO0FBQ3ZCLFVBQUk2ZSxRQUFRO0FBQ1YxZCxZQUFJLEtBQUsyRixRQUFRMEM7QUFFakIsWUFBSTJaLGVBQWUsUUFBUTtBQUN6Qkcsc0JBQVk7UUFDYixXQUFVSCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1puaUIsZUFBTXdjLFNBQVM7ZUFDVjtBQUNMMkYsc0JBQVk7QUFDWm5pQixlQUFLd2M7UUFDTjthQUNJO0FBQ0x4YyxZQUFJLEtBQUsyRixRQUFRc2M7QUFFakIsWUFBSUQsZUFBZSxRQUFRO0FBQ3pCRyxzQkFBWTtRQUNiLFdBQVVILGVBQWUsVUFBVTtBQUNsQ0csc0JBQVk7QUFDWm5pQixlQUFNd2MsU0FBUztlQUNWO0FBQ0wyRixzQkFBWTtBQUNabmlCLGNBQUksS0FBSzBGO1FBQ1Y7TUFDRjtJQUNGLFdBQVU3RyxhQUFhLFNBQVM7QUFDL0IsVUFBSTZlLFFBQVE7QUFDVjFkLFlBQUksS0FBSzBGLE9BQU8yQztBQUVoQixZQUFJMlosZUFBZSxRQUFRO0FBQ3pCRyxzQkFBWTtRQUNiLFdBQVVILGVBQWUsVUFBVTtBQUNsQ0csc0JBQVk7QUFDWm5pQixlQUFNd2MsU0FBUztlQUNWO0FBQ0wyRixzQkFBWTtBQUNabmlCLGVBQUt3YztRQUNOO2FBQ0k7QUFDTHhjLFlBQUksS0FBSzBGLE9BQU91YztBQUVoQixZQUFJRCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO1FBQ2IsV0FBVUgsZUFBZSxVQUFVO0FBQ2xDRyxzQkFBWTtBQUNabmlCLGVBQUt3YyxTQUFTO2VBQ1Q7QUFDTDJGLHNCQUFZO0FBQ1puaUIsY0FBSSxLQUFLMkY7UUFDVjtNQUNGO1dBQ0k7QUFDTHdjLGtCQUFZO0lBQ2I7QUFFRCxXQUFPO01BQUNBO01BQVduaUI7O0VBQ3BCO0VBS0RzakIsb0JBQW9CO0FBQ2xCLFFBQUksS0FBSzVtQixRQUFRNFUsTUFBTW9NLFFBQVE7QUFDN0I7SUFDRDtBQUVELFVBQU05ZSxRQUFRLEtBQUtBO0FBQ25CLFVBQU1DLFdBQVcsS0FBS25DLFFBQVFtQztBQUU5QixRQUFJQSxhQUFhLFVBQVVBLGFBQWEsU0FBUztBQUMvQyxhQUFPO1FBQUMrRyxLQUFLO1FBQUdGLE1BQU0sS0FBS0E7UUFBTUcsUUFBUWpILE1BQU0yRztRQUFRSSxPQUFPLEtBQUtBOztJQUNwRTtBQUFDLFFBQUk5RyxhQUFhLFNBQVNBLGFBQWEsVUFBVTtBQUNqRCxhQUFPO1FBQUMrRyxLQUFLLEtBQUtBO1FBQUtGLE1BQU07UUFBR0csUUFBUSxLQUFLQTtRQUFRRixPQUFPL0csTUFBTXlHOztJQUNuRTtFQUNGO0VBS0RrZSxpQkFBaUI7QUFDZixVQUFNLEVBQUNqVSxLQUFLNVMsU0FBUyxFQUFDOG1CLGdCQUFlLEdBQUc5ZCxNQUFNRSxLQUFLUCxPQUFPRSxPQUFNLElBQUk7QUFDcEUsUUFBSWllLGlCQUFpQjtBQUNuQmxVLFVBQUltVSxLQUFJO0FBQ1JuVSxVQUFJb1UsWUFBWUY7QUFDaEJsVSxVQUFJcVUsU0FBU2plLE1BQU1FLEtBQUtQLE9BQU9FLE1BQU07QUFDckMrSixVQUFJc1UsUUFBTztJQUNaO0VBQ0Y7RUFFREMscUJBQXFCdG1CLE9BQU87QUFDMUIsVUFBTXFmLE9BQU8sS0FBS2xnQixRQUFRa2dCO0FBQzFCLFFBQUksQ0FBQyxLQUFLUixXQUFVLEtBQU0sQ0FBQ1EsS0FBS25ULFNBQVM7QUFDdkMsYUFBTztJQUNSO0FBQ0QsVUFBTTZILFFBQVEsS0FBS0E7QUFDbkIsVUFBTW5TLFFBQVFtUyxNQUFNd1MsVUFBVUMsQ0FBQUEsT0FBS0EsR0FBRXhtQixVQUFVQSxLQUFLO0FBQ3BELFFBQUk0QixTQUFTLEdBQUc7QUFDZCxZQUFNNmtCLE9BQU9wSCxLQUFLeEUsV0FBVyxLQUFLeE4sV0FBV3pMLEtBQUssQ0FBQztBQUNuRCxhQUFPNmtCLEtBQUszQztJQUNiO0FBQ0QsV0FBTztFQUNSO0VBS0Q0QyxTQUFTcGpCLFdBQVc7QUFDbEIsVUFBTStiLE9BQU8sS0FBS2xnQixRQUFRa2dCO0FBQzFCLFVBQU10TixNQUFNLEtBQUtBO0FBQ2pCLFVBQU05TyxRQUFRLEtBQUsrVyxtQkFBbUIsS0FBS0EsaUJBQWlCLEtBQUt3SSxzQkFBc0JsZixTQUFTO0FBQ2hHLFFBQUk1QixHQUFHQztBQUVQLFVBQU1nbEIsV0FBVyxDQUFDQyxJQUFJQyxJQUFJelksVUFBVTtBQUNsQyxVQUFJLENBQUNBLE1BQU10RyxTQUFTLENBQUNzRyxNQUFNNFYsT0FBTztBQUNoQztNQUNEO0FBQ0RqUyxVQUFJbVUsS0FBSTtBQUNSblUsVUFBSStSLFlBQVkxVixNQUFNdEc7QUFDdEJpSyxVQUFJK1UsY0FBYzFZLE1BQU00VjtBQUN4QmpTLFVBQUlnVixZQUFZM1ksTUFBTTZWLGNBQWMsQ0FBQSxDQUFFO0FBQ3RDbFMsVUFBSWlWLGlCQUFpQjVZLE1BQU0rVjtBQUUzQnBTLFVBQUlrVixVQUFTO0FBQ2JsVixVQUFJbVYsT0FBT04sR0FBR25rQixHQUFHbWtCLEdBQUdqa0IsQ0FBQztBQUNyQm9QLFVBQUlvVixPQUFPTixHQUFHcGtCLEdBQUdva0IsR0FBR2xrQixDQUFDO0FBQ3JCb1AsVUFBSXFWLE9BQU07QUFDVnJWLFVBQUlzVSxRQUFPOztBQUdiLFFBQUloSCxLQUFLblQsU0FBUztBQUNoQixXQUFLeEssSUFBSSxHQUFHQyxPQUFPc0IsTUFBTTFDLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDOUMsY0FBTXVKLE9BQU9oSSxNQUFNdkI7QUFFbkIsWUFBSTJkLEtBQUtnSSxpQkFBaUI7QUFDeEJWLG1CQUNFO1lBQUNsa0IsR0FBR3dJLEtBQUtxWTtZQUFJM2dCLEdBQUdzSSxLQUFLc1k7YUFDckI7WUFBQzlnQixHQUFHd0ksS0FBS3VZO1lBQUk3Z0IsR0FBR3NJLEtBQUt3WTthQUNyQnhZLElBQUk7UUFFUDtBQUVELFlBQUlvVSxLQUFLMUgsV0FBVztBQUNsQmdQLG1CQUNFO1lBQUNsa0IsR0FBR3dJLEtBQUtpWTtZQUFLdmdCLEdBQUdzSSxLQUFLa1k7YUFDdEI7WUFBQzFnQixHQUFHd0ksS0FBS21ZO1lBQUt6Z0IsR0FBR3NJLEtBQUtvWTthQUN0QjtZQUNFVyxPQUFPL1ksS0FBS29aO1lBQ1p2YyxPQUFPbUQsS0FBSzBUO1lBQ1pzRixZQUFZaFosS0FBS3FaO1lBQ2pCSCxrQkFBa0JsWixLQUFLc1o7VUFDeEIsQ0FBQTtRQUVKO01BQ0Y7SUFDRjtFQUNGO0VBS0QrQyxhQUFhO0FBQ1gsVUFBTSxFQUFDam1CLE9BQU8wUSxLQUFLNVMsU0FBUyxFQUFDc2pCLFFBQVFwRCxLQUFJLEVBQUMsSUFBSTtBQUM5QyxVQUFNdUQsYUFBYUgsT0FBTzVILFdBQVcsS0FBS3hOLFdBQVUsQ0FBRTtBQUN0RCxVQUFNd1YsWUFBWUosT0FBT3ZXLFVBQVUwVyxXQUFXOWEsUUFBUTtBQUN0RCxRQUFJLENBQUMrYSxXQUFXO0FBQ2Q7SUFDRDtBQUNELFVBQU0wRSxnQkFBZ0JsSSxLQUFLeEUsV0FBVyxLQUFLeE4sV0FBVyxDQUFDLENBQUMsRUFBRXlXO0FBQzFELFVBQU1kLGNBQWMsS0FBS3ZJO0FBQ3pCLFFBQUk2SSxJQUFJRSxJQUFJRCxJQUFJRTtBQUVoQixRQUFJLEtBQUs1YyxhQUFZLEdBQUk7QUFDdkJ5YyxXQUFLckIsWUFBWTVnQixPQUFPLEtBQUs4RyxNQUFNMGEsU0FBUyxJQUFJQSxZQUFZO0FBQzVEVyxXQUFLdkIsWUFBWTVnQixPQUFPLEtBQUsrRyxPQUFPbWYsYUFBYSxJQUFJQSxnQkFBZ0I7QUFDckVoRSxXQUFLRSxLQUFLVDtXQUNMO0FBQ0xPLFdBQUt0QixZQUFZNWdCLE9BQU8sS0FBS2dILEtBQUt3YSxTQUFTLElBQUlBLFlBQVk7QUFDM0RZLFdBQUt4QixZQUFZNWdCLE9BQU8sS0FBS2lILFFBQVFpZixhQUFhLElBQUlBLGdCQUFnQjtBQUN0RWpFLFdBQUtFLEtBQUtSO0lBQ1g7QUFDRGpSLFFBQUltVSxLQUFJO0FBQ1JuVSxRQUFJK1IsWUFBWWxCLFdBQVc5YTtBQUMzQmlLLFFBQUkrVSxjQUFjbEUsV0FBV29CO0FBRTdCalMsUUFBSWtWLFVBQVM7QUFDYmxWLFFBQUltVixPQUFPNUQsSUFBSUMsRUFBRTtBQUNqQnhSLFFBQUlvVixPQUFPM0QsSUFBSUMsRUFBRTtBQUNqQjFSLFFBQUlxVixPQUFNO0FBRVZyVixRQUFJc1UsUUFBTztFQUNaO0VBS0RtQixXQUFXbGtCLFdBQVc7QUFDcEIsVUFBTStlLGNBQWMsS0FBS2xqQixRQUFRNFU7QUFFakMsUUFBSSxDQUFDc08sWUFBWW5XLFNBQVM7QUFDeEI7SUFDRDtBQUVELFVBQU02RixNQUFNLEtBQUtBO0FBRWpCLFVBQU0wVixPQUFPLEtBQUsxQixrQkFBaUI7QUFDbkMsUUFBSTBCLE1BQU07QUFDUkMsZUFBUzNWLEtBQUswVixJQUFJO0lBQ25CO0FBRUQsVUFBTXhrQixRQUFRLEtBQUtnWCxnQkFBZ0IsS0FBS0EsY0FBYyxLQUFLdUssbUJBQW1CbGhCLFNBQVM7QUFDdkYsUUFBSTVCLEdBQUdDO0FBRVAsU0FBS0QsSUFBSSxHQUFHQyxPQUFPc0IsTUFBTTFDLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDOUMsWUFBTXVKLE9BQU9oSSxNQUFNdkI7QUFDbkIsWUFBTXdmLFdBQVdqVyxLQUFLNk07QUFDdEIsWUFBTXVHLFFBQVFwVCxLQUFLb1Q7QUFFbkIsVUFBSTFiLElBQUlzSSxLQUFLNlo7QUFDYjZDLGlCQUFXNVYsS0FBS3NNLE9BQU8sR0FBRzFiLEdBQUd1ZSxVQUFValcsSUFBSTtJQUM1QztBQUVELFFBQUl3YyxNQUFNO0FBQ1JHLGlCQUFXN1YsR0FBRztJQUNmO0VBQ0Y7RUFLRDhWLFlBQVk7QUFDVixVQUFNLEVBQUM5VixLQUFLNVMsU0FBUyxFQUFDbUMsVUFBVWdlLE9BQU90WixRQUFPLEVBQUMsSUFBSTtBQUVuRCxRQUFJLENBQUNzWixNQUFNcFQsU0FBUztBQUNsQjtJQUNEO0FBRUQsVUFBTTRMLE9BQU9DLE9BQU91SCxNQUFNeEgsSUFBSTtBQUM5QixVQUFNaE4sVUFBVVksVUFBVTRULE1BQU14VSxPQUFPO0FBQ3ZDLFVBQU15TCxRQUFRK0ksTUFBTS9JO0FBQ3BCLFFBQUlwQixTQUFTMkMsS0FBS0ssYUFBYTtBQUUvQixRQUFJN1csYUFBYSxZQUFZQSxhQUFhLFlBQVk2SCxTQUFTN0gsUUFBUSxHQUFHO0FBQ3hFNlQsZ0JBQVVySyxRQUFReEM7QUFDbEIsVUFBSTJQLFFBQVFxSCxNQUFNcEgsSUFBSSxHQUFHO0FBQ3ZCL0Msa0JBQVUyQyxLQUFLSyxjQUFjbUgsTUFBTXBILEtBQUszWCxTQUFTO01BQ2xEO1dBQ0k7QUFDTDRVLGdCQUFVckssUUFBUXpDO0lBQ25CO0FBRUQsVUFBTSxFQUFDMFEsUUFBUUMsUUFBUUYsVUFBVUQsU0FBUSxJQUFJRixVQUFVLE1BQU14RCxRQUFRN1QsVUFBVWlWLEtBQUs7QUFFcEZvUixlQUFXNVYsS0FBS3VOLE1BQU1wSCxNQUFNLEdBQUcsR0FBR0osTUFBTTtNQUN0Q2tNLE9BQU8xRSxNQUFNMEU7TUFDYmxMO01BQ0FEO01BQ0ErTCxXQUFXbk0sV0FBV2xDLE9BQU9qVixVQUFVMEUsT0FBTztNQUM5QytlLGNBQWM7TUFDZGUsYUFBYTtRQUFDL007UUFBUUM7TUFBTztJQUM5QixDQUFBO0VBQ0Y7RUFFRDVOLEtBQUs5SCxXQUFXO0FBQ2QsUUFBSSxDQUFDLEtBQUt1YixXQUFVLEdBQUk7QUFDdEI7SUFDRDtBQUVELFNBQUttSCxlQUFjO0FBQ25CLFNBQUtVLFNBQVNwakIsU0FBUztBQUN2QixTQUFLZ2tCLFdBQVU7QUFDZixTQUFLTyxVQUFTO0FBQ2QsU0FBS0wsV0FBV2xrQixTQUFTO0VBQzFCO0VBTUQ0SCxVQUFVO0FBQ1IsVUFBTXViLE9BQU8sS0FBS3RuQjtBQUNsQixVQUFNMm9CLEtBQUtyQixLQUFLMVMsU0FBUzBTLEtBQUsxUyxNQUFNNUksS0FBSztBQUN6QyxVQUFNNGMsS0FBSzVSLGVBQWVzUSxLQUFLcEgsUUFBUW9ILEtBQUtwSCxLQUFLbFUsR0FBRyxFQUFFO0FBQ3RELFVBQU02YyxLQUFLN1IsZUFBZXNRLEtBQUtoRSxVQUFVZ0UsS0FBS2hFLE9BQU90WCxHQUFHLENBQUM7QUFFekQsUUFBSSxDQUFDLEtBQUswVCxXQUFVLEtBQU0sS0FBS3pULFNBQVNpTyxNQUFNcGEsVUFBVW1NLE1BQU07QUFFNUQsYUFBTztRQUFDO1VBQ05ELEdBQUcyYztVQUNIMWMsTUFBTSxDQUFDOUgsY0FBYztBQUNuQixpQkFBSzhILEtBQUs5SCxTQUFTO1VBQ3BCO1FBQ0Y7O0lBQ0Y7QUFFRCxXQUFPO01BQUM7UUFDTjZILEdBQUc0YztRQUNIM2MsTUFBTSxDQUFDOUgsY0FBYztBQUNuQixlQUFLMGlCLGVBQWM7QUFDbkIsZUFBS1UsU0FBU3BqQixTQUFTO0FBQ3ZCLGVBQUt1a0IsVUFBUztRQUNmO01BQ0Y7TUFBRTtRQUNEMWMsR0FBRzZjO1FBQ0g1YyxNQUFNLE1BQU07QUFDVixlQUFLa2MsV0FBVTtRQUNoQjtNQUNGO01BQUU7UUFDRG5jLEdBQUcyYztRQUNIMWMsTUFBTSxDQUFDOUgsY0FBYztBQUNuQixlQUFLa2tCLFdBQVdsa0IsU0FBUztRQUMxQjtNQUNGOztFQUNGO0VBT0RvWSx3QkFBd0IvTyxNQUFNO0FBQzVCLFVBQU04TyxRQUFRLEtBQUtwYSxNQUFNSSw2QkFBNEI7QUFDckQsVUFBTXdtQixTQUFTLEtBQUtsb0IsT0FBTztBQUMzQixVQUFNK1YsU0FBUyxDQUFBO0FBQ2YsUUFBSXBVLEdBQUdDO0FBRVAsU0FBS0QsSUFBSSxHQUFHQyxPQUFPOFosTUFBTWxiLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDOUMsWUFBTXdELE9BQU91VyxNQUFNL1o7QUFDbkIsVUFBSXdELEtBQUsraUIsWUFBWSxLQUFLMU8sT0FBTyxDQUFDNU0sUUFBUXpILEtBQUt5SCxTQUFTQSxPQUFPO0FBQzdEbUosZUFBT3RTLEtBQUswQixJQUFJO01BQ2pCO0lBQ0Y7QUFDRCxXQUFPNFE7RUFDUjtFQU9EdUwsd0JBQXdCemYsT0FBTztBQUM3QixVQUFNNmtCLE9BQU8sS0FBS3RuQixRQUFRNFUsTUFBTThHLFdBQVcsS0FBS3hOLFdBQVd6TCxLQUFLLENBQUM7QUFDakUsV0FBT21XLE9BQU8wTyxLQUFLM08sSUFBSTtFQUN4QjtFQUtEb1EsYUFBYTtBQUNYLFVBQU1DLFdBQVcsS0FBSzlHLHdCQUF3QixDQUFDLEVBQUVsSjtBQUNqRCxZQUFRLEtBQUt0UixhQUFZLElBQUssS0FBS2lCLFFBQVEsS0FBS0UsVUFBVW1nQjtFQUMzRDs7QUNycERZLElBQU1DLGdCQUFOLE1BQW1CO0VBQ2hDbHBCLFlBQVl5TixNQUFNMGIsT0FBT3hwQixVQUFVO0FBQ2pDLFNBQUs4TixPQUFPQTtBQUNaLFNBQUswYixRQUFRQTtBQUNiLFNBQUt4cEIsV0FBV0E7QUFDaEIsU0FBS29FLFFBQVFsRSx1QkFBT3VwQixPQUFPLElBQUk7RUFDaEM7RUFFREMsVUFBVTViLE1BQU07QUFDZCxXQUFPNU4sT0FBT0UsVUFBVXVwQixjQUFjdk0sS0FBSyxLQUFLdFAsS0FBSzFOLFdBQVcwTixLQUFLMU4sU0FBUztFQUMvRTtFQU1Ed3BCLFNBQVN4ZCxNQUFNO0FBQ2IsVUFBTXlkLFFBQVEzcEIsT0FBTzRwQixlQUFlMWQsSUFBSTtBQUN4QyxRQUFJMmQ7QUFFSixRQUFJQyxrQkFBa0JILEtBQUssR0FBRztBQUU1QkUsb0JBQWMsS0FBS0gsU0FBU0MsS0FBSztJQUNsQztBQUVELFVBQU16bEIsUUFBUSxLQUFLQTtBQUNuQixVQUFNc1csS0FBS3RPLEtBQUtzTztBQUNoQixVQUFNOE8sUUFBUSxLQUFLQSxRQUFRLE1BQU05TztBQUVqQyxRQUFJLENBQUNBLElBQUk7QUFDUCxZQUFNLElBQUk1YSxNQUFNLDZCQUE2QnNNLElBQUk7SUFDbEQ7QUFFRCxRQUFJc08sTUFBTXRXLE9BQU87QUFFZixhQUFPb2xCO0lBQ1I7QUFFRHBsQixVQUFNc1csTUFBTXRPO0FBQ1o2ZCxxQkFBaUI3ZCxNQUFNb2QsT0FBT08sV0FBVztBQUN6QyxRQUFJLEtBQUsvcEIsVUFBVTtBQUNqQjhVLGVBQVM5VSxTQUFTb00sS0FBS3NPLElBQUl0TyxLQUFLOGQsU0FBUztJQUMxQztBQUVELFdBQU9WO0VBQ1I7RUFNRFcsSUFBSXpQLElBQUk7QUFDTixXQUFPLEtBQUt0VyxNQUFNc1c7RUFDbkI7RUFLRDBQLFdBQVdoZSxNQUFNO0FBQ2YsVUFBTWhJLFFBQVEsS0FBS0E7QUFDbkIsVUFBTXNXLEtBQUt0TyxLQUFLc087QUFDaEIsVUFBTThPLFFBQVEsS0FBS0E7QUFFbkIsUUFBSTlPLE1BQU10VyxPQUFPO0FBQ2YsYUFBT0EsTUFBTXNXO0lBQ2Q7QUFFRCxRQUFJOE8sU0FBUzlPLE1BQU01RixTQUFTMFUsUUFBUTtBQUNsQyxhQUFPMVUsU0FBUzBVLE9BQU85TztBQUN2QixVQUFJLEtBQUsxYSxVQUFVO0FBQ2pCLGVBQU9rcUIsVUFBVXhQO01BQ2xCO0lBQ0Y7RUFDRjs7QUFHSCxTQUFTdVAsaUJBQWlCN2QsTUFBTW9kLE9BQU9PLGFBQWE7QUFFbEQsUUFBTU0sZUFBZUMsTUFBTXBxQix1QkFBT3VwQixPQUFPLElBQUksR0FBRztJQUM5Q00sY0FBY2pWLFNBQVNxVixJQUFJSixXQUFXLElBQUksQ0FBQTtJQUMxQ2pWLFNBQVNxVixJQUFJWCxLQUFLO0lBQ2xCcGQsS0FBSzBJO0VBQ04sQ0FBQTtBQUVEQSxXQUFTMUMsSUFBSW9YLE9BQU9hLFlBQVk7QUFFaEMsTUFBSWplLEtBQUsySSxlQUFlO0FBQ3RCd1Ysa0JBQWNmLE9BQU9wZCxLQUFLMkksYUFBYTtFQUN4QztBQUVELE1BQUkzSSxLQUFLb2UsYUFBYTtBQUNwQjFWLGFBQVMyVixTQUFTakIsT0FBT3BkLEtBQUtvZSxXQUFXO0VBQzFDO0FBQ0Y7QUFFRCxTQUFTRCxjQUFjZixPQUFPa0IsUUFBUTtBQUNwQ3hxQixTQUFPc1QsS0FBS2tYLE1BQU0sRUFBRXRrQixRQUFRdWtCLENBQUFBLGFBQVk7QUFDdEMsVUFBTUMsZ0JBQWdCRCxTQUFTRSxNQUFNLEdBQUc7QUFDeEMsVUFBTUMsYUFBYUYsY0FBY0csSUFBRztBQUNwQyxVQUFNQyxjQUFjO01BQUN4QjtNQUFPM2YsT0FBTytnQixhQUFhLEVBQUVLLEtBQUssR0FBRztBQUMxRCxVQUFNQyxRQUFRUixPQUFPQyxVQUFVRSxNQUFNLEdBQUc7QUFDeEMsVUFBTU0sYUFBYUQsTUFBTUgsSUFBRztBQUM1QixVQUFNSyxjQUFjRixNQUFNRCxLQUFLLEdBQUc7QUFDbENuVyxhQUFTdVcsTUFBTUwsYUFBYUYsWUFBWU0sYUFBYUQsVUFBVTtFQUNoRSxDQUFBO0FBQ0Y7QUFFRCxTQUFTbkIsa0JBQWtCSCxPQUFPO0FBQ2hDLFNBQU8sUUFBUUEsU0FBUyxjQUFjQTtBQUN2QztBQzFHTSxJQUFNeUIsV0FBTixNQUFjO0VBQ25CanJCLGNBQWM7QUFDWixTQUFLa3JCLGNBQWMsSUFBSWhDLGNBQWNpQyxtQkFBbUIsWUFBWSxJQUFJO0FBQ3hFLFNBQUtybEIsV0FBVyxJQUFJb2pCLGNBQWNwVixTQUFTLFVBQVU7QUFDckQsU0FBS3NYLFVBQVUsSUFBSWxDLGNBQWNycEIsUUFBUSxTQUFTO0FBQ2xELFNBQUs2WixTQUFTLElBQUl3UCxjQUFjL08sT0FBTyxRQUFRO0FBRy9DLFNBQUtrUixtQkFBbUI7TUFBQyxLQUFLSDtNQUFhLEtBQUt4UjtNQUFRLEtBQUs1VDs7RUFDOUQ7RUFLRHhGLE9BQU9nckIsTUFBTTtBQUNYLFNBQUtDLE1BQU0sWUFBWUQsSUFBSTtFQUM1QjtFQUVERSxVQUFVRixNQUFNO0FBQ2QsU0FBS0MsTUFBTSxjQUFjRCxJQUFJO0VBQzlCO0VBS0RHLGtCQUFrQkgsTUFBTTtBQUN0QixTQUFLQyxNQUFNLFlBQVlELE1BQU0sS0FBS0osV0FBVztFQUM5QztFQUtEUSxlQUFlSixNQUFNO0FBQ25CLFNBQUtDLE1BQU0sWUFBWUQsTUFBTSxLQUFLeGxCLFFBQVE7RUFDM0M7RUFLRDZsQixjQUFjTCxNQUFNO0FBQ2xCLFNBQUtDLE1BQU0sWUFBWUQsTUFBTSxLQUFLRixPQUFPO0VBQzFDO0VBS0RRLGFBQWFOLE1BQU07QUFDakIsU0FBS0MsTUFBTSxZQUFZRCxNQUFNLEtBQUs1UixNQUFNO0VBQ3pDO0VBTURtUyxjQUFjeFIsSUFBSTtBQUNoQixXQUFPLEtBQUt5UixLQUFLelIsSUFBSSxLQUFLNlEsYUFBYSxZQUFZO0VBQ3BEO0VBTURhLFdBQVcxUixJQUFJO0FBQ2IsV0FBTyxLQUFLeVIsS0FBS3pSLElBQUksS0FBS3ZVLFVBQVUsU0FBUztFQUM5QztFQU1Ea21CLFVBQVUzUixJQUFJO0FBQ1osV0FBTyxLQUFLeVIsS0FBS3pSLElBQUksS0FBSytRLFNBQVMsUUFBUTtFQUM1QztFQU1EYSxTQUFTNVIsSUFBSTtBQUNYLFdBQU8sS0FBS3lSLEtBQUt6UixJQUFJLEtBQUtYLFFBQVEsT0FBTztFQUMxQztFQUtEd1MscUJBQXFCWixNQUFNO0FBQ3pCLFNBQUtDLE1BQU0sY0FBY0QsTUFBTSxLQUFLSixXQUFXO0VBQ2hEO0VBS0RpQixrQkFBa0JiLE1BQU07QUFDdEIsU0FBS0MsTUFBTSxjQUFjRCxNQUFNLEtBQUt4bEIsUUFBUTtFQUM3QztFQUtEc21CLGlCQUFpQmQsTUFBTTtBQUNyQixTQUFLQyxNQUFNLGNBQWNELE1BQU0sS0FBS0YsT0FBTztFQUM1QztFQUtEaUIsZ0JBQWdCZixNQUFNO0FBQ3BCLFNBQUtDLE1BQU0sY0FBY0QsTUFBTSxLQUFLNVIsTUFBTTtFQUMzQztFQUtENlIsTUFBTWUsUUFBUWhCLE1BQU1pQixlQUFlO0FBQ2pDO1NBQUlqQjtJQUFLLEVBQUN2bEIsUUFBUXltQixDQUFBQSxRQUFPO0FBQ3ZCLFlBQU1DLE1BQU1GLGlCQUFpQixLQUFLRyxvQkFBb0JGLEdBQUc7QUFDekQsVUFBSUQsaUJBQWlCRSxJQUFJcEQsVUFBVW1ELEdBQUcsS0FBTUMsUUFBUSxLQUFLckIsV0FBV29CLElBQUluUyxJQUFLO0FBQzNFLGFBQUtzUyxNQUFNTCxRQUFRRyxLQUFLRCxHQUFHO2FBQ3RCO0FBS0w3ZixhQUFLNmYsS0FBS3pnQixDQUFBQSxTQUFRO0FBT2hCLGdCQUFNNmdCLFVBQVVMLGlCQUFpQixLQUFLRyxvQkFBb0IzZ0IsSUFBSTtBQUM5RCxlQUFLNGdCLE1BQU1MLFFBQVFNLFNBQVM3Z0IsSUFBSTtRQUNqQyxDQUFBO01BQ0Y7SUFDRixDQUFBO0VBQ0Y7RUFLRDRnQixNQUFNTCxRQUFRTyxXQUFVQyxXQUFXO0FBQ2pDLFVBQU1DLGNBQWNDLFlBQVlWLE1BQU07QUFDdEN2UCxhQUFLK1AsVUFBVSxXQUFXQyxjQUFjLENBQUEsR0FBSUQsU0FBUztBQUNyREQsSUFBQUEsVUFBU1AsUUFBUVEsU0FBUztBQUMxQi9QLGFBQUsrUCxVQUFVLFVBQVVDLGNBQWMsQ0FBQSxHQUFJRCxTQUFTO0VBQ3JEO0VBS0RKLG9CQUFvQmpmLE1BQU07QUFDeEIsYUFBU2pMLElBQUksR0FBR0EsSUFBSSxLQUFLNm9CLGlCQUFpQmhxQixRQUFRbUIsS0FBSztBQUNyRCxZQUFNaXFCLE1BQU0sS0FBS3BCLGlCQUFpQjdvQjtBQUNsQyxVQUFJaXFCLElBQUlwRCxVQUFVNWIsSUFBSSxHQUFHO0FBQ3ZCLGVBQU9nZjtNQUNSO0lBQ0Y7QUFFRCxXQUFPLEtBQUtyQjtFQUNiO0VBS0RVLEtBQUt6UixJQUFJa1MsZUFBZTllLE1BQU07QUFDNUIsVUFBTTFCLE9BQU93Z0IsY0FBY3pDLElBQUl6UCxFQUFFO0FBQ2pDLFFBQUl0TyxTQUFTMkQsUUFBVztBQUN0QixZQUFNLElBQUlqUSxNQUFNLE1BQU00YSxLQUFLLDJCQUEyQjVNLE9BQU8sR0FBRztJQUNqRTtBQUNELFdBQU8xQjtFQUNSO0FBRUY7QUFHRCxJQUFBLFdBQStCLG9CQUFJa2YsU0FBUTtBQ3RLNUIsSUFBTWdDLGdCQUFOLE1BQW1CO0VBQ2hDanRCLGNBQWM7QUFDWixTQUFLa3RCLFFBQVEsQ0FBQTtFQUNkO0VBWURDLE9BQU9ockIsT0FBT2lyQixNQUFNOUIsTUFBTTlrQixRQUFRO0FBQ2hDLFFBQUk0bUIsU0FBUyxjQUFjO0FBQ3pCLFdBQUtGLFFBQVEsS0FBS0csbUJBQW1CbHJCLE9BQU8sSUFBSTtBQUNoRCxXQUFLbXJCLFFBQVEsS0FBS0osT0FBTy9xQixPQUFPLFNBQVM7SUFDMUM7QUFFRCxVQUFNZ29CLGVBQWMzakIsU0FBUyxLQUFLK21CLGFBQWFwckIsS0FBSyxFQUFFcUUsT0FBT0EsTUFBTSxJQUFJLEtBQUsrbUIsYUFBYXByQixLQUFLO0FBQzlGLFVBQU15VSxTQUFTLEtBQUswVyxRQUFRbkQsY0FBYWhvQixPQUFPaXJCLE1BQU05QixJQUFJO0FBRTFELFFBQUk4QixTQUFTLGdCQUFnQjtBQUMzQixXQUFLRSxRQUFRbkQsY0FBYWhvQixPQUFPLE1BQU07QUFDdkMsV0FBS21yQixRQUFRLEtBQUtKLE9BQU8vcUIsT0FBTyxXQUFXO0lBQzVDO0FBQ0QsV0FBT3lVO0VBQ1I7RUFLRDBXLFFBQVFuRCxjQUFhaG9CLE9BQU9pckIsTUFBTTlCLE1BQU07QUFDdENBLFdBQU9BLFFBQVEsQ0FBQTtBQUNmLGVBQVdrQyxjQUFjckQsY0FBYTtBQUNwQyxZQUFNc0QsU0FBU0QsV0FBV0M7QUFDMUIsWUFBTW5CLFNBQVNtQixPQUFPTDtBQUN0QixZQUFNOWtCLFNBQVM7UUFBQ25HO1FBQU9tcEI7UUFBTWtDLFdBQVd2dEI7O0FBQ3hDLFVBQUl5dEIsU0FBYXBCLFFBQVFoa0IsUUFBUW1sQixNQUFNLE1BQU0sU0FBU25DLEtBQUtxQyxZQUFZO0FBQ3JFLGVBQU87TUFDUjtJQUNGO0FBRUQsV0FBTztFQUNSO0VBRURDLGFBQWE7QUFNWCxRQUFJLENBQUM1YSxjQUFjLEtBQUt3SSxNQUFNLEdBQUc7QUFDL0IsV0FBS3FTLFlBQVksS0FBS3JTO0FBQ3RCLFdBQUtBLFNBQVM5TDtJQUNmO0VBQ0Y7RUFNRDZkLGFBQWFwckIsT0FBTztBQUNsQixRQUFJLEtBQUtxWixRQUFRO0FBQ2YsYUFBTyxLQUFLQTtJQUNiO0FBRUQsVUFBTTJPLGVBQWMsS0FBSzNPLFNBQVMsS0FBSzZSLG1CQUFtQmxyQixLQUFLO0FBRS9ELFNBQUsyckIsb0JBQW9CM3JCLEtBQUs7QUFFOUIsV0FBT2dvQjtFQUNSO0VBRURrRCxtQkFBbUJsckIsT0FBTzRyQixLQUFLO0FBQzdCLFVBQU05ZixTQUFTOUwsU0FBU0EsTUFBTThMO0FBQzlCLFVBQU1oTyxVQUFVZ1gsZUFBZWhKLE9BQU9oTyxXQUFXZ08sT0FBT2hPLFFBQVFtckIsU0FBUyxDQUFBLENBQUU7QUFDM0UsVUFBTUEsVUFBVTRDLFdBQVcvZixNQUFNO0FBRWpDLFdBQU9oTyxZQUFZLFNBQVMsQ0FBQzh0QixNQUFNLENBQUEsSUFBS0Usa0JBQWtCOXJCLE9BQU9pcEIsU0FBU25yQixTQUFTOHRCLEdBQUc7RUFDdkY7RUFNREQsb0JBQW9CM3JCLE9BQU87QUFDekIsVUFBTStyQixzQkFBc0IsS0FBS0wsYUFBYSxDQUFBO0FBQzlDLFVBQU0xRCxlQUFjLEtBQUszTztBQUN6QixVQUFNamIsT0FBTyxDQUFDeUcsR0FBR0MsTUFBTUQsRUFBRVIsT0FBT2pELENBQUFBLE1BQUssQ0FBQzBELEVBQUVrbkIsS0FBSzFxQixDQUFBQSxNQUFLRixFQUFFa3FCLE9BQU9wVCxPQUFPNVcsRUFBRWdxQixPQUFPcFQsRUFBRSxDQUFDO0FBQzlFLFNBQUtpVCxRQUFRL3NCLEtBQUsydEIscUJBQXFCL0QsWUFBVyxHQUFHaG9CLE9BQU8sTUFBTTtBQUNsRSxTQUFLbXJCLFFBQVEvc0IsS0FBSzRwQixjQUFhK0QsbUJBQW1CLEdBQUcvckIsT0FBTyxPQUFPO0VBQ3BFOztBQU1ILFNBQVM2ckIsV0FBVy9mLFFBQVE7QUFDMUIsUUFBTW1nQixXQUFXLENBQUE7QUFDakIsUUFBTWhELFVBQVUsQ0FBQTtBQUNoQixRQUFNalksT0FBT3RULE9BQU9zVCxLQUFLMFosU0FBU3pCLFFBQVFybkIsS0FBSztBQUMvQyxXQUFTdkIsSUFBSSxHQUFHQSxJQUFJMlEsS0FBSzlSLFFBQVFtQixLQUFLO0FBQ3BDNG9CLFlBQVE5bUIsS0FBS3VvQixTQUFTYixVQUFVN1ksS0FBSzNRLEVBQUUsQ0FBQztFQUN6QztBQUVELFFBQU02ckIsUUFBUXBnQixPQUFPbWQsV0FBVyxDQUFBO0FBQ2hDLFdBQVM1b0IsS0FBSSxHQUFHQSxLQUFJNnJCLE1BQU1odEIsUUFBUW1CLE1BQUs7QUFDckMsVUFBTWlyQixTQUFTWSxNQUFNN3JCO0FBRXJCLFFBQUk0b0IsUUFBUXBvQixRQUFReXFCLE1BQU0sTUFBTSxJQUFJO0FBQ2xDckMsY0FBUTltQixLQUFLbXBCLE1BQU07QUFDbkJXLGVBQVNYLE9BQU9wVCxNQUFNO0lBQ3ZCO0VBQ0Y7QUFFRCxTQUFPO0lBQUMrUTtJQUFTZ0Q7O0FBQ2xCO0FBRUQsU0FBU0UsUUFBUXJ1QixTQUFTOHRCLEtBQUs7QUFDN0IsTUFBSSxDQUFDQSxPQUFPOXRCLFlBQVksT0FBTztBQUM3QixXQUFPO0VBQ1I7QUFDRCxNQUFJQSxZQUFZLE1BQU07QUFDcEIsV0FBTyxDQUFBO0VBQ1I7QUFDRCxTQUFPQTtBQUNSO0FBRUQsU0FBU2d1QixrQkFBa0I5ckIsT0FBTyxFQUFDaXBCLFNBQVNnRCxTQUFRLEdBQUdudUIsU0FBUzh0QixLQUFLO0FBQ25FLFFBQU1uWCxTQUFTLENBQUE7QUFDZixRQUFNckosVUFBVXBMLE1BQU1nTSxXQUFVO0FBRWhDLGFBQVdzZixVQUFVckMsU0FBUztBQUM1QixVQUFNL1EsS0FBS29ULE9BQU9wVDtBQUNsQixVQUFNa04sT0FBTytHLFFBQVFydUIsUUFBUW9hLEtBQUswVCxHQUFHO0FBQ3JDLFFBQUl4RyxTQUFTLE1BQU07QUFDakI7SUFDRDtBQUNEM1EsV0FBT3RTLEtBQUs7TUFDVm1wQjtNQUNBeHRCLFNBQVNzdUIsV0FBV3BzQixNQUFNOEwsUUFBUTtRQUFDd2Y7UUFBUVksT0FBT0QsU0FBUy9UO1NBQU1rTixNQUFNaGEsT0FBTztJQUMvRSxDQUFBO0VBQ0Y7QUFFRCxTQUFPcUo7QUFDUjtBQUVELFNBQVMyWCxXQUFXdGdCLFFBQVEsRUFBQ3dmLFFBQVFZLE1BQUssR0FBRzlHLE1BQU1oYSxTQUFTO0FBQzFELFFBQU00RixPQUFPbEYsT0FBT3VnQixnQkFBZ0JmLE1BQU07QUFDMUMsUUFBTWdCLFNBQVN4Z0IsT0FBT3lnQixnQkFBZ0JuSCxNQUFNcFUsSUFBSTtBQUNoRCxNQUFJa2IsU0FBU1osT0FBT2haLFVBQVU7QUFFNUJnYSxXQUFPbnFCLEtBQUttcEIsT0FBT2haLFFBQVE7RUFDNUI7QUFDRCxTQUFPeEcsT0FBTzBnQixlQUFlRixRQUFRbGhCLFNBQVM7SUFBQztLQUFLO0lBRWxEcWhCLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxTQUFTO0VBQ1YsQ0FBQTtBQUNGO0FDbExNLFNBQVNDLGFBQWF0aEIsTUFBTXhOLFNBQVM7QUFDMUMsUUFBTSt1QixrQkFBa0J2YSxTQUFTd2EsU0FBU3hoQixTQUFTLENBQUE7QUFDbkQsUUFBTXloQixrQkFBa0JqdkIsUUFBUWd2QixZQUFZLENBQUEsR0FBSXhoQixTQUFTLENBQUE7QUFDekQsU0FBT3loQixlQUFlQyxhQUFhbHZCLFFBQVFrdkIsYUFBYUgsZ0JBQWdCRyxhQUFhO0FBQ3RGO0FBRUQsU0FBU0MsMEJBQTBCL1UsSUFBSThVLFdBQVc7QUFDaEQsTUFBSXR1QixPQUFPd1o7QUFDWCxNQUFJQSxPQUFPLFdBQVc7QUFDcEJ4WixXQUFPc3VCO0VBQ1IsV0FBVTlVLE9BQU8sV0FBVztBQUMzQnhaLFdBQU9zdUIsY0FBYyxNQUFNLE1BQU07RUFDbEM7QUFDRCxTQUFPdHVCO0FBQ1I7QUFFRCxTQUFTd3VCLDBCQUEwQnh1QixNQUFNc3VCLFdBQVc7QUFDbEQsU0FBT3R1QixTQUFTc3VCLFlBQVksWUFBWTtBQUN6QztBQUVELFNBQVNHLGlCQUFpQmx0QixVQUFVO0FBQ2xDLE1BQUlBLGFBQWEsU0FBU0EsYUFBYSxVQUFVO0FBQy9DLFdBQU87RUFDUjtBQUNELE1BQUlBLGFBQWEsVUFBVUEsYUFBYSxTQUFTO0FBQy9DLFdBQU87RUFDUjtBQUNGO0FBRU0sU0FBU210QixjQUFjbFYsSUFBSW1WLGNBQWM7QUFDOUMsTUFBSW5WLE9BQU8sT0FBT0EsT0FBTyxPQUFPQSxPQUFPLEtBQUs7QUFDMUMsV0FBT0E7RUFDUjtBQUVEQSxPQUFLbVYsYUFBYTN1QixRQUNieXVCLGlCQUFpQkUsYUFBYXB0QixRQUFRLEtBQ3RDaVksR0FBR2haLFNBQVMsS0FBS2t1QixjQUFjbFYsR0FBRyxHQUFHb1YsWUFBVyxHQUFJRCxZQUFZO0FBRXJFLE1BQUluVixJQUFJO0FBQ04sV0FBT0E7RUFDUjtBQUVELFFBQU0sSUFBSTVhLE1BQU0sNkJBQTZCc2YseURBQXlEO0FBQ3ZHO0FBRUQsU0FBUzJRLGlCQUFpQnpoQixRQUFRaE8sU0FBUztBQUN6QyxRQUFNMHZCLGdCQUFnQjlGLFVBQVU1YixPQUFPUixTQUFTO0lBQUNpTSxRQUFRLENBQUE7O0FBQ3pELFFBQU1rVyxlQUFlM3ZCLFFBQVF5WixVQUFVLENBQUE7QUFDdkMsUUFBTW1XLGlCQUFpQmQsYUFBYTlnQixPQUFPUixNQUFNeE4sT0FBTztBQUN4RCxRQUFNeVosU0FBUzdaLHVCQUFPdXBCLE9BQU8sSUFBSTtBQUdqQ3ZwQixTQUFPc1QsS0FBS3ljLFlBQVksRUFBRTdwQixRQUFRc1UsQ0FBQUEsT0FBTTtBQUN0QyxVQUFNeVYsWUFBWUYsYUFBYXZWO0FBQy9CLFFBQUksQ0FBQ3BRLFNBQVM2bEIsU0FBUyxHQUFHO0FBQ3hCLGFBQU9DLFFBQVFDLE1BQU0sMENBQTBDM1YsSUFBSTtJQUNwRTtBQUNELFFBQUl5VixVQUFVRyxRQUFRO0FBQ3BCLGFBQU9GLFFBQVFHLEtBQUssa0RBQWtEN1YsSUFBSTtJQUMzRTtBQUNELFVBQU14WixPQUFPMHVCLGNBQWNsVixJQUFJeVYsU0FBUztBQUN4QyxVQUFNSyxZQUFZZCwwQkFBMEJ4dUIsTUFBTWd2QixjQUFjO0FBQ2hFLFVBQU1PLHNCQUFzQlQsY0FBY2pXLFVBQVUsQ0FBQTtBQUNwREEsV0FBT1csTUFBTWdXLFFBQVF4d0IsdUJBQU91cEIsT0FBTyxJQUFJLEdBQUc7TUFBQztRQUFDdm9CO01BQUs7TUFBRWl2QjtNQUFXTSxvQkFBb0J2dkI7TUFBT3V2QixvQkFBb0JEO0lBQVcsQ0FBQTtFQUN6SCxDQUFBO0FBR0RsaUIsU0FBT2hOLEtBQUtndUIsU0FBU2xwQixRQUFRRSxDQUFBQSxZQUFXO0FBQ3RDLFVBQU13SCxPQUFPeEgsUUFBUXdILFFBQVFRLE9BQU9SO0FBQ3BDLFVBQU0waEIsWUFBWWxwQixRQUFRa3BCLGFBQWFKLGFBQWF0aEIsTUFBTXhOLE9BQU87QUFDakUsVUFBTSt1QixrQkFBa0JuRixVQUFVcGMsU0FBUyxDQUFBO0FBQzNDLFVBQU0yaUIsc0JBQXNCcEIsZ0JBQWdCdFYsVUFBVSxDQUFBO0FBQ3REN1osV0FBT3NULEtBQUtpZCxtQkFBbUIsRUFBRXJxQixRQUFRdXFCLENBQUFBLGNBQWE7QUFDcEQsWUFBTXp2QixPQUFPdXVCLDBCQUEwQmtCLFdBQVduQixTQUFTO0FBQzNELFlBQU05VSxLQUFLcFUsUUFBUXBGLE9BQU8sYUFBYUE7QUFDdkM2WSxhQUFPVyxNQUFNWCxPQUFPVyxPQUFPeGEsdUJBQU91cEIsT0FBTyxJQUFJO0FBQzdDaUgsY0FBUTNXLE9BQU9XLEtBQUs7UUFBQztVQUFDeFo7UUFBSztRQUFFK3VCLGFBQWF2VjtRQUFLK1Ysb0JBQW9CRTtNQUFXLENBQUE7SUFDL0UsQ0FBQTtFQUNGLENBQUE7QUFHRHp3QixTQUFPc1QsS0FBS3VHLE1BQU0sRUFBRTNULFFBQVFxTixDQUFBQSxRQUFPO0FBQ2pDLFVBQU13QixRQUFROEUsT0FBT3RHO0FBQ3JCaWQsWUFBUXpiLE9BQU87TUFBQ0gsU0FBU2lGLE9BQU85RSxNQUFNbkg7TUFBT2dILFNBQVNHO0lBQU0sQ0FBQTtFQUM3RCxDQUFBO0FBRUQsU0FBTzhFO0FBQ1I7QUFFRCxTQUFTNlcsWUFBWXRpQixRQUFRO0FBQzNCLFFBQU1oTyxVQUFVZ08sT0FBT2hPLFlBQVlnTyxPQUFPaE8sVUFBVSxDQUFBO0FBRXBEQSxVQUFRbXJCLFVBQVVuVSxlQUFlaFgsUUFBUW1yQixTQUFTLENBQUEsQ0FBRTtBQUNwRG5yQixVQUFReVosU0FBU2dXLGlCQUFpQnpoQixRQUFRaE8sT0FBTztBQUNsRDtBQUVELFNBQVN1d0IsU0FBU3Z2QixNQUFNO0FBQ3RCQSxTQUFPQSxRQUFRLENBQUE7QUFDZkEsT0FBS2d1QixXQUFXaHVCLEtBQUtndUIsWUFBWSxDQUFBO0FBQ2pDaHVCLE9BQUswYixTQUFTMWIsS0FBSzBiLFVBQVUsQ0FBQTtBQUM3QixTQUFPMWI7QUFDUjtBQUVELFNBQVN3dkIsV0FBV3hpQixRQUFRO0FBQzFCQSxXQUFTQSxVQUFVLENBQUE7QUFDbkJBLFNBQU9oTixPQUFPdXZCLFNBQVN2aUIsT0FBT2hOLElBQUk7QUFFbENzdkIsY0FBWXRpQixNQUFNO0FBRWxCLFNBQU9BO0FBQ1I7QUFFRCxJQUFNeWlCLFdBQVcsb0JBQUlwZixJQUFHO0FBQ3hCLElBQU1xZixhQUFhLG9CQUFJQyxJQUFHO0FBRTFCLFNBQVNDLFdBQVdDLFVBQVVDLFVBQVU7QUFDdEMsTUFBSTVkLE9BQU91ZCxTQUFTNUcsSUFBSWdILFFBQVE7QUFDaEMsTUFBSSxDQUFDM2QsTUFBTTtBQUNUQSxXQUFPNGQsU0FBUTtBQUNmTCxhQUFTM2UsSUFBSStlLFVBQVUzZCxJQUFJO0FBQzNCd2QsZUFBV3J3QixJQUFJNlMsSUFBSTtFQUNwQjtBQUNELFNBQU9BO0FBQ1I7QUFFRCxJQUFNNmQsYUFBYSxDQUFDamYsTUFBS2tmLEtBQUs3ZCxRQUFRO0FBQ3BDLFFBQU1tVSxPQUFPMkosaUJBQWlCRCxLQUFLN2QsR0FBRztBQUN0QyxNQUFJbVUsU0FBUzdYLFFBQVc7QUFDdEJxQyxJQUFBQSxLQUFJelIsSUFBSWluQixJQUFJO0VBQ2I7O0FBR1ksSUFBTTRKLFNBQU4sTUFBWTtFQUN6Qm54QixZQUFZaU8sUUFBUTtBQUNsQixTQUFLbWpCLFVBQVVYLFdBQVd4aUIsTUFBTTtBQUNoQyxTQUFLb2pCLGNBQWMsb0JBQUkvZixJQUFHO0FBQzFCLFNBQUtnZ0IsaUJBQWlCLG9CQUFJaGdCLElBQUc7RUFDOUI7RUFFRCxJQUFJaWdCLFdBQVc7QUFDYixXQUFPLEtBQUtILFFBQVFHO0VBQ3JCO0VBRUQsSUFBSTlqQixPQUFPO0FBQ1QsV0FBTyxLQUFLMmpCLFFBQVEzakI7RUFDckI7RUFFRCxJQUFJQSxLQUFLQSxNQUFNO0FBQ2IsU0FBSzJqQixRQUFRM2pCLE9BQU9BO0VBQ3JCO0VBRUQsSUFBSXhNLE9BQU87QUFDVCxXQUFPLEtBQUttd0IsUUFBUW53QjtFQUNyQjtFQUVELElBQUlBLEtBQUtBLE1BQU07QUFDYixTQUFLbXdCLFFBQVFud0IsT0FBT3V2QixTQUFTdnZCLElBQUk7RUFDbEM7RUFFRCxJQUFJaEIsVUFBVTtBQUNaLFdBQU8sS0FBS214QixRQUFRbnhCO0VBQ3JCO0VBRUQsSUFBSUEsUUFBUUEsU0FBUztBQUNuQixTQUFLbXhCLFFBQVFueEIsVUFBVUE7RUFDeEI7RUFFRCxJQUFJbXJCLFVBQVU7QUFDWixXQUFPLEtBQUtnRyxRQUFRaEc7RUFDckI7RUFFRDVmLFNBQVM7QUFDUCxVQUFNeUMsU0FBUyxLQUFLbWpCO0FBQ3BCLFNBQUtJLFdBQVU7QUFDZmpCLGdCQUFZdGlCLE1BQU07RUFDbkI7RUFFRHVqQixhQUFhO0FBQ1gsU0FBS0gsWUFBWUksTUFBSztBQUN0QixTQUFLSCxlQUFlRyxNQUFLO0VBQzFCO0VBUURDLGlCQUFpQkMsYUFBYTtBQUM1QixXQUFPZCxXQUFXYyxhQUNoQixNQUFNO01BQUM7UUFDTCxZQUFZQTtRQUNaO01BQ0Q7SUFBQyxDQUFBO0VBQ0w7RUFTREMsMEJBQTBCRCxhQUFhRSxZQUFZO0FBQ2pELFdBQU9oQixXQUFXLEdBQUdjLDBCQUEwQkUsY0FDN0MsTUFBTTtNQUNKO1FBQ0UsWUFBWUYsMkJBQTJCRTtRQUN2QyxlQUFlQTtNQUNoQjtNQUVEO1FBQ0UsWUFBWUY7UUFDWjtNQUNEO0lBQ0YsQ0FBQTtFQUNKO0VBVURHLHdCQUF3QkgsYUFBYUksYUFBYTtBQUNoRCxXQUFPbEIsV0FBVyxHQUFHYyxlQUFlSSxlQUNsQyxNQUFNO01BQUM7UUFDTCxZQUFZSix3QkFBd0JJO1FBQ3BDLFlBQVlKO1FBQ1osWUFBWUk7UUFDWjtNQUNEO0lBQUMsQ0FBQTtFQUNMO0VBT0R2RCxnQkFBZ0JmLFFBQVE7QUFDdEIsVUFBTXBULEtBQUtvVCxPQUFPcFQ7QUFDbEIsVUFBTTVNLE9BQU8sS0FBS0E7QUFDbEIsV0FBT29qQixXQUFXLEdBQUdwakIsZUFBZTRNLE1BQ2xDLE1BQU07TUFBQztRQUNMLFdBQVdBO1dBQ1JvVCxPQUFPdUUsMEJBQTBCLENBQUE7TUFDckM7SUFBQyxDQUFBO0VBQ0w7RUFLREMsY0FBY0MsV0FBV0MsWUFBWTtBQUNuQyxVQUFNZCxjQUFjLEtBQUtBO0FBQ3pCLFFBQUloWixRQUFRZ1osWUFBWXZILElBQUlvSSxTQUFTO0FBQ3JDLFFBQUksQ0FBQzdaLFNBQVM4WixZQUFZO0FBQ3hCOVosY0FBUSxvQkFBSS9HLElBQUc7QUFDZitmLGtCQUFZdGYsSUFBSW1nQixXQUFXN1osS0FBSztJQUNqQztBQUNELFdBQU9BO0VBQ1I7RUFRRHFXLGdCQUFnQndELFdBQVdFLFVBQVVELFlBQVk7QUFDL0MsVUFBTSxFQUFDbHlCLFNBQVN3TixLQUFJLElBQUk7QUFDeEIsVUFBTTRLLFFBQVEsS0FBSzRaLGNBQWNDLFdBQVdDLFVBQVU7QUFDdEQsVUFBTUUsU0FBU2hhLE1BQU15UixJQUFJc0ksUUFBUTtBQUNqQyxRQUFJQyxRQUFRO0FBQ1YsYUFBT0E7SUFDUjtBQUVELFVBQU01RCxTQUFTLG9CQUFJbUMsSUFBRztBQUV0QndCLGFBQVNyc0IsUUFBUW9OLENBQUFBLFNBQVE7QUFDdkIsVUFBSStlLFdBQVc7QUFDYnpELGVBQU9udUIsSUFBSTR4QixTQUFTO0FBQ3BCL2UsYUFBS3BOLFFBQVFxTixDQUFBQSxRQUFPNGQsV0FBV3ZDLFFBQVF5RCxXQUFXOWUsR0FBRyxDQUFDO01BQ3ZEO0FBQ0RELFdBQUtwTixRQUFRcU4sQ0FBQUEsUUFBTzRkLFdBQVd2QyxRQUFReHVCLFNBQVNtVCxHQUFHLENBQUM7QUFDcERELFdBQUtwTixRQUFRcU4sQ0FBQUEsUUFBTzRkLFdBQVd2QyxRQUFRNUUsVUFBVXBjLFNBQVMsQ0FBQSxHQUFJMkYsR0FBRyxDQUFDO0FBQ2xFRCxXQUFLcE4sUUFBUXFOLENBQUFBLFFBQU80ZCxXQUFXdkMsUUFBUWhhLFVBQVVyQixHQUFHLENBQUM7QUFDckRELFdBQUtwTixRQUFRcU4sQ0FBQUEsUUFBTzRkLFdBQVd2QyxRQUFRdEUsYUFBYS9XLEdBQUcsQ0FBQztJQUN6RCxDQUFBO0FBRUQsVUFBTTdNLFFBQVErckIsTUFBTUMsS0FBSzlELE1BQU07QUFDL0IsUUFBSWxvQixNQUFNbEYsV0FBVyxHQUFHO0FBQ3RCa0YsWUFBTWpDLEtBQUt6RSx1QkFBT3VwQixPQUFPLElBQUksQ0FBQztJQUMvQjtBQUNELFFBQUl1SCxXQUFXNkIsSUFBSUosUUFBUSxHQUFHO0FBQzVCL1osWUFBTXRHLElBQUlxZ0IsVUFBVTdyQixLQUFLO0lBQzFCO0FBQ0QsV0FBT0E7RUFDUjtFQU1Ea3NCLG9CQUFvQjtBQUNsQixVQUFNLEVBQUN4eUIsU0FBU3dOLEtBQUksSUFBSTtBQUV4QixXQUFPO01BQ0x4TjtNQUNBNHBCLFVBQVVwYyxTQUFTLENBQUE7TUFDbkJnSCxTQUFTd2EsU0FBU3hoQixTQUFTLENBQUE7TUFDM0I7UUFBQ0E7TUFBSztNQUNOZ0g7TUFDQTBWOztFQUVIO0VBU0R1SSxvQkFBb0JqRSxRQUFRa0UsUUFBT3BsQixTQUFTcWxCLFdBQVc7SUFBQztLQUFLO0FBQzNELFVBQU1oYyxTQUFTO01BQUNpYyxTQUFTOztBQUN6QixVQUFNLEVBQUNDLFVBQVVDLFlBQVcsSUFBSUMsWUFBWSxLQUFLMUIsZ0JBQWdCN0MsUUFBUW1FLFFBQVE7QUFDakYsUUFBSTN5QixVQUFVNnlCO0FBQ2QsUUFBSUcsWUFBWUgsVUFBVUgsTUFBSyxHQUFHO0FBQ2hDL2IsYUFBT2ljLFVBQVU7QUFDakJ0bEIsZ0JBQVUybEIsV0FBVzNsQixPQUFPLElBQUlBLFFBQU8sSUFBS0E7QUFFNUMsWUFBTTRsQixjQUFjLEtBQUt4RSxlQUFlRixRQUFRbGhCLFNBQVN3bEIsV0FBVztBQUNwRTl5QixnQkFBVW16QixlQUFlTixVQUFVdmxCLFNBQVM0bEIsV0FBVztJQUN4RDtBQUVELGVBQVdwZ0IsUUFBUTRmLFFBQU87QUFDeEIvYixhQUFPN0QsUUFBUTlTLFFBQVE4UztJQUN4QjtBQUNELFdBQU82RDtFQUNSO0VBUUQrWCxlQUFlRixRQUFRbGhCLFNBQVNxbEIsV0FBVztJQUFDO0VBQUcsR0FBRVMsb0JBQW9CO0FBQ25FLFVBQU0sRUFBQ1AsU0FBUSxJQUFJRSxZQUFZLEtBQUsxQixnQkFBZ0I3QyxRQUFRbUUsUUFBUTtBQUNwRSxXQUFPM29CLFNBQVNzRCxPQUFPLElBQ25CNmxCLGVBQWVOLFVBQVV2bEIsU0FBU21DLFFBQVcyakIsa0JBQWtCLElBQy9EUDtFQUNMOztBQUdILFNBQVNFLFlBQVlNLGVBQWU3RSxRQUFRbUUsVUFBVTtBQUNwRCxNQUFJdmEsUUFBUWliLGNBQWN4SixJQUFJMkUsTUFBTTtBQUNwQyxNQUFJLENBQUNwVyxPQUFPO0FBQ1ZBLFlBQVEsb0JBQUkvRyxJQUFHO0FBQ2ZnaUIsa0JBQWN2aEIsSUFBSTBjLFFBQVFwVyxLQUFLO0VBQ2hDO0FBQ0QsUUFBTXlZLFdBQVc4QixTQUFTaEksS0FBSTtBQUM5QixNQUFJeUgsU0FBU2hhLE1BQU15UixJQUFJZ0gsUUFBUTtBQUMvQixNQUFJLENBQUN1QixRQUFRO0FBQ1gsVUFBTVMsV0FBV1MsZ0JBQWdCOUUsUUFBUW1FLFFBQVE7QUFDakRQLGFBQVM7TUFDUFM7TUFDQUMsYUFBYUgsU0FBU3BzQixPQUFPZ3RCLENBQUFBLE1BQUssQ0FBQ0EsRUFBRS9ELFlBQVcsRUFBR3puQixTQUFTLE9BQU8sQ0FBQzs7QUFFdEVxUSxVQUFNdEcsSUFBSStlLFVBQVV1QixNQUFNO0VBQzNCO0FBQ0QsU0FBT0E7QUFDUjtBQUVELElBQU1vQixjQUFjM3lCLENBQUFBLFVBQVNtSixTQUFTbkosS0FBSyxLQUN0Q2pCLE9BQU82ekIsb0JBQW9CNXlCLEtBQUssRUFBRWdNLE9BQU8sQ0FBQzZtQixLQUFLdmdCLFFBQVF1Z0IsT0FBT1QsV0FBV3B5QixNQUFNc1MsSUFBSSxHQUFHLEtBQUs7QUFFaEcsU0FBUzZmLFlBQVlyZ0IsT0FBTytmLFFBQU87QUFDakMsUUFBTSxFQUFDaUIsY0FBY0MsWUFBVyxJQUFJdEcsYUFBYTNhLEtBQUs7QUFFdEQsYUFBV0csUUFBUTRmLFFBQU87QUFDeEIsVUFBTS9ELGFBQWFnRixhQUFhN2dCLElBQUk7QUFDcEMsVUFBTThiLFlBQVlnRixZQUFZOWdCLElBQUk7QUFDbEMsVUFBTWpTLFNBQVMrdEIsYUFBYUQsZUFBZWhjLE1BQU1HO0FBQ2pELFFBQUs2YixlQUFlc0UsV0FBV3B5QixLQUFLLEtBQUsyeUIsWUFBWTN5QixLQUFLLE1BQ3BEK3RCLGFBQWE5VixRQUFRalksS0FBSyxHQUFJO0FBQ2xDLGFBQU87SUFDUjtFQUNGO0FBQ0QsU0FBTztBQUNSOztBQ3hYRCxJQUFNZ3pCLGtCQUFrQjtFQUFDO0VBQU87RUFBVTtFQUFRO0VBQVM7O0FBQzNELFNBQVNDLHFCQUFxQjN4QixVQUFVdkIsTUFBTTtBQUM1QyxTQUFPdUIsYUFBYSxTQUFTQSxhQUFhLFlBQWEweEIsZ0JBQWdCOXdCLFFBQVFaLFFBQVEsTUFBTSxNQUFNdkIsU0FBUztBQUM3RztBQUVELFNBQVNtekIsY0FBY0MsSUFBSUMsSUFBSTtBQUM3QixTQUFPLFNBQVNsdEIsR0FBR0MsR0FBRztBQUNwQixXQUFPRCxFQUFFaXRCLFFBQVFodEIsRUFBRWd0QixNQUNmanRCLEVBQUVrdEIsTUFBTWp0QixFQUFFaXRCLE1BQ1ZsdEIsRUFBRWl0QixNQUFNaHRCLEVBQUVndEI7O0FBRWpCO0FBRUQsU0FBU0UscUJBQXFCNW1CLFNBQVM7QUFDckMsUUFBTXBMLFFBQVFvTCxRQUFRcEw7QUFDdEIsUUFBTWl5QixtQkFBbUJqeUIsTUFBTWxDLFFBQVFtTztBQUV2Q2pNLFFBQU02YyxjQUFjLGFBQWE7QUFDakMwTyxXQUFhMEcsb0JBQW9CQSxpQkFBaUJDLFlBQVk7SUFBQzltQjtLQUFVcEwsS0FBSztBQUMvRTtBQUVELFNBQVNteUIsb0JBQW9CL21CLFNBQVM7QUFDcEMsUUFBTXBMLFFBQVFvTCxRQUFRcEw7QUFDdEIsUUFBTWl5QixtQkFBbUJqeUIsTUFBTWxDLFFBQVFtTztBQUN2Q3NmLFdBQWEwRyxvQkFBb0JBLGlCQUFpQkcsWUFBWTtJQUFDaG5CO0tBQVVwTCxLQUFLO0FBQy9FO0FBTUQsU0FBU3F5QixVQUFVem9CLE1BQU07QUFDdkIsTUFBSTZILGdCQUFlLEtBQU0sT0FBTzdILFNBQVMsVUFBVTtBQUNqREEsV0FBT2tGLFNBQVN3akIsZUFBZTFvQixJQUFJO0VBQ3BDLFdBQVVBLFFBQVFBLEtBQUsxSyxRQUFRO0FBRTlCMEssV0FBT0EsS0FBSztFQUNiO0FBRUQsTUFBSUEsUUFBUUEsS0FBS3FCLFFBQVE7QUFFdkJyQixXQUFPQSxLQUFLcUI7RUFDYjtBQUNELFNBQU9yQjtBQUNSO0FBRUQsSUFBTTJvQixZQUFZLENBQUE7QUFDbEIsSUFBTUMsV0FBVyxDQUFDdmhCLFFBQVE7QUFDeEIsUUFBTWhHLFNBQVNvbkIsVUFBVXBoQixHQUFHO0FBQzVCLFNBQU92VCxPQUFPKzBCLE9BQU9GLFNBQVMsRUFBRWx1QixPQUFPLENBQUNxdUIsTUFBTUEsRUFBRXpuQixXQUFXQSxNQUFNLEVBQUVzZCxJQUFHOztBQUd4RSxTQUFTb0ssZ0JBQWdCN0QsS0FBS252QixPQUFPaXpCLE1BQU07QUFDekMsUUFBTTVoQixPQUFPdFQsT0FBT3NULEtBQUs4ZCxHQUFHO0FBQzVCLGFBQVc3ZCxPQUFPRCxNQUFNO0FBQ3RCLFVBQU02aEIsU0FBUyxDQUFDNWhCO0FBQ2hCLFFBQUk0aEIsVUFBVWx6QixPQUFPO0FBQ25CLFlBQU1oQixRQUFRbXdCLElBQUk3ZDtBQUNsQixhQUFPNmQsSUFBSTdkO0FBQ1gsVUFBSTJoQixPQUFPLEtBQUtDLFNBQVNsekIsT0FBTztBQUM5Qm12QixZQUFJK0QsU0FBU0QsUUFBUWowQjtNQUN0QjtJQUNGO0VBQ0Y7QUFDRjtBQVNELFNBQVNtMEIsbUJBQW1CcnZCLEdBQUdzdkIsV0FBV0MsYUFBYUMsU0FBUztBQUM5RCxNQUFJLENBQUNELGVBQWV2dkIsRUFBRTZILFNBQVMsWUFBWTtBQUN6QyxXQUFPO0VBQ1I7QUFDRCxNQUFJMm5CLFNBQVM7QUFDWCxXQUFPRjtFQUNSO0FBQ0QsU0FBT3R2QjtBQUNSO0FBRUQsU0FBU3l2QixlQUFlcnZCLE1BQU07QUFDNUIsUUFBTSxFQUFDc3ZCLFFBQVFDLE9BQU0sSUFBSXZ2QjtBQUN6QixNQUFJc3ZCLFVBQVVDLFFBQVE7QUFDcEIsV0FBTztNQUNMdHNCLE1BQU1xc0IsT0FBT3JzQjtNQUNiQyxPQUFPb3NCLE9BQU9wc0I7TUFDZEMsS0FBS29zQixPQUFPcHNCO01BQ1pDLFFBQVFtc0IsT0FBT25zQjs7RUFFbEI7QUFDRjtBQUVELElBQU1vc0IsUUFBTixNQUFXO0VBU1QsT0FBT2pNLFlBQVl4bEIsT0FBTztBQUN4QjhvQixhQUFTdnNCLElBQU95RCxHQUFBQSxLQUFLO0FBQ3JCMHhCLHNCQUFpQjtFQUNsQjtFQUVELE9BQU8xTCxjQUFjaG1CLE9BQU87QUFDMUI4b0IsYUFBU3JCLE9BQVV6bkIsR0FBQUEsS0FBSztBQUN4QjB4QixzQkFBaUI7RUFDbEI7RUFHRHoxQixZQUFZK0wsTUFBTTJwQixZQUFZO0FBQzVCLFVBQU16bkIsU0FBUyxLQUFLQSxTQUFTLElBQUlrakIsT0FBT3VFLFVBQVU7QUFDbEQsVUFBTUMsZ0JBQWdCbkIsVUFBVXpvQixJQUFJO0FBQ3BDLFVBQU02cEIsZ0JBQWdCakIsU0FBU2dCLGFBQWE7QUFDNUMsUUFBSUMsZUFBZTtBQUNqQixZQUFNLElBQUluMkIsTUFDUiw4Q0FBK0NtMkIsY0FBY3ZiLEtBQUssb0RBQ2xCdWIsY0FBY3hvQixPQUFPaU4sS0FBSyxrQkFBbUI7SUFFaEc7QUFFRCxVQUFNcGEsVUFBVWdPLE9BQU8wZ0IsZUFBZTFnQixPQUFPd2tCLGtCQUFpQixHQUFJLEtBQUt0a0IsV0FBVSxDQUFFO0FBRW5GLFNBQUtvakIsV0FBVyxLQUFLdGpCLE9BQU9zakIsWUFBWTVkLGdCQUFnQmdpQixhQUFhLEdBQUM7QUFDdEUsU0FBS3BFLFNBQVN2akIsYUFBYUMsTUFBTTtBQUVqQyxVQUFNVixVQUFVLEtBQUtna0IsU0FBU3BrQixlQUFld29CLGVBQWUxMUIsUUFBUW9OLFdBQVc7QUFDL0UsVUFBTUQsU0FBU0csV0FBV0EsUUFBUUg7QUFDbEMsVUFBTXRFLFNBQVNzRSxVQUFVQSxPQUFPdEU7QUFDaEMsVUFBTUYsUUFBUXdFLFVBQVVBLE9BQU94RTtBQUUvQixTQUFLeVIsS0FBS3diLElBQUc7QUFDYixTQUFLaGpCLE1BQU10RjtBQUNYLFNBQUtILFNBQVNBO0FBQ2QsU0FBS3hFLFFBQVFBO0FBQ2IsU0FBS0UsU0FBU0E7QUFDZCxTQUFLZ3RCLFdBQVc3MUI7QUFJaEIsU0FBSzgxQixlQUFlLEtBQUsxb0I7QUFDekIsU0FBS3JCLFVBQVUsQ0FBQTtBQUNmLFNBQUtncUIsWUFBWSxDQUFBO0FBQ2pCLFNBQUtDLFVBQVV2bUI7QUFDZixTQUFLcEksUUFBUSxDQUFBO0FBQ2IsU0FBS3VLLDBCQUEwQm5DO0FBQy9CLFNBQUt0TCxZQUFZc0w7QUFDakIsU0FBS3dtQixVQUFVLENBQUE7QUFDZixTQUFLQyxhQUFhem1CO0FBQ2xCLFNBQUswbUIsYUFBYSxDQUFBO0FBRWxCLFNBQUtDLHVCQUF1QjNtQjtBQUM1QixTQUFLNG1CLGtCQUFrQixDQUFBO0FBQ3ZCLFNBQUs1YyxTQUFTLENBQUE7QUFDZCxTQUFLNmMsV0FBVyxJQUFJdEosY0FBYTtBQUNqQyxTQUFLM1osV0FBVyxDQUFBO0FBQ2hCLFNBQUtrakIsaUJBQWlCLENBQUE7QUFDdEIsU0FBS0MsV0FBVztBQUNoQixTQUFLQyxzQkFBc0JobkI7QUFDM0IsU0FBS2dNLFdBQVdoTTtBQUNoQixTQUFLaW5CLFlBQVlDLFNBQVNDLENBQUFBLFNBQVEsS0FBS3JyQixPQUFPcXJCLElBQUksR0FBRzUyQixRQUFRNjJCLGVBQWUsQ0FBQztBQUM3RSxTQUFLQyxlQUFlLENBQUE7QUFHcEJyQyxjQUFVLEtBQUtyYSxNQUFNO0FBRXJCLFFBQUksQ0FBQzlNLFdBQVcsQ0FBQ0gsUUFBUTtBQUt2QjJpQixjQUFRQyxNQUFNLG1FQUFtRTtBQUNqRjtJQUNEO0FBRURnSCxhQUFTQyxPQUFPLE1BQU0sWUFBWTlDLG9CQUFvQjtBQUN0RDZDLGFBQVNDLE9BQU8sTUFBTSxZQUFZM0MsbUJBQW1CO0FBRXJELFNBQUs0QyxZQUFXO0FBQ2hCLFFBQUksS0FBS1QsVUFBVTtBQUNqQixXQUFLanJCLE9BQU07SUFDWjtFQUNGO0VBRUQsSUFBSTZCLGNBQWM7QUFDaEIsVUFBTSxFQUFDcE4sU0FBUyxFQUFDb04sYUFBYThwQixvQkFBbUIsR0FBR3Z1QixPQUFPRSxRQUFRaXRCLGFBQVksSUFBSTtBQUNuRixRQUFJLENBQUMvaUIsY0FBYzNGLFdBQVcsR0FBRztBQUUvQixhQUFPQTtJQUNSO0FBRUQsUUFBSThwQix1QkFBdUJwQixjQUFjO0FBRXZDLGFBQU9BO0lBQ1I7QUFHRCxXQUFPanRCLFNBQVNGLFFBQVFFLFNBQVM7RUFDbEM7RUFFRCxJQUFJN0gsT0FBTztBQUNULFdBQU8sS0FBS2dOLE9BQU9oTjtFQUNwQjtFQUVELElBQUlBLEtBQUtBLE1BQU07QUFDYixTQUFLZ04sT0FBT2hOLE9BQU9BO0VBQ3BCO0VBRUQsSUFBSWhCLFVBQVU7QUFDWixXQUFPLEtBQUs2MUI7RUFDYjtFQUVELElBQUk3MUIsUUFBUUEsU0FBUztBQUNuQixTQUFLZ08sT0FBT2hPLFVBQVVBO0VBQ3ZCO0VBRUQsSUFBSTRzQixXQUFXO0FBQ2IsV0FBT0E7RUFDUjtFQUtEcUssY0FBYztBQUVaLFNBQUtsWSxjQUFjLFlBQVk7QUFFL0IsUUFBSSxLQUFLL2UsUUFBUW0zQixZQUFZO0FBQzNCLFdBQUt4bEIsT0FBTTtXQUNOO0FBQ0x5bEIsa0JBQVksTUFBTSxLQUFLcDNCLFFBQVEwUixnQkFBZ0I7SUFDaEQ7QUFFRCxTQUFLMmxCLFdBQVU7QUFHZixTQUFLdFksY0FBYyxXQUFXO0FBRTlCLFdBQU87RUFDUjtFQUVEeVMsUUFBUTtBQUNOOEYsZ0JBQVksS0FBS25xQixRQUFRLEtBQUt5RixHQUFHO0FBQ2pDLFdBQU87RUFDUjtFQUVEMmtCLE9BQU87QUFDTFIsYUFBU1EsS0FBSyxJQUFJO0FBQ2xCLFdBQU87RUFDUjtFQU9ENWxCLE9BQU9oSixPQUFPRSxRQUFRO0FBQ3BCLFFBQUksQ0FBQ2t1QixTQUFTUyxRQUFRLElBQUksR0FBRztBQUMzQixXQUFLQyxRQUFROXVCLE9BQU9FLE1BQU07V0FDckI7QUFDTCxXQUFLNnVCLG9CQUFvQjtRQUFDL3VCO1FBQU9FOztJQUNsQztFQUNGO0VBRUQ0dUIsUUFBUTl1QixPQUFPRSxRQUFRO0FBQ3JCLFVBQU03SSxVQUFVLEtBQUtBO0FBQ3JCLFVBQU1tTixTQUFTLEtBQUtBO0FBQ3BCLFVBQU1DLGNBQWNwTixRQUFRazNCLHVCQUF1QixLQUFLOXBCO0FBQ3hELFVBQU11cUIsVUFBVSxLQUFLckcsU0FBUzFqQixlQUFlVCxRQUFReEUsT0FBT0UsUUFBUXVFLFdBQVc7QUFDL0UsVUFBTXdxQixXQUFXNTNCLFFBQVEwUixvQkFBb0IsS0FBSzRmLFNBQVMzakIsb0JBQW1CO0FBQzlFLFVBQU1pcEIsT0FBTyxLQUFLanVCLFFBQVEsV0FBVztBQUVyQyxTQUFLQSxRQUFRZ3ZCLFFBQVFodkI7QUFDckIsU0FBS0UsU0FBUzh1QixRQUFROXVCO0FBQ3RCLFNBQUtpdEIsZUFBZSxLQUFLMW9CO0FBQ3pCLFFBQUksQ0FBQ2dxQixZQUFZLE1BQU1RLFVBQVUsSUFBSSxHQUFHO0FBQ3RDO0lBQ0Q7QUFFRCxTQUFLN1ksY0FBYyxVQUFVO01BQUM1VyxNQUFNd3ZCO0lBQVEsQ0FBQTtBQUU1Q2xLLGFBQWF6dEIsUUFBUTYzQixVQUFVO01BQUM7TUFBTUY7T0FBVSxJQUFJO0FBRXBELFFBQUksS0FBS25CLFVBQVU7QUFDakIsVUFBSSxLQUFLRSxVQUFVRSxJQUFJLEdBQUc7QUFFeEIsYUFBS2tCLE9BQU07TUFDWjtJQUNGO0VBQ0Y7RUFFREMsc0JBQXNCO0FBQ3BCLFVBQU0vM0IsVUFBVSxLQUFLQTtBQUNyQixVQUFNZzRCLGdCQUFnQmg0QixRQUFReVosVUFBVSxDQUFBO0FBRXhDL00sU0FBS3NyQixlQUFlLENBQUNDLGFBQWFuUCxXQUFXO0FBQzNDbVAsa0JBQVk3ZCxLQUFLME87SUFDbEIsQ0FBQTtFQUNGO0VBS0RvUCxzQkFBc0I7QUFDcEIsVUFBTWw0QixVQUFVLEtBQUtBO0FBQ3JCLFVBQU1tNEIsWUFBWW40QixRQUFReVo7QUFDMUIsVUFBTUEsU0FBUyxLQUFLQTtBQUNwQixVQUFNMmUsVUFBVXg0QixPQUFPc1QsS0FBS3VHLE1BQU0sRUFBRTVNLE9BQU8sQ0FBQ21rQixLQUFLNVcsT0FBTztBQUN0RDRXLFVBQUk1VyxNQUFNO0FBQ1YsYUFBTzRXO09BQ04sQ0FBQSxDQUFFO0FBQ0wsUUFBSWx0QixRQUFRLENBQUE7QUFFWixRQUFJcTBCLFdBQVc7QUFDYnIwQixjQUFRQSxNQUFNeUYsT0FDWjNKLE9BQU9zVCxLQUFLaWxCLFNBQVMsRUFBRUUsSUFBSSxDQUFDamUsT0FBTztBQUNqQyxjQUFNbVYsZUFBZTRJLFVBQVUvZDtBQUMvQixjQUFNeFosT0FBTzB1QixjQUFjbFYsSUFBSW1WLFlBQVk7QUFDM0MsY0FBTStJLFdBQVcxM0IsU0FBUztBQUMxQixjQUFNOEcsZUFBZTlHLFNBQVM7QUFDOUIsZUFBTztVQUNMWixTQUFTdXZCO1VBQ1RnSixXQUFXRCxXQUFXLGNBQWM1d0IsZUFBZSxXQUFXO1VBQzlEOHdCLE9BQU9GLFdBQVcsaUJBQWlCNXdCLGVBQWUsYUFBYTs7TUFFbEUsQ0FBQSxDQUFDO0lBRUw7QUFFRGdGLFNBQUs1SSxPQUFPLENBQUNnSSxTQUFTO0FBQ3BCLFlBQU15akIsZUFBZXpqQixLQUFLOUw7QUFDMUIsWUFBTW9hLEtBQUttVixhQUFhblY7QUFDeEIsWUFBTXhaLE9BQU8wdUIsY0FBY2xWLElBQUltVixZQUFZO0FBQzNDLFlBQU1rSixZQUFZemhCLGVBQWV1WSxhQUFhL2hCLE1BQU0xQixLQUFLMHNCLEtBQUs7QUFFOUQsVUFBSWpKLGFBQWFwdEIsYUFBYXNOLFVBQWFxa0IscUJBQXFCdkUsYUFBYXB0QixVQUFVdkIsSUFBSSxNQUFNa3pCLHFCQUFxQmhvQixLQUFLeXNCLFNBQVMsR0FBRztBQUNySWhKLHFCQUFhcHRCLFdBQVcySixLQUFLeXNCO01BQzlCO0FBRURILGNBQVFoZSxNQUFNO0FBQ2QsVUFBSXpGLFFBQVE7QUFDWixVQUFJeUYsTUFBTVgsVUFBVUEsT0FBT1csSUFBSTVNLFNBQVNpckIsV0FBVztBQUNqRDlqQixnQkFBUThFLE9BQU9XO2FBQ1Y7QUFDTCxjQUFNc2UsYUFBYTlMLFNBQVNaLFNBQVN5TSxTQUFTO0FBQzlDOWpCLGdCQUFRLElBQUkrakIsV0FBVztVQUNyQnRlO1VBQ0E1TSxNQUFNaXJCO1VBQ043bEIsS0FBSyxLQUFLQTtVQUNWMVEsT0FBTztRQUNSLENBQUE7QUFDRHVYLGVBQU85RSxNQUFNeUYsTUFBTXpGO01BQ3BCO0FBRURBLFlBQU0xVSxLQUFLc3ZCLGNBQWN2dkIsT0FBTztJQUNqQyxDQUFBO0FBRUQwTSxTQUFLMHJCLFNBQVMsQ0FBQ08sWUFBWXZlLE9BQU87QUFDaEMsVUFBSSxDQUFDdWUsWUFBWTtBQUNmLGVBQU9sZixPQUFPVztNQUNmO0lBQ0YsQ0FBQTtBQUVEMU4sU0FBSytNLFFBQVEsQ0FBQzlFLFVBQVU7QUFDdEIvTSxjQUFReUUsVUFBVSxNQUFNc0ksT0FBT0EsTUFBTTNVLE9BQU87QUFDNUM0SCxjQUFRaUUsT0FBTyxNQUFNOEksS0FBSztJQUMzQixDQUFBO0VBQ0Y7RUFLRGlrQixrQkFBa0I7QUFDaEIsVUFBTXYyQixXQUFXLEtBQUswekI7QUFDdEIsVUFBTThDLFVBQVUsS0FBSzczQixLQUFLZ3VCLFNBQVM1dEI7QUFDbkMsVUFBTTAzQixVQUFVejJCLFNBQVNqQjtBQUV6QmlCLGFBQVN5RSxLQUFLLENBQUNDLEdBQUdDLE1BQU1ELEVBQUV0RSxRQUFRdUUsRUFBRXZFLEtBQUs7QUFDekMsUUFBSXEyQixVQUFVRCxTQUFTO0FBQ3JCLGVBQVN0MkIsSUFBSXMyQixTQUFTdDJCLElBQUl1MkIsU0FBUyxFQUFFdjJCLEdBQUc7QUFDdEMsYUFBS3cyQixvQkFBb0J4MkIsQ0FBQztNQUMzQjtBQUNERixlQUFTK0osT0FBT3lzQixTQUFTQyxVQUFVRCxPQUFPO0lBQzNDO0FBQ0QsU0FBS3hDLGtCQUFrQmgwQixTQUFTMjJCLE1BQU0sQ0FBQyxFQUFFbHlCLEtBQUtpdEIsY0FBYyxTQUFTLE9BQU8sQ0FBQztFQUM5RTtFQUtEa0YsOEJBQThCO0FBQzVCLFVBQU0sRUFBQ2xELFdBQVcxekIsVUFBVXJCLE1BQU0sRUFBQ2d1QixTQUFRLEVBQUMsSUFBSTtBQUNoRCxRQUFJM3NCLFNBQVNqQixTQUFTNHRCLFNBQVM1dEIsUUFBUTtBQUNyQyxhQUFPLEtBQUs0MEI7SUFDYjtBQUNEM3pCLGFBQVN5RCxRQUFRLENBQUNDLE1BQU10RCxVQUFVO0FBQ2hDLFVBQUl1c0IsU0FBU3pvQixPQUFPakQsQ0FBQUEsTUFBS0EsTUFBTXlDLEtBQUttekIsUUFBUSxFQUFFOTNCLFdBQVcsR0FBRztBQUMxRCxhQUFLMjNCLG9CQUFvQnQyQixLQUFLO01BQy9CO0lBQ0YsQ0FBQTtFQUNGO0VBRUQwMkIsMkJBQTJCO0FBQ3pCLFVBQU1DLGlCQUFpQixDQUFBO0FBQ3ZCLFVBQU1wSyxXQUFXLEtBQUtodUIsS0FBS2d1QjtBQUMzQixRQUFJenNCLEdBQUdDO0FBRVAsU0FBS3kyQiw0QkFBMkI7QUFFaEMsU0FBSzEyQixJQUFJLEdBQUdDLE9BQU93c0IsU0FBUzV0QixRQUFRbUIsSUFBSUMsTUFBTUQsS0FBSztBQUNqRCxZQUFNeUQsVUFBVWdwQixTQUFTenNCO0FBQ3pCLFVBQUl3RCxPQUFPLEtBQUtFLGVBQWUxRCxDQUFDO0FBQ2hDLFlBQU1pTCxPQUFPeEgsUUFBUXdILFFBQVEsS0FBS1EsT0FBT1I7QUFFekMsVUFBSXpILEtBQUt5SCxRQUFRekgsS0FBS3lILFNBQVNBLE1BQU07QUFDbkMsYUFBS3VyQixvQkFBb0J4MkIsQ0FBQztBQUMxQndELGVBQU8sS0FBS0UsZUFBZTFELENBQUM7TUFDN0I7QUFDRHdELFdBQUt5SCxPQUFPQTtBQUNaekgsV0FBS21wQixZQUFZbHBCLFFBQVFrcEIsYUFBYUosYUFBYXRoQixNQUFNLEtBQUt4TixPQUFPO0FBQ3JFK0YsV0FBS3N6QixRQUFRcnpCLFFBQVFxekIsU0FBUztBQUM5QnR6QixXQUFLdEQsUUFBUUY7QUFDYndELFdBQUttWixRQUFRLEtBQUtsWixRQUFRa1o7QUFDMUJuWixXQUFLdXpCLFVBQVUsS0FBS0MsaUJBQWlCaDNCLENBQUM7QUFFdEMsVUFBSXdELEtBQUtoRixZQUFZO0FBQ25CZ0YsYUFBS2hGLFdBQVd5NEIsWUFBWWozQixDQUFDO0FBQzdCd0QsYUFBS2hGLFdBQVcwNEIsV0FBVTthQUNyQjtBQUNMLGNBQU1DLGtCQUFrQjlNLFNBQVNoQixjQUFjcGUsSUFBSTtBQUNuRCxjQUFNLEVBQUNtc0Isb0JBQW9CQyxnQkFBZSxJQUFJcGxCLFNBQVN3YSxTQUFTeGhCO0FBQ2hFNU4sZUFBT0MsT0FBTzY1QixpQkFBaUI7VUFDN0JFLGlCQUFpQmhOLFNBQVNkLFdBQVc4TixlQUFlO1VBQ3BERCxvQkFBb0JBLHNCQUFzQi9NLFNBQVNkLFdBQVc2TixrQkFBa0I7UUFDakYsQ0FBQTtBQUNENXpCLGFBQUtoRixhQUFhLElBQUkyNEIsZ0JBQWdCLE1BQU1uM0IsQ0FBQztBQUM3QzYyQix1QkFBZS8wQixLQUFLMEIsS0FBS2hGLFVBQVU7TUFDcEM7SUFDRjtBQUVELFNBQUs2M0IsZ0JBQWU7QUFDcEIsV0FBT1E7RUFDUjtFQU1EUyxpQkFBaUI7QUFDZm50QixTQUFLLEtBQUsxTCxLQUFLZ3VCLFVBQVUsQ0FBQ2hwQixTQUFTL0IsaUJBQWlCO0FBQ2xELFdBQUtnQyxlQUFlaEMsWUFBWSxFQUFFbEQsV0FBVys0QixNQUFLO09BQ2pELElBQUk7RUFDUjtFQUtEQSxRQUFRO0FBQ04sU0FBS0QsZUFBYztBQUNuQixTQUFLOWEsY0FBYyxPQUFPO0VBQzNCO0VBRUR4VCxPQUFPcXJCLE1BQU07QUFDWCxVQUFNNW9CLFNBQVMsS0FBS0E7QUFFcEJBLFdBQU96QyxPQUFNO0FBQ2IsVUFBTXZMLFVBQVUsS0FBSzYxQixXQUFXN25CLE9BQU8wZ0IsZUFBZTFnQixPQUFPd2tCLGtCQUFpQixHQUFJLEtBQUt0a0IsV0FBVSxDQUFFO0FBQ25HLFVBQU02ckIsZ0JBQWdCLEtBQUt0RCxzQkFBc0IsQ0FBQ3oyQixRQUFRbU87QUFFMUQsU0FBSzZyQixjQUFhO0FBQ2xCLFNBQUtDLG9CQUFtQjtBQUN4QixTQUFLQyxxQkFBb0I7QUFJekIsU0FBSzVELFNBQVMzSSxXQUFVO0FBRXhCLFFBQUksS0FBSzVPLGNBQWMsZ0JBQWdCO01BQUM2WDtNQUFNbEosWUFBWTtLQUFLLE1BQU0sT0FBTztBQUMxRTtJQUNEO0FBR0QsVUFBTTBMLGlCQUFpQixLQUFLRCx5QkFBd0I7QUFFcEQsU0FBS3BhLGNBQWMsc0JBQXNCO0FBR3pDLFFBQUl6UyxhQUFhO0FBQ2pCLGFBQVMvSixJQUFJLEdBQUdDLE9BQU8sS0FBS3hCLEtBQUtndUIsU0FBUzV0QixRQUFRbUIsSUFBSUMsTUFBTUQsS0FBSztBQUMvRCxZQUFNLEVBQUN4QixXQUFVLElBQUksS0FBS2tGLGVBQWUxRCxDQUFDO0FBQzFDLFlBQU11M0IsU0FBUSxDQUFDQyxpQkFBaUJYLGVBQWVyMkIsUUFBUWhDLFVBQVUsTUFBTTtBQUd2RUEsaUJBQVdvNUIsc0JBQXNCTCxNQUFLO0FBQ3RDeHRCLG1CQUFhbEosS0FBS3dHLElBQUksQ0FBQzdJLFdBQVdxNUIsZUFBYyxHQUFJOXRCLFVBQVU7SUFDL0Q7QUFDREEsaUJBQWEsS0FBSyt0QixjQUFjcjZCLFFBQVF3SSxPQUFPOHhCLGNBQWNodUIsYUFBYTtBQUMxRSxTQUFLaXVCLGNBQWNqdUIsVUFBVTtBQUc3QixRQUFJLENBQUN5dEIsZUFBZTtBQUdsQnJ0QixXQUFLMHNCLGdCQUFnQixDQUFDcjRCLGVBQWU7QUFDbkNBLG1CQUFXKzRCLE1BQUs7TUFDakIsQ0FBQTtJQUNGO0FBRUQsU0FBS1UsZ0JBQWdCNUQsSUFBSTtBQUd6QixTQUFLN1gsY0FBYyxlQUFlO01BQUM2WDtJQUFLLENBQUE7QUFFeEMsU0FBSzdxQixRQUFRakYsS0FBS2l0QixjQUFjLEtBQUssTUFBTSxDQUFDO0FBRzVDLFVBQU0sRUFBQ2tDLFNBQVNDLFdBQVUsSUFBSTtBQUM5QixRQUFJQSxZQUFZO0FBQ2QsV0FBS3VFLGNBQWN2RSxZQUFZLElBQUk7SUFDcEMsV0FBVUQsUUFBUTcwQixRQUFRO0FBQ3pCLFdBQUtzNUIsbUJBQW1CekUsU0FBU0EsU0FBUyxJQUFJO0lBQy9DO0FBRUQsU0FBSzZCLE9BQU07RUFDWjtFQUtEa0MsZ0JBQWdCO0FBQ2R0dEIsU0FBSyxLQUFLK00sUUFBUSxDQUFDOUUsVUFBVTtBQUMzQi9NLGNBQVFzRSxVQUFVLE1BQU15SSxLQUFLO0lBQzlCLENBQUE7QUFFRCxTQUFLb2pCLG9CQUFtQjtBQUN4QixTQUFLRyxvQkFBbUI7RUFDekI7RUFLRCtCLHNCQUFzQjtBQUNwQixVQUFNajZCLFVBQVUsS0FBS0E7QUFDckIsVUFBTTI2QixpQkFBaUIsSUFBSWhLLElBQUkvd0IsT0FBT3NULEtBQUssS0FBS2lqQixVQUFVLENBQUM7QUFDM0QsVUFBTXlFLFlBQVksSUFBSWpLLElBQUkzd0IsUUFBUTY2QixNQUFNO0FBRXhDLFFBQUksQ0FBQ0MsVUFBVUgsZ0JBQWdCQyxTQUFTLEtBQUssQ0FBQyxDQUFDLEtBQUt4RSx5QkFBeUJwMkIsUUFBUW0zQixZQUFZO0FBRS9GLFdBQUs0RCxhQUFZO0FBQ2pCLFdBQUsxRCxXQUFVO0lBQ2hCO0VBQ0Y7RUFLRDZDLHVCQUF1QjtBQUNyQixVQUFNLEVBQUMzRCxlQUFjLElBQUk7QUFDekIsVUFBTXlFLFVBQVUsS0FBS0MsdUJBQXNCLEtBQU0sQ0FBQTtBQUNqRCxlQUFXLEVBQUM1TyxRQUFReHFCLE9BQU9vRyxNQUFLLEtBQUsreUIsU0FBUztBQUM1QyxZQUFNbEcsT0FBT3pJLFdBQVcsb0JBQW9CLENBQUNwa0IsUUFBUUE7QUFDckQ0c0Isc0JBQWdCMEIsZ0JBQWdCMTBCLE9BQU9pekIsSUFBSTtJQUM1QztFQUNGO0VBS0RtRyx5QkFBeUI7QUFDdkIsVUFBTW5FLGVBQWUsS0FBS0E7QUFDMUIsUUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ0EsYUFBYTExQixRQUFRO0FBQ3pDO0lBQ0Q7QUFFRCxTQUFLMDFCLGVBQWUsQ0FBQTtBQUNwQixVQUFNb0UsZUFBZSxLQUFLbDZCLEtBQUtndUIsU0FBUzV0QjtBQUN4QyxVQUFNKzVCLFVBQVUsQ0FBQzdZLFFBQVEsSUFBSXFPLElBQzNCbUcsYUFDR3Z3QixPQUFPcXVCLENBQUFBLE1BQUtBLEVBQUUsT0FBT3RTLEdBQUcsRUFDeEIrVixJQUFJLENBQUN6RCxHQUFHcnlCLE1BQU1BLElBQUksTUFBTXF5QixFQUFFeG9CLE9BQU8sQ0FBQyxFQUFFdWUsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUduRCxVQUFNeVEsWUFBWUQsUUFBUSxDQUFDO0FBQzNCLGFBQVM1NEIsSUFBSSxHQUFHQSxJQUFJMjRCLGNBQWMzNEIsS0FBSztBQUNyQyxVQUFJLENBQUN1NEIsVUFBVU0sV0FBV0QsUUFBUTU0QixDQUFDLENBQUMsR0FBRztBQUNyQztNQUNEO0lBQ0Y7QUFDRCxXQUFPOHZCLE1BQU1DLEtBQUs4SSxTQUFTLEVBQ3hCL0MsSUFBSXpELENBQUFBLE1BQUtBLEVBQUVySyxNQUFNLEdBQUcsQ0FBQyxFQUNyQjhOLElBQUl0eEIsQ0FBQUEsT0FBTTtNQUFDc2xCLFFBQVF0bEIsRUFBRTtNQUFJbEYsT0FBTyxDQUFDa0YsRUFBRTtNQUFJa0IsT0FBTyxDQUFDbEIsRUFBRTtJQUFHLEVBQUM7RUFDekQ7RUFPRHd6QixjQUFjanVCLFlBQVk7QUFDeEIsUUFBSSxLQUFLeVMsY0FBYyxnQkFBZ0I7TUFBQzJPLFlBQVk7S0FBSyxNQUFNLE9BQU87QUFDcEU7SUFDRDtBQUVEOWxCLFlBQVEyRCxPQUFPLE1BQU0sS0FBSzVDLE9BQU8sS0FBS0UsUUFBUXlELFVBQVU7QUFFeEQsVUFBTWdjLE9BQU8sS0FBS25rQjtBQUNsQixVQUFNazNCLFNBQVMvUyxLQUFLM2YsU0FBUyxLQUFLMmYsS0FBS3pmLFVBQVU7QUFFakQsU0FBS2tELFVBQVUsQ0FBQTtBQUNmVyxTQUFLLEtBQUtyRixPQUFPLENBQUNWLFFBQVE7QUFDeEIsVUFBSTAwQixVQUFVMTBCLElBQUl4RSxhQUFhLGFBQWE7QUFFMUM7TUFDRDtBQUlELFVBQUl3RSxJQUFJMEYsV0FBVztBQUNqQjFGLFlBQUkwRixVQUFTO01BQ2Q7QUFDRCxXQUFLTixRQUFRMUgsS0FBSSxHQUFJc0MsSUFBSW9GLFFBQU8sQ0FBRTtPQUNqQyxJQUFJO0FBRVAsU0FBS0EsUUFBUWpHLFFBQVEsQ0FBQ2dHLE1BQU1ySixVQUFVO0FBQ3BDcUosV0FBS3d2QixPQUFPNzRCO0lBQ2IsQ0FBQTtBQUVELFNBQUtzYyxjQUFjLGFBQWE7RUFDakM7RUFPRHliLGdCQUFnQjVELE1BQU07QUFDcEIsUUFBSSxLQUFLN1gsY0FBYyx3QkFBd0I7TUFBQzZYO01BQU1sSixZQUFZO0tBQUssTUFBTSxPQUFPO0FBQ2xGO0lBQ0Q7QUFFRCxhQUFTbnJCLElBQUksR0FBR0MsT0FBTyxLQUFLeEIsS0FBS2d1QixTQUFTNXRCLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDL0QsV0FBSzBELGVBQWUxRCxDQUFDLEVBQUV4QixXQUFXc0wsVUFBUztJQUM1QztBQUVELGFBQVM5SixLQUFJLEdBQUdDLFFBQU8sS0FBS3hCLEtBQUtndUIsU0FBUzV0QixRQUFRbUIsS0FBSUMsT0FBTSxFQUFFRCxJQUFHO0FBQy9ELFdBQUtnNUIsZUFBZWg1QixJQUFHMHdCLFdBQVcyRCxJQUFJLElBQUlBLEtBQUs7UUFBQzN5QixjQUFjMUI7T0FBRSxJQUFJcTBCLElBQUk7SUFDekU7QUFFRCxTQUFLN1gsY0FBYyx1QkFBdUI7TUFBQzZYO0lBQUssQ0FBQTtFQUNqRDtFQU9EMkUsZUFBZTk0QixPQUFPbTBCLE1BQU07QUFDMUIsVUFBTTd3QixPQUFPLEtBQUtFLGVBQWV4RCxLQUFLO0FBQ3RDLFVBQU00b0IsT0FBTztNQUFDdGxCO01BQU10RDtNQUFPbTBCO01BQU1sSixZQUFZOztBQUU3QyxRQUFJLEtBQUszTyxjQUFjLHVCQUF1QnNNLElBQUksTUFBTSxPQUFPO0FBQzdEO0lBQ0Q7QUFFRHRsQixTQUFLaEYsV0FBV3k2QixRQUFRNUUsSUFBSTtBQUU1QnZMLFNBQUtxQyxhQUFhO0FBQ2xCLFNBQUszTyxjQUFjLHNCQUFzQnNNLElBQUk7RUFDOUM7RUFFRHlNLFNBQVM7QUFDUCxRQUFJLEtBQUsvWSxjQUFjLGdCQUFnQjtNQUFDMk8sWUFBWTtLQUFLLE1BQU0sT0FBTztBQUNwRTtJQUNEO0FBRUQsUUFBSXFKLFNBQVN4RSxJQUFJLElBQUksR0FBRztBQUN0QixVQUFJLEtBQUtpRSxZQUFZLENBQUNPLFNBQVNTLFFBQVEsSUFBSSxHQUFHO0FBQzVDVCxpQkFBU2wxQixNQUFNLElBQUk7TUFDcEI7V0FDSTtBQUNMLFdBQUtvSyxLQUFJO0FBQ1Rpb0IsMkJBQXFCO1FBQUNoeUIsT0FBTztNQUFLLENBQUE7SUFDbkM7RUFDRjtFQUVEK0osT0FBTztBQUNMLFFBQUkxSjtBQUNKLFFBQUksS0FBS20xQixtQkFBbUI7QUFDMUIsWUFBTSxFQUFDL3VCLE9BQU9FLE9BQU0sSUFBSSxLQUFLNnVCO0FBQzdCLFdBQUtELFFBQVE5dUIsT0FBT0UsTUFBTTtBQUMxQixXQUFLNnVCLG9CQUFvQjtJQUMxQjtBQUNELFNBQUtsRyxNQUFLO0FBRVYsUUFBSSxLQUFLN29CLFNBQVMsS0FBSyxLQUFLRSxVQUFVLEdBQUc7QUFDdkM7SUFDRDtBQUVELFFBQUksS0FBS2tXLGNBQWMsY0FBYztNQUFDMk8sWUFBWTtLQUFLLE1BQU0sT0FBTztBQUNsRTtJQUNEO0FBS0QsVUFBTStOLFNBQVMsS0FBSzF2QjtBQUNwQixTQUFLeEosSUFBSSxHQUFHQSxJQUFJazVCLE9BQU9yNkIsVUFBVXE2QixPQUFPbDVCLEdBQUd5SixLQUFLLEdBQUcsRUFBRXpKLEdBQUc7QUFDdERrNUIsYUFBT2w1QixHQUFHMEosS0FBSyxLQUFLOUgsU0FBUztJQUM5QjtBQUVELFNBQUt1M0IsY0FBYTtBQUdsQixXQUFPbjVCLElBQUlrNUIsT0FBT3I2QixRQUFRLEVBQUVtQixHQUFHO0FBQzdCazVCLGFBQU9sNUIsR0FBRzBKLEtBQUssS0FBSzlILFNBQVM7SUFDOUI7QUFFRCxTQUFLNGEsY0FBYyxXQUFXO0VBQy9CO0VBS0Q0Yyx1QkFBdUJDLGVBQWU7QUFDcEMsVUFBTXY1QixXQUFXLEtBQUtnMEI7QUFDdEIsVUFBTTFmLFNBQVMsQ0FBQTtBQUNmLFFBQUlwVSxHQUFHQztBQUVQLFNBQUtELElBQUksR0FBR0MsT0FBT0gsU0FBU2pCLFFBQVFtQixJQUFJQyxNQUFNLEVBQUVELEdBQUc7QUFDakQsWUFBTXdELE9BQU8xRCxTQUFTRTtBQUN0QixVQUFJLENBQUNxNUIsaUJBQWlCNzFCLEtBQUt1ekIsU0FBUztBQUNsQzNpQixlQUFPdFMsS0FBSzBCLElBQUk7TUFDakI7SUFDRjtBQUVELFdBQU80UTtFQUNSO0VBTURyVSwrQkFBK0I7QUFDN0IsV0FBTyxLQUFLcTVCLHVCQUF1QixJQUFJO0VBQ3hDO0VBT0RELGdCQUFnQjtBQUNkLFFBQUksS0FBSzNjLGNBQWMsc0JBQXNCO01BQUMyTyxZQUFZO0tBQUssTUFBTSxPQUFPO0FBQzFFO0lBQ0Q7QUFFRCxVQUFNcnJCLFdBQVcsS0FBS0MsNkJBQTRCO0FBQ2xELGFBQVNDLElBQUlGLFNBQVNqQixTQUFTLEdBQUdtQixLQUFLLEdBQUcsRUFBRUEsR0FBRztBQUM3QyxXQUFLczVCLGFBQWF4NUIsU0FBU0UsRUFBRTtJQUM5QjtBQUVELFNBQUt3YyxjQUFjLG1CQUFtQjtFQUN2QztFQU9EOGMsYUFBYTkxQixNQUFNO0FBQ2pCLFVBQU02TSxNQUFNLEtBQUtBO0FBQ2pCLFVBQU1rcEIsT0FBTy8xQixLQUFLZzJCO0FBQ2xCLFVBQU1DLFVBQVUsQ0FBQ0YsS0FBS0c7QUFDdEIsVUFBTTNULE9BQU84TSxlQUFlcnZCLElBQUksS0FBSyxLQUFLNUI7QUFDMUMsVUFBTWtuQixPQUFPO01BQ1h0bEI7TUFDQXRELE9BQU9zRCxLQUFLdEQ7TUFDWmlyQixZQUFZOztBQUdkLFFBQUksS0FBSzNPLGNBQWMscUJBQXFCc00sSUFBSSxNQUFNLE9BQU87QUFDM0Q7SUFDRDtBQUVELFFBQUkyUSxTQUFTO0FBQ1h6VCxlQUFTM1YsS0FBSztRQUNaNUosTUFBTTh5QixLQUFLOXlCLFNBQVMsUUFBUSxJQUFJc2YsS0FBS3RmLE9BQU84eUIsS0FBSzl5QjtRQUNqREMsT0FBTzZ5QixLQUFLN3lCLFVBQVUsUUFBUSxLQUFLTixRQUFRMmYsS0FBS3JmLFFBQVE2eUIsS0FBSzd5QjtRQUM3REMsS0FBSzR5QixLQUFLNXlCLFFBQVEsUUFBUSxJQUFJb2YsS0FBS3BmLE1BQU00eUIsS0FBSzV5QjtRQUM5Q0MsUUFBUTJ5QixLQUFLM3lCLFdBQVcsUUFBUSxLQUFLTixTQUFTeWYsS0FBS25mLFNBQVMyeUIsS0FBSzN5QjtNQUNsRSxDQUFBO0lBQ0Y7QUFFRHBELFNBQUtoRixXQUFXa0wsS0FBSTtBQUVwQixRQUFJK3ZCLFNBQVM7QUFDWHZULGlCQUFXN1YsR0FBRztJQUNmO0FBRUR5WSxTQUFLcUMsYUFBYTtBQUNsQixTQUFLM08sY0FBYyxvQkFBb0JzTSxJQUFJO0VBQzVDO0VBT0R0bkIsY0FBY21DLE9BQU87QUFDbkIsV0FBT2hDLGVBQWVnQyxPQUFPLEtBQUsvQixXQUFXLEtBQUtrMkIsV0FBVztFQUM5RDtFQUVENkIsMEJBQTBCdjJCLEdBQUdpeEIsTUFBTTUyQixTQUFTNEQsa0JBQWtCO0FBQzVELFVBQU15b0IsU0FBUzhQLFlBQVl6MkIsTUFBTWt4QjtBQUNqQyxRQUFJLE9BQU92SyxXQUFXLFlBQVk7QUFDaEMsYUFBT0EsT0FBTyxNQUFNMW1CLEdBQUczRixTQUFTNEQsZ0JBQWdCO0lBQ2pEO0FBRUQsV0FBTyxDQUFBO0VBQ1I7RUFFRHFDLGVBQWVoQyxjQUFjO0FBQzNCLFVBQU0rQixVQUFVLEtBQUtoRixLQUFLZ3VCLFNBQVMvcUI7QUFDbkMsVUFBTTVCLFdBQVcsS0FBSzB6QjtBQUN0QixRQUFJaHdCLE9BQU8xRCxTQUFTa0UsT0FBT2pELENBQUFBLE1BQUtBLEtBQUtBLEVBQUU0MUIsYUFBYWx6QixPQUFPLEVBQUV5a0IsSUFBRztBQUVoRSxRQUFJLENBQUMxa0IsTUFBTTtBQUNUQSxhQUFPO1FBQ0x5SCxNQUFNO1FBQ054TSxNQUFNLENBQUE7UUFDTmdGLFNBQVM7UUFDVGpGLFlBQVk7UUFDWnE3QixRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsU0FBUztRQUNUakQsT0FBT3J6QixXQUFXQSxRQUFRcXpCLFNBQVM7UUFDbkM1MkIsT0FBT3dCO1FBQ1BpMUIsVUFBVWx6QjtRQUNWdTJCLFNBQVMsQ0FBQTtRQUNUdDdCLFNBQVM7O0FBRVhvQixlQUFTZ0MsS0FBSzBCLElBQUk7SUFDbkI7QUFFRCxXQUFPQTtFQUNSO0VBRURtSSxhQUFhO0FBQ1gsV0FBTyxLQUFLdU4sYUFBYSxLQUFLQSxXQUFXdEMsY0FBYyxNQUFNO01BQUNqWCxPQUFPO01BQU1zTCxNQUFNO0lBQVEsQ0FBQTtFQUMxRjtFQUVEZ3ZCLHlCQUF5QjtBQUN2QixXQUFPLEtBQUtsNkIsNkJBQTRCLEVBQUdsQjtFQUM1QztFQUVEbTRCLGlCQUFpQnQxQixjQUFjO0FBQzdCLFVBQU0rQixVQUFVLEtBQUtoRixLQUFLZ3VCLFNBQVMvcUI7QUFDbkMsUUFBSSxDQUFDK0IsU0FBUztBQUNaLGFBQU87SUFDUjtBQUVELFVBQU1ELE9BQU8sS0FBS0UsZUFBZWhDLFlBQVk7QUFJN0MsV0FBTyxPQUFPOEIsS0FBS3EyQixXQUFXLFlBQVksQ0FBQ3IyQixLQUFLcTJCLFNBQVMsQ0FBQ3AyQixRQUFRbzJCO0VBQ25FO0VBRURLLHFCQUFxQng0QixjQUFjcTFCLFNBQVM7QUFDMUMsVUFBTXZ6QixPQUFPLEtBQUtFLGVBQWVoQyxZQUFZO0FBQzdDOEIsU0FBS3EyQixTQUFTLENBQUM5QztFQUNoQjtFQUVEb0QscUJBQXFCajZCLE9BQU87QUFDMUIsU0FBSzh6QixlQUFlOXpCLFNBQVMsQ0FBQyxLQUFLOHpCLGVBQWU5ekI7RUFDbkQ7RUFFRGs2QixrQkFBa0JsNkIsT0FBTztBQUN2QixXQUFPLENBQUMsS0FBSzh6QixlQUFlOXpCO0VBQzdCO0VBS0RtNkIsa0JBQWtCMzRCLGNBQWM0NEIsV0FBV3ZELFNBQVM7QUFDbEQsVUFBTTFDLE9BQU8wQyxVQUFVLFNBQVM7QUFDaEMsVUFBTXZ6QixPQUFPLEtBQUtFLGVBQWVoQyxZQUFZO0FBQzdDLFVBQU1tUSxRQUFRck8sS0FBS2hGLFdBQVcrN0IsbUJBQW1CcnRCLFFBQVdtbkIsSUFBSTtBQUVoRSxRQUFJaHJCLFFBQVFpeEIsU0FBUyxHQUFHO0FBQ3RCOTJCLFdBQUsvRSxLQUFLNjdCLFdBQVdULFNBQVMsQ0FBQzlDO0FBQy9CLFdBQUsvdEIsT0FBTTtXQUNOO0FBQ0wsV0FBS2t4QixxQkFBcUJ4NEIsY0FBY3ExQixPQUFPO0FBRS9DbGxCLFlBQU03SSxPQUFPeEYsTUFBTTtRQUFDdXpCO01BQVEsQ0FBQTtBQUM1QixXQUFLL3RCLE9BQU8sQ0FBQ3FILFFBQVFBLElBQUkzTyxpQkFBaUJBLGVBQWUyeUIsT0FBT25uQixNQUFTO0lBQzFFO0VBQ0Y7RUFFRHN0QixLQUFLOTRCLGNBQWM0NEIsV0FBVztBQUM1QixTQUFLRCxrQkFBa0IzNEIsY0FBYzQ0QixXQUFXLEtBQUs7RUFDdEQ7RUFFREcsS0FBSy80QixjQUFjNDRCLFdBQVc7QUFDNUIsU0FBS0Qsa0JBQWtCMzRCLGNBQWM0NEIsV0FBVyxJQUFJO0VBQ3JEO0VBS0Q5RCxvQkFBb0I5MEIsY0FBYztBQUNoQyxVQUFNOEIsT0FBTyxLQUFLZ3dCLFVBQVU5eEI7QUFDNUIsUUFBSThCLFFBQVFBLEtBQUtoRixZQUFZO0FBQzNCZ0YsV0FBS2hGLFdBQVdrOEIsU0FBUTtJQUN6QjtBQUNELFdBQU8sS0FBS2xILFVBQVU5eEI7RUFDdkI7RUFFRGk1QixRQUFRO0FBQ04sUUFBSTM2QixHQUFHQztBQUNQLFNBQUsrMEIsS0FBSTtBQUNUUixhQUFTeEwsT0FBTyxJQUFJO0FBRXBCLFNBQUtocEIsSUFBSSxHQUFHQyxPQUFPLEtBQUt4QixLQUFLZ3VCLFNBQVM1dEIsUUFBUW1CLElBQUlDLE1BQU0sRUFBRUQsR0FBRztBQUMzRCxXQUFLdzJCLG9CQUFvQngyQixDQUFDO0lBQzNCO0VBQ0Y7RUFFRDQ2QixVQUFVO0FBQ1IsU0FBS3BlLGNBQWMsZUFBZTtBQUNsQyxVQUFNLEVBQUM1UixRQUFReUYsSUFBRyxJQUFJO0FBRXRCLFNBQUtzcUIsTUFBSztBQUNWLFNBQUtsdkIsT0FBT3VqQixXQUFVO0FBRXRCLFFBQUlwa0IsUUFBUTtBQUNWLFdBQUs0dEIsYUFBWTtBQUNqQnpELGtCQUFZbnFCLFFBQVF5RixHQUFHO0FBQ3ZCLFdBQUswZSxTQUFTamtCLGVBQWV1RixHQUFHO0FBQ2hDLFdBQUt6RixTQUFTO0FBQ2QsV0FBS3lGLE1BQU07SUFDWjtBQUVELFdBQU82aEIsVUFBVSxLQUFLcmE7QUFFdEIsU0FBSzJFLGNBQWMsY0FBYztFQUNsQztFQUVEcWUsaUJBQWlCL1IsTUFBTTtBQUNyQixXQUFPLEtBQUtsZSxPQUFPa3dCLFVBQWFoUyxHQUFBQSxJQUFJO0VBQ3JDO0VBS0RnTSxhQUFhO0FBQ1gsU0FBS2lHLGVBQWM7QUFDbkIsUUFBSSxLQUFLdDlCLFFBQVFtM0IsWUFBWTtBQUMzQixXQUFLb0cscUJBQW9CO1dBQ3BCO0FBQ0wsV0FBSy9HLFdBQVc7SUFDakI7RUFDRjtFQUtEOEcsaUJBQWlCO0FBQ2YsVUFBTUUsWUFBWSxLQUFLckg7QUFDdkIsVUFBTTdFLFdBQVcsS0FBS0E7QUFFdEIsVUFBTW1NLE9BQU8sQ0FBQ2p3QixNQUFNQyxjQUFhO0FBQy9CNmpCLGVBQVMvakIsaUJBQWlCLE1BQU1DLE1BQU1DLFNBQVE7QUFDOUMrdkIsZ0JBQVVod0IsUUFBUUM7O0FBR3BCLFVBQU1BLFdBQVcsQ0FBQzlILEdBQUdyQyxHQUFHRSxNQUFNO0FBQzVCbUMsUUFBRSszQixVQUFVcDZCO0FBQ1pxQyxRQUFFZzRCLFVBQVVuNkI7QUFDWixXQUFLaTNCLGNBQWM5MEIsQ0FBQzs7QUFHdEIrRyxTQUFLLEtBQUsxTSxRQUFRNjZCLFFBQVEsQ0FBQ3J0QixTQUFTaXdCLEtBQUtqd0IsTUFBTUMsUUFBUSxDQUFDO0VBQ3pEO0VBS0Q4dkIsdUJBQXVCO0FBQ3JCLFFBQUksQ0FBQyxLQUFLbkgsc0JBQXNCO0FBQzlCLFdBQUtBLHVCQUF1QixDQUFBO0lBQzdCO0FBQ0QsVUFBTW9ILFlBQVksS0FBS3BIO0FBQ3ZCLFVBQU05RSxXQUFXLEtBQUtBO0FBRXRCLFVBQU1tTSxPQUFPLENBQUNqd0IsTUFBTUMsY0FBYTtBQUMvQjZqQixlQUFTL2pCLGlCQUFpQixNQUFNQyxNQUFNQyxTQUFRO0FBQzlDK3ZCLGdCQUFVaHdCLFFBQVFDOztBQUVwQixVQUFNbXdCLFVBQVUsQ0FBQ3B3QixNQUFNQyxjQUFhO0FBQ2xDLFVBQUkrdkIsVUFBVWh3QixPQUFPO0FBQ25COGpCLGlCQUFTNWpCLG9CQUFvQixNQUFNRixNQUFNQyxTQUFRO0FBQ2pELGVBQU8rdkIsVUFBVWh3QjtNQUNsQjs7QUFHSCxVQUFNQyxXQUFXLENBQUM5RSxPQUFPRSxXQUFXO0FBQ2xDLFVBQUksS0FBS3NFLFFBQVE7QUFDZixhQUFLd0UsT0FBT2hKLE9BQU9FLE1BQU07TUFDMUI7O0FBR0gsUUFBSWcxQjtBQUNKLFVBQU1ySCxXQUFXLE1BQU07QUFDckJvSCxjQUFRLFVBQVVwSCxRQUFRO0FBRTFCLFdBQUtBLFdBQVc7QUFDaEIsV0FBSzdrQixPQUFNO0FBRVg4ckIsV0FBSyxVQUFVaHdCLFFBQVE7QUFDdkJnd0IsV0FBSyxVQUFVSSxRQUFROztBQUd6QkEsZUFBVyxNQUFNO0FBQ2YsV0FBS3JILFdBQVc7QUFFaEJvSCxjQUFRLFVBQVVud0IsUUFBUTtBQUcxQixXQUFLeXZCLE1BQUs7QUFDVixXQUFLekYsUUFBUSxHQUFHLENBQUM7QUFFakJnRyxXQUFLLFVBQVVqSCxRQUFROztBQUd6QixRQUFJbEYsU0FBU3hqQixXQUFXLEtBQUtYLE1BQU0sR0FBRztBQUNwQ3FwQixlQUFRO1dBQ0g7QUFDTHFILGVBQVE7SUFDVDtFQUNGO0VBS0Q5QyxlQUFlO0FBQ2JydUIsU0FBSyxLQUFLeXBCLFlBQVksQ0FBQzFvQixVQUFVRCxTQUFTO0FBQ3hDLFdBQUs4akIsU0FBUzVqQixvQkFBb0IsTUFBTUYsTUFBTUMsUUFBUTtJQUN2RCxDQUFBO0FBQ0QsU0FBSzBvQixhQUFhLENBQUE7QUFFbEJ6cEIsU0FBSyxLQUFLMHBCLHNCQUFzQixDQUFDM29CLFVBQVVELFNBQVM7QUFDbEQsV0FBSzhqQixTQUFTNWpCLG9CQUFvQixNQUFNRixNQUFNQyxRQUFRO0lBQ3ZELENBQUE7QUFDRCxTQUFLMm9CLHVCQUF1QjNtQjtFQUM3QjtFQUVEcXVCLGlCQUFpQmg2QixPQUFPOHlCLE1BQU12aEIsU0FBUztBQUNyQyxVQUFNMG9CLFNBQVMxb0IsVUFBVSxRQUFRO0FBQ2pDLFFBQUl0UCxNQUFNK0YsTUFBTXZKLEdBQUdDO0FBRW5CLFFBQUlvMEIsU0FBUyxXQUFXO0FBQ3RCN3dCLGFBQU8sS0FBS0UsZUFBZW5DLE1BQU0sR0FBR0csWUFBWTtBQUNoRDhCLFdBQUtoRixXQUFXLE1BQU1nOUIsU0FBUyxxQkFBb0I7SUFDcEQ7QUFFRCxTQUFLeDdCLElBQUksR0FBR0MsT0FBT3NCLE1BQU0xQyxRQUFRbUIsSUFBSUMsTUFBTSxFQUFFRCxHQUFHO0FBQzlDdUosYUFBT2hJLE1BQU12QjtBQUNiLFlBQU14QixhQUFhK0ssUUFBUSxLQUFLN0YsZUFBZTZGLEtBQUs3SCxZQUFZLEVBQUVsRDtBQUNsRSxVQUFJQSxZQUFZO0FBQ2RBLG1CQUFXZzlCLFNBQVMsY0FBY2p5QixLQUFLbkosU0FBU21KLEtBQUs3SCxjQUFjNkgsS0FBS3JKLEtBQUs7TUFDOUU7SUFDRjtFQUNGO0VBTUR1N0Isb0JBQW9CO0FBQ2xCLFdBQU8sS0FBSy9ILFdBQVcsQ0FBQTtFQUN4QjtFQU1EZ0ksa0JBQWtCQyxnQkFBZ0I7QUFDaEMsVUFBTUMsYUFBYSxLQUFLbEksV0FBVyxDQUFBO0FBQ25DLFVBQU1uaUIsU0FBU29xQixlQUFlN0YsSUFBSSxDQUFDLEVBQUNwMEIsY0FBY3hCLE1BQUssTUFBTTtBQUMzRCxZQUFNc0QsT0FBTyxLQUFLRSxlQUFlaEMsWUFBWTtBQUM3QyxVQUFJLENBQUM4QixNQUFNO0FBQ1QsY0FBTSxJQUFJdkcsTUFBTSwrQkFBK0J5RSxZQUFZO01BQzVEO0FBRUQsYUFBTztRQUNMQTtRQUNBdEIsU0FBU29ELEtBQUsvRSxLQUFLeUI7UUFDbkJBOztJQUVILENBQUE7QUFDRCxVQUFNNkksVUFBVSxDQUFDOHlCLGVBQWV0cUIsUUFBUXFxQixVQUFVO0FBRWxELFFBQUk3eUIsU0FBUztBQUNYLFdBQUsycUIsVUFBVW5pQjtBQUVmLFdBQUtvaUIsYUFBYTtBQUNsQixXQUFLd0UsbUJBQW1CNW1CLFFBQVFxcUIsVUFBVTtJQUMzQztFQUNGO0VBV0RwZixjQUFjb08sTUFBTTlCLE1BQU05a0IsUUFBUTtBQUNoQyxXQUFPLEtBQUsrdkIsU0FBU3BKLE9BQU8sTUFBTUMsTUFBTTlCLE1BQU05a0IsTUFBTTtFQUNyRDtFQU9EODNCLGdCQUFnQkMsVUFBVTtBQUN4QixXQUFPLEtBQUtoSSxTQUFTL2EsT0FBT2hWLE9BQU9ndEIsQ0FBQUEsTUFBS0EsRUFBRS9GLE9BQU9wVCxPQUFPa2tCLFFBQVEsRUFBRWw5QixXQUFXO0VBQzlFO0VBS0RzNUIsbUJBQW1CNW1CLFFBQVFxcUIsWUFBWUksUUFBUTtBQUM3QyxVQUFNQyxlQUFlLEtBQUt4K0IsUUFBUXkrQjtBQUNsQyxVQUFNbitCLE9BQU8sQ0FBQ3lHLEdBQUdDLE1BQU1ELEVBQUVSLE9BQU9qRCxDQUFBQSxNQUFLLENBQUMwRCxFQUFFa25CLEtBQUsxcUIsQ0FBQUEsTUFBS0YsRUFBRVcsaUJBQWlCVCxFQUFFUyxnQkFBZ0JYLEVBQUViLFVBQVVlLEVBQUVmLEtBQUssQ0FBQztBQUMzRyxVQUFNaThCLGNBQWNwK0IsS0FBSzY5QixZQUFZcnFCLE1BQU07QUFDM0MsVUFBTTZxQixZQUFZSixTQUFTenFCLFNBQVN4VCxLQUFLd1QsUUFBUXFxQixVQUFVO0FBRTNELFFBQUlPLFlBQVl0OUIsUUFBUTtBQUN0QixXQUFLMDhCLGlCQUFpQlksYUFBYUYsYUFBYTVILE1BQU0sS0FBSztJQUM1RDtBQUVELFFBQUkrSCxVQUFVdjlCLFVBQVVvOUIsYUFBYTVILE1BQU07QUFDekMsV0FBS2tILGlCQUFpQmEsV0FBV0gsYUFBYTVILE1BQU0sSUFBSTtJQUN6RDtFQUNGO0VBS0Q2RCxjQUFjOTBCLEdBQUc0NEIsUUFBUTtBQUN2QixVQUFNbFQsT0FBTztNQUNYbmIsT0FBT3ZLO01BQ1A0NEI7TUFDQTdRLFlBQVk7TUFDWndILGFBQWEsS0FBS254QixjQUFjNEIsQ0FBQzs7QUFFbkMsVUFBTWk1QixjQUFjLENBQUNwUixZQUFZQSxPQUFPeHRCLFFBQVE2NkIsVUFBVSxLQUFLNzZCLFFBQVE2NkIsUUFBUTl5QixTQUFTcEMsRUFBRXdLLE9BQU8zQyxJQUFJO0FBRXJHLFFBQUksS0FBS3VSLGNBQWMsZUFBZXNNLE1BQU11VCxXQUFXLE1BQU0sT0FBTztBQUNsRTtJQUNEO0FBRUQsVUFBTXR6QixVQUFVLEtBQUt1ekIsYUFBYWw1QixHQUFHNDRCLFFBQVFsVCxLQUFLNkosV0FBVztBQUU3RDdKLFNBQUtxQyxhQUFhO0FBQ2xCLFNBQUszTyxjQUFjLGNBQWNzTSxNQUFNdVQsV0FBVztBQUVsRCxRQUFJdHpCLFdBQVcrZixLQUFLL2YsU0FBUztBQUMzQixXQUFLd3NCLE9BQU07SUFDWjtBQUVELFdBQU87RUFDUjtFQVVEK0csYUFBYWw1QixHQUFHNDRCLFFBQVFySixhQUFhO0FBQ25DLFVBQU0sRUFBQ2UsU0FBU2tJLGFBQWEsQ0FBQSxHQUFJbitCLFFBQU8sSUFBSTtBQWU1QyxVQUFNNEQsbUJBQW1CMjZCO0FBQ3pCLFVBQU16cUIsU0FBUyxLQUFLZ3JCLG1CQUFtQm41QixHQUFHdzRCLFlBQVlqSixhQUFhdHhCLGdCQUFnQjtBQUNuRixVQUFNdXhCLFVBQVU0SixjQUFjcDVCLENBQUM7QUFDL0IsVUFBTXN2QixZQUFZRCxtQkFBbUJydkIsR0FBRyxLQUFLdXdCLFlBQVloQixhQUFhQyxPQUFPO0FBRTdFLFFBQUlELGFBQWE7QUFHZixXQUFLZ0IsYUFBYTtBQUdsQnpJLGVBQWF6dEIsUUFBUWcvQixTQUFTO1FBQUNyNUI7UUFBR21PO1FBQVE7U0FBTyxJQUFJO0FBRXJELFVBQUlxaEIsU0FBUztBQUNYMUgsaUJBQWF6dEIsUUFBUWkvQixTQUFTO1VBQUN0NUI7VUFBR21PO1VBQVE7V0FBTyxJQUFJO01BQ3REO0lBQ0Y7QUFFRCxVQUFNeEksVUFBVSxDQUFDOHlCLGVBQWV0cUIsUUFBUXFxQixVQUFVO0FBQ2xELFFBQUk3eUIsV0FBV2l6QixRQUFRO0FBQ3JCLFdBQUt0SSxVQUFVbmlCO0FBQ2YsV0FBSzRtQixtQkFBbUI1bUIsUUFBUXFxQixZQUFZSSxNQUFNO0lBQ25EO0FBRUQsU0FBS3JJLGFBQWFqQjtBQUVsQixXQUFPM3BCO0VBQ1I7RUFVRHd6QixtQkFBbUJuNUIsR0FBR3c0QixZQUFZakosYUFBYXR4QixrQkFBa0I7QUFDL0QsUUFBSStCLEVBQUU2SCxTQUFTLFlBQVk7QUFDekIsYUFBTyxDQUFBO0lBQ1I7QUFFRCxRQUFJLENBQUMwbkIsYUFBYTtBQUVoQixhQUFPaUo7SUFDUjtBQUVELFVBQU1LLGVBQWUsS0FBS3grQixRQUFReStCO0FBQ2xDLFdBQU8sS0FBS3ZDLDBCQUEwQnYyQixHQUFHNjRCLGFBQWE1SCxNQUFNNEgsY0FBYzU2QixnQkFBZ0I7RUFDM0Y7QUFDRjtBQTFvQ0MsY0FGSTJ4QixPQUVHL2dCLFlBQVdBO0FBQ2xCLGNBSEkrZ0IsT0FHR2QsYUFBWUE7QUFDbkIsY0FKSWMsT0FJRzNMLGFBQVlBO0FBQ25CLGNBTEkyTCxPQUtHM0ksWUFBV0E7QUFDbEIsY0FOSTJJLE9BTUcySixXQUFVQTtBQUNqQixjQVBJM0osT0FPR2IsWUFBV0E7QUF3b0NwQixTQUFTYyxvQkFBb0I7QUFDM0IsU0FBTzlvQixLQUFLNm9CLE1BQU1kLFdBQVcsQ0FBQ3Z5QixVQUFVQSxNQUFNbzBCLFNBQVMzSSxXQUFVLENBQUU7QUFDcEU7QUFFRCxJQUFBLFVBQWU0SDtBQy92Q2YsU0FBUzRKLFFBQVF2c0IsS0FBK0JqUSxTQUFxQjZCLFVBQWtCO0FBQ3JGLFFBQU0sRUFBQ0QsWUFBWTY2QixhQUFhOTdCLEdBQUdFLEdBQUc2N0IsYUFBYUMsWUFBVyxJQUFJMzhCO0FBQ2xFLE1BQUk0OEIsY0FBY0gsY0FBY0M7QUFJaEN6c0IsTUFBSWtWLFVBQVM7QUFDYmxWLE1BQUk0c0IsSUFBSWw4QixHQUFHRSxHQUFHNjdCLGFBQWE5NkIsYUFBYWc3QixhQUFhLzZCLFdBQVcrNkIsV0FBVztBQUMzRSxNQUFJRCxjQUFjRixhQUFhO0FBQzdCRyxrQkFBY0gsY0FBY0U7QUFDNUIxc0IsUUFBSTRzQixJQUFJbDhCLEdBQUdFLEdBQUc4N0IsYUFBYTk2QixXQUFXKzZCLGFBQWFoN0IsYUFBYWc3QixhQUFhLElBQUk7U0FDNUU7QUFDTDNzQixRQUFJNHNCLElBQUlsOEIsR0FBR0UsR0FBRzQ3QixhQUFhNTZCLFdBQVd5VixTQUFTMVYsYUFBYTBWLE9BQU87RUFDcEU7QUFDRHJILE1BQUk2c0IsVUFBUztBQUNiN3NCLE1BQUlrcEIsS0FBSTtBQUNUO0FBRUQsU0FBUzRELGdCQUFnQjcrQixPQUFPO0FBQzlCLFNBQU84K0Isa0JBQWtCOStCLE9BQU87SUFBQztJQUFjO0lBQVk7SUFBYztFQUFXLENBQUE7QUFDckY7QUFLRCxTQUFTKytCLG9CQUFrQkosS0FBaUJGLGFBQXFCRCxhQUFxQlEsWUFBb0I7QUFDeEcsUUFBTUMsSUFBSUosZ0JBQWdCRixJQUFJeC9CLFFBQVErL0IsWUFBWTtBQUNsRCxRQUFNQyxpQkFBaUJYLGNBQWNDLGVBQWU7QUFDcEQsUUFBTVcsYUFBYTc4QixLQUFLNlIsSUFBSStxQixlQUFlSCxhQUFhUCxjQUFjLENBQUM7QUFTdkUsUUFBTVksb0JBQW9CLENBQUNDLFFBQVE7QUFDakMsVUFBTUMsaUJBQWlCZixjQUFjajhCLEtBQUs2UixJQUFJK3FCLGVBQWVHLEdBQUcsS0FBS04sYUFBYTtBQUNsRixXQUFPNWYsWUFBWWtnQixLQUFLLEdBQUcvOEIsS0FBSzZSLElBQUkrcUIsZUFBZUksYUFBYSxDQUFDOztBQUduRSxTQUFPO0lBQ0xDLFlBQVlILGtCQUFrQkosRUFBRU8sVUFBVTtJQUMxQ0MsVUFBVUosa0JBQWtCSixFQUFFUSxRQUFRO0lBQ3RDQyxZQUFZdGdCLFlBQVk2ZixFQUFFUyxZQUFZLEdBQUdOLFVBQVU7SUFDbkRPLFVBQVV2Z0IsWUFBWTZmLEVBQUVVLFVBQVUsR0FBR1AsVUFBVTs7QUFFbEQ7QUFLRCxTQUFTUSxXQUFXQyxHQUFXQyxPQUFlcjlCLEdBQVdFLEdBQVc7QUFDbEUsU0FBTztJQUNMRixHQUFHQSxJQUFJbzlCLElBQUl0OUIsS0FBS3lkLElBQUk4ZixLQUFLO0lBQ3pCbjlCLEdBQUdBLElBQUlrOUIsSUFBSXQ5QixLQUFLMGQsSUFBSTZmLEtBQUs7O0FBRTVCO0FBaUJELFNBQVNDLFFBQ1BodUIsS0FDQWpRLFNBQ0FxVCxRQUNBSixTQUNBOVQsS0FDQSsrQixVQUNBO0FBQ0EsUUFBTSxFQUFDdjlCLEdBQUdFLEdBQUdlLFlBQVkxQyxPQUFPdTlCLGFBQWFFLGFBQWF3QixPQUFNLElBQUluK0I7QUFFcEUsUUFBTTA4QixjQUFjajhCLEtBQUt3RyxJQUFJakgsUUFBUTA4QixjQUFjenBCLFVBQVVJLFNBQVNvcEIsYUFBYSxDQUFDO0FBQ3BGLFFBQU1FLGNBQWN3QixTQUFTLElBQUlBLFNBQVNsckIsVUFBVUksU0FBU29wQixjQUFjO0FBRTNFLE1BQUkyQixnQkFBZ0I7QUFDcEIsUUFBTUMsU0FBUWwvQixNQUFNRDtBQUVwQixNQUFJK1QsU0FBUztBQUlYLFVBQU1xckIsdUJBQXVCSCxTQUFTLElBQUlBLFNBQVNsckIsVUFBVTtBQUM3RCxVQUFNc3JCLHVCQUF1QjdCLGNBQWMsSUFBSUEsY0FBY3pwQixVQUFVO0FBQ3ZFLFVBQU11ckIsc0JBQXNCRix1QkFBdUJDLHdCQUF3QjtBQUMzRSxVQUFNRSxnQkFBZ0JELHVCQUF1QixJQUFJSCxTQUFTRyxzQkFBdUJBLHFCQUFxQnZyQixXQUFXb3JCO0FBQ2pIRCxxQkFBaUJDLFNBQVFJLGlCQUFpQjtFQUMzQztBQUVELFFBQU1DLE9BQU9qK0IsS0FBS3dHLElBQUksTUFBT28zQixTQUFRM0IsY0FBY3JwQixTQUFTc3JCLEVBQUUsSUFBSWpDO0FBQ2xFLFFBQU1rQyxlQUFlUCxTQUFRSyxRQUFRO0FBQ3JDLFFBQU05OEIsYUFBYTFDLFFBQVEwL0IsY0FBY1I7QUFDekMsUUFBTXY4QixXQUFXMUMsTUFBTXkvQixjQUFjUjtBQUNyQyxRQUFNLEVBQUNWLFlBQVlDLFVBQVVDLFlBQVlDLFNBQVEsSUFBSVosb0JBQWtCajlCLFNBQVMyOEIsYUFBYUQsYUFBYTc2QixXQUFXRCxVQUFVO0FBRS9ILFFBQU1pOUIsMkJBQTJCbkMsY0FBY2dCO0FBQy9DLFFBQU1vQix5QkFBeUJwQyxjQUFjaUI7QUFDN0MsUUFBTW9CLDBCQUEwQm45QixhQUFhODdCLGFBQWFtQjtBQUMxRCxRQUFNRyx3QkFBd0JuOUIsV0FBVzg3QixXQUFXbUI7QUFFcEQsUUFBTUcsMkJBQTJCdEMsY0FBY2lCO0FBQy9DLFFBQU1zQix5QkFBeUJ2QyxjQUFja0I7QUFDN0MsUUFBTXNCLDBCQUEwQnY5QixhQUFhZzhCLGFBQWFxQjtBQUMxRCxRQUFNRyx3QkFBd0J2OUIsV0FBV2c4QixXQUFXcUI7QUFFcERqdkIsTUFBSWtWLFVBQVM7QUFFYixNQUFJK1ksVUFBVTtBQUVaLFVBQU1tQix5QkFBeUJOLDBCQUEwQkMseUJBQXlCO0FBQ2xGL3VCLFFBQUk0c0IsSUFBSWw4QixHQUFHRSxHQUFHNjdCLGFBQWFxQyx5QkFBeUJNLHFCQUFxQjtBQUN6RXB2QixRQUFJNHNCLElBQUlsOEIsR0FBR0UsR0FBRzY3QixhQUFhMkMsdUJBQXVCTCxxQkFBcUI7QUFHdkUsUUFBSXJCLFdBQVcsR0FBRztBQUNoQixZQUFNMkIsVUFBVXhCLFdBQVdnQix3QkFBd0JFLHVCQUF1QnIrQixHQUFHRSxDQUFDO0FBQzlFb1AsVUFBSTRzQixJQUFJeUMsUUFBUTMrQixHQUFHMitCLFFBQVF6K0IsR0FBRzg4QixVQUFVcUIsdUJBQXVCbjlCLFdBQVd5VixPQUFPO0lBQ2xGO0FBR0QsVUFBTWlvQixLQUFLekIsV0FBV29CLHdCQUF3QnI5QixVQUFVbEIsR0FBR0UsQ0FBQztBQUM1RG9QLFFBQUlvVixPQUFPa2EsR0FBRzUrQixHQUFHNCtCLEdBQUcxK0IsQ0FBQztBQUdyQixRQUFJZzlCLFdBQVcsR0FBRztBQUNoQixZQUFNeUIsV0FBVXhCLFdBQVdvQix3QkFBd0JFLHVCQUF1QnorQixHQUFHRSxDQUFDO0FBQzlFb1AsVUFBSTRzQixJQUFJeUMsU0FBUTMrQixHQUFHMitCLFNBQVF6K0IsR0FBR2c5QixVQUFVaDhCLFdBQVd5VixTQUFTOG5CLHdCQUF3QjMrQixLQUFLaytCLEVBQUU7SUFDNUY7QUFHRCxVQUFNYSx5QkFBMEIzOUIsV0FBWWc4QixXQUFXbEIsZUFBaUIvNkIsYUFBY2c4QixhQUFhakIsZ0JBQWlCO0FBQ3BIMXNCLFFBQUk0c0IsSUFBSWw4QixHQUFHRSxHQUFHODdCLGFBQWE5NkIsV0FBWWc4QixXQUFXbEIsYUFBYzZDLHVCQUF1QixJQUFJO0FBQzNGdnZCLFFBQUk0c0IsSUFBSWw4QixHQUFHRSxHQUFHODdCLGFBQWE2Qyx1QkFBdUI1OUIsYUFBY2c4QixhQUFhakIsYUFBYyxJQUFJO0FBRy9GLFFBQUlpQixhQUFhLEdBQUc7QUFDbEIsWUFBTTBCLFdBQVV4QixXQUFXbUIsMEJBQTBCRSx5QkFBeUJ4K0IsR0FBR0UsQ0FBQztBQUNsRm9QLFVBQUk0c0IsSUFBSXlDLFNBQVEzK0IsR0FBRzIrQixTQUFReitCLEdBQUcrOEIsWUFBWXVCLDBCQUEwQjErQixLQUFLaytCLElBQUkvOEIsYUFBYTBWLE9BQU87SUFDbEc7QUFHRCxVQUFNbW9CLEtBQUszQixXQUFXZSwwQkFBMEJqOUIsWUFBWWpCLEdBQUdFLENBQUM7QUFDaEVvUCxRQUFJb1YsT0FBT29hLEdBQUc5K0IsR0FBRzgrQixHQUFHNStCLENBQUM7QUFHckIsUUFBSTY4QixhQUFhLEdBQUc7QUFDbEIsWUFBTTRCLFdBQVV4QixXQUFXZSwwQkFBMEJFLHlCQUF5QnArQixHQUFHRSxDQUFDO0FBQ2xGb1AsVUFBSTRzQixJQUFJeUMsU0FBUTMrQixHQUFHMitCLFNBQVF6K0IsR0FBRzY4QixZQUFZOTdCLGFBQWEwVixTQUFTeW5CLHVCQUF1QjtJQUN4RjtTQUNJO0FBQ0w5dUIsUUFBSW1WLE9BQU96a0IsR0FBR0UsQ0FBQztBQUVmLFVBQU02K0IsY0FBY2ovQixLQUFLeWQsSUFBSTZnQix1QkFBdUIsSUFBSXJDLGNBQWMvN0I7QUFDdEUsVUFBTWcvQixjQUFjbC9CLEtBQUswZCxJQUFJNGdCLHVCQUF1QixJQUFJckMsY0FBYzc3QjtBQUN0RW9QLFFBQUlvVixPQUFPcWEsYUFBYUMsV0FBVztBQUVuQyxVQUFNQyxZQUFZbi9CLEtBQUt5ZCxJQUFJOGdCLHFCQUFxQixJQUFJdEMsY0FBYy83QjtBQUNsRSxVQUFNay9CLFlBQVlwL0IsS0FBSzBkLElBQUk2Z0IscUJBQXFCLElBQUl0QyxjQUFjNzdCO0FBQ2xFb1AsUUFBSW9WLE9BQU91YSxXQUFXQyxTQUFTO0VBQ2hDO0FBRUQ1dkIsTUFBSTZzQixVQUFTO0FBQ2Q7QUFFRCxTQUFTZ0QsUUFDUDd2QixLQUNBalEsU0FDQXFULFFBQ0FKLFNBQ0FpckIsVUFDQTtBQUNBLFFBQU0sRUFBQzZCLGFBQWFuK0IsWUFBWW8rQixjQUFhLElBQUloZ0M7QUFDakQsTUFBSTZCLFdBQVc3QixRQUFRNkI7QUFDdkIsTUFBSWsrQixhQUFhO0FBQ2Y5QixZQUFRaHVCLEtBQUtqUSxTQUFTcVQsUUFBUUosU0FBU3BSLFVBQVVxOEIsUUFBUTtBQUN6RCxhQUFTdCtCLElBQUksR0FBR0EsSUFBSW1nQyxhQUFhLEVBQUVuZ0MsR0FBRztBQUNwQ3FRLFVBQUlnd0IsS0FBSTtJQUNUO0FBQ0QsUUFBSSxDQUFDQyxNQUFNRixhQUFhLEdBQUc7QUFDekJuK0IsaUJBQVdELGNBQWNvK0IsZ0JBQWdCRyxPQUFPQTtJQUNqRDtFQUNGO0FBQ0RsQyxVQUFRaHVCLEtBQUtqUSxTQUFTcVQsUUFBUUosU0FBU3BSLFVBQVVxOEIsUUFBUTtBQUN6RGp1QixNQUFJZ3dCLEtBQUk7QUFDUixTQUFPcCtCO0FBQ1I7QUFFRCxTQUFTMmpCLFdBQ1B2VixLQUNBalEsU0FDQXFULFFBQ0FKLFNBQ0FpckIsVUFDQTtBQUNBLFFBQU0sRUFBQzZCLGFBQWFuK0IsWUFBWW8rQixlQUFlM2lDLFFBQU8sSUFBSTJDO0FBQzFELFFBQU0sRUFBQ29nQyxhQUFhQyxnQkFBZSxJQUFJaGpDO0FBQ3ZDLFFBQU1pakMsUUFBUWpqQyxRQUFRa2pDLGdCQUFnQjtBQUV0QyxNQUFJLENBQUNILGFBQWE7QUFDaEI7RUFDRDtBQUVELE1BQUlFLE9BQU87QUFDVHJ3QixRQUFJK1IsWUFBWW9lLGNBQWM7QUFDOUJud0IsUUFBSXV3QixXQUFXSCxtQkFBbUI7U0FDN0I7QUFDTHB3QixRQUFJK1IsWUFBWW9lO0FBQ2hCbndCLFFBQUl1d0IsV0FBV0gsbUJBQW1CO0VBQ25DO0FBRUQsTUFBSXgrQixXQUFXN0IsUUFBUTZCO0FBQ3ZCLE1BQUlrK0IsYUFBYTtBQUNmOUIsWUFBUWh1QixLQUFLalEsU0FBU3FULFFBQVFKLFNBQVNwUixVQUFVcThCLFFBQVE7QUFDekQsYUFBU3QrQixJQUFJLEdBQUdBLElBQUltZ0MsYUFBYSxFQUFFbmdDLEdBQUc7QUFDcENxUSxVQUFJcVYsT0FBTTtJQUNYO0FBQ0QsUUFBSSxDQUFDNGEsTUFBTUYsYUFBYSxHQUFHO0FBQ3pCbitCLGlCQUFXRCxjQUFjbytCLGdCQUFnQkcsT0FBT0E7SUFDakQ7RUFDRjtBQUVELE1BQUlHLE9BQU87QUFDVDlELFlBQVF2c0IsS0FBS2pRLFNBQVM2QixRQUFRO0VBQy9CO0FBRUQsTUFBSSxDQUFDaytCLGFBQWE7QUFDaEI5QixZQUFRaHVCLEtBQUtqUSxTQUFTcVQsUUFBUUosU0FBU3BSLFVBQVVxOEIsUUFBUTtBQUN6RGp1QixRQUFJcVYsT0FBTTtFQUNYO0FBQ0Y7QUFVYyxJQUFNbWIsYUFBTixjQUF5QnZ2QixRQUFPO0VBNEI3QzlULFlBQVlvYSxLQUFLO0FBQ2YsVUFBSztBQUVMLFNBQUtuYSxVQUFVeVA7QUFDZixTQUFLa3pCLGdCQUFnQmx6QjtBQUNyQixTQUFLbEwsYUFBYWtMO0FBQ2xCLFNBQUtqTCxXQUFXaUw7QUFDaEIsU0FBSzZ2QixjQUFjN3ZCO0FBQ25CLFNBQUs0dkIsY0FBYzV2QjtBQUNuQixTQUFLMnZCLGNBQWM7QUFDbkIsU0FBS3NELGNBQWM7QUFFbkIsUUFBSXZvQixLQUFLO0FBQ1B2YSxhQUFPQyxPQUFPLE1BQU1zYSxHQUFHO0lBQ3hCO0VBQ0Y7RUFFRC9WLFFBQVFpL0IsUUFBZ0JDLFFBQWdCMS9CLGtCQUEyQjtBQUNqRSxVQUFNc0MsUUFBUSxLQUFLekIsU0FBUztNQUFDO01BQUs7T0FBTWIsZ0JBQWdCO0FBQ3hELFVBQU0sRUFBQ2MsT0FBT1csU0FBUSxJQUFJVixrQkFBa0J1QixPQUFPO01BQUM1QyxHQUFHKy9CO01BQVE3L0IsR0FBRzgvQjtJQUFPLENBQUE7QUFDekUsVUFBTSxFQUFDLytCLFlBQVlDLFVBQVU4NkIsYUFBYUQsYUFBYXNELGNBQWEsSUFBSSxLQUFLbCtCLFNBQVM7TUFDcEY7TUFDQTtNQUNBO01BQ0E7TUFDQTtPQUNDYixnQkFBZ0I7QUFDbkIsVUFBTTIvQixVQUFVLEtBQUt2akMsUUFBUTRWLFVBQVU7QUFDdkMsVUFBTTR0QixpQkFBaUJ4c0IsZUFBZTJyQixlQUFlbitCLFdBQVdELFVBQVU7QUFDMUUsVUFBTWsvQixnQkFBZ0JELGtCQUFrQlYsT0FBT2wrQixjQUFjRixPQUFPSCxZQUFZQyxRQUFRO0FBQ3hGLFVBQU1rL0IsZUFBZUMsV0FBV3QrQixVQUFVaTZCLGNBQWNpRSxTQUFTbEUsY0FBY2tFLE9BQU87QUFFdEYsV0FBUUUsaUJBQWlCQztFQUMxQjtFQUVEditCLGVBQWV2QixrQkFBMkI7QUFDeEMsVUFBTSxFQUFDTixHQUFHRSxHQUFHZSxZQUFZQyxVQUFVODZCLGFBQWFELFlBQVcsSUFBSSxLQUFLNTZCLFNBQVM7TUFDM0U7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7T0FDQ2IsZ0JBQWdCO0FBQ25CLFVBQU0sRUFBQ29TLFFBQVFKLFFBQU8sSUFBSSxLQUFLNVY7QUFDL0IsVUFBTTRqQyxhQUFhci9CLGFBQWFDLFlBQVk7QUFDNUMsVUFBTXEvQixjQUFjdkUsY0FBY0QsY0FBY3pwQixVQUFVSSxVQUFVO0FBQ3BFLFdBQU87TUFDTDFTLEdBQUdBLElBQUlGLEtBQUt5ZCxJQUFJK2lCLFNBQVMsSUFBSUM7TUFDN0JyZ0MsR0FBR0EsSUFBSUosS0FBSzBkLElBQUk4aUIsU0FBUyxJQUFJQzs7RUFFaEM7RUFFRDl2QixnQkFBZ0JuUSxrQkFBMkI7QUFDekMsV0FBTyxLQUFLdUIsZUFBZXZCLGdCQUFnQjtFQUM1QztFQUVEcUksS0FBSzJHLEtBQStCO0FBQ2xDLFVBQU0sRUFBQzVTLFNBQVMyaUMsY0FBYSxJQUFJO0FBQ2pDLFVBQU0zc0IsVUFBVWhXLFFBQVFnVyxVQUFVLEtBQUs7QUFDdkMsVUFBTUosV0FBVzVWLFFBQVE0VixXQUFXLEtBQUs7QUFDekMsVUFBTWlyQixXQUFXN2dDLFFBQVE2Z0M7QUFDekIsU0FBS3pCLGNBQWVwL0IsUUFBUWtqQyxnQkFBZ0IsVUFBVyxPQUFPO0FBQzlELFNBQUtSLGNBQWNDLGdCQUFnQkcsTUFBTTEvQixLQUFLeUssTUFBTTgwQixnQkFBZ0JHLEdBQUcsSUFBSTtBQUUzRSxRQUFJSCxrQkFBa0IsS0FBSyxLQUFLckQsY0FBYyxLQUFLLEtBQUtELGNBQWMsR0FBRztBQUN2RTtJQUNEO0FBRUR6c0IsUUFBSW1VLEtBQUk7QUFFUixVQUFNNmMsYUFBYSxLQUFLci9CLGFBQWEsS0FBS0MsWUFBWTtBQUN0RG9PLFFBQUlreEIsVUFBVTFnQyxLQUFLeWQsSUFBSStpQixTQUFTLElBQUk1dEIsUUFBUTVTLEtBQUswZCxJQUFJOGlCLFNBQVMsSUFBSTV0QixNQUFNO0FBQ3hFLFVBQU0rdEIsTUFBTSxJQUFJM2dDLEtBQUswZCxJQUFJMWQsS0FBSzZSLElBQUlxc0IsSUFBSXFCLGlCQUFpQixDQUFDLENBQUM7QUFDekQsVUFBTXFCLGVBQWVodUIsU0FBUyt0QjtBQUU5Qm54QixRQUFJb1UsWUFBWWhuQixRQUFROG1CO0FBQ3hCbFUsUUFBSStVLGNBQWMzbkIsUUFBUWlrQztBQUUxQnhCLFlBQVE3dkIsS0FBSyxNQUFNb3hCLGNBQWNwdUIsU0FBU2lyQixRQUFRO0FBQ2xEMVksZUFBV3ZWLEtBQUssTUFBTW94QixjQUFjcHVCLFNBQVNpckIsUUFBUTtBQUVyRGp1QixRQUFJc1UsUUFBTztFQUNaOztBQTlHRCxjQUZtQmtjLFlBRVpocEIsTUFBSztBQUVaLGNBSm1CZ3BCLFlBSVo1dUIsWUFBVztFQUNoQjB1QixhQUFhO0VBQ2JlLGFBQWE7RUFDYmpCLGlCQUFpQnZ6QjtFQUNqQnN3QixjQUFjO0VBQ2RnRCxhQUFhO0VBQ2Ivc0IsUUFBUTtFQUNSSixTQUFTO0VBQ1RsUixPQUFPK0s7RUFDUG94QixVQUFVOztBQUdaLGNBaEJtQnVDLFlBZ0JaM3VCLGlCQUFnQjtFQUNyQnFTLGlCQUFpQjs7QUd0UXJCLFNBQVNvZCxhQUFhQyxLQUFLQyxrQkFBa0I7QUFDM0MsUUFBTSxFQUFDQyxHQUFHQyxHQUFHQyxNQUFNQyxPQUFPQyxPQUFNLElBQTZCTixJQUFJTyxTQUFTO0lBQUM7SUFBSztJQUFLO0lBQVE7SUFBUztLQUFXTixnQkFBZ0I7QUFFakksTUFBSU8sTUFBTUMsT0FBT0MsS0FBS0MsUUFBUUM7QUFFOUIsTUFBSVosSUFBSWEsWUFBWTtBQUNsQkQsV0FBT04sU0FBUztBQUNoQkUsV0FBT00sS0FBS0MsSUFBSWIsR0FBR0UsSUFBSTtBQUN2QkssWUFBUUssS0FBS0UsSUFBSWQsR0FBR0UsSUFBSTtBQUN4Qk0sVUFBTVAsSUFBSVM7QUFDVkQsYUFBU1IsSUFBSVM7U0FDUjtBQUNMQSxXQUFPUCxRQUFRO0FBQ2ZHLFdBQU9OLElBQUlVO0FBQ1hILFlBQVFQLElBQUlVO0FBQ1pGLFVBQU1JLEtBQUtDLElBQUlaLEdBQUdDLElBQUk7QUFDdEJPLGFBQVNHLEtBQUtFLElBQUliLEdBQUdDLElBQUk7RUFDMUI7QUFFRCxTQUFPO0lBQUNJO0lBQU1FO0lBQUtEO0lBQU9FOztBQUMzQjtBQUVELFNBQVNNLFlBQVlDLE9BQU1DLE9BQU9KLEtBQUtDLEtBQUs7QUFDMUMsU0FBT0UsUUFBTyxJQUFJRSxZQUFZRCxPQUFPSixLQUFLQyxHQUFHO0FBQzlDO0FBRUQsU0FBU0ssaUJBQWlCckIsS0FBS3NCLE1BQU1DLE1BQU07QUFDekMsUUFBTUosUUFBUW5CLElBQUl3QixRQUFRQztBQUMxQixRQUFNUCxRQUFPbEIsSUFBSTBCO0FBQ2pCLFFBQU1DLElBQUlDLE9BQU9ULEtBQUs7QUFFdEIsU0FBTztJQUNMVSxHQUFHWixZQUFZQyxNQUFLUixLQUFLaUIsRUFBRWpCLEtBQUssR0FBR2EsSUFBSTtJQUN2Q08sR0FBR2IsWUFBWUMsTUFBS1QsT0FBT2tCLEVBQUVsQixPQUFPLEdBQUdhLElBQUk7SUFDM0NTLEdBQUdkLFlBQVlDLE1BQUtQLFFBQVFnQixFQUFFaEIsUUFBUSxHQUFHWSxJQUFJO0lBQzdDUyxHQUFHZixZQUFZQyxNQUFLVixNQUFNbUIsRUFBRW5CLE1BQU0sR0FBR2MsSUFBSTs7QUFFNUM7QUFFRCxTQUFTVyxrQkFBa0JqQyxLQUFLc0IsTUFBTUMsTUFBTTtBQUMxQyxRQUFNLEVBQUNXLG1CQUFrQixJQUFJbEMsSUFBSU8sU0FBUztJQUFDO0VBQXFCLENBQUE7QUFDaEUsUUFBTVksUUFBUW5CLElBQUl3QixRQUFRVztBQUMxQixRQUFNUixJQUFJUyxjQUFjakIsS0FBSztBQUM3QixRQUFNa0IsT0FBT3ZCLEtBQUtDLElBQUlPLE1BQU1DLElBQUk7QUFDaEMsUUFBTUwsUUFBT2xCLElBQUkwQjtBQUlqQixRQUFNWSxlQUFlSixzQkFBc0JLLFNBQVNwQixLQUFLO0FBRXpELFNBQU87SUFDTHFCLFNBQVN2QixZQUFZLENBQUNxQixnQkFBZ0JwQixNQUFLUixPQUFPUSxNQUFLVixNQUFNbUIsRUFBRWEsU0FBUyxHQUFHSCxJQUFJO0lBQy9FSSxVQUFVeEIsWUFBWSxDQUFDcUIsZ0JBQWdCcEIsTUFBS1IsT0FBT1EsTUFBS1QsT0FBT2tCLEVBQUVjLFVBQVUsR0FBR0osSUFBSTtJQUNsRkssWUFBWXpCLFlBQVksQ0FBQ3FCLGdCQUFnQnBCLE1BQUtQLFVBQVVPLE1BQUtWLE1BQU1tQixFQUFFZSxZQUFZLEdBQUdMLElBQUk7SUFDeEZNLGFBQWExQixZQUFZLENBQUNxQixnQkFBZ0JwQixNQUFLUCxVQUFVTyxNQUFLVCxPQUFPa0IsRUFBRWdCLGFBQWEsR0FBR04sSUFBSTs7QUFFOUY7QUFFRCxTQUFTTyxjQUFjNUMsS0FBSztBQUMxQixRQUFNNkMsU0FBUzlDLGFBQWFDLEdBQUc7QUFDL0IsUUFBTUssUUFBUXdDLE9BQU9wQyxRQUFRb0MsT0FBT3JDO0FBQ3BDLFFBQU1GLFNBQVN1QyxPQUFPbEMsU0FBU2tDLE9BQU9uQztBQUN0QyxRQUFNb0MsU0FBU3pCLGlCQUFpQnJCLEtBQUtLLFFBQVEsR0FBR0MsU0FBUyxDQUFDO0FBQzFELFFBQU15QyxTQUFTZCxrQkFBa0JqQyxLQUFLSyxRQUFRLEdBQUdDLFNBQVMsQ0FBQztBQUUzRCxTQUFPO0lBQ0wwQyxPQUFPO01BQ0w5QyxHQUFHMkMsT0FBT3JDO01BQ1ZMLEdBQUcwQyxPQUFPbkM7TUFDVnVDLEdBQUc1QztNQUNINkMsR0FBRzVDO01BQ0h5QztJQUNEO0lBQ0RJLE9BQU87TUFDTGpELEdBQUcyQyxPQUFPckMsT0FBT3NDLE9BQU9kO01BQ3hCN0IsR0FBRzBDLE9BQU9uQyxNQUFNb0MsT0FBT2pCO01BQ3ZCb0IsR0FBRzVDLFFBQVF5QyxPQUFPZCxJQUFJYyxPQUFPaEI7TUFDN0JvQixHQUFHNUMsU0FBU3dDLE9BQU9qQixJQUFJaUIsT0FBT2Y7TUFDOUJnQixRQUFRO1FBQ05QLFNBQVMxQixLQUFLRSxJQUFJLEdBQUcrQixPQUFPUCxVQUFVMUIsS0FBS0UsSUFBSThCLE9BQU9qQixHQUFHaUIsT0FBT2QsQ0FBQyxDQUFDO1FBQ2xFUyxVQUFVM0IsS0FBS0UsSUFBSSxHQUFHK0IsT0FBT04sV0FBVzNCLEtBQUtFLElBQUk4QixPQUFPakIsR0FBR2lCLE9BQU9oQixDQUFDLENBQUM7UUFDcEVZLFlBQVk1QixLQUFLRSxJQUFJLEdBQUcrQixPQUFPTCxhQUFhNUIsS0FBS0UsSUFBSThCLE9BQU9mLEdBQUdlLE9BQU9kLENBQUMsQ0FBQztRQUN4RVcsYUFBYTdCLEtBQUtFLElBQUksR0FBRytCLE9BQU9KLGNBQWM3QixLQUFLRSxJQUFJOEIsT0FBT2YsR0FBR2UsT0FBT2hCLENBQUMsQ0FBQztNQUMzRTtJQUNGOztBQUVKO0FBRUQsU0FBU3NCLFFBQVFwRCxLQUFLRSxHQUFHQyxHQUFHRixrQkFBa0I7QUFDNUMsUUFBTW9ELFFBQVFuRCxNQUFNO0FBQ3BCLFFBQU1vRCxRQUFRbkQsTUFBTTtBQUNwQixRQUFNb0QsV0FBV0YsU0FBU0M7QUFDMUIsUUFBTVQsU0FBUzdDLE9BQU8sQ0FBQ3VELFlBQVl4RCxhQUFhQyxLQUFLQyxnQkFBZ0I7QUFFckUsU0FBTzRDLFdBQ0hRLFNBQVNHLFdBQVd0RCxHQUFHMkMsT0FBT3JDLE1BQU1xQyxPQUFPcEMsS0FBSyxPQUNoRDZDLFNBQVNFLFdBQVdyRCxHQUFHMEMsT0FBT25DLEtBQUttQyxPQUFPbEMsTUFBTTtBQUNyRDtBQUVELFNBQVM4QyxVQUFVVixRQUFRO0FBQ3pCLFNBQU9BLE9BQU9QLFdBQVdPLE9BQU9OLFlBQVlNLE9BQU9MLGNBQWNLLE9BQU9KO0FBQ3pFO0FBT0QsU0FBU2Usa0JBQWtCQyxLQUFLQyxNQUFNO0FBQ3BDRCxNQUFJQyxLQUFLQSxLQUFLMUQsR0FBRzBELEtBQUt6RCxHQUFHeUQsS0FBS1gsR0FBR1csS0FBS1YsQ0FBQztBQUN4QztBQUVELFNBQVNXLFlBQVlELE1BQU1FLFFBQVFDLFVBQVUsQ0FBQSxHQUFJO0FBQy9DLFFBQU03RCxJQUFJMEQsS0FBSzFELE1BQU02RCxRQUFRN0QsSUFBSSxDQUFDNEQsU0FBUztBQUMzQyxRQUFNM0QsSUFBSXlELEtBQUt6RCxNQUFNNEQsUUFBUTVELElBQUksQ0FBQzJELFNBQVM7QUFDM0MsUUFBTWIsS0FBS1csS0FBSzFELElBQUkwRCxLQUFLWCxNQUFNYyxRQUFRN0QsSUFBSTZELFFBQVFkLElBQUlhLFNBQVMsS0FBSzVEO0FBQ3JFLFFBQU1nRCxNQUFLVSxLQUFLekQsSUFBSXlELEtBQUtWLE1BQU1hLFFBQVE1RCxJQUFJNEQsUUFBUWIsSUFBSVksU0FBUyxLQUFLM0Q7QUFDckUsU0FBTztJQUNMRCxHQUFHMEQsS0FBSzFELElBQUlBO0lBQ1pDLEdBQUd5RCxLQUFLekQsSUFBSUE7SUFDWjhDLEdBQUdXLEtBQUtYLElBQUlBO0lBQ1pDLEdBQUdVLEtBQUtWLElBQUlBO0lBQ1pILFFBQVFhLEtBQUtiOztBQUVoQjtBQUVjLElBQU1pQixhQUFOLGNBQXlCQyxRQUFPO0VBdUI3Q0MsWUFBWUMsS0FBSztBQUNmLFVBQUs7QUFFTCxTQUFLM0MsVUFBVTRDO0FBQ2YsU0FBS3ZELGFBQWF1RDtBQUNsQixTQUFLaEUsT0FBT2dFO0FBQ1osU0FBSy9ELFFBQVErRDtBQUNiLFNBQUs5RCxTQUFTOEQ7QUFDZCxTQUFLQyxnQkFBZ0JEO0FBRXJCLFFBQUlELEtBQUs7QUFDUEcsYUFBT0MsT0FBTyxNQUFNSixHQUFHO0lBQ3hCO0VBQ0Y7RUFFREssS0FBS2IsS0FBSztBQUNSLFVBQU0sRUFBQ1UsZUFBZTdDLFNBQVMsRUFBQ2lELGFBQWFDLGdCQUFlLEVBQUMsSUFBSTtBQUNqRSxVQUFNLEVBQUN2QixPQUFPSCxNQUFLLElBQUlKLGNBQWMsSUFBSTtBQUN6QyxVQUFNK0IsY0FBY2xCLFVBQVVULE1BQU1ELE1BQU0sSUFBSTZCLHFCQUFxQmxCO0FBRW5FQyxRQUFJa0IsS0FBSTtBQUVSLFFBQUk3QixNQUFNQyxNQUFNRSxNQUFNRixLQUFLRCxNQUFNRSxNQUFNQyxNQUFNRCxHQUFHO0FBQzlDUyxVQUFJbUIsVUFBUztBQUNiSCxrQkFBWWhCLEtBQUtFLFlBQVliLE9BQU9xQixlQUFlbEIsS0FBSyxDQUFDO0FBQ3pEUSxVQUFJb0IsS0FBSTtBQUNSSixrQkFBWWhCLEtBQUtFLFlBQVlWLE9BQU8sQ0FBQ2tCLGVBQWVyQixLQUFLLENBQUM7QUFDMURXLFVBQUlxQixZQUFZUDtBQUNoQmQsVUFBSXNCLEtBQUssU0FBUztJQUNuQjtBQUVEdEIsUUFBSW1CLFVBQVM7QUFDYkgsZ0JBQVloQixLQUFLRSxZQUFZVixPQUFPa0IsYUFBYSxDQUFDO0FBQ2xEVixRQUFJcUIsWUFBWU47QUFDaEJmLFFBQUlzQixLQUFJO0FBRVJ0QixRQUFJdUIsUUFBTztFQUNaO0VBRUQ5QixRQUFRK0IsUUFBUUMsUUFBUW5GLGtCQUFrQjtBQUN4QyxXQUFPbUQsUUFBUSxNQUFNK0IsUUFBUUMsUUFBUW5GLGdCQUFnQjtFQUN0RDtFQUVEb0YsU0FBU0YsUUFBUWxGLGtCQUFrQjtBQUNqQyxXQUFPbUQsUUFBUSxNQUFNK0IsUUFBUSxNQUFNbEYsZ0JBQWdCO0VBQ3BEO0VBRURxRixTQUFTRixRQUFRbkYsa0JBQWtCO0FBQ2pDLFdBQU9tRCxRQUFRLE1BQU0sTUFBTWdDLFFBQVFuRixnQkFBZ0I7RUFDcEQ7RUFFRHNGLGVBQWV0RixrQkFBa0I7QUFDL0IsVUFBTSxFQUFDQyxHQUFHQyxHQUFHQyxNQUFNUyxXQUFVLElBQTZCLEtBQUtOLFNBQVM7TUFBQztNQUFLO01BQUs7TUFBUTtPQUFlTixnQkFBZ0I7QUFDMUgsV0FBTztNQUNMQyxHQUFHVyxjQUFjWCxJQUFJRSxRQUFRLElBQUlGO01BQ2pDQyxHQUFHVSxhQUFhVixLQUFLQSxJQUFJQyxRQUFROztFQUVwQztFQUVEb0YsU0FBU0MsTUFBTTtBQUNiLFdBQU9BLFNBQVMsTUFBTSxLQUFLcEYsUUFBUSxJQUFJLEtBQUtDLFNBQVM7RUFDdEQ7O0FBbEZELGNBRm1CMEQsWUFFWjBCLE1BQUs7QUFLWixjQVBtQjFCLFlBT1oyQixZQUFXO0VBQ2hCakUsZUFBZTtFQUNmRCxhQUFhO0VBQ2JVLGNBQWM7RUFDZGtDLGVBQWU7RUFDZnVCLFlBQVl4Qjs7QUFNZCxjQWxCbUJKLFlBa0JaNkIsaUJBQWdCO0VBQ3JCbkIsaUJBQWlCO0VBQ2pCRCxhQUFhOztBV3pJakIsSUFBTXFCLGFBQWEsQ0FBQ0MsV0FBV0MsYUFBYTtBQUMxQyxNQUFJLEVBQUNDLFlBQVlELFVBQVVFLFdBQVdGLFNBQVEsSUFBSUQ7QUFFbEQsTUFBSUEsVUFBVUksZUFBZTtBQUMzQkYsZ0JBQVlHLEtBQUtDLElBQUlKLFdBQVdELFFBQVE7QUFDeENFLGVBQVdILFVBQVVPLG1CQUFtQkYsS0FBS0MsSUFBSUgsVUFBVUYsUUFBUTtFQUNwRTtBQUVELFNBQU87SUFDTEU7SUFDQUQ7SUFDQU0sWUFBWUgsS0FBS0ksSUFBSVIsVUFBVUMsU0FBUzs7O0FBSTVDLElBQU1RLGFBQWEsQ0FBQ0MsR0FBR0MsTUFBTUQsTUFBTSxRQUFRQyxNQUFNLFFBQVFELEVBQUVFLGlCQUFpQkQsRUFBRUMsZ0JBQWdCRixFQUFFRyxVQUFVRixFQUFFRTtBQUVyRyxJQUFNQyxTQUFOLGNBQXFCQyxRQUFPO0VBS2pDQyxZQUFZQyxRQUFRO0FBQ2xCLFVBQUs7QUFFTCxTQUFLQyxTQUFTO0FBR2QsU0FBS0MsaUJBQWlCLENBQUE7QUFLdEIsU0FBS0MsZUFBZTtBQUdwQixTQUFLQyxlQUFlO0FBRXBCLFNBQUtDLFFBQVFMLE9BQU9LO0FBQ3BCLFNBQUtDLFVBQVVOLE9BQU9NO0FBQ3RCLFNBQUtDLE1BQU1QLE9BQU9PO0FBQ2xCLFNBQUtDLGNBQWNDO0FBQ25CLFNBQUtDLGNBQWNEO0FBQ25CLFNBQUtFLGFBQWFGO0FBQ2xCLFNBQUtHLFlBQVlIO0FBQ2pCLFNBQUtJLFdBQVdKO0FBQ2hCLFNBQUtLLE1BQU1MO0FBQ1gsU0FBS00sU0FBU047QUFDZCxTQUFLTyxPQUFPUDtBQUNaLFNBQUtRLFFBQVFSO0FBQ2IsU0FBS1MsU0FBU1Q7QUFDZCxTQUFLVSxRQUFRVjtBQUNiLFNBQUtXLFdBQVdYO0FBQ2hCLFNBQUtZLFdBQVdaO0FBQ2hCLFNBQUthLFNBQVNiO0FBQ2QsU0FBS2MsV0FBV2Q7RUFDakI7RUFFRGUsT0FBT1gsVUFBVUQsV0FBV2EsU0FBUztBQUNuQyxTQUFLWixXQUFXQTtBQUNoQixTQUFLRCxZQUFZQTtBQUNqQixTQUFLUSxXQUFXSztBQUVoQixTQUFLQyxjQUFhO0FBQ2xCLFNBQUtDLFlBQVc7QUFDaEIsU0FBS0MsSUFBRztFQUNUO0VBRURGLGdCQUFnQjtBQUNkLFFBQUksS0FBS0csYUFBWSxHQUFJO0FBQ3ZCLFdBQUtWLFFBQVEsS0FBS047QUFDbEIsV0FBS0csT0FBTyxLQUFLSSxTQUFTSjtBQUMxQixXQUFLQyxRQUFRLEtBQUtFO1dBQ2I7QUFDTCxXQUFLRCxTQUFTLEtBQUtOO0FBQ25CLFdBQUtFLE1BQU0sS0FBS00sU0FBU047QUFDekIsV0FBS0MsU0FBUyxLQUFLRztJQUNwQjtFQUNGO0VBRURTLGNBQWM7QUFDWixVQUFNN0MsWUFBWSxLQUFLd0IsUUFBUXdCLFVBQVUsQ0FBQTtBQUN6QyxRQUFJdEIsY0FBY3VCLFNBQUtqRCxVQUFVa0QsZ0JBQWdCO01BQUMsS0FBSzNCO0lBQU0sR0FBRSxJQUFJLEtBQUssQ0FBQTtBQUV4RSxRQUFJdkIsVUFBVW1ELFFBQVE7QUFDcEJ6QixvQkFBY0EsWUFBWXlCLE9BQU8sQ0FBQ0MsU0FBU3BELFVBQVVtRCxPQUFPQyxNQUFNLEtBQUs3QixNQUFNOEIsSUFBSSxDQUFDO0lBQ25GO0FBRUQsUUFBSXJELFVBQVVzRCxNQUFNO0FBQ2xCNUIsb0JBQWNBLFlBQVk0QixLQUFLLENBQUMzQyxHQUFHQyxNQUFNWixVQUFVc0QsS0FBSzNDLEdBQUdDLEdBQUcsS0FBS1csTUFBTThCLElBQUksQ0FBQztJQUMvRTtBQUVELFFBQUksS0FBSzdCLFFBQVErQixTQUFTO0FBQ3hCN0Isa0JBQVk2QixRQUFPO0lBQ3BCO0FBRUQsU0FBSzdCLGNBQWNBO0VBQ3BCO0VBRURvQixNQUFNO0FBQ0osVUFBTSxFQUFDdEIsU0FBU0MsSUFBRyxJQUFJO0FBTXZCLFFBQUksQ0FBQ0QsUUFBUWdDLFNBQVM7QUFDcEIsV0FBS25CLFFBQVEsS0FBS0QsU0FBUztBQUMzQjtJQUNEO0FBRUQsVUFBTXBDLFlBQVl3QixRQUFRd0I7QUFDMUIsVUFBTVMsWUFBWUMsT0FBTzFELFVBQVUyRCxJQUFJO0FBQ3ZDLFVBQU0xRCxXQUFXd0QsVUFBVUc7QUFDM0IsVUFBTUMsY0FBYyxLQUFLQyxvQkFBbUI7QUFDNUMsVUFBTSxFQUFDM0QsVUFBVUssV0FBVSxJQUFJVCxXQUFXQyxXQUFXQyxRQUFRO0FBRTdELFFBQUlvQyxPQUFPRDtBQUVYWCxRQUFJa0MsT0FBT0YsVUFBVU07QUFFckIsUUFBSSxLQUFLaEIsYUFBWSxHQUFJO0FBQ3ZCVixjQUFRLEtBQUtOO0FBQ2JLLGVBQVMsS0FBSzRCLFNBQVNILGFBQWE1RCxVQUFVRSxVQUFVSyxVQUFVLElBQUk7V0FDakU7QUFDTDRCLGVBQVMsS0FBS047QUFDZE8sY0FBUSxLQUFLNEIsU0FBU0osYUFBYUosV0FBV3RELFVBQVVLLFVBQVUsSUFBSTtJQUN2RTtBQUVELFNBQUs2QixRQUFRaEMsS0FBS0MsSUFBSStCLE9BQU9iLFFBQVFPLFlBQVksS0FBS0EsUUFBUTtBQUM5RCxTQUFLSyxTQUFTL0IsS0FBS0MsSUFBSThCLFFBQVFaLFFBQVFNLGFBQWEsS0FBS0EsU0FBUztFQUNuRTtFQUtEa0MsU0FBU0gsYUFBYTVELFVBQVVFLFVBQVVLLFlBQVk7QUFDcEQsVUFBTSxFQUFDaUIsS0FBS00sVUFBVVAsU0FBUyxFQUFDd0IsUUFBUSxFQUFDa0IsUUFBTyxFQUFDLEVBQUMsSUFBSTtBQUN0RCxVQUFNQyxXQUFXLEtBQUsvQyxpQkFBaUIsQ0FBQTtBQUV2QyxVQUFNUyxhQUFhLEtBQUtBLGFBQWE7TUFBRTs7QUFDdkMsVUFBTXVDLGFBQWE1RCxhQUFhMEQ7QUFDaEMsUUFBSUcsY0FBY1I7QUFFbEJwQyxRQUFJNkMsWUFBWTtBQUNoQjdDLFFBQUk4QyxlQUFlO0FBRW5CLFFBQUlDLE1BQU07QUFDVixRQUFJeEMsTUFBTSxDQUFDb0M7QUFDWCxTQUFLMUMsWUFBWStDLFFBQVEsQ0FBQ0MsWUFBWUMsTUFBTTtBQUMxQyxZQUFNQyxZQUFZekUsV0FBWUYsV0FBVyxJQUFLd0IsSUFBSW9ELFlBQVlILFdBQVdJLElBQUksRUFBRXpDO0FBRS9FLFVBQUlzQyxNQUFNLEtBQUs5QyxXQUFXQSxXQUFXa0QsU0FBUyxLQUFLSCxZQUFZLElBQUlWLFVBQVVuQyxVQUFVO0FBQ3JGc0MsdUJBQWVEO0FBQ2Z2QyxtQkFBV0EsV0FBV2tELFVBQVVKLElBQUksSUFBSSxJQUFJLE1BQU07QUFDbEQzQyxlQUFPb0M7QUFDUEk7TUFDRDtBQUVETCxlQUFTUSxLQUFLO1FBQUN6QyxNQUFNO1FBQUdGO1FBQUt3QztRQUFLbkMsT0FBT3VDO1FBQVd4QyxRQUFRNUI7O0FBRTVEcUIsaUJBQVdBLFdBQVdrRCxTQUFTLE1BQU1ILFlBQVlWO0lBQ2xELENBQUE7QUFFRCxXQUFPRztFQUNSO0VBRURKLFNBQVNKLGFBQWFKLFdBQVd0RCxVQUFVNkUsYUFBYTtBQUN0RCxVQUFNLEVBQUN2RCxLQUFLSyxXQUFXTixTQUFTLEVBQUN3QixRQUFRLEVBQUNrQixRQUFPLEVBQUMsRUFBQyxJQUFJO0FBQ3ZELFVBQU1DLFdBQVcsS0FBSy9DLGlCQUFpQixDQUFBO0FBQ3ZDLFVBQU1RLGNBQWMsS0FBS0EsY0FBYyxDQUFBO0FBQ3ZDLFVBQU1xRCxjQUFjbkQsWUFBWStCO0FBRWhDLFFBQUlxQixhQUFhaEI7QUFDakIsUUFBSWlCLGtCQUFrQjtBQUN0QixRQUFJQyxtQkFBbUI7QUFFdkIsUUFBSWxELE9BQU87QUFDWCxRQUFJbUQsTUFBTTtBQUVWLFNBQUszRCxZQUFZK0MsUUFBUSxDQUFDQyxZQUFZQyxNQUFNO0FBQzFDLFlBQU0sRUFBQ0MsV0FBV3BFLFdBQVUsSUFBSThFLGtCQUFrQm5GLFVBQVVzRCxXQUFXaEMsS0FBS2lELFlBQVlNLFdBQVc7QUFHbkcsVUFBSUwsSUFBSSxLQUFLUyxtQkFBbUI1RSxhQUFhLElBQUkwRCxVQUFVZSxhQUFhO0FBQ3RFQyxzQkFBY0Msa0JBQWtCakI7QUFDaEN0QyxvQkFBWTJELEtBQUs7VUFBQ2xELE9BQU84QztVQUFpQi9DLFFBQVFnRDtTQUFpQjtBQUNuRWxELGdCQUFRaUQsa0JBQWtCakI7QUFDMUJtQjtBQUNBRiwwQkFBa0JDLG1CQUFtQjtNQUN0QztBQUdEakIsZUFBU1EsS0FBSztRQUFDekM7UUFBTUYsS0FBS29EO1FBQWtCQztRQUFLaEQsT0FBT3VDO1FBQVd4QyxRQUFRNUI7O0FBRzNFMkUsd0JBQWtCOUUsS0FBS0ksSUFBSTBFLGlCQUFpQlAsU0FBUztBQUNyRFEsMEJBQW9CNUUsYUFBYTBEO0lBQ2xDLENBQUE7QUFFRGdCLGtCQUFjQztBQUNkdkQsZ0JBQVkyRCxLQUFLO01BQUNsRCxPQUFPOEM7TUFBaUIvQyxRQUFRZ0Q7S0FBaUI7QUFFbkUsV0FBT0Y7RUFDUjtFQUVETSxpQkFBaUI7QUFDZixRQUFJLENBQUMsS0FBS2hFLFFBQVFnQyxTQUFTO0FBQ3pCO0lBQ0Q7QUFDRCxVQUFNSyxjQUFjLEtBQUtDLG9CQUFtQjtBQUM1QyxVQUFNLEVBQUMxQyxnQkFBZ0IrQyxVQUFVM0MsU0FBUyxFQUFDaUUsT0FBT3pDLFFBQVEsRUFBQ2tCLFFBQU8sR0FBR3dCLElBQUcsRUFBQyxJQUFJO0FBQzdFLFVBQU1DLFlBQVlDLGNBQWNGLEtBQUssS0FBS3hELE1BQU0sS0FBS0csS0FBSztBQUMxRCxRQUFJLEtBQUtVLGFBQVksR0FBSTtBQUN2QixVQUFJeUIsTUFBTTtBQUNWLFVBQUl0QyxPQUFPMkQsZUFBZUosT0FBTyxLQUFLdkQsT0FBT2dDLFNBQVMsS0FBSy9CLFFBQVEsS0FBS04sV0FBVzJDLElBQUk7QUFDdkYsaUJBQVdzQixVQUFVM0IsVUFBVTtBQUM3QixZQUFJSyxRQUFRc0IsT0FBT3RCLEtBQUs7QUFDdEJBLGdCQUFNc0IsT0FBT3RCO0FBQ2J0QyxpQkFBTzJELGVBQWVKLE9BQU8sS0FBS3ZELE9BQU9nQyxTQUFTLEtBQUsvQixRQUFRLEtBQUtOLFdBQVcyQyxJQUFJO1FBQ3BGO0FBQ0RzQixlQUFPOUQsT0FBTyxLQUFLQSxNQUFNNkIsY0FBY0s7QUFDdkM0QixlQUFPNUQsT0FBT3lELFVBQVVJLFdBQVdKLFVBQVVLLEVBQUU5RCxJQUFJLEdBQUc0RCxPQUFPekQsS0FBSztBQUNsRUgsZ0JBQVE0RCxPQUFPekQsUUFBUTZCO01BQ3hCO1dBQ0k7QUFDTCxVQUFJbUIsTUFBTTtBQUNWLFVBQUlyRCxNQUFNNkQsZUFBZUosT0FBTyxLQUFLekQsTUFBTTZCLGNBQWNLLFNBQVMsS0FBS2pDLFNBQVMsS0FBS0wsWUFBWXlELEtBQUtqRCxNQUFNO0FBQzVHLGlCQUFXMEQsV0FBVTNCLFVBQVU7QUFDN0IsWUFBSTJCLFFBQU9ULFFBQVFBLEtBQUs7QUFDdEJBLGdCQUFNUyxRQUFPVDtBQUNickQsZ0JBQU02RCxlQUFlSixPQUFPLEtBQUt6RCxNQUFNNkIsY0FBY0ssU0FBUyxLQUFLakMsU0FBUyxLQUFLTCxZQUFZeUQsS0FBS2pELE1BQU07UUFDekc7QUFDRDBELGdCQUFPOUQsTUFBTUE7QUFDYjhELGdCQUFPNUQsUUFBUSxLQUFLQSxPQUFPZ0M7QUFDM0I0QixnQkFBTzVELE9BQU95RCxVQUFVSSxXQUFXSixVQUFVSyxFQUFFRixRQUFPNUQsSUFBSSxHQUFHNEQsUUFBT3pELEtBQUs7QUFDekVMLGVBQU84RCxRQUFPMUQsU0FBUzhCO01BQ3hCO0lBQ0Y7RUFDRjtFQUVEbkIsZUFBZTtBQUNiLFdBQU8sS0FBS3ZCLFFBQVFlLGFBQWEsU0FBUyxLQUFLZixRQUFRZSxhQUFhO0VBQ3JFO0VBRUQwRCxPQUFPO0FBQ0wsUUFBSSxLQUFLekUsUUFBUWdDLFNBQVM7QUFDeEIsWUFBTS9CLE1BQU0sS0FBS0E7QUFDakJ5RSxlQUFTekUsS0FBSyxJQUFJO0FBRWxCLFdBQUswRSxNQUFLO0FBRVZDLGlCQUFXM0UsR0FBRztJQUNmO0VBQ0Y7RUFLRDBFLFFBQVE7QUFDTixVQUFNLEVBQUMzRSxTQUFTNkUsTUFBTXpFLGFBQWFDLFlBQVlKLElBQUcsSUFBSTtBQUN0RCxVQUFNLEVBQUNnRSxPQUFPekMsUUFBUWhELFVBQVMsSUFBSXFHO0FBQ25DLFVBQU1DLGVBQWVDLFNBQVNDO0FBQzlCLFVBQU1iLFlBQVlDLGNBQWNTLEtBQUtYLEtBQUssS0FBS3hELE1BQU0sS0FBS0csS0FBSztBQUMvRCxVQUFNb0IsWUFBWUMsT0FBTzFELFVBQVUyRCxJQUFJO0FBQ3ZDLFVBQU0sRUFBQ08sUUFBTyxJQUFJbEU7QUFDbEIsVUFBTUMsV0FBV3dELFVBQVVHO0FBQzNCLFVBQU02QyxlQUFleEcsV0FBVztBQUNoQyxRQUFJeUc7QUFFSixTQUFLQyxVQUFTO0FBR2RsRixRQUFJNkMsWUFBWXFCLFVBQVVyQixVQUFVLE1BQU07QUFDMUM3QyxRQUFJOEMsZUFBZTtBQUNuQjlDLFFBQUltRixZQUFZO0FBQ2hCbkYsUUFBSWtDLE9BQU9GLFVBQVVNO0FBRXJCLFVBQU0sRUFBQzVELFVBQVVELFdBQVdNLFdBQVUsSUFBSVQsV0FBV0MsV0FBV0MsUUFBUTtBQUd4RSxVQUFNNEcsZ0JBQWdCLFNBQVNiLEdBQUdjLEdBQUdwQyxZQUFZO0FBQy9DLFVBQUlxQyxNQUFNNUcsUUFBUSxLQUFLQSxZQUFZLEtBQUs0RyxNQUFNN0csU0FBUyxLQUFLQSxZQUFZLEdBQUc7QUFDekU7TUFDRDtBQUdEdUIsVUFBSXVGLEtBQUk7QUFFUixZQUFNSixZQUFZSyxlQUFldkMsV0FBV2tDLFdBQVcsQ0FBQztBQUN4RG5GLFVBQUl5RixZQUFZRCxlQUFldkMsV0FBV3dDLFdBQVdaLFlBQVk7QUFDakU3RSxVQUFJMEYsVUFBVUYsZUFBZXZDLFdBQVd5QyxTQUFTLE1BQU07QUFDdkQxRixVQUFJMkYsaUJBQWlCSCxlQUFldkMsV0FBVzBDLGdCQUFnQixDQUFDO0FBQ2hFM0YsVUFBSTRGLFdBQVdKLGVBQWV2QyxXQUFXMkMsVUFBVSxPQUFPO0FBQzFENUYsVUFBSW1GLFlBQVlBO0FBQ2hCbkYsVUFBSTZGLGNBQWNMLGVBQWV2QyxXQUFXNEMsYUFBYWhCLFlBQVk7QUFFckU3RSxVQUFJOEYsWUFBWU4sZUFBZXZDLFdBQVc4QyxVQUFVLENBQUEsQ0FBRSxDQUFDO0FBRXZELFVBQUl4SCxVQUFVSSxlQUFlO0FBRzNCLGNBQU1xSCxjQUFjO1VBQ2xCQyxRQUFReEgsWUFBWUcsS0FBS3NILFFBQVE7VUFDakNDLFlBQVlsRCxXQUFXa0Q7VUFDdkJDLFVBQVVuRCxXQUFXbUQ7VUFDckJDLGFBQWFsQjs7QUFFZixjQUFNbUIsVUFBVXBDLFVBQVVxQyxNQUFNaEMsR0FBRzdGLFdBQVcsQ0FBQztBQUMvQyxjQUFNOEgsVUFBVW5CLElBQUlMO0FBR3BCeUIsd0JBQWdCekcsS0FBS2dHLGFBQWFNLFNBQVNFLFNBQVNqSSxVQUFVTyxtQkFBbUJKLFFBQVE7YUFDcEY7QUFHTCxjQUFNZ0ksVUFBVXJCLElBQUl6RyxLQUFLSSxLQUFLUixXQUFXQyxhQUFhLEdBQUcsQ0FBQztBQUMxRCxjQUFNa0ksV0FBV3pDLFVBQVVJLFdBQVdDLEdBQUc3RixRQUFRO0FBQ2pELGNBQU1rSSxlQUFlQyxjQUFjNUQsV0FBVzJELFlBQVk7QUFFMUQ1RyxZQUFJOEcsVUFBUztBQUViLFlBQUlDLE9BQU9DLE9BQU9KLFlBQVksRUFBRUssS0FBS0MsQ0FBQUEsTUFBS0EsTUFBTSxDQUFDLEdBQUc7QUFDbERDLDZCQUFtQm5ILEtBQUs7WUFDdEJ1RSxHQUFHb0M7WUFDSHRCLEdBQUdxQjtZQUNIVSxHQUFHMUk7WUFDSDJJLEdBQUc1STtZQUNId0gsUUFBUVc7VUFDVCxDQUFBO2VBQ0k7QUFDTDVHLGNBQUlzSCxLQUFLWCxVQUFVRCxTQUFTaEksVUFBVUQsU0FBUztRQUNoRDtBQUVEdUIsWUFBSXVILEtBQUk7QUFDUixZQUFJcEMsY0FBYyxHQUFHO0FBQ25CbkYsY0FBSXdILE9BQU07UUFDWDtNQUNGO0FBRUR4SCxVQUFJeUgsUUFBTzs7QUFHYixVQUFNQyxXQUFXLFNBQVNuRCxHQUFHYyxHQUFHcEMsWUFBWTtBQUMxQzBFLGlCQUFXM0gsS0FBS2lELFdBQVdJLE1BQU1rQixHQUFHYyxJQUFLdEcsYUFBYSxHQUFJaUQsV0FBVztRQUNuRTRGLGVBQWUzRSxXQUFXNEU7UUFDMUJoRixXQUFXcUIsVUFBVXJCLFVBQVVJLFdBQVdKLFNBQVM7TUFDcEQsQ0FBQTs7QUFJSCxVQUFNdkIsZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU1jLGNBQWMsS0FBS0Msb0JBQW1CO0FBQzVDLFFBQUlmLGNBQWM7QUFDaEIyRCxlQUFTO1FBQ1BWLEdBQUdILGVBQWVKLE9BQU8sS0FBS3ZELE9BQU9nQyxTQUFTLEtBQUsvQixRQUFRTixXQUFXLEVBQUU7UUFDeEVpRixHQUFHLEtBQUs5RSxNQUFNa0MsVUFBVUw7UUFDeEIwRixNQUFNOztXQUVIO0FBQ0w3QyxlQUFTO1FBQ1BWLEdBQUcsS0FBSzlELE9BQU9nQztRQUNmNEMsR0FBR2pCLGVBQWVKLE9BQU8sS0FBS3pELE1BQU02QixjQUFjSyxTQUFTLEtBQUtqQyxTQUFTTCxZQUFZLEdBQUdRLE1BQU07UUFDOUZtSCxNQUFNOztJQUVUO0FBRURDLDBCQUFzQixLQUFLL0gsS0FBSzRFLEtBQUtvRCxhQUFhO0FBRWxELFVBQU1yRixhQUFhNUQsYUFBYTBEO0FBQ2hDLFNBQUt4QyxZQUFZK0MsUUFBUSxDQUFDQyxZQUFZQyxNQUFNO0FBQzFDbEQsVUFBSTZGLGNBQWM1QyxXQUFXZ0Y7QUFDN0JqSSxVQUFJeUYsWUFBWXhDLFdBQVdnRjtBQUUzQixZQUFNQyxZQUFZbEksSUFBSW9ELFlBQVlILFdBQVdJLElBQUksRUFBRXpDO0FBQ25ELFlBQU1pQyxZQUFZcUIsVUFBVXJCLFVBQVVJLFdBQVdKLGNBQWNJLFdBQVdKLFlBQVl0RSxVQUFVc0UsVUFBVTtBQUMxRyxZQUFNakMsUUFBUWxDLFdBQVdzRyxlQUFla0Q7QUFDeEMsVUFBSTNELElBQUlVLE9BQU9WO0FBQ2YsVUFBSWMsSUFBSUosT0FBT0k7QUFFZm5CLGdCQUFVaUUsU0FBUyxLQUFLdkgsS0FBSztBQUU3QixVQUFJVSxjQUFjO0FBQ2hCLFlBQUk0QixJQUFJLEtBQUtxQixJQUFJM0QsUUFBUTZCLFVBQVUsS0FBSy9CLE9BQU87QUFDN0MyRSxjQUFJSixPQUFPSSxLQUFLMUM7QUFDaEJzQyxpQkFBTzZDO0FBQ1B2RCxjQUFJVSxPQUFPVixJQUFJSCxlQUFlSixPQUFPLEtBQUt2RCxPQUFPZ0MsU0FBUyxLQUFLL0IsUUFBUU4sV0FBVzZFLE9BQU82QyxLQUFLO1FBQy9GO01BQ0YsV0FBVTVFLElBQUksS0FBS21DLElBQUkxQyxhQUFhLEtBQUtuQyxRQUFRO0FBQ2hEK0QsWUFBSVUsT0FBT1YsSUFBSUEsSUFBSXBFLFlBQVk4RSxPQUFPNkMsTUFBTWxILFFBQVE2QjtBQUNwRHdDLGVBQU82QztBQUNQekMsWUFBSUosT0FBT0ksSUFBSWpCLGVBQWVKLE9BQU8sS0FBS3pELE1BQU02QixjQUFjSyxTQUFTLEtBQUtqQyxTQUFTTCxZQUFZOEUsT0FBTzZDLE1BQU1uSCxNQUFNO01BQ3JIO0FBRUQsWUFBTXlILFFBQVFsRSxVQUFVSyxFQUFFQSxDQUFDO0FBRTNCYSxvQkFBY2dELE9BQU8vQyxHQUFHcEMsVUFBVTtBQUVsQ3NCLFVBQUk4RCxPQUFPeEYsV0FBVzBCLElBQUk3RixXQUFXc0csY0FBYzFELGVBQWVpRCxJQUFJM0QsUUFBUSxLQUFLRixPQUFPa0UsS0FBS1gsR0FBRztBQUdsR3lELGVBQVN4RCxVQUFVSyxFQUFFQSxDQUFDLEdBQUdjLEdBQUdwQyxVQUFVO0FBRXRDLFVBQUkzQixjQUFjO0FBQ2hCMkQsZUFBT1YsS0FBSzNELFFBQVE2QjtNQUNyQixXQUFVLE9BQU9RLFdBQVdJLFNBQVMsVUFBVTtBQUM5QyxjQUFNaUYsaUJBQWlCdEcsVUFBVVc7QUFDakNzQyxlQUFPSSxLQUFLa0QsMEJBQTBCdEYsWUFBWXFGLGNBQWM7YUFDM0Q7QUFDTHJELGVBQU9JLEtBQUsxQztNQUNiO0lBQ0YsQ0FBQTtBQUVENkYseUJBQXFCLEtBQUt4SSxLQUFLNEUsS0FBS29ELGFBQWE7RUFDbEQ7RUFLRDlDLFlBQVk7QUFDVixVQUFNTixPQUFPLEtBQUs3RTtBQUNsQixVQUFNMEksWUFBWTdELEtBQUs4RDtBQUN2QixVQUFNQyxZQUFZMUcsT0FBT3dHLFVBQVV2RyxJQUFJO0FBQ3ZDLFVBQU0wRyxlQUFlQyxVQUFVSixVQUFVaEcsT0FBTztBQUVoRCxRQUFJLENBQUNnRyxVQUFVMUcsU0FBUztBQUN0QjtJQUNEO0FBRUQsVUFBTW1DLFlBQVlDLGNBQWNTLEtBQUtYLEtBQUssS0FBS3hELE1BQU0sS0FBS0csS0FBSztBQUMvRCxVQUFNWixNQUFNLEtBQUtBO0FBQ2pCLFVBQU1jLFdBQVcySCxVQUFVM0g7QUFDM0IsVUFBTWtFLGVBQWUyRCxVQUFVeEcsT0FBTztBQUN0QyxVQUFNMkcsNkJBQTZCRixhQUFhckksTUFBTXlFO0FBQ3RELFFBQUlLO0FBSUosUUFBSTVFLE9BQU8sS0FBS0E7QUFDaEIsUUFBSUgsV0FBVyxLQUFLTTtBQUVwQixRQUFJLEtBQUtVLGFBQVksR0FBSTtBQUV2QmhCLGlCQUFXMUIsS0FBS0ksSUFBRyxHQUFJLEtBQUtvQixVQUFVO0FBQ3RDaUYsVUFBSSxLQUFLOUUsTUFBTXVJO0FBQ2ZySSxhQUFPMkQsZUFBZVEsS0FBS1osT0FBT3ZELE1BQU0sS0FBS0MsUUFBUUosUUFBUTtXQUN4RDtBQUVMLFlBQU1ELFlBQVksS0FBS0YsWUFBWTRJLE9BQU8sQ0FBQ0MsS0FBSzdHLFNBQVN2RCxLQUFLSSxJQUFJZ0ssS0FBSzdHLEtBQUt4QixNQUFNLEdBQUcsQ0FBQztBQUN0RjBFLFVBQUl5RCw2QkFBNkIxRSxlQUFlUSxLQUFLWixPQUFPLEtBQUt6RCxLQUFLLEtBQUtDLFNBQVNILFlBQVl1RSxLQUFLckQsT0FBT2tCLFVBQVUsS0FBS0osb0JBQW1CLENBQUU7SUFDako7QUFJRCxVQUFNa0MsSUFBSUgsZUFBZXRELFVBQVVMLE1BQU1BLE9BQU9ILFFBQVE7QUFHeEROLFFBQUk2QyxZQUFZcUIsVUFBVXJCLFVBQVVvRyxtQkFBbUJuSSxRQUFRLENBQUM7QUFDaEVkLFFBQUk4QyxlQUFlO0FBQ25COUMsUUFBSTZGLGNBQWM0QyxVQUFVMUQ7QUFDNUIvRSxRQUFJeUYsWUFBWWdELFVBQVUxRDtBQUMxQi9FLFFBQUlrQyxPQUFPeUcsVUFBVXJHO0FBRXJCcUYsZUFBVzNILEtBQUt5SSxVQUFVcEYsTUFBTWtCLEdBQUdjLEdBQUdzRCxTQUFTO0VBQ2hEO0VBS0R0RyxzQkFBc0I7QUFDcEIsVUFBTW9HLFlBQVksS0FBSzFJLFFBQVEySTtBQUMvQixVQUFNQyxZQUFZMUcsT0FBT3dHLFVBQVV2RyxJQUFJO0FBQ3ZDLFVBQU0wRyxlQUFlQyxVQUFVSixVQUFVaEcsT0FBTztBQUNoRCxXQUFPZ0csVUFBVTFHLFVBQVU0RyxVQUFVaEcsYUFBYWlHLGFBQWFqSSxTQUFTO0VBQ3pFO0VBS0R1SSxpQkFBaUIzRSxHQUFHYyxHQUFHO0FBQ3JCLFFBQUluQyxHQUFHaUcsUUFBUUM7QUFFZixRQUFJQyxXQUFXOUUsR0FBRyxLQUFLOUQsTUFBTSxLQUFLQyxLQUFLLEtBQ2xDMkksV0FBV2hFLEdBQUcsS0FBSzlFLEtBQUssS0FBS0MsTUFBTSxHQUFHO0FBRXpDNEksV0FBSyxLQUFLeko7QUFDVixXQUFLdUQsSUFBSSxHQUFHQSxJQUFJa0csR0FBRzlGLFFBQVEsRUFBRUosR0FBRztBQUM5QmlHLGlCQUFTQyxHQUFHbEc7QUFFWixZQUFJbUcsV0FBVzlFLEdBQUc0RSxPQUFPMUksTUFBTTBJLE9BQU8xSSxPQUFPMEksT0FBT3ZJLEtBQUssS0FDcER5SSxXQUFXaEUsR0FBRzhELE9BQU81SSxLQUFLNEksT0FBTzVJLE1BQU00SSxPQUFPeEksTUFBTSxHQUFHO0FBRTFELGlCQUFPLEtBQUtWLFlBQVlpRDtRQUN6QjtNQUNGO0lBQ0Y7QUFFRCxXQUFPO0VBQ1I7RUFNRG9HLFlBQVlDLEdBQUc7QUFDYixVQUFNM0UsT0FBTyxLQUFLN0U7QUFDbEIsUUFBSSxDQUFDeUosV0FBV0QsRUFBRUUsTUFBTTdFLElBQUksR0FBRztBQUM3QjtJQUNEO0FBR0QsVUFBTThFLGNBQWMsS0FBS1IsaUJBQWlCSyxFQUFFaEYsR0FBR2dGLEVBQUVsRSxDQUFDO0FBRWxELFFBQUlrRSxFQUFFRSxTQUFTLGVBQWVGLEVBQUVFLFNBQVMsWUFBWTtBQUNuRCxZQUFNRSxXQUFXLEtBQUsvSjtBQUN0QixZQUFNZ0ssV0FBVzNLLFdBQVcwSyxVQUFVRCxXQUFXO0FBQ2pELFVBQUlDLFlBQVksQ0FBQ0MsVUFBVTtBQUN6QnBJLGlCQUFLb0QsS0FBS2lGLFNBQVM7VUFBQ047VUFBR0k7VUFBVTtXQUFPLElBQUk7TUFDN0M7QUFFRCxXQUFLL0osZUFBZThKO0FBRXBCLFVBQUlBLGVBQWUsQ0FBQ0UsVUFBVTtBQUM1QnBJLGlCQUFLb0QsS0FBS2tGLFNBQVM7VUFBQ1A7VUFBR0c7VUFBYTtXQUFPLElBQUk7TUFDaEQ7ZUFDUUEsYUFBYTtBQUN0QmxJLGVBQUtvRCxLQUFLbUYsU0FBUztRQUFDUjtRQUFHRztRQUFhO1NBQU8sSUFBSTtJQUNoRDtFQUNGO0FBQ0Y7QUFFRCxTQUFTN0Ysa0JBQWtCbkYsVUFBVXNELFdBQVdoQyxLQUFLaUQsWUFBWU0sYUFBYTtBQUM1RSxRQUFNSixZQUFZNkcsbUJBQW1CL0csWUFBWXZFLFVBQVVzRCxXQUFXaEMsR0FBRztBQUN6RSxRQUFNakIsYUFBYWtMLG9CQUFvQjFHLGFBQWFOLFlBQVlqQixVQUFVVyxVQUFVO0FBQ3BGLFNBQU87SUFBQ1E7SUFBV3BFOztBQUNwQjtBQUVELFNBQVNpTCxtQkFBbUIvRyxZQUFZdkUsVUFBVXNELFdBQVdoQyxLQUFLO0FBQ2hFLE1BQUlrSyxpQkFBaUJqSCxXQUFXSTtBQUNoQyxNQUFJNkcsa0JBQWtCLE9BQU9BLG1CQUFtQixVQUFVO0FBQ3hEQSxxQkFBaUJBLGVBQWVuQixPQUFPLENBQUM3SixHQUFHQyxNQUFNRCxFQUFFb0UsU0FBU25FLEVBQUVtRSxTQUFTcEUsSUFBSUMsQ0FBQztFQUM3RTtBQUNELFNBQU9ULFdBQVlzRCxVQUFVRyxPQUFPLElBQUtuQyxJQUFJb0QsWUFBWThHLGNBQWMsRUFBRXRKO0FBQzFFO0FBRUQsU0FBU3FKLG9CQUFvQjFHLGFBQWFOLFlBQVlxRixnQkFBZ0I7QUFDcEUsTUFBSXZKLGFBQWF3RTtBQUNqQixNQUFJLE9BQU9OLFdBQVdJLFNBQVMsVUFBVTtBQUN2Q3RFLGlCQUFhd0osMEJBQTBCdEYsWUFBWXFGLGNBQWM7RUFDbEU7QUFDRCxTQUFPdko7QUFDUjtBQUVELFNBQVN3SiwwQkFBMEJ0RixZQUFZcUYsZ0JBQWdCO0FBQzdELFFBQU02QixjQUFjbEgsV0FBV0ksT0FBT0osV0FBV0ksS0FBS0MsU0FBUyxNQUFNO0FBQ3JFLFNBQU9nRixpQkFBaUI2QjtBQUN6QjtBQUVELFNBQVNYLFdBQVdDLE1BQU03RSxNQUFNO0FBQzlCLE9BQUs2RSxTQUFTLGVBQWVBLFNBQVMsZ0JBQWdCN0UsS0FBS2tGLFdBQVdsRixLQUFLaUYsVUFBVTtBQUNuRixXQUFPO0VBQ1I7QUFDRCxNQUFJakYsS0FBS21GLFlBQVlOLFNBQVMsV0FBV0EsU0FBUyxZQUFZO0FBQzVELFdBQU87RUFDUjtBQUNELFNBQU87QUFDUjtBQUVELElBQUEsZ0JBQWU7RUFDYlcsSUFBSTtFQU1KQyxVQUFVL0s7RUFFVmdMLE1BQU14SyxPQUFPeUssT0FBT3hLLFNBQVM7QUFDM0IsVUFBTXlLLFNBQVMxSyxNQUFNMEssU0FBUyxJQUFJbEwsT0FBTztNQUFDVSxLQUFLRixNQUFNRTtNQUFLRDtNQUFTRDtJQUFNLENBQUE7QUFDekUySyxZQUFRQyxVQUFVNUssT0FBTzBLLFFBQVF6SyxPQUFPO0FBQ3hDMEssWUFBUUUsT0FBTzdLLE9BQU8wSyxNQUFNO0VBQzdCO0VBRURJLEtBQUs5SyxPQUFPO0FBQ1YySyxZQUFRSSxVQUFVL0ssT0FBT0EsTUFBTTBLLE1BQU07QUFDckMsV0FBTzFLLE1BQU0wSztFQUNkO0VBS0RNLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsVUFBTXlLLFNBQVMxSyxNQUFNMEs7QUFDckJDLFlBQVFDLFVBQVU1SyxPQUFPMEssUUFBUXpLLE9BQU87QUFDeEN5SyxXQUFPekssVUFBVUE7RUFDbEI7RUFJRGdMLFlBQVlqTCxPQUFPO0FBQ2pCLFVBQU0wSyxTQUFTMUssTUFBTTBLO0FBQ3JCQSxXQUFPcEosWUFBVztBQUNsQm9KLFdBQU96RyxlQUFjO0VBQ3RCO0VBR0RpSCxXQUFXbEwsT0FBT21MLE1BQU07QUFDdEIsUUFBSSxDQUFDQSxLQUFLQyxRQUFRO0FBQ2hCcEwsWUFBTTBLLE9BQU9sQixZQUFZMkIsS0FBS0UsS0FBSztJQUNwQztFQUNGO0VBRURyRyxVQUFVO0lBQ1IvQyxTQUFTO0lBQ1RqQixVQUFVO0lBQ1ZrRCxPQUFPO0lBQ1BoRCxVQUFVO0lBQ1ZjLFNBQVM7SUFDVGYsUUFBUTtJQUdSZ0osUUFBUVIsR0FBR3RHLFlBQVl1SCxRQUFRO0FBQzdCLFlBQU1uTCxRQUFRNEQsV0FBVzdEO0FBQ3pCLFlBQU1nTSxLQUFLWixPQUFPMUs7QUFDbEIsVUFBSXNMLEdBQUdDLGlCQUFpQmhNLEtBQUssR0FBRztBQUM5QitMLFdBQUdFLEtBQUtqTSxLQUFLO0FBQ2I0RCxtQkFBVzRFLFNBQVM7YUFDZjtBQUNMdUQsV0FBR0csS0FBS2xNLEtBQUs7QUFDYjRELG1CQUFXNEUsU0FBUztNQUNyQjtJQUNGO0lBRURpQyxTQUFTO0lBQ1RELFNBQVM7SUFFVHRJLFFBQVE7TUFDTndELE9BQU8sQ0FBQy9FLFFBQVFBLElBQUlGLE1BQU1DLFFBQVFnRjtNQUNsQ3JHLFVBQVU7TUFDVitELFNBQVM7TUFZVGhCLGVBQWUzQixPQUFPO0FBQ3BCLGNBQU0wTCxXQUFXMUwsTUFBTThCLEtBQUs0SjtBQUM1QixjQUFNLEVBQUNqSyxRQUFRLEVBQUM1QyxlQUFld0gsWUFBWXRELFdBQVdrQyxPQUFBQSxRQUFPMEcsaUJBQWlCN0UsYUFBWSxFQUFDLElBQUk5RyxNQUFNMEssT0FBT3pLO0FBRTVHLGVBQU9ELE1BQU00TCx1QkFBc0IsRUFBR0MsSUFBSSxDQUFDQyxTQUFTO0FBQ2xELGdCQUFNQyxRQUFRRCxLQUFLRSxXQUFXQyxTQUFTcE4sZ0JBQWdCLElBQUl1QixNQUFTO0FBQ3BFLGdCQUFNbUcsY0FBY3dDLFVBQVVnRCxNQUFNeEYsV0FBVztBQUUvQyxpQkFBTztZQUNMaEQsTUFBTW1JLFNBQVNJLEtBQUt2TSxPQUFPMk07WUFDM0J2RyxXQUFXb0csTUFBTUk7WUFDakJoRSxXQUFXbEQ7WUFDWDhDLFFBQVEsQ0FBQytELEtBQUtNO1lBQ2R4RyxTQUFTbUcsTUFBTU07WUFDZnBHLFVBQVU4RixNQUFNTztZQUNoQnpHLGdCQUFnQmtHLE1BQU1RO1lBQ3RCekcsVUFBVWlHLE1BQU1TO1lBQ2hCbkgsWUFBWWtCLFlBQVl6RixRQUFReUYsWUFBWTFGLFVBQVU7WUFDdERrRixhQUFhZ0csTUFBTVU7WUFDbkJwRyxZQUFZQSxjQUFjMEYsTUFBTTFGO1lBQ2hDQyxVQUFVeUYsTUFBTXpGO1lBQ2hCdkQsV0FBV0EsYUFBYWdKLE1BQU1oSjtZQUM5QitELGNBQWM2RSxvQkFBb0I3RSxnQkFBZ0JpRixNQUFNakY7WUFHeER4SCxjQUFjd00sS0FBS3ZNOztXQUVwQixJQUFJO01BQ1I7SUFDRjtJQUVEcUosT0FBTztNQUNMM0QsT0FBTyxDQUFDL0UsUUFBUUEsSUFBSUYsTUFBTUMsUUFBUWdGO01BQ2xDaEQsU0FBUztNQUNUakIsVUFBVTtNQUNWdUMsTUFBTTtJQUNQO0VBQ0Y7RUFFRG1KLGFBQWE7SUFDWEMsYUFBYSxDQUFDQyxVQUFTLENBQUNBLE1BQUtDLFdBQVcsSUFBSTtJQUM1Q3BMLFFBQVE7TUFDTmtMLGFBQWEsQ0FBQ0MsVUFBUyxDQUFDO1FBQUM7UUFBa0I7UUFBVTtRQUFRRSxTQUFTRixLQUFJO0lBQzNFO0VBQ0Y7O0FDeHNCSSxJQUFNRyxRQUFOLGNBQW9CdE4sUUFBTztFQUloQ0MsWUFBWUMsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS0ssUUFBUUwsT0FBT0s7QUFDcEIsU0FBS0MsVUFBVU4sT0FBT007QUFDdEIsU0FBS0MsTUFBTVAsT0FBT087QUFDbEIsU0FBSzhNLFdBQVc1TTtBQUNoQixTQUFLSyxNQUFNTDtBQUNYLFNBQUtNLFNBQVNOO0FBQ2QsU0FBS08sT0FBT1A7QUFDWixTQUFLUSxRQUFRUjtBQUNiLFNBQUtVLFFBQVFWO0FBQ2IsU0FBS1MsU0FBU1Q7QUFDZCxTQUFLWSxXQUFXWjtBQUNoQixTQUFLYSxTQUFTYjtBQUNkLFNBQUtjLFdBQVdkO0VBQ2pCO0VBRURlLE9BQU9YLFVBQVVELFdBQVc7QUFDMUIsVUFBTXVFLE9BQU8sS0FBSzdFO0FBRWxCLFNBQUtVLE9BQU87QUFDWixTQUFLRixNQUFNO0FBRVgsUUFBSSxDQUFDcUUsS0FBSzdDLFNBQVM7QUFDakIsV0FBS25CLFFBQVEsS0FBS0QsU0FBUyxLQUFLRCxRQUFRLEtBQUtGLFNBQVM7QUFDdEQ7SUFDRDtBQUVELFNBQUtJLFFBQVEsS0FBS0YsUUFBUUo7QUFDMUIsU0FBS0ssU0FBUyxLQUFLSCxTQUFTSDtBQUU1QixVQUFNME0sWUFBWUMsUUFBUXBJLEtBQUt2QixJQUFJLElBQUl1QixLQUFLdkIsS0FBS0MsU0FBUztBQUMxRCxTQUFLd0osV0FBV2pFLFVBQVVqRSxLQUFLbkMsT0FBTztBQUN0QyxVQUFNd0ssV0FBV0YsWUFBWTlLLE9BQU8yQyxLQUFLMUMsSUFBSSxFQUFFUyxhQUFhLEtBQUttSyxTQUFTbk07QUFFMUUsUUFBSSxLQUFLVyxhQUFZLEdBQUk7QUFDdkIsV0FBS1gsU0FBU3NNO1dBQ1Q7QUFDTCxXQUFLck0sUUFBUXFNO0lBQ2Q7RUFDRjtFQUVEM0wsZUFBZTtBQUNiLFVBQU00TCxNQUFNLEtBQUtuTixRQUFRZTtBQUN6QixXQUFPb00sUUFBUSxTQUFTQSxRQUFRO0VBQ2pDO0VBRURDLFVBQVVDLFFBQVE7QUFDaEIsVUFBTSxFQUFDN00sS0FBS0UsTUFBTUQsUUFBUUUsT0FBT1gsUUFBTyxJQUFJO0FBQzVDLFVBQU1pRSxRQUFRakUsUUFBUWlFO0FBQ3RCLFFBQUlvQyxXQUFXO0FBQ2YsUUFBSTlGLFVBQVUrTSxRQUFRQztBQUV0QixRQUFJLEtBQUtoTSxhQUFZLEdBQUk7QUFDdkIrTCxlQUFTakosZUFBZUosT0FBT3ZELE1BQU1DLEtBQUs7QUFDMUM0TSxlQUFTL00sTUFBTTZNO0FBQ2Y5TSxpQkFBV0ksUUFBUUQ7V0FDZDtBQUNMLFVBQUlWLFFBQVFlLGFBQWEsUUFBUTtBQUMvQnVNLGlCQUFTNU0sT0FBTzJNO0FBQ2hCRSxpQkFBU2xKLGVBQWVKLE9BQU94RCxRQUFRRCxHQUFHO0FBQzFDNkYsbUJBQVdtSCxLQUFLO2FBQ1g7QUFDTEYsaUJBQVMzTSxRQUFRME07QUFDakJFLGlCQUFTbEosZUFBZUosT0FBT3pELEtBQUtDLE1BQU07QUFDMUM0RixtQkFBV21ILEtBQUs7TUFDakI7QUFDRGpOLGlCQUFXRSxTQUFTRDtJQUNyQjtBQUNELFdBQU87TUFBQzhNO01BQVFDO01BQVFoTjtNQUFVOEY7O0VBQ25DO0VBRUQ1QixPQUFPO0FBQ0wsVUFBTXhFLE1BQU0sS0FBS0E7QUFDakIsVUFBTTRFLE9BQU8sS0FBSzdFO0FBRWxCLFFBQUksQ0FBQzZFLEtBQUs3QyxTQUFTO0FBQ2pCO0lBQ0Q7QUFFRCxVQUFNeUwsV0FBV3ZMLE9BQU8yQyxLQUFLMUMsSUFBSTtBQUNqQyxVQUFNUyxhQUFhNkssU0FBUzdLO0FBQzVCLFVBQU15SyxTQUFTekssYUFBYSxJQUFJLEtBQUttSyxTQUFTdk07QUFDOUMsVUFBTSxFQUFDOE0sUUFBUUMsUUFBUWhOLFVBQVU4RixTQUFRLElBQUksS0FBSytHLFVBQVVDLE1BQU07QUFFbEV6RixlQUFXM0gsS0FBSzRFLEtBQUt2QixNQUFNLEdBQUcsR0FBR21LLFVBQVU7TUFDekN6SSxPQUFPSCxLQUFLRztNQUNaekU7TUFDQThGO01BQ0F2RCxXQUFXb0csbUJBQW1CckUsS0FBS1osS0FBSztNQUN4Q2xCLGNBQWM7TUFDZDJLLGFBQWE7UUFBQ0o7UUFBUUM7TUFBTztJQUM5QixDQUFBO0VBQ0Y7QUFDRjtBQUVELFNBQVNJLFlBQVk1TixPQUFPMkksV0FBVztBQUNyQyxRQUFNQyxRQUFRLElBQUltRSxNQUFNO0lBQ3RCN00sS0FBS0YsTUFBTUU7SUFDWEQsU0FBUzBJO0lBQ1QzSTtFQUNELENBQUE7QUFFRDJLLFVBQVFDLFVBQVU1SyxPQUFPNEksT0FBT0QsU0FBUztBQUN6Q2dDLFVBQVFFLE9BQU83SyxPQUFPNEksS0FBSztBQUMzQjVJLFFBQU02TixhQUFhakY7QUFDcEI7QUFFRCxJQUFBLGVBQWU7RUFDYjBCLElBQUk7RUFNSkMsVUFBVXdDO0VBRVZ2QyxNQUFNeEssT0FBT3lLLE9BQU94SyxTQUFTO0FBQzNCMk4sZ0JBQVk1TixPQUFPQyxPQUFPO0VBQzNCO0VBRUQ2SyxLQUFLOUssT0FBTztBQUNWLFVBQU02TixhQUFhN04sTUFBTTZOO0FBQ3pCbEQsWUFBUUksVUFBVS9LLE9BQU82TixVQUFVO0FBQ25DLFdBQU83TixNQUFNNk47RUFDZDtFQUVEN0MsYUFBYWhMLE9BQU95SyxPQUFPeEssU0FBUztBQUNsQyxVQUFNMkksUUFBUTVJLE1BQU02TjtBQUNwQmxELFlBQVFDLFVBQVU1SyxPQUFPNEksT0FBTzNJLE9BQU87QUFDdkMySSxVQUFNM0ksVUFBVUE7RUFDakI7RUFFRCtFLFVBQVU7SUFDUmQsT0FBTztJQUNQakMsU0FBUztJQUNURyxNQUFNO01BQ0puQixRQUFRO0lBQ1Q7SUFDREMsVUFBVTtJQUNWeUIsU0FBUztJQUNUM0IsVUFBVTtJQUNWdUMsTUFBTTtJQUNOdEMsUUFBUTtFQUNUO0VBRUQ2TSxlQUFlO0lBQ2I3SSxPQUFPO0VBQ1I7RUFFRHlILGFBQWE7SUFDWEMsYUFBYTtJQUNib0IsWUFBWTtFQUNiOztBQ2pLSCxJQUFNbEMsT0FBTSxvQkFBSW1DLFFBQU87QUFFdkIsSUFBQSxrQkFBZTtFQUNiMUQsSUFBSTtFQUVKRSxNQUFNeEssT0FBT3lLLE9BQU94SyxTQUFTO0FBQzNCLFVBQU0ySSxRQUFRLElBQUltRSxNQUFNO01BQ3RCN00sS0FBS0YsTUFBTUU7TUFDWEQ7TUFDQUQ7SUFDRCxDQUFBO0FBRUQySyxZQUFRQyxVQUFVNUssT0FBTzRJLE9BQU8zSSxPQUFPO0FBQ3ZDMEssWUFBUUUsT0FBTzdLLE9BQU80SSxLQUFLO0FBQzNCaUQsSUFBQUEsS0FBSW9DLElBQUlqTyxPQUFPNEksS0FBSztFQUNyQjtFQUVEa0MsS0FBSzlLLE9BQU87QUFDVjJLLFlBQVFJLFVBQVUvSyxPQUFPNkwsS0FBSXFDLElBQUlsTyxLQUFLLENBQUM7QUFDdkM2TCxJQUFBQSxLQUFJc0MsT0FBT25PLEtBQUs7RUFDakI7RUFFRGdMLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsVUFBTTJJLFFBQVFpRCxLQUFJcUMsSUFBSWxPLEtBQUs7QUFDM0IySyxZQUFRQyxVQUFVNUssT0FBTzRJLE9BQU8zSSxPQUFPO0FBQ3ZDMkksVUFBTTNJLFVBQVVBO0VBQ2pCO0VBRUQrRSxVQUFVO0lBQ1JkLE9BQU87SUFDUGpDLFNBQVM7SUFDVEcsTUFBTTtNQUNKbkIsUUFBUTtJQUNUO0lBQ0RDLFVBQVU7SUFDVnlCLFNBQVM7SUFDVDNCLFVBQVU7SUFDVnVDLE1BQU07SUFDTnRDLFFBQVE7RUFDVDtFQUVENk0sZUFBZTtJQUNiN0ksT0FBTztFQUNSO0VBRUR5SCxhQUFhO0lBQ1hDLGFBQWE7SUFDYm9CLFlBQVk7RUFDYjs7QUNuQ0gsSUFBTUssY0FBYztFQUlsQkMsUUFBUUMsT0FBTztBQUNiLFFBQUksQ0FBQ0EsTUFBTTlLLFFBQVE7QUFDakIsYUFBTztJQUNSO0FBRUQsUUFBSUosR0FBR21MO0FBQ1AsUUFBSTlKLElBQUk7QUFDUixRQUFJYyxJQUFJO0FBQ1IsUUFBSWlKLFFBQVE7QUFFWixTQUFLcEwsSUFBSSxHQUFHbUwsTUFBTUQsTUFBTTlLLFFBQVFKLElBQUltTCxLQUFLLEVBQUVuTCxHQUFHO0FBQzVDLFlBQU1xTCxLQUFLSCxNQUFNbEwsR0FBR3NMO0FBQ3BCLFVBQUlELE1BQU1BLEdBQUdFLFNBQVEsR0FBSTtBQUN2QixjQUFNdkIsTUFBTXFCLEdBQUdHLGdCQUFlO0FBQzlCbkssYUFBSzJJLElBQUkzSTtBQUNUYyxhQUFLNkgsSUFBSTdIO0FBQ1QsVUFBRWlKO01BQ0g7SUFDRjtBQUVELFdBQU87TUFDTC9KLEdBQUdBLElBQUkrSjtNQUNQakosR0FBR0EsSUFBSWlKOztFQUVWO0VBS0RLLFFBQVFQLE9BQU9RLGVBQWU7QUFDNUIsUUFBSSxDQUFDUixNQUFNOUssUUFBUTtBQUNqQixhQUFPO0lBQ1I7QUFFRCxRQUFJaUIsSUFBSXFLLGNBQWNySztBQUN0QixRQUFJYyxJQUFJdUosY0FBY3ZKO0FBQ3RCLFFBQUl3SixjQUFjQyxPQUFPQztBQUN6QixRQUFJN0wsR0FBR21MLEtBQUtXO0FBRVosU0FBSzlMLElBQUksR0FBR21MLE1BQU1ELE1BQU05SyxRQUFRSixJQUFJbUwsS0FBSyxFQUFFbkwsR0FBRztBQUM1QyxZQUFNcUwsS0FBS0gsTUFBTWxMLEdBQUdzTDtBQUNwQixVQUFJRCxNQUFNQSxHQUFHRSxTQUFRLEdBQUk7QUFDdkIsY0FBTVEsU0FBU1YsR0FBR1csZUFBYztBQUNoQyxjQUFNQyxJQUFJQyxzQkFBc0JSLGVBQWVLLE1BQU07QUFFckQsWUFBSUUsSUFBSU4sYUFBYTtBQUNuQkEsd0JBQWNNO0FBQ2RILDJCQUFpQlQ7UUFDbEI7TUFDRjtJQUNGO0FBRUQsUUFBSVMsZ0JBQWdCO0FBQ2xCLFlBQU1LLEtBQUtMLGVBQWVOLGdCQUFlO0FBQ3pDbkssVUFBSThLLEdBQUc5SztBQUNQYyxVQUFJZ0ssR0FBR2hLO0lBQ1I7QUFFRCxXQUFPO01BQ0xkO01BQ0FjOztFQUVIOztBQUlILFNBQVNpSyxhQUFhQyxNQUFNQyxRQUFRO0FBQ2xDLE1BQUlBLFFBQVE7QUFDVixRQUFJeEMsUUFBUXdDLE1BQU0sR0FBRztBQUVuQkMsWUFBTUMsVUFBVTVMLEtBQUs2TCxNQUFNSixNQUFNQyxNQUFNO1dBQ2xDO0FBQ0xELFdBQUt6TCxLQUFLMEwsTUFBTTtJQUNqQjtFQUNGO0FBRUQsU0FBT0Q7QUFDUjtBQVFELFNBQVNLLGNBQWNDLEtBQUs7QUFDMUIsT0FBSyxPQUFPQSxRQUFRLFlBQVlBLGVBQWVDLFdBQVdELElBQUlFLFFBQVEsSUFBSSxJQUFJLElBQUk7QUFDaEYsV0FBT0YsSUFBSUcsTUFBTSxJQUFJO0VBQ3RCO0FBQ0QsU0FBT0g7QUFDUjtBQVNELFNBQVNJLGtCQUFrQm5RLE9BQU82QixNQUFNO0FBQ3RDLFFBQU0sRUFBQzZNLFNBQVNwUCxjQUFjQyxNQUFLLElBQUlzQztBQUN2QyxRQUFNbUssYUFBYWhNLE1BQU1vUSxlQUFlOVEsWUFBWSxFQUFFME07QUFDdEQsUUFBTSxFQUFDRSxPQUFPbUUsTUFBSyxJQUFJckUsV0FBV3NFLGlCQUFpQi9RLEtBQUs7QUFFeEQsU0FBTztJQUNMUztJQUNBa007SUFDQXFFLFFBQVF2RSxXQUFXd0UsVUFBVWpSLEtBQUs7SUFDbENrUixLQUFLelEsTUFBTThCLEtBQUs0SixTQUFTcE0sY0FBY3dDLEtBQUt2QztJQUM1Q21SLGdCQUFnQkw7SUFDaEJNLFNBQVMzRSxXQUFXNEUsV0FBVTtJQUM5QkMsV0FBV3RSO0lBQ1hEO0lBQ0FvUDs7QUFFSDtBQUtELFNBQVNvQyxlQUFlQyxTQUFTOVEsU0FBUztBQUN4QyxRQUFNQyxNQUFNNlEsUUFBUS9RLE1BQU1FO0FBQzFCLFFBQU0sRUFBQzhRLE1BQU1DLFFBQVFySSxNQUFLLElBQUltSTtBQUM5QixRQUFNLEVBQUNuUyxVQUFVRCxVQUFTLElBQUlzQjtBQUM5QixRQUFNaVIsV0FBVy9PLE9BQU9sQyxRQUFRaVIsUUFBUTtBQUN4QyxRQUFNckksWUFBWTFHLE9BQU9sQyxRQUFRNEksU0FBUztBQUMxQyxRQUFNc0ksYUFBYWhQLE9BQU9sQyxRQUFRa1IsVUFBVTtBQUM1QyxRQUFNQyxpQkFBaUJ4SSxNQUFNcEY7QUFDN0IsUUFBTTZOLGtCQUFrQkosT0FBT3pOO0FBQy9CLFFBQU04TixvQkFBb0JOLEtBQUt4TjtBQUUvQixRQUFNYixVQUFVb0csVUFBVTlJLFFBQVEwQyxPQUFPO0FBQ3pDLE1BQUk5QixTQUFTOEIsUUFBUTlCO0FBQ3JCLE1BQUlDLFFBQVE7QUFHWixNQUFJeVEscUJBQXFCUCxLQUFLL0gsT0FBTyxDQUFDdUYsT0FBT2dELGFBQWFoRCxRQUFRZ0QsU0FBU0MsT0FBT2pPLFNBQVNnTyxTQUFTRSxNQUFNbE8sU0FBU2dPLFNBQVNHLE1BQU1uTyxRQUFRLENBQUM7QUFDM0krTix3QkFBc0JSLFFBQVFhLFdBQVdwTyxTQUFTdU4sUUFBUWMsVUFBVXJPO0FBRXBFLE1BQUk0TixnQkFBZ0I7QUFDbEJ2USxjQUFVdVEsaUJBQWlCdkksVUFBVWhHLGNBQ25DdU8saUJBQWlCLEtBQUtuUixRQUFRNlIsZUFDL0I3UixRQUFROFI7RUFDVjtBQUNELE1BQUlSLG9CQUFvQjtBQUV0QixVQUFNUyxpQkFBaUIvUixRQUFRZ1MsZ0JBQWdCblQsS0FBS0ksSUFBSVAsV0FBV3VTLFNBQVNyTyxVQUFVLElBQUlxTyxTQUFTck87QUFDbkdoQyxjQUFVeVEsb0JBQW9CVSxrQkFDNUJULHFCQUFxQkQscUJBQXFCSixTQUFTck8sY0FDbkQwTyxxQkFBcUIsS0FBS3RSLFFBQVFpUztFQUNyQztBQUNELE1BQUliLGlCQUFpQjtBQUNuQnhRLGNBQVVaLFFBQVFrUyxrQkFDakJkLGtCQUFrQkYsV0FBV3RPLGNBQzVCd08sa0JBQWtCLEtBQUtwUixRQUFRbVM7RUFDbEM7QUFHRCxNQUFJQyxlQUFlO0FBQ25CLFFBQU1DLGVBQWUsU0FBU3RLLE1BQU07QUFDbENsSCxZQUFRaEMsS0FBS0ksSUFBSTRCLE9BQU9aLElBQUlvRCxZQUFZMEUsSUFBSSxFQUFFbEgsUUFBUXVSLFlBQVk7O0FBR3BFblMsTUFBSXVGLEtBQUk7QUFFUnZGLE1BQUlrQyxPQUFPeUcsVUFBVXJHO0FBQ3JCK1AsT0FBS3hCLFFBQVFuSSxPQUFPMEosWUFBWTtBQUdoQ3BTLE1BQUlrQyxPQUFPOE8sU0FBUzFPO0FBQ3BCK1AsT0FBS3hCLFFBQVFhLFdBQVdZLE9BQU96QixRQUFRYyxTQUFTLEdBQUdTLFlBQVk7QUFHL0RELGlCQUFlcFMsUUFBUWdTLGdCQUFpQnJULFdBQVcsSUFBSXFCLFFBQVF3UyxhQUFjO0FBQzdFRixPQUFLdkIsTUFBTSxDQUFDUSxhQUFhO0FBQ3ZCZSxTQUFLZixTQUFTQyxRQUFRYSxZQUFZO0FBQ2xDQyxTQUFLZixTQUFTRSxPQUFPWSxZQUFZO0FBQ2pDQyxTQUFLZixTQUFTRyxPQUFPVyxZQUFZO0VBQ2xDLENBQUE7QUFHREQsaUJBQWU7QUFHZm5TLE1BQUlrQyxPQUFPK08sV0FBVzNPO0FBQ3RCK1AsT0FBS3hCLFFBQVFFLFFBQVFxQixZQUFZO0FBRWpDcFMsTUFBSXlILFFBQU87QUFHWDdHLFdBQVM2QixRQUFRN0I7QUFFakIsU0FBTztJQUFDQTtJQUFPRDs7QUFDaEI7QUFFRCxTQUFTNlIsZ0JBQWdCMVMsT0FBT3FDLE1BQU07QUFDcEMsUUFBTSxFQUFDa0QsR0FBRzFFLE9BQU0sSUFBSXdCO0FBRXBCLE1BQUlrRCxJQUFJMUUsU0FBUyxHQUFHO0FBQ2xCLFdBQU87YUFDRTBFLElBQUt2RixNQUFNYSxTQUFTQSxTQUFTLEdBQUk7QUFDMUMsV0FBTztFQUNSO0FBQ0QsU0FBTztBQUNSO0FBRUQsU0FBUzhSLG9CQUFvQkMsUUFBUTVTLE9BQU9DLFNBQVNvQyxNQUFNO0FBQ3pELFFBQU0sRUFBQ29DLEdBQUczRCxNQUFLLElBQUl1QjtBQUNuQixRQUFNd1EsUUFBUTVTLFFBQVE2UyxZQUFZN1MsUUFBUThTO0FBQzFDLE1BQUlILFdBQVcsVUFBVW5PLElBQUkzRCxRQUFRK1IsUUFBUTdTLE1BQU1jLE9BQU87QUFDeEQsV0FBTztFQUNSO0FBRUQsTUFBSThSLFdBQVcsV0FBV25PLElBQUkzRCxRQUFRK1IsUUFBUSxHQUFHO0FBQy9DLFdBQU87RUFDUjtBQUNGO0FBRUQsU0FBU0csZ0JBQWdCaFQsT0FBT0MsU0FBU29DLE1BQU00USxRQUFRO0FBQ3JELFFBQU0sRUFBQ3hPLEdBQUczRCxNQUFLLElBQUl1QjtBQUNuQixRQUFNLEVBQUN2QixPQUFPb1MsWUFBWUMsV0FBVyxFQUFDeFMsTUFBTUMsTUFBSyxFQUFDLElBQUlaO0FBQ3RELE1BQUk0UyxTQUFTO0FBRWIsTUFBSUssV0FBVyxVQUFVO0FBQ3ZCTCxhQUFTbk8sTUFBTTlELE9BQU9DLFNBQVMsSUFBSSxTQUFTO0VBQzdDLFdBQVU2RCxLQUFLM0QsUUFBUSxHQUFHO0FBQ3pCOFIsYUFBUzthQUNBbk8sS0FBS3lPLGFBQWFwUyxRQUFRLEdBQUc7QUFDdEM4UixhQUFTO0VBQ1Y7QUFFRCxNQUFJRCxvQkFBb0JDLFFBQVE1UyxPQUFPQyxTQUFTb0MsSUFBSSxHQUFHO0FBQ3JEdVEsYUFBUztFQUNWO0FBRUQsU0FBT0E7QUFDUjtBQUtELFNBQVNRLG1CQUFtQnBULE9BQU9DLFNBQVNvQyxNQUFNO0FBQ2hELFFBQU00USxTQUFTNVEsS0FBSzRRLFVBQVVoVCxRQUFRZ1QsVUFBVVAsZ0JBQWdCMVMsT0FBT3FDLElBQUk7QUFFM0UsU0FBTztJQUNMdVEsUUFBUXZRLEtBQUt1USxVQUFVM1MsUUFBUTJTLFVBQVVJLGdCQUFnQmhULE9BQU9DLFNBQVNvQyxNQUFNNFEsTUFBTTtJQUNyRkE7O0FBRUg7QUFFRCxTQUFTSSxPQUFPaFIsTUFBTXVRLFFBQVE7QUFDNUIsTUFBSSxFQUFDbk8sR0FBRzNELE1BQUssSUFBSXVCO0FBQ2pCLE1BQUl1USxXQUFXLFNBQVM7QUFDdEJuTyxTQUFLM0Q7RUFDTixXQUFVOFIsV0FBVyxVQUFVO0FBQzlCbk8sU0FBTTNELFFBQVE7RUFDZjtBQUNELFNBQU8yRDtBQUNSO0FBRUQsU0FBUzZPLE9BQU9qUixNQUFNNFEsUUFBUU0sZ0JBQWdCO0FBRTVDLE1BQUksRUFBQ2hPLEdBQUcxRSxPQUFNLElBQUl3QjtBQUNsQixNQUFJNFEsV0FBVyxPQUFPO0FBQ3BCMU4sU0FBS2dPO0VBQ04sV0FBVU4sV0FBVyxVQUFVO0FBQzlCMU4sU0FBSzFFLFNBQVMwUztTQUNUO0FBQ0xoTyxTQUFNMUUsU0FBUztFQUNoQjtBQUNELFNBQU8wRTtBQUNSO0FBS0QsU0FBU2lPLG1CQUFtQnZULFNBQVNvQyxNQUFNb1IsV0FBV3pULE9BQU87QUFDM0QsUUFBTSxFQUFDOFMsV0FBV0MsY0FBY1csYUFBWSxJQUFJelQ7QUFDaEQsUUFBTSxFQUFDMlMsUUFBUUssT0FBTSxJQUFJUTtBQUN6QixRQUFNRixpQkFBaUJULFlBQVlDO0FBQ25DLFFBQU0sRUFBQ1ksU0FBU0MsVUFBVUMsWUFBWUMsWUFBVyxJQUFJL00sY0FBYzJNLFlBQVk7QUFFL0UsTUFBSWpQLElBQUk0TyxPQUFPaFIsTUFBTXVRLE1BQU07QUFDM0IsUUFBTXJOLElBQUkrTixPQUFPalIsTUFBTTRRLFFBQVFNLGNBQWM7QUFFN0MsTUFBSU4sV0FBVyxVQUFVO0FBQ3ZCLFFBQUlMLFdBQVcsUUFBUTtBQUNyQm5PLFdBQUs4TztJQUNOLFdBQVVYLFdBQVcsU0FBUztBQUM3Qm5PLFdBQUs4TztJQUNOO0VBQ0YsV0FBVVgsV0FBVyxRQUFRO0FBQzVCbk8sU0FBSzNGLEtBQUtJLElBQUl5VSxTQUFTRSxVQUFVLElBQUlmO0VBQ3RDLFdBQVVGLFdBQVcsU0FBUztBQUM3Qm5PLFNBQUszRixLQUFLSSxJQUFJMFUsVUFBVUUsV0FBVyxJQUFJaEI7RUFDeEM7QUFFRCxTQUFPO0lBQ0xyTyxHQUFHc1AsWUFBWXRQLEdBQUcsR0FBR3pFLE1BQU1jLFFBQVF1QixLQUFLdkIsS0FBSztJQUM3Q3lFLEdBQUd3TyxZQUFZeE8sR0FBRyxHQUFHdkYsTUFBTWEsU0FBU3dCLEtBQUt4QixNQUFNOztBQUVsRDtBQUVELFNBQVNtVCxZQUFZakQsU0FBUzdNLE9BQU9qRSxTQUFTO0FBQzVDLFFBQU0wQyxVQUFVb0csVUFBVTlJLFFBQVEwQyxPQUFPO0FBRXpDLFNBQU91QixVQUFVLFdBQ2I2TSxRQUFRdE0sSUFBSXNNLFFBQVFqUSxRQUFRLElBQzVCb0QsVUFBVSxVQUNSNk0sUUFBUXRNLElBQUlzTSxRQUFRalEsUUFBUTZCLFFBQVEvQixRQUNwQ21RLFFBQVF0TSxJQUFJOUIsUUFBUWhDO0FBQzNCO0FBS0QsU0FBU3NULHdCQUF3QkMsV0FBVTtBQUN6QyxTQUFPMUUsYUFBYSxDQUFBLEdBQUlNLGNBQWNvRSxTQUFRLENBQUM7QUFDaEQ7QUFFRCxTQUFTQyxxQkFBcUJDLFFBQVFyRCxTQUFTc0QsY0FBYztBQUMzRCxTQUFPQyxjQUFjRixRQUFRO0lBQzNCckQ7SUFDQXNEO0lBQ0ExSyxNQUFNO0VBQ1AsQ0FBQTtBQUNGO0FBRUQsU0FBUzRLLGtCQUFrQkMsV0FBV0MsU0FBUztBQUM3QyxRQUFNQyxXQUFXRCxXQUFXQSxRQUFROUQsV0FBVzhELFFBQVE5RCxRQUFRSSxXQUFXMEQsUUFBUTlELFFBQVFJLFFBQVF5RDtBQUNsRyxTQUFPRSxXQUFXRixVQUFVRSxTQUFTQSxRQUFRLElBQUlGO0FBQ2xEO0FBRUQsSUFBTUcsbUJBQW1CO0VBRXZCQyxhQUFhQztFQUNiak0sTUFBTXlMLGNBQWM7QUFDbEIsUUFBSUEsYUFBYTdRLFNBQVMsR0FBRztBQUMzQixZQUFNM0IsT0FBT3dTLGFBQWE7QUFDMUIsWUFBTTVTLFNBQVNJLEtBQUs3QixNQUFNOEIsS0FBS0w7QUFDL0IsWUFBTXFULGFBQWFyVCxTQUFTQSxPQUFPK0IsU0FBUztBQUU1QyxVQUFJLFFBQVEsS0FBS3ZELFdBQVcsS0FBS0EsUUFBUThVLFNBQVMsV0FBVztBQUMzRCxlQUFPbFQsS0FBSzhPLFFBQVF6RSxTQUFTO01BQzlCLFdBQVVySyxLQUFLcUssT0FBTztBQUNyQixlQUFPckssS0FBS3FLO2lCQUNINEksYUFBYSxLQUFLalQsS0FBS2dQLFlBQVlpRSxZQUFZO0FBQ3hELGVBQU9yVCxPQUFPSSxLQUFLZ1A7TUFDcEI7SUFDRjtBQUVELFdBQU87RUFDUjtFQUNEbUUsWUFBWUg7RUFHWmpELFlBQVlpRDtFQUdaSSxhQUFhSjtFQUNiM0ksTUFBTWdKLGFBQWE7QUFDakIsUUFBSSxRQUFRLEtBQUtqVixXQUFXLEtBQUtBLFFBQVE4VSxTQUFTLFdBQVc7QUFDM0QsYUFBT0csWUFBWWhKLFFBQVEsT0FBT2dKLFlBQVl4RSxrQkFBa0J3RSxZQUFZeEU7SUFDN0U7QUFFRCxRQUFJeEUsUUFBUWdKLFlBQVl2RSxRQUFRekUsU0FBUztBQUV6QyxRQUFJQSxPQUFPO0FBQ1RBLGVBQVM7SUFDVjtBQUNELFVBQU1tRSxRQUFRNkUsWUFBWXhFO0FBQzFCLFFBQUksQ0FBQ3lFLGNBQWM5RSxLQUFLLEdBQUc7QUFDekJuRSxlQUFTbUU7SUFDVjtBQUNELFdBQU9uRTtFQUNSO0VBQ0RrSixXQUFXRixhQUFhO0FBQ3RCLFVBQU1wSixPQUFPb0osWUFBWWxWLE1BQU1vUSxlQUFlOEUsWUFBWTVWLFlBQVk7QUFDdEUsVUFBTVcsVUFBVTZMLEtBQUtFLFdBQVdDLFNBQVNpSixZQUFZckUsU0FBUztBQUM5RCxXQUFPO01BQ0xwRSxhQUFheE0sUUFBUXdNO01BQ3JCTixpQkFBaUJsTSxRQUFRa007TUFDekI1RixhQUFhdEcsUUFBUXNHO01BQ3JCK0YsWUFBWXJNLFFBQVFxTTtNQUNwQkMsa0JBQWtCdE0sUUFBUXNNO01BQzFCekYsY0FBYzs7RUFFakI7RUFDRHVPLGlCQUFpQjtBQUNmLFdBQU8sS0FBS3BWLFFBQVFxVjtFQUNyQjtFQUNEQyxnQkFBZ0JMLGFBQWE7QUFDM0IsVUFBTXBKLE9BQU9vSixZQUFZbFYsTUFBTW9RLGVBQWU4RSxZQUFZNVYsWUFBWTtBQUN0RSxVQUFNVyxVQUFVNkwsS0FBS0UsV0FBV0MsU0FBU2lKLFlBQVlyRSxTQUFTO0FBQzlELFdBQU87TUFDTHhLLFlBQVlwRyxRQUFRb0c7TUFDcEJDLFVBQVVyRyxRQUFRcUc7O0VBRXJCO0VBQ0RrUCxZQUFZWDtFQUdaaEQsV0FBV2dEO0VBR1hZLGNBQWNaO0VBQ2Q1RCxRQUFRNEQ7RUFDUmEsYUFBYWI7O0FBWWYsU0FBU2MsMkJBQTJCbkIsV0FBVzVILE9BQU0xTSxLQUFLMFYsS0FBSztBQUM3RCxRQUFNQyxTQUFTckIsVUFBVTVILE9BQU1sTCxLQUFLeEIsS0FBSzBWLEdBQUc7QUFFNUMsTUFBSSxPQUFPQyxXQUFXLGFBQWE7QUFDakMsV0FBT2xCLGlCQUFpQi9ILE9BQU1sTCxLQUFLeEIsS0FBSzBWLEdBQUc7RUFDNUM7QUFFRCxTQUFPQztBQUNSO0FBRU0sSUFBTUMsVUFBTixjQUFzQnJXLFFBQU87RUFPbENDLFlBQVlDLFFBQVE7QUFDbEIsVUFBSztBQUVMLFNBQUtvVyxVQUFVO0FBQ2YsU0FBS0MsVUFBVSxDQUFBO0FBQ2YsU0FBS0MsaUJBQWlCN1Y7QUFDdEIsU0FBSzhWLFFBQVE5VjtBQUNiLFNBQUsrVixvQkFBb0IvVjtBQUN6QixTQUFLZ1csZ0JBQWdCLENBQUE7QUFDckIsU0FBS0MsY0FBY2pXO0FBQ25CLFNBQUtrVyxXQUFXbFc7QUFDaEIsU0FBS0osUUFBUUwsT0FBT0s7QUFDcEIsU0FBS0MsVUFBVU4sT0FBT007QUFDdEIsU0FBS3NXLGFBQWFuVztBQUNsQixTQUFLd0ksUUFBUXhJO0FBQ2IsU0FBS3dSLGFBQWF4UjtBQUNsQixTQUFLNFEsT0FBTzVRO0FBQ1osU0FBS3lSLFlBQVl6UjtBQUNqQixTQUFLNlEsU0FBUzdRO0FBQ2QsU0FBS3dTLFNBQVN4UztBQUNkLFNBQUs2UyxTQUFTN1M7QUFDZCxTQUFLcUUsSUFBSXJFO0FBQ1QsU0FBS21GLElBQUluRjtBQUNULFNBQUtTLFNBQVNUO0FBQ2QsU0FBS1UsUUFBUVY7QUFDYixTQUFLb1csU0FBU3BXO0FBQ2QsU0FBS3FXLFNBQVNyVztBQUdkLFNBQUtzVyxjQUFjdFc7QUFDbkIsU0FBS3VXLG1CQUFtQnZXO0FBQ3hCLFNBQUt3VyxrQkFBa0J4VztFQUN4QjtFQUVEeVcsV0FBVzVXLFNBQVM7QUFDbEIsU0FBS0EsVUFBVUE7QUFDZixTQUFLa1csb0JBQW9CL1Y7QUFDekIsU0FBS2tXLFdBQVdsVztFQUNqQjtFQUtEMFcscUJBQXFCO0FBQ25CLFVBQU1DLFNBQVMsS0FBS1o7QUFFcEIsUUFBSVksUUFBUTtBQUNWLGFBQU9BO0lBQ1I7QUFFRCxVQUFNL1csUUFBUSxLQUFLQTtBQUNuQixVQUFNQyxVQUFVLEtBQUtBLFFBQVErVyxXQUFXLEtBQUtDLFdBQVUsQ0FBRTtBQUN6RCxVQUFNblMsT0FBTzdFLFFBQVFpWCxXQUFXbFgsTUFBTUMsUUFBUWtYLGFBQWFsWCxRQUFRbVg7QUFDbkUsVUFBTUEsYUFBYSxJQUFJQyxXQUFXLEtBQUtyWCxPQUFPOEUsSUFBSTtBQUNsRCxRQUFJQSxLQUFLd1MsWUFBWTtBQUNuQixXQUFLbkIsb0JBQW9CbFAsT0FBT3NRLE9BQU9ILFVBQVU7SUFDbEQ7QUFFRCxXQUFPQTtFQUNSO0VBS0RILGFBQWE7QUFDWCxXQUFPLEtBQUtYLGFBQ1osS0FBS0EsV0FBV25DLHFCQUFxQixLQUFLblUsTUFBTWlYLFdBQVUsR0FBSSxNQUFNLEtBQUtiLGFBQWE7RUFDdkY7RUFFRG9CLFNBQVMvQyxTQUFTeFUsU0FBUztBQUN6QixVQUFNLEVBQUN1VSxVQUFTLElBQUl2VTtBQUVwQixVQUFNMlUsY0FBY2UsMkJBQTJCbkIsV0FBVyxlQUFlLE1BQU1DLE9BQU87QUFDdEYsVUFBTTdMLFFBQVErTSwyQkFBMkJuQixXQUFXLFNBQVMsTUFBTUMsT0FBTztBQUMxRSxVQUFNTyxhQUFhVywyQkFBMkJuQixXQUFXLGNBQWMsTUFBTUMsT0FBTztBQUVwRixRQUFJL0MsUUFBUSxDQUFBO0FBQ1pBLFlBQVFsQyxhQUFha0MsT0FBTzVCLGNBQWM4RSxXQUFXLENBQUM7QUFDdERsRCxZQUFRbEMsYUFBYWtDLE9BQU81QixjQUFjbEgsS0FBSyxDQUFDO0FBQ2hEOEksWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBY2tGLFVBQVUsQ0FBQztBQUVyRCxXQUFPdEQ7RUFDUjtFQUVEK0YsY0FBY3BELGNBQWNwVSxTQUFTO0FBQ25DLFdBQU9nVSx3QkFDTDBCLDJCQUEyQjFWLFFBQVF1VSxXQUFXLGNBQWMsTUFBTUgsWUFBWSxDQUFDO0VBRWxGO0VBRURxRCxRQUFRckQsY0FBY3BVLFNBQVM7QUFDN0IsVUFBTSxFQUFDdVUsVUFBUyxJQUFJdlU7QUFDcEIsVUFBTTBYLFlBQVksQ0FBQTtBQUVsQnBGLFNBQUs4QixjQUFjLENBQUNJLFlBQVk7QUFDOUIsWUFBTWpELFdBQVc7UUFDZkMsUUFBUSxDQUFBO1FBQ1JDLE9BQU8sQ0FBQTtRQUNQQyxPQUFPLENBQUE7O0FBRVQsWUFBTWlHLFNBQVNyRCxrQkFBa0JDLFdBQVdDLE9BQU87QUFDbkRqRixtQkFBYWdDLFNBQVNDLFFBQVEzQixjQUFjNkYsMkJBQTJCaUMsUUFBUSxlQUFlLE1BQU1uRCxPQUFPLENBQUMsQ0FBQztBQUM3R2pGLG1CQUFhZ0MsU0FBU0UsT0FBT2lFLDJCQUEyQmlDLFFBQVEsU0FBUyxNQUFNbkQsT0FBTyxDQUFDO0FBQ3ZGakYsbUJBQWFnQyxTQUFTRyxPQUFPN0IsY0FBYzZGLDJCQUEyQmlDLFFBQVEsY0FBYyxNQUFNbkQsT0FBTyxDQUFDLENBQUM7QUFFM0drRCxnQkFBVTNULEtBQUt3TixRQUFRO0lBQ3hCLENBQUE7QUFFRCxXQUFPbUc7RUFDUjtFQUVERSxhQUFheEQsY0FBY3BVLFNBQVM7QUFDbEMsV0FBT2dVLHdCQUNMMEIsMkJBQTJCMVYsUUFBUXVVLFdBQVcsYUFBYSxNQUFNSCxZQUFZLENBQUM7RUFFakY7RUFHRHlELFVBQVV6RCxjQUFjcFUsU0FBUztBQUMvQixVQUFNLEVBQUN1VSxVQUFTLElBQUl2VTtBQUVwQixVQUFNd1YsZUFBZUUsMkJBQTJCbkIsV0FBVyxnQkFBZ0IsTUFBTUgsWUFBWTtBQUM3RixVQUFNcEQsU0FBUzBFLDJCQUEyQm5CLFdBQVcsVUFBVSxNQUFNSCxZQUFZO0FBQ2pGLFVBQU1xQixjQUFjQywyQkFBMkJuQixXQUFXLGVBQWUsTUFBTUgsWUFBWTtBQUUzRixRQUFJM0MsUUFBUSxDQUFBO0FBQ1pBLFlBQVFsQyxhQUFha0MsT0FBTzVCLGNBQWMyRixZQUFZLENBQUM7QUFDdkQvRCxZQUFRbEMsYUFBYWtDLE9BQU81QixjQUFjbUIsTUFBTSxDQUFDO0FBQ2pEUyxZQUFRbEMsYUFBYWtDLE9BQU81QixjQUFjNEYsV0FBVyxDQUFDO0FBRXRELFdBQU9oRTtFQUNSO0VBS0RxRyxhQUFhOVgsU0FBUztBQUNwQixVQUFNK1gsU0FBUyxLQUFLaEM7QUFDcEIsVUFBTWxVLE9BQU8sS0FBSzlCLE1BQU04QjtBQUN4QixVQUFNNFUsY0FBYyxDQUFBO0FBQ3BCLFVBQU1DLG1CQUFtQixDQUFBO0FBQ3pCLFVBQU1DLGtCQUFrQixDQUFBO0FBQ3hCLFFBQUl2QyxlQUFlLENBQUE7QUFDbkIsUUFBSWpSLEdBQUdtTDtBQUVQLFNBQUtuTCxJQUFJLEdBQUdtTCxNQUFNeUosT0FBT3hVLFFBQVFKLElBQUltTCxLQUFLLEVBQUVuTCxHQUFHO0FBQzdDaVIsbUJBQWFyUSxLQUFLbU0sa0JBQWtCLEtBQUtuUSxPQUFPZ1ksT0FBTzVVLEVBQUUsQ0FBQztJQUMzRDtBQUdELFFBQUluRCxRQUFRMkIsUUFBUTtBQUNsQnlTLHFCQUFlQSxhQUFhelMsT0FBTyxDQUFDOE0sU0FBU25QLE9BQU8wWSxVQUFVaFksUUFBUTJCLE9BQU84TSxTQUFTblAsT0FBTzBZLE9BQU9uVyxJQUFJLENBQUM7SUFDMUc7QUFHRCxRQUFJN0IsUUFBUWlZLFVBQVU7QUFDcEI3RCxxQkFBZUEsYUFBYXRTLEtBQUssQ0FBQzNDLEdBQUdDLE1BQU1ZLFFBQVFpWSxTQUFTOVksR0FBR0MsR0FBR3lDLElBQUksQ0FBQztJQUN4RTtBQUdEeVEsU0FBSzhCLGNBQWMsQ0FBQ0ksWUFBWTtBQUM5QixZQUFNbUQsU0FBU3JELGtCQUFrQnRVLFFBQVF1VSxXQUFXQyxPQUFPO0FBQzNEaUMsa0JBQVkxUyxLQUFLMlIsMkJBQTJCaUMsUUFBUSxjQUFjLE1BQU1uRCxPQUFPLENBQUM7QUFDaEZrQyx1QkFBaUIzUyxLQUFLMlIsMkJBQTJCaUMsUUFBUSxtQkFBbUIsTUFBTW5ELE9BQU8sQ0FBQztBQUMxRm1DLHNCQUFnQjVTLEtBQUsyUiwyQkFBMkJpQyxRQUFRLGtCQUFrQixNQUFNbkQsT0FBTyxDQUFDO0lBQ3pGLENBQUE7QUFFRCxTQUFLaUMsY0FBY0E7QUFDbkIsU0FBS0MsbUJBQW1CQTtBQUN4QixTQUFLQyxrQkFBa0JBO0FBQ3ZCLFNBQUtMLGFBQWFsQztBQUNsQixXQUFPQTtFQUNSO0VBRURsVCxPQUFPZ1gsU0FBUy9NLFFBQVE7QUFDdEIsVUFBTW5MLFVBQVUsS0FBS0EsUUFBUStXLFdBQVcsS0FBS0MsV0FBVSxDQUFFO0FBQ3pELFVBQU1lLFNBQVMsS0FBS2hDO0FBQ3BCLFFBQUlvQztBQUNKLFFBQUkvRCxlQUFlLENBQUE7QUFFbkIsUUFBSSxDQUFDMkQsT0FBT3hVLFFBQVE7QUFDbEIsVUFBSSxLQUFLdVMsWUFBWSxHQUFHO0FBQ3RCcUMscUJBQWE7VUFDWHJDLFNBQVM7O01BRVo7V0FDSTtBQUNMLFlBQU0vVSxXQUFXb04sWUFBWW5PLFFBQVFlLFVBQVVVLEtBQUssTUFBTXNXLFFBQVEsS0FBSy9CLGNBQWM7QUFDckY1QixxQkFBZSxLQUFLMEQsYUFBYTlYLE9BQU87QUFFeEMsV0FBSzJJLFFBQVEsS0FBSzRPLFNBQVNuRCxjQUFjcFUsT0FBTztBQUNoRCxXQUFLMlIsYUFBYSxLQUFLNkYsY0FBY3BELGNBQWNwVSxPQUFPO0FBQzFELFdBQUsrUSxPQUFPLEtBQUswRyxRQUFRckQsY0FBY3BVLE9BQU87QUFDOUMsV0FBSzRSLFlBQVksS0FBS2dHLGFBQWF4RCxjQUFjcFUsT0FBTztBQUN4RCxXQUFLZ1IsU0FBUyxLQUFLNkcsVUFBVXpELGNBQWNwVSxPQUFPO0FBRWxELFlBQU1vQyxPQUFPLEtBQUs2VCxRQUFRcEYsZUFBZSxNQUFNN1EsT0FBTztBQUN0RCxZQUFNb1ksa0JBQWtCcFIsT0FBT3FSLE9BQU8sQ0FBQSxHQUFJdFgsVUFBVXFCLElBQUk7QUFDeEQsWUFBTW9SLFlBQVlMLG1CQUFtQixLQUFLcFQsT0FBT0MsU0FBU29ZLGVBQWU7QUFDekUsWUFBTUUsa0JBQWtCL0UsbUJBQW1CdlQsU0FBU29ZLGlCQUFpQjVFLFdBQVcsS0FBS3pULEtBQUs7QUFFMUYsV0FBSzRTLFNBQVNhLFVBQVViO0FBQ3hCLFdBQUtLLFNBQVNRLFVBQVVSO0FBRXhCbUYsbUJBQWE7UUFDWHJDLFNBQVM7UUFDVHRSLEdBQUc4VCxnQkFBZ0I5VDtRQUNuQmMsR0FBR2dULGdCQUFnQmhUO1FBQ25CekUsT0FBT3VCLEtBQUt2QjtRQUNaRCxRQUFRd0IsS0FBS3hCO1FBQ2IyVixRQUFReFYsU0FBU3lEO1FBQ2pCZ1MsUUFBUXpWLFNBQVN1RTs7SUFFcEI7QUFFRCxTQUFLNlEsZ0JBQWdCL0I7QUFDckIsU0FBS2lDLFdBQVdsVztBQUVoQixRQUFJZ1ksWUFBWTtBQUNkLFdBQUt0QixtQkFBa0IsRUFBRzNWLE9BQU8sTUFBTWlYLFVBQVU7SUFDbEQ7QUFFRCxRQUFJRCxXQUFXbFksUUFBUXVZLFVBQVU7QUFDL0J2WSxjQUFRdVksU0FBUzlXLEtBQUssTUFBTTtRQUFDMUIsT0FBTyxLQUFLQTtRQUFPK1EsU0FBUztRQUFNM0Y7TUFBTyxDQUFBO0lBQ3ZFO0VBQ0Y7RUFFRHFOLFVBQVVDLGNBQWN4WSxLQUFLbUMsTUFBTXBDLFNBQVM7QUFDMUMsVUFBTTBZLGdCQUFnQixLQUFLQyxpQkFBaUJGLGNBQWNyVyxNQUFNcEMsT0FBTztBQUV2RUMsUUFBSTJZLE9BQU9GLGNBQWNHLElBQUlILGNBQWNJLEVBQUU7QUFDN0M3WSxRQUFJMlksT0FBT0YsY0FBY0ssSUFBSUwsY0FBY00sRUFBRTtBQUM3Qy9ZLFFBQUkyWSxPQUFPRixjQUFjTyxJQUFJUCxjQUFjUSxFQUFFO0VBQzlDO0VBRURQLGlCQUFpQkYsY0FBY3JXLE1BQU1wQyxTQUFTO0FBQzVDLFVBQU0sRUFBQzJTLFFBQVFLLE9BQU0sSUFBSTtBQUN6QixVQUFNLEVBQUNILFdBQVdZLGFBQVksSUFBSXpUO0FBQ2xDLFVBQU0sRUFBQzBULFNBQVNDLFVBQVVDLFlBQVlDLFlBQVcsSUFBSS9NLGNBQWMyTSxZQUFZO0FBQy9FLFVBQU0sRUFBQ2pQLEdBQUcyVSxLQUFLN1QsR0FBRzhULElBQUcsSUFBSVg7QUFDekIsVUFBTSxFQUFDNVgsT0FBT0QsT0FBTSxJQUFJd0I7QUFDeEIsUUFBSXlXLElBQUlFLElBQUlFLElBQUlILElBQUlFLElBQUlFO0FBRXhCLFFBQUlsRyxXQUFXLFVBQVU7QUFDdkJnRyxXQUFLSSxNQUFPeFksU0FBUztBQUVyQixVQUFJK1IsV0FBVyxRQUFRO0FBQ3JCa0csYUFBS007QUFDTEosYUFBS0YsS0FBS2hHO0FBR1ZpRyxhQUFLRSxLQUFLbkc7QUFDVnFHLGFBQUtGLEtBQUtuRzthQUNMO0FBQ0xnRyxhQUFLTSxNQUFNdFk7QUFDWGtZLGFBQUtGLEtBQUtoRztBQUdWaUcsYUFBS0UsS0FBS25HO0FBQ1ZxRyxhQUFLRixLQUFLbkc7TUFDWDtBQUVEb0csV0FBS0o7V0FDQTtBQUNMLFVBQUlsRyxXQUFXLFFBQVE7QUFDckJvRyxhQUFLSSxNQUFNdGEsS0FBS0ksSUFBSXlVLFNBQVNFLFVBQVUsSUFBS2Y7TUFDN0MsV0FBVUYsV0FBVyxTQUFTO0FBQzdCb0csYUFBS0ksTUFBTXRZLFFBQVFoQyxLQUFLSSxJQUFJMFUsVUFBVUUsV0FBVyxJQUFJaEI7YUFDaEQ7QUFDTGtHLGFBQUssS0FBS3hDO01BQ1g7QUFFRCxVQUFJdkQsV0FBVyxPQUFPO0FBQ3BCOEYsYUFBS007QUFDTEosYUFBS0YsS0FBS2pHO0FBR1ZnRyxhQUFLRSxLQUFLbEc7QUFDVm9HLGFBQUtGLEtBQUtsRzthQUNMO0FBQ0xpRyxhQUFLTSxNQUFNeFk7QUFDWG9ZLGFBQUtGLEtBQUtqRztBQUdWZ0csYUFBS0UsS0FBS2xHO0FBQ1ZvRyxhQUFLRixLQUFLbEc7TUFDWDtBQUNEcUcsV0FBS0o7SUFDTjtBQUNELFdBQU87TUFBQ0Q7TUFBSUU7TUFBSUU7TUFBSUg7TUFBSUU7TUFBSUU7O0VBQzdCO0VBRUQvVCxVQUFVa1UsSUFBSXBaLEtBQUtELFNBQVM7QUFDMUIsVUFBTTJJLFFBQVEsS0FBS0E7QUFDbkIsVUFBTXBGLFNBQVNvRixNQUFNcEY7QUFDckIsUUFBSXFGLFdBQVdpSixjQUFjMU87QUFFN0IsUUFBSUksUUFBUTtBQUNWLFlBQU1ZLFlBQVlDLGNBQWNwRSxRQUFRa0UsS0FBSyxLQUFLTSxHQUFHLEtBQUszRCxLQUFLO0FBRS9Ed1ksU0FBRzdVLElBQUl1UCxZQUFZLE1BQU0vVCxRQUFRc1osWUFBWXRaLE9BQU87QUFFcERDLFVBQUk2QyxZQUFZcUIsVUFBVXJCLFVBQVU5QyxRQUFRc1osVUFBVTtBQUN0RHJaLFVBQUk4QyxlQUFlO0FBRW5CNkYsa0JBQVkxRyxPQUFPbEMsUUFBUTRJLFNBQVM7QUFDcENpSixxQkFBZTdSLFFBQVE2UjtBQUV2QjVSLFVBQUl5RixZQUFZMUYsUUFBUXVaO0FBQ3hCdFosVUFBSWtDLE9BQU95RyxVQUFVckc7QUFFckIsV0FBS1ksSUFBSSxHQUFHQSxJQUFJSSxRQUFRLEVBQUVKLEdBQUc7QUFDM0JsRCxZQUFJMEgsU0FBU2dCLE1BQU14RixJQUFJZ0IsVUFBVUssRUFBRTZVLEdBQUc3VSxDQUFDLEdBQUc2VSxHQUFHL1QsSUFBSXNELFVBQVVoRyxhQUFhLENBQUM7QUFDekV5VyxXQUFHL1QsS0FBS3NELFVBQVVoRyxhQUFhaVA7QUFFL0IsWUFBSTFPLElBQUksTUFBTUksUUFBUTtBQUNwQjhWLGFBQUcvVCxLQUFLdEYsUUFBUThSLG9CQUFvQkQ7UUFDckM7TUFDRjtJQUNGO0VBQ0Y7RUFLRDJILGNBQWN2WixLQUFLb1osSUFBSWxXLEdBQUdnQixXQUFXbkUsU0FBUztBQUM1QyxVQUFNeVcsY0FBYyxLQUFLQSxZQUFZdFQ7QUFDckMsVUFBTW1TLGtCQUFrQixLQUFLb0IsaUJBQWlCdlQ7QUFDOUMsVUFBTSxFQUFDekUsV0FBV0MsVUFBVTZULFdBQVUsSUFBSXhTO0FBQzFDLFVBQU1pUixXQUFXL08sT0FBT2xDLFFBQVFpUixRQUFRO0FBQ3hDLFVBQU13SSxTQUFTMUYsWUFBWSxNQUFNLFFBQVEvVCxPQUFPO0FBQ2hELFVBQU0wWixZQUFZdlYsVUFBVUssRUFBRWlWLE1BQU07QUFDcEMsVUFBTUUsVUFBVWpiLFlBQVl1UyxTQUFTck8sY0FBY3FPLFNBQVNyTyxhQUFhbEUsYUFBYSxJQUFJO0FBQzFGLFVBQU1rYixTQUFTUCxHQUFHL1QsSUFBSXFVO0FBRXRCLFFBQUkzWixRQUFRcEIsZUFBZTtBQUN6QixZQUFNcUgsY0FBYztRQUNsQkMsUUFBUXJILEtBQUtDLElBQUlILFVBQVVELFNBQVMsSUFBSTtRQUN4QzBILFlBQVlrUCxnQkFBZ0JsUDtRQUM1QkMsVUFBVWlQLGdCQUFnQmpQO1FBQzFCQyxhQUFhOztBQUlmLFlBQU1DLFVBQVVwQyxVQUFVSSxXQUFXbVYsV0FBVy9hLFFBQVEsSUFBSUEsV0FBVztBQUN2RSxZQUFNOEgsVUFBVW1ULFNBQVNsYixZQUFZO0FBR3JDdUIsVUFBSTZGLGNBQWM5RixRQUFRNlo7QUFDMUI1WixVQUFJeUYsWUFBWTFGLFFBQVE2WjtBQUN4QkMsZ0JBQVU3WixLQUFLZ0csYUFBYU0sU0FBU0UsT0FBTztBQUc1Q3hHLFVBQUk2RixjQUFjMlEsWUFBWWpLO0FBQzlCdk0sVUFBSXlGLFlBQVkrUSxZQUFZdks7QUFDNUI0TixnQkFBVTdaLEtBQUtnRyxhQUFhTSxTQUFTRSxPQUFPO1dBQ3ZDO0FBRUx4RyxVQUFJbUYsWUFBWTJVLFNBQVN0RCxZQUFZblEsV0FBVyxJQUFJekgsS0FBS0ksSUFBRyxHQUFJK0gsT0FBT0MsT0FBT3dQLFlBQVluUSxXQUFXLENBQUMsSUFBS21RLFlBQVluUSxlQUFlO0FBQ3RJckcsVUFBSTZGLGNBQWMyUSxZQUFZaks7QUFDOUJ2TSxVQUFJOEYsWUFBWTBRLFlBQVlwSyxjQUFjLENBQUEsQ0FBRTtBQUM1Q3BNLFVBQUkyRixpQkFBaUI2USxZQUFZbkssb0JBQW9CO0FBR3JELFlBQU0wTixTQUFTN1YsVUFBVUksV0FBV21WLFdBQVcvYSxXQUFXNlQsVUFBVTtBQUNwRSxZQUFNeUgsU0FBUzlWLFVBQVVJLFdBQVdKLFVBQVVxQyxNQUFNa1QsV0FBVyxDQUFDLEdBQUcvYSxXQUFXNlQsYUFBYSxDQUFDO0FBQzVGLFlBQU0zTCxlQUFlQyxjQUFjMlAsWUFBWTVQLFlBQVk7QUFFM0QsVUFBSUcsT0FBT0MsT0FBT0osWUFBWSxFQUFFSyxLQUFLQyxDQUFBQSxNQUFLQSxNQUFNLENBQUMsR0FBRztBQUNsRGxILFlBQUk4RyxVQUFTO0FBQ2I5RyxZQUFJeUYsWUFBWTFGLFFBQVE2WjtBQUN4QnpTLDJCQUFtQm5ILEtBQUs7VUFDdEJ1RSxHQUFHd1Y7VUFDSDFVLEdBQUdzVTtVQUNIdlMsR0FBRzFJO1VBQ0gySSxHQUFHNUk7VUFDSHdILFFBQVFXO1FBQ1QsQ0FBQTtBQUNENUcsWUFBSXVILEtBQUk7QUFDUnZILFlBQUl3SCxPQUFNO0FBR1Z4SCxZQUFJeUYsWUFBWStRLFlBQVl2SztBQUM1QmpNLFlBQUk4RyxVQUFTO0FBQ2JLLDJCQUFtQm5ILEtBQUs7VUFDdEJ1RSxHQUFHeVY7VUFDSDNVLEdBQUdzVSxTQUFTO1VBQ1p2UyxHQUFHMUksV0FBVztVQUNkMkksR0FBRzVJLFlBQVk7VUFDZndILFFBQVFXO1FBQ1QsQ0FBQTtBQUNENUcsWUFBSXVILEtBQUk7YUFDSDtBQUVMdkgsWUFBSXlGLFlBQVkxRixRQUFRNlo7QUFDeEI1WixZQUFJaWEsU0FBU0YsUUFBUUosUUFBUWpiLFVBQVVELFNBQVM7QUFDaER1QixZQUFJa2EsV0FBV0gsUUFBUUosUUFBUWpiLFVBQVVELFNBQVM7QUFFbER1QixZQUFJeUYsWUFBWStRLFlBQVl2SztBQUM1QmpNLFlBQUlpYSxTQUFTRCxRQUFRTCxTQUFTLEdBQUdqYixXQUFXLEdBQUdELFlBQVksQ0FBQztNQUM3RDtJQUNGO0FBR0R1QixRQUFJeUYsWUFBWSxLQUFLaVIsZ0JBQWdCeFQ7RUFDdEM7RUFFRGlYLFNBQVNmLElBQUlwWixLQUFLRCxTQUFTO0FBQ3pCLFVBQU0sRUFBQytRLEtBQUksSUFBSTtBQUNmLFVBQU0sRUFBQ2tCLGFBQWFvSSxXQUFXckksZUFBZXRULFdBQVdDLFVBQVU2VCxXQUFVLElBQUl4UztBQUNqRixVQUFNaVIsV0FBVy9PLE9BQU9sQyxRQUFRaVIsUUFBUTtBQUN4QyxRQUFJYyxpQkFBaUJkLFNBQVNyTztBQUM5QixRQUFJMFgsZUFBZTtBQUVuQixVQUFNblcsWUFBWUMsY0FBY3BFLFFBQVFrRSxLQUFLLEtBQUtNLEdBQUcsS0FBSzNELEtBQUs7QUFFL0QsVUFBTTBaLGlCQUFpQixTQUFTeFMsTUFBTTtBQUNwQzlILFVBQUkwSCxTQUFTSSxNQUFNNUQsVUFBVUssRUFBRTZVLEdBQUc3VSxJQUFJOFYsWUFBWSxHQUFHakIsR0FBRy9ULElBQUl5TSxpQkFBaUIsQ0FBQztBQUM5RXNILFNBQUcvVCxLQUFLeU0saUJBQWlCRTs7QUFHM0IsVUFBTXVJLDBCQUEwQnJXLFVBQVVyQixVQUFVdVgsU0FBUztBQUM3RCxRQUFJOUksVUFBVWtKLFdBQVdoSixPQUFPdE8sR0FBR3VYLEdBQUdDLE1BQU1DO0FBRTVDM2EsUUFBSTZDLFlBQVl1WDtBQUNoQnBhLFFBQUk4QyxlQUFlO0FBQ25COUMsUUFBSWtDLE9BQU84TyxTQUFTMU87QUFFcEI4VyxPQUFHN1UsSUFBSXVQLFlBQVksTUFBTXlHLHlCQUF5QnhhLE9BQU87QUFHekRDLFFBQUl5RixZQUFZMUYsUUFBUXFWO0FBQ3hCL0MsU0FBSyxLQUFLWCxZQUFZNEksY0FBYztBQUVwQ0QsbUJBQWV0SSxpQkFBaUJ3SSw0QkFBNEIsVUFDeERILGNBQWMsV0FBWTFiLFdBQVcsSUFBSTZULGFBQWU3VCxXQUFXLElBQUk2VCxhQUN2RTtBQUdKLFNBQUtyUCxJQUFJLEdBQUd3WCxPQUFPNUosS0FBS3hOLFFBQVFKLElBQUl3WCxNQUFNLEVBQUV4WCxHQUFHO0FBQzdDb08saUJBQVdSLEtBQUs1TjtBQUNoQnNYLGtCQUFZLEtBQUs5RCxnQkFBZ0J4VDtBQUVqQ2xELFVBQUl5RixZQUFZK1U7QUFDaEJuSSxXQUFLZixTQUFTQyxRQUFRK0ksY0FBYztBQUVwQzlJLGNBQVFGLFNBQVNFO0FBRWpCLFVBQUlPLGlCQUFpQlAsTUFBTWxPLFFBQVE7QUFDakMsYUFBS2lXLGNBQWN2WixLQUFLb1osSUFBSWxXLEdBQUdnQixXQUFXbkUsT0FBTztBQUNqRCtSLHlCQUFpQmxULEtBQUtJLElBQUlnUyxTQUFTck8sWUFBWWxFLFNBQVM7TUFDekQ7QUFFRCxXQUFLZ2MsSUFBSSxHQUFHRSxPQUFPbkosTUFBTWxPLFFBQVFtWCxJQUFJRSxNQUFNLEVBQUVGLEdBQUc7QUFDOUNILHVCQUFlOUksTUFBTWlKLEVBQUU7QUFFdkIzSSx5QkFBaUJkLFNBQVNyTztNQUMzQjtBQUVEMFAsV0FBS2YsU0FBU0csT0FBTzZJLGNBQWM7SUFDcEM7QUFHREQsbUJBQWU7QUFDZnZJLHFCQUFpQmQsU0FBU3JPO0FBRzFCMFAsU0FBSyxLQUFLVixXQUFXMkksY0FBYztBQUNuQ2xCLE9BQUcvVCxLQUFLMk07RUFDVDtFQUVENEksV0FBV3hCLElBQUlwWixLQUFLRCxTQUFTO0FBQzNCLFVBQU1nUixTQUFTLEtBQUtBO0FBQ3BCLFVBQU16TixTQUFTeU4sT0FBT3pOO0FBQ3RCLFFBQUkyTixZQUFZL047QUFFaEIsUUFBSUksUUFBUTtBQUNWLFlBQU1ZLFlBQVlDLGNBQWNwRSxRQUFRa0UsS0FBSyxLQUFLTSxHQUFHLEtBQUszRCxLQUFLO0FBRS9Ed1ksU0FBRzdVLElBQUl1UCxZQUFZLE1BQU0vVCxRQUFROGEsYUFBYTlhLE9BQU87QUFDckRxWixTQUFHL1QsS0FBS3RGLFFBQVFrUztBQUVoQmpTLFVBQUk2QyxZQUFZcUIsVUFBVXJCLFVBQVU5QyxRQUFROGEsV0FBVztBQUN2RDdhLFVBQUk4QyxlQUFlO0FBRW5CbU8sbUJBQWFoUCxPQUFPbEMsUUFBUWtSLFVBQVU7QUFFdENqUixVQUFJeUYsWUFBWTFGLFFBQVErYTtBQUN4QjlhLFVBQUlrQyxPQUFPK08sV0FBVzNPO0FBRXRCLFdBQUtZLElBQUksR0FBR0EsSUFBSUksUUFBUSxFQUFFSixHQUFHO0FBQzNCbEQsWUFBSTBILFNBQVNxSixPQUFPN04sSUFBSWdCLFVBQVVLLEVBQUU2VSxHQUFHN1UsQ0FBQyxHQUFHNlUsR0FBRy9ULElBQUk0TCxXQUFXdE8sYUFBYSxDQUFDO0FBQzNFeVcsV0FBRy9ULEtBQUs0TCxXQUFXdE8sYUFBYTVDLFFBQVFtUztNQUN6QztJQUNGO0VBQ0Y7RUFFRDZJLGVBQWUzQixJQUFJcFosS0FBS2diLGFBQWFqYixTQUFTO0FBQzVDLFVBQU0sRUFBQzJTLFFBQVFLLE9BQU0sSUFBSTtBQUN6QixVQUFNLEVBQUN4TyxHQUFHYyxFQUFDLElBQUkrVDtBQUNmLFVBQU0sRUFBQ3hZLE9BQU9ELE9BQU0sSUFBSXFhO0FBQ3hCLFVBQU0sRUFBQ3ZILFNBQVNDLFVBQVVDLFlBQVlDLFlBQVcsSUFBSS9NLGNBQWM5RyxRQUFReVQsWUFBWTtBQUV2RnhULFFBQUl5RixZQUFZMUYsUUFBUWtNO0FBQ3hCak0sUUFBSTZGLGNBQWM5RixRQUFRd007QUFDMUJ2TSxRQUFJbUYsWUFBWXBGLFFBQVFzRztBQUV4QnJHLFFBQUk4RyxVQUFTO0FBQ2I5RyxRQUFJaWIsT0FBTzFXLElBQUlrUCxTQUFTcE8sQ0FBQztBQUN6QixRQUFJME4sV0FBVyxPQUFPO0FBQ3BCLFdBQUt3RixVQUFVYSxJQUFJcFosS0FBS2diLGFBQWFqYixPQUFPO0lBQzdDO0FBQ0RDLFFBQUkyWSxPQUFPcFUsSUFBSTNELFFBQVE4UyxVQUFVck8sQ0FBQztBQUNsQ3JGLFFBQUlrYixpQkFBaUIzVyxJQUFJM0QsT0FBT3lFLEdBQUdkLElBQUkzRCxPQUFPeUUsSUFBSXFPLFFBQVE7QUFDMUQsUUFBSVgsV0FBVyxZQUFZTCxXQUFXLFNBQVM7QUFDN0MsV0FBSzZGLFVBQVVhLElBQUlwWixLQUFLZ2IsYUFBYWpiLE9BQU87SUFDN0M7QUFDREMsUUFBSTJZLE9BQU9wVSxJQUFJM0QsT0FBT3lFLElBQUkxRSxTQUFTaVQsV0FBVztBQUM5QzVULFFBQUlrYixpQkFBaUIzVyxJQUFJM0QsT0FBT3lFLElBQUkxRSxRQUFRNEQsSUFBSTNELFFBQVFnVCxhQUFhdk8sSUFBSTFFLE1BQU07QUFDL0UsUUFBSW9TLFdBQVcsVUFBVTtBQUN2QixXQUFLd0YsVUFBVWEsSUFBSXBaLEtBQUtnYixhQUFhamIsT0FBTztJQUM3QztBQUNEQyxRQUFJMlksT0FBT3BVLElBQUlvUCxZQUFZdE8sSUFBSTFFLE1BQU07QUFDckNYLFFBQUlrYixpQkFBaUIzVyxHQUFHYyxJQUFJMUUsUUFBUTRELEdBQUdjLElBQUkxRSxTQUFTZ1QsVUFBVTtBQUM5RCxRQUFJWixXQUFXLFlBQVlMLFdBQVcsUUFBUTtBQUM1QyxXQUFLNkYsVUFBVWEsSUFBSXBaLEtBQUtnYixhQUFhamIsT0FBTztJQUM3QztBQUNEQyxRQUFJMlksT0FBT3BVLEdBQUdjLElBQUlvTyxPQUFPO0FBQ3pCelQsUUFBSWtiLGlCQUFpQjNXLEdBQUdjLEdBQUdkLElBQUlrUCxTQUFTcE8sQ0FBQztBQUN6Q3JGLFFBQUltYixVQUFTO0FBRWJuYixRQUFJdUgsS0FBSTtBQUVSLFFBQUl4SCxRQUFRc0csY0FBYyxHQUFHO0FBQzNCckcsVUFBSXdILE9BQU07SUFDWDtFQUNGO0VBTUQ0VCx1QkFBdUJyYixTQUFTO0FBQzlCLFVBQU1ELFFBQVEsS0FBS0E7QUFDbkIsVUFBTXViLFFBQVEsS0FBS2xGO0FBQ25CLFVBQU1tRixRQUFRRCxTQUFTQSxNQUFNOVc7QUFDN0IsVUFBTWdYLFFBQVFGLFNBQVNBLE1BQU1oVztBQUM3QixRQUFJaVcsU0FBU0MsT0FBTztBQUNsQixZQUFNemEsV0FBV29OLFlBQVluTyxRQUFRZSxVQUFVVSxLQUFLLE1BQU0sS0FBS3NVLFNBQVMsS0FBS0MsY0FBYztBQUMzRixVQUFJLENBQUNqVixVQUFVO0FBQ2I7TUFDRDtBQUNELFlBQU1xQixPQUFPLEtBQUs2VCxRQUFRcEYsZUFBZSxNQUFNN1EsT0FBTztBQUN0RCxZQUFNb1ksa0JBQWtCcFIsT0FBT3FSLE9BQU8sQ0FBQSxHQUFJdFgsVUFBVSxLQUFLa1YsS0FBSztBQUM5RCxZQUFNekMsWUFBWUwsbUJBQW1CcFQsT0FBT0MsU0FBU29ZLGVBQWU7QUFDcEUsWUFBTXFELFFBQVFsSSxtQkFBbUJ2VCxTQUFTb1ksaUJBQWlCNUUsV0FBV3pULEtBQUs7QUFDM0UsVUFBSXdiLE1BQU1HLFFBQVFELE1BQU1qWCxLQUFLZ1gsTUFBTUUsUUFBUUQsTUFBTW5XLEdBQUc7QUFDbEQsYUFBS3FOLFNBQVNhLFVBQVViO0FBQ3hCLGFBQUtLLFNBQVNRLFVBQVVSO0FBQ3hCLGFBQUtuUyxRQUFRdUIsS0FBS3ZCO0FBQ2xCLGFBQUtELFNBQVN3QixLQUFLeEI7QUFDbkIsYUFBSzJWLFNBQVN4VixTQUFTeUQ7QUFDdkIsYUFBS2dTLFNBQVN6VixTQUFTdUU7QUFDdkIsYUFBS3VSLG1CQUFrQixFQUFHM1YsT0FBTyxNQUFNdWEsS0FBSztNQUM3QztJQUNGO0VBQ0Y7RUFNREUsY0FBYztBQUNaLFdBQU8sQ0FBQyxDQUFDLEtBQUs3RjtFQUNmO0VBRURyUixLQUFLeEUsS0FBSztBQUNSLFVBQU1ELFVBQVUsS0FBS0EsUUFBUStXLFdBQVcsS0FBS0MsV0FBVSxDQUFFO0FBQ3pELFFBQUlsQixVQUFVLEtBQUtBO0FBRW5CLFFBQUksQ0FBQ0EsU0FBUztBQUNaO0lBQ0Q7QUFFRCxTQUFLdUYsdUJBQXVCcmIsT0FBTztBQUVuQyxVQUFNaWIsY0FBYztNQUNsQnBhLE9BQU8sS0FBS0E7TUFDWkQsUUFBUSxLQUFLQTs7QUFFZixVQUFNeVksS0FBSztNQUNUN1UsR0FBRyxLQUFLQTtNQUNSYyxHQUFHLEtBQUtBOztBQUlWd1EsY0FBVWpYLEtBQUsrYyxJQUFJOUYsT0FBTyxJQUFJLE9BQU8sSUFBSUE7QUFFekMsVUFBTXBULFVBQVVvRyxVQUFVOUksUUFBUTBDLE9BQU87QUFHekMsVUFBTW1aLG9CQUFvQixLQUFLbFQsTUFBTXBGLFVBQVUsS0FBS29PLFdBQVdwTyxVQUFVLEtBQUt3TixLQUFLeE4sVUFBVSxLQUFLcU8sVUFBVXJPLFVBQVUsS0FBS3lOLE9BQU96TjtBQUVsSSxRQUFJdkQsUUFBUWlYLFdBQVc0RSxtQkFBbUI7QUFDeEM1YixVQUFJdUYsS0FBSTtBQUNSdkYsVUFBSTZiLGNBQWNoRztBQUdsQixXQUFLa0YsZUFBZTNCLElBQUlwWixLQUFLZ2IsYUFBYWpiLE9BQU87QUFFakRnSSw0QkFBc0IvSCxLQUFLRCxRQUFRaUksYUFBYTtBQUVoRG9SLFNBQUcvVCxLQUFLNUMsUUFBUWxDO0FBR2hCLFdBQUsyRSxVQUFVa1UsSUFBSXBaLEtBQUtELE9BQU87QUFHL0IsV0FBS29hLFNBQVNmLElBQUlwWixLQUFLRCxPQUFPO0FBRzlCLFdBQUs2YSxXQUFXeEIsSUFBSXBaLEtBQUtELE9BQU87QUFFaEN5SSwyQkFBcUJ4SSxLQUFLRCxRQUFRaUksYUFBYTtBQUUvQ2hJLFVBQUl5SCxRQUFPO0lBQ1o7RUFDRjtFQU1EcVUsb0JBQW9CO0FBQ2xCLFdBQU8sS0FBS2hHLFdBQVcsQ0FBQTtFQUN4QjtFQU9EaUcsa0JBQWtCQyxnQkFBZ0JwTixlQUFlO0FBQy9DLFVBQU1xTixhQUFhLEtBQUtuRztBQUN4QixVQUFNZ0MsU0FBU2tFLGVBQWVyUSxJQUFJLENBQUMsRUFBQ3ZNLGNBQWNDLE1BQUssTUFBTTtBQUMzRCxZQUFNdU0sT0FBTyxLQUFLOUwsTUFBTW9RLGVBQWU5USxZQUFZO0FBRW5ELFVBQUksQ0FBQ3dNLE1BQU07QUFDVCxjQUFNLElBQUlzUSxNQUFNLG9DQUFvQzljLFlBQVk7TUFDakU7QUFFRCxhQUFPO1FBQ0xBO1FBQ0FvUCxTQUFTNUMsS0FBS2hLLEtBQUt2QztRQUNuQkE7O0lBRUgsQ0FBQTtBQUNELFVBQU00WSxVQUFVLENBQUNrRSxlQUFlRixZQUFZbkUsTUFBTTtBQUNsRCxVQUFNc0Usa0JBQWtCLEtBQUtDLGlCQUFpQnZFLFFBQVFsSixhQUFhO0FBRW5FLFFBQUlxSixXQUFXbUUsaUJBQWlCO0FBQzlCLFdBQUt0RyxVQUFVZ0M7QUFDZixXQUFLL0IsaUJBQWlCbkg7QUFDdEIsV0FBSzBOLHNCQUFzQjtBQUMzQixXQUFLcmIsT0FBTyxJQUFJO0lBQ2pCO0VBQ0Y7RUFTRHFJLFlBQVlDLEdBQUcyQixRQUFRcVIsY0FBYyxNQUFNO0FBQ3pDLFFBQUlyUixVQUFVLEtBQUtvUixxQkFBcUI7QUFDdEMsYUFBTztJQUNSO0FBQ0QsU0FBS0Esc0JBQXNCO0FBRTNCLFVBQU12YyxVQUFVLEtBQUtBO0FBQ3JCLFVBQU1rYyxhQUFhLEtBQUtuRyxXQUFXLENBQUE7QUFDbkMsVUFBTWdDLFNBQVMsS0FBSzBFLG1CQUFtQmpULEdBQUcwUyxZQUFZL1EsUUFBUXFSLFdBQVc7QUFLekUsVUFBTUgsa0JBQWtCLEtBQUtDLGlCQUFpQnZFLFFBQVF2TyxDQUFDO0FBR3ZELFVBQU0wTyxVQUFVL00sVUFBVSxDQUFDaVIsZUFBZXJFLFFBQVFtRSxVQUFVLEtBQUtHO0FBR2pFLFFBQUluRSxTQUFTO0FBQ1gsV0FBS25DLFVBQVVnQztBQUVmLFVBQUkvWCxRQUFRaVgsV0FBV2pYLFFBQVF1WSxVQUFVO0FBQ3ZDLGFBQUt2QyxpQkFBaUI7VUFDcEJ4UixHQUFHZ0YsRUFBRWhGO1VBQ0xjLEdBQUdrRSxFQUFFbEU7O0FBR1AsYUFBS3BFLE9BQU8sTUFBTWlLLE1BQU07TUFDekI7SUFDRjtBQUVELFdBQU8rTTtFQUNSO0VBV0R1RSxtQkFBbUJqVCxHQUFHMFMsWUFBWS9RLFFBQVFxUixhQUFhO0FBQ3JELFVBQU14YyxVQUFVLEtBQUtBO0FBRXJCLFFBQUl3SixFQUFFRSxTQUFTLFlBQVk7QUFDekIsYUFBTyxDQUFBO0lBQ1I7QUFFRCxRQUFJLENBQUM4UyxhQUFhO0FBRWhCLGFBQU9OO0lBQ1I7QUFHRCxVQUFNbkUsU0FBUyxLQUFLaFksTUFBTTJjLDBCQUEwQmxULEdBQUd4SixRQUFROFUsTUFBTTlVLFNBQVNtTCxNQUFNO0FBRXBGLFFBQUluTCxRQUFRK0IsU0FBUztBQUNuQmdXLGFBQU9oVyxRQUFPO0lBQ2Y7QUFFRCxXQUFPZ1c7RUFDUjtFQVNEdUUsaUJBQWlCdkUsUUFBUXZPLEdBQUc7QUFDMUIsVUFBTSxFQUFDK00sUUFBUUMsUUFBUXhXLFFBQU8sSUFBSTtBQUNsQyxVQUFNZSxXQUFXb04sWUFBWW5PLFFBQVFlLFVBQVVVLEtBQUssTUFBTXNXLFFBQVF2TyxDQUFDO0FBQ25FLFdBQU96SSxhQUFhLFVBQVV3VixXQUFXeFYsU0FBU3lELEtBQUtnUyxXQUFXelYsU0FBU3VFO0VBQzVFO0FBQ0Y7QUFudkJDLGNBTFd1USxTQUtKMUgsZUFBY0E7QUFxdkJ2QixJQUFBLGlCQUFlO0VBQ2I5RCxJQUFJO0VBQ0pDLFVBQVV1TDtFQUNWMUg7RUFFQXdPLFVBQVU1YyxPQUFPeUssT0FBT3hLLFNBQVM7QUFDL0IsUUFBSUEsU0FBUztBQUNYRCxZQUFNK1EsVUFBVSxJQUFJK0UsUUFBUTtRQUFDOVY7UUFBT0M7TUFBUSxDQUFBO0lBQzdDO0VBQ0Y7RUFFRCtLLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsUUFBSUQsTUFBTStRLFNBQVM7QUFDakIvUSxZQUFNK1EsUUFBUThGLFdBQVc1VyxPQUFPO0lBQ2pDO0VBQ0Y7RUFFRDRjLE1BQU03YyxPQUFPeUssT0FBT3hLLFNBQVM7QUFDM0IsUUFBSUQsTUFBTStRLFNBQVM7QUFDakIvUSxZQUFNK1EsUUFBUThGLFdBQVc1VyxPQUFPO0lBQ2pDO0VBQ0Y7RUFFRDZjLFVBQVU5YyxPQUFPO0FBQ2YsVUFBTStRLFVBQVUvUSxNQUFNK1E7QUFFdEIsUUFBSUEsV0FBV0EsUUFBUTZLLFlBQVcsR0FBSTtBQUNwQyxZQUFNelEsT0FBTztRQUNYNEY7O0FBR0YsVUFBSS9RLE1BQU0rYyxjQUFjLHFCQUFxQjtRQUFDLEdBQUc1UjtRQUFNNlIsWUFBWTtPQUFLLE1BQU0sT0FBTztBQUNuRjtNQUNEO0FBRURqTSxjQUFRck0sS0FBSzFFLE1BQU1FLEdBQUc7QUFFdEJGLFlBQU0rYyxjQUFjLG9CQUFvQjVSLElBQUk7SUFDN0M7RUFDRjtFQUVERCxXQUFXbEwsT0FBT21MLE1BQU07QUFDdEIsUUFBSW5MLE1BQU0rUSxTQUFTO0FBRWpCLFlBQU1rTSxtQkFBbUI5UixLQUFLQztBQUM5QixVQUFJcEwsTUFBTStRLFFBQVF2SCxZQUFZMkIsS0FBS0UsT0FBTzRSLGtCQUFrQjlSLEtBQUtzUixXQUFXLEdBQUc7QUFFN0V0UixhQUFLZ04sVUFBVTtNQUNoQjtJQUNGO0VBQ0Y7RUFFRG5ULFVBQVU7SUFDUmtTLFNBQVM7SUFDVHNCLFVBQVU7SUFDVnhYLFVBQVU7SUFDVm1MLGlCQUFpQjtJQUNqQnFOLFlBQVk7SUFDWjNRLFdBQVc7TUFDVDVILFFBQVE7SUFDVDtJQUNENlEsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJ3SCxZQUFZO0lBQ1pqRSxXQUFXO0lBQ1hwRCxhQUFhO0lBQ2JoQixVQUFVLENBQUE7SUFFVm9KLFdBQVc7SUFDWFUsYUFBYTtJQUNiNUksZUFBZTtJQUNmRCxpQkFBaUI7SUFDakJoQixZQUFZO01BQ1ZsUSxRQUFRO0lBQ1Q7SUFDRDhaLGFBQWE7SUFDYnBZLFNBQVM7SUFDVG9RLGNBQWM7SUFDZEQsV0FBVztJQUNYWSxjQUFjO0lBQ2QvVSxXQUFXLENBQUN1QixLQUFLNEUsU0FBU0EsS0FBS29NLFNBQVM3TztJQUN4Q3pELFVBQVUsQ0FBQ3NCLEtBQUs0RSxTQUFTQSxLQUFLb00sU0FBUzdPO0lBQ3ZDeVgsb0JBQW9CO0lBQ3BCN0gsZUFBZTtJQUNmUSxZQUFZO0lBQ1poRyxhQUFhO0lBQ2JsRyxhQUFhO0lBQ2I0USxXQUFXO01BQ1QrRixVQUFVO01BQ1ZDLFFBQVE7SUFDVDtJQUNEL0YsWUFBWTtNQUNWZ0csU0FBUztRQUNQelQsTUFBTTtRQUNOeU8sWUFBWTtVQUFDO1VBQUs7VUFBSztVQUFTO1VBQVU7VUFBVTtRQUFTO01BQzlEO01BQ0RyQyxTQUFTO1FBQ1BvSCxRQUFRO1FBQ1JELFVBQVU7TUFDWDtJQUNGO0lBQ0QxSSxXQUFXRztFQUNaO0VBRUQ3RyxlQUFlO0lBQ2JvRCxVQUFVO0lBQ1ZDLFlBQVk7SUFDWnRJLFdBQVc7RUFDWjtFQUVENkQsYUFBYTtJQUNYQyxhQUFhLENBQUNDLFVBQVNBLFVBQVMsWUFBWUEsVUFBUyxjQUFjQSxVQUFTO0lBQzVFbUIsWUFBWTtJQUNaeUcsV0FBVztNQUNUN0gsYUFBYTtNQUNib0IsWUFBWTtJQUNiO0lBQ0RvSixXQUFXO01BQ1RrRyxXQUFXO0lBQ1o7SUFDRGpHLFlBQVk7TUFDVmlHLFdBQVc7SUFDWjtFQUNGO0VBR0RDLHdCQUF3QjtJQUFDO0VBQWM7O0FDdHpDekMsSUFBTUMsY0FBYyxDQUFDQyxRQUFRQyxLQUFLQyxPQUFPQyxnQkFBZ0I7QUFDdkQsTUFBSSxPQUFPRixRQUFRLFVBQVU7QUFDM0JDLFlBQVFGLE9BQU9JLEtBQUtILEdBQUcsSUFBSTtBQUMzQkUsZ0JBQVlFLFFBQVE7TUFBQ0g7TUFBT0ksT0FBT0w7SUFBSSxDQUFBO0VBQ3hDLFdBQVVNLE1BQU1OLEdBQUcsR0FBRztBQUNyQkMsWUFBUTtFQUNUO0FBQ0QsU0FBT0E7O0FBR1QsU0FBU00sZUFBZVIsUUFBUUMsS0FBS0MsT0FBT0MsYUFBYTtBQUN2RCxRQUFNTSxRQUFRVCxPQUFPVSxRQUFRVCxHQUFHO0FBQ2hDLE1BQUlRLFVBQVUsSUFBSTtBQUNoQixXQUFPVixZQUFZQyxRQUFRQyxLQUFLQyxPQUFPQyxXQUFXO0VBQ25EO0FBQ0QsUUFBTVEsT0FBT1gsT0FBT1ksWUFBWVgsR0FBRztBQUNuQyxTQUFPUSxVQUFVRSxPQUFPVCxRQUFRTztBQUNqQztBQUVELElBQU1JLGFBQWEsQ0FBQ1gsT0FBT1ksUUFBUVosVUFBVSxPQUFPLE9BQU9hLFlBQVlDLEtBQUtDLE1BQU1mLEtBQUssR0FBRyxHQUFHWSxHQUFHO0FBRWhHLFNBQVNJLGtCQUFrQkMsT0FBTztBQUNoQyxRQUFNbkIsU0FBUyxLQUFLb0IsVUFBUztBQUU3QixNQUFJRCxTQUFTLEtBQUtBLFFBQVFuQixPQUFPcUIsUUFBUTtBQUN2QyxXQUFPckIsT0FBT21CO0VBQ2Y7QUFDRCxTQUFPQTtBQUNSO0FBRWMsSUFBTUcsZ0JBQU4sY0FBNEJDLE1BQUs7RUFhOUNDLFlBQVlDLEtBQUs7QUFDZixVQUFNQSxHQUFHO0FBR1QsU0FBS0MsY0FBY0M7QUFDbkIsU0FBS0MsY0FBYztBQUNuQixTQUFLQyxlQUFlLENBQUE7RUFDckI7RUFFREMsS0FBS0MsY0FBYztBQUNqQixVQUFNQyxRQUFRLEtBQUtIO0FBQ25CLFFBQUlHLE1BQU1YLFFBQVE7QUFDaEIsWUFBTXJCLFNBQVMsS0FBS29CLFVBQVM7QUFDN0IsaUJBQVcsRUFBQ2xCLE9BQU9JLE1BQUssS0FBSzBCLE9BQU87QUFDbEMsWUFBSWhDLE9BQU9FLFdBQVdJLE9BQU87QUFDM0JOLGlCQUFPaUMsT0FBTy9CLE9BQU8sQ0FBQztRQUN2QjtNQUNGO0FBQ0QsV0FBSzJCLGVBQWUsQ0FBQTtJQUNyQjtBQUNELFVBQU1DLEtBQUtDLFlBQVk7RUFDeEI7RUFFREcsTUFBTWpDLEtBQUtDLE9BQU87QUFDaEIsUUFBSWlDLGNBQWNsQyxHQUFHLEdBQUc7QUFDdEIsYUFBTztJQUNSO0FBQ0QsVUFBTUQsU0FBUyxLQUFLb0IsVUFBUztBQUM3QmxCLFlBQVFrQyxTQUFTbEMsS0FBSyxLQUFLRixPQUFPRSxXQUFXRCxNQUFNQyxRQUMvQ00sZUFBZVIsUUFBUUMsS0FBS29DLGVBQWVuQyxPQUFPRCxHQUFHLEdBQUcsS0FBSzRCLFlBQVk7QUFDN0UsV0FBT2hCLFdBQVdYLE9BQU9GLE9BQU9xQixTQUFTLENBQUM7RUFDM0M7RUFFRGlCLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNDLFlBQVlDLFdBQVUsSUFBSSxLQUFLQyxjQUFhO0FBQ25ELFFBQUksRUFBQ0MsS0FBSzVCLElBQUcsSUFBSSxLQUFLNkIsVUFBVSxJQUFJO0FBRXBDLFFBQUksS0FBS0MsUUFBUUMsV0FBVyxTQUFTO0FBQ25DLFVBQUksQ0FBQ04sWUFBWTtBQUNmRyxjQUFNO01BQ1A7QUFDRCxVQUFJLENBQUNGLFlBQVk7QUFDZjFCLGNBQU0sS0FBS00sVUFBUyxFQUFHQyxTQUFTO01BQ2pDO0lBQ0Y7QUFFRCxTQUFLcUIsTUFBTUE7QUFDWCxTQUFLNUIsTUFBTUE7RUFDWjtFQUVEZ0MsYUFBYTtBQUNYLFVBQU1KLE1BQU0sS0FBS0E7QUFDakIsVUFBTTVCLE1BQU0sS0FBS0E7QUFDakIsVUFBTWlDLFNBQVMsS0FBS0gsUUFBUUc7QUFDNUIsVUFBTUMsUUFBUSxDQUFBO0FBQ2QsUUFBSWhELFNBQVMsS0FBS29CLFVBQVM7QUFHM0JwQixhQUFTLFFBQVMsS0FBS2MsUUFBUWQsT0FBT3FCLFNBQVMsSUFBS3JCLFNBQVNBLE9BQU9pRCxNQUFNUCxLQUFLNUIsTUFBTSxDQUFDO0FBRXRGLFNBQUtjLGNBQWNaLEtBQUtGLElBQUlkLE9BQU9xQixVQUFVMEIsU0FBUyxJQUFJLElBQUksQ0FBQztBQUMvRCxTQUFLckIsY0FBYyxLQUFLZ0IsT0FBT0ssU0FBUyxNQUFNO0FBRTlDLGFBQVM1QixRQUFRdUIsS0FBS3ZCLFNBQVNMLEtBQUtLLFNBQVM7QUFDM0M2QixZQUFNNUMsS0FBSztRQUFDZTtNQUFNLENBQUE7SUFDbkI7QUFDRCxXQUFPNkI7RUFDUjtFQUVERSxpQkFBaUIvQixPQUFPO0FBQ3RCLFdBQU9ELGtCQUFrQmlDLEtBQUssTUFBTWhDLEtBQUs7RUFDMUM7RUFLRGlDLFlBQVk7QUFDVixVQUFNQSxVQUFTO0FBRWYsUUFBSSxDQUFDLEtBQUtDLGFBQVksR0FBSTtBQUV4QixXQUFLQyxpQkFBaUIsQ0FBQyxLQUFLQTtJQUM3QjtFQUNGO0VBR0RDLGlCQUFpQnBDLE9BQU87QUFDdEIsUUFBSSxPQUFPQSxVQUFVLFVBQVU7QUFDN0JBLGNBQVEsS0FBS2UsTUFBTWYsS0FBSztJQUN6QjtBQUVELFdBQU9BLFVBQVUsT0FBT3FDLE1BQU0sS0FBS0Msb0JBQW9CdEMsUUFBUSxLQUFLTyxlQUFlLEtBQUtFLFdBQVc7RUFDcEc7RUFJRDhCLGdCQUFnQnhELE9BQU87QUFDckIsVUFBTThDLFFBQVEsS0FBS0E7QUFDbkIsUUFBSTlDLFFBQVEsS0FBS0EsUUFBUThDLE1BQU0zQixTQUFTLEdBQUc7QUFDekMsYUFBTztJQUNSO0FBQ0QsV0FBTyxLQUFLa0MsaUJBQWlCUCxNQUFNOUMsT0FBT2lCLEtBQUs7RUFDaEQ7RUFFRHdDLGlCQUFpQkMsT0FBTztBQUN0QixXQUFPNUMsS0FBS0MsTUFBTSxLQUFLUyxjQUFjLEtBQUttQyxtQkFBbUJELEtBQUssSUFBSSxLQUFLaEMsV0FBVztFQUN2RjtFQUVEa0MsZUFBZTtBQUNiLFdBQU8sS0FBS0M7RUFDYjs7QUF6SEQsY0FGbUJ6QyxlQUVaMEMsTUFBSztBQUtaLGNBUG1CMUMsZUFPWjJDLFlBQVc7RUFDaEJqQixPQUFPO0lBQ0xrQixVQUFVaEQ7RUFDWDs7QUNuQkwsU0FBU2lELGdCQUFjQyxtQkFBbUJDLFdBQVc7QUFDbkQsUUFBTXJCLFFBQVEsQ0FBQTtBQUtkLFFBQU1zQixjQUFjO0FBQ3BCLFFBQU0sRUFBQ3pCLFFBQVEwQixNQUFNN0IsS0FBSzVCLEtBQUswRCxXQUFXQyxPQUFPQyxVQUFVQyxXQUFXQyxjQUFhLElBQUlSO0FBQ3ZGLFFBQU1TLE9BQU9OLFFBQVE7QUFDckIsUUFBTU8sWUFBWUosV0FBVztBQUM3QixRQUFNLEVBQUNoQyxLQUFLcUMsTUFBTWpFLEtBQUtrRSxLQUFJLElBQUlYO0FBQy9CLFFBQU05QixhQUFhLENBQUNKLGNBQWNPLEdBQUc7QUFDckMsUUFBTUYsYUFBYSxDQUFDTCxjQUFjckIsR0FBRztBQUNyQyxRQUFNbUUsZUFBZSxDQUFDOUMsY0FBY3NDLEtBQUs7QUFDekMsUUFBTVMsY0FBY0YsT0FBT0QsU0FBU0osWUFBWTtBQUNoRCxNQUFJUSxVQUFVQyxTQUFTSixPQUFPRCxRQUFRRCxZQUFZRCxJQUFJLElBQUlBO0FBQzFELE1BQUlRLFFBQVFDLFNBQVNDLFNBQVNDO0FBSTlCLE1BQUlMLFVBQVViLGVBQWUsQ0FBQy9CLGNBQWMsQ0FBQ0MsWUFBWTtBQUN2RCxXQUFPO01BQUM7UUFBQ3JCLE9BQU80RDtNQUFLO01BQUU7UUFBQzVELE9BQU82RDtNQUFLOztFQUNyQztBQUVEUSxjQUFZeEUsS0FBS3lFLEtBQUtULE9BQU9HLE9BQU8sSUFBSW5FLEtBQUswRSxNQUFNWCxPQUFPSSxPQUFPO0FBQ2pFLE1BQUlLLFlBQVlWLFdBQVc7QUFFekJLLGNBQVVDLFFBQVFJLFlBQVlMLFVBQVVMLFlBQVlELElBQUksSUFBSUE7RUFDN0Q7QUFFRCxNQUFJLENBQUMxQyxjQUFjcUMsU0FBUyxHQUFHO0FBRTdCYSxhQUFTckUsS0FBSzJFLElBQUksSUFBSW5CLFNBQVM7QUFDL0JXLGNBQVVuRSxLQUFLeUUsS0FBS04sVUFBVUUsTUFBTSxJQUFJQTtFQUN6QztBQUVELE1BQUl4QyxXQUFXLFNBQVM7QUFDdEJ5QyxjQUFVdEUsS0FBSzBFLE1BQU1YLE9BQU9JLE9BQU8sSUFBSUE7QUFDdkNJLGNBQVV2RSxLQUFLeUUsS0FBS1QsT0FBT0csT0FBTyxJQUFJQTtTQUNqQztBQUNMRyxjQUFVUDtBQUNWUSxjQUFVUDtFQUNYO0FBRUQsTUFBSXpDLGNBQWNDLGNBQWMrQixRQUFRcUIsYUFBYTlFLE1BQU00QixPQUFPNkIsTUFBTVksVUFBVSxHQUFJLEdBQUc7QUFLdkZLLGdCQUFZeEUsS0FBS0MsTUFBTUQsS0FBSzBCLEtBQUs1QixNQUFNNEIsT0FBT3lDLFNBQVNULFFBQVEsQ0FBQztBQUNoRVMsZUFBV3JFLE1BQU00QixPQUFPOEM7QUFDeEJGLGNBQVU1QztBQUNWNkMsY0FBVXpFO2FBQ0RtRSxjQUFjO0FBSXZCSyxjQUFVL0MsYUFBYUcsTUFBTTRDO0FBQzdCQyxjQUFVL0MsYUFBYTFCLE1BQU15RTtBQUM3QkMsZ0JBQVlmLFFBQVE7QUFDcEJVLGVBQVdJLFVBQVVELFdBQVdFO1NBQzNCO0FBRUxBLGlCQUFhRCxVQUFVRCxXQUFXSDtBQUdsQyxRQUFJVSxhQUFhTCxXQUFXeEUsS0FBS0MsTUFBTXVFLFNBQVMsR0FBR0wsVUFBVSxHQUFJLEdBQUc7QUFDbEVLLGtCQUFZeEUsS0FBS0MsTUFBTXVFLFNBQVM7V0FDM0I7QUFDTEEsa0JBQVl4RSxLQUFLeUUsS0FBS0QsU0FBUztJQUNoQztFQUNGO0FBSUQsUUFBTU0sZ0JBQWdCOUUsS0FBS0YsSUFDekJpRixlQUFlWixPQUFPLEdBQ3RCWSxlQUFlVCxPQUFPLENBQUM7QUFFekJELFdBQVNyRSxLQUFLMkUsSUFBSSxJQUFJeEQsY0FBY3FDLFNBQVMsSUFBSXNCLGdCQUFnQnRCLFNBQVM7QUFDMUVjLFlBQVV0RSxLQUFLQyxNQUFNcUUsVUFBVUQsTUFBTSxJQUFJQTtBQUN6Q0UsWUFBVXZFLEtBQUtDLE1BQU1zRSxVQUFVRixNQUFNLElBQUlBO0FBRXpDLE1BQUlXLElBQUk7QUFDUixNQUFJekQsWUFBWTtBQUNkLFFBQUlxQyxpQkFBaUJVLFlBQVk1QyxLQUFLO0FBQ3BDTSxZQUFNNUMsS0FBSztRQUFDZSxPQUFPdUI7TUFBSSxDQUFBO0FBRXZCLFVBQUk0QyxVQUFVNUMsS0FBSztBQUNqQnNEO01BQ0Q7QUFFRCxVQUFJSCxhQUFhN0UsS0FBS0MsT0FBT3FFLFVBQVVVLElBQUliLFdBQVdFLE1BQU0sSUFBSUEsUUFBUTNDLEtBQUt1RCxrQkFBa0J2RCxLQUFLd0MsWUFBWWQsaUJBQWlCLENBQUMsR0FBRztBQUNuSTRCO01BQ0Q7SUFDRixXQUFVVixVQUFVNUMsS0FBSztBQUN4QnNEO0lBQ0Q7RUFDRjtBQUVELFNBQU9BLElBQUlSLFdBQVcsRUFBRVEsR0FBRztBQUN6QmhELFVBQU01QyxLQUFLO01BQUNlLE9BQU9ILEtBQUtDLE9BQU9xRSxVQUFVVSxJQUFJYixXQUFXRSxNQUFNLElBQUlBO0lBQU8sQ0FBQTtFQUMxRTtBQUVELE1BQUk3QyxjQUFjb0MsaUJBQWlCVyxZQUFZekUsS0FBSztBQUVsRCxRQUFJa0MsTUFBTTNCLFVBQVV3RSxhQUFhN0MsTUFBTUEsTUFBTTNCLFNBQVMsR0FBR0YsT0FBT0wsS0FBS21GLGtCQUFrQm5GLEtBQUtvRSxZQUFZZCxpQkFBaUIsQ0FBQyxHQUFHO0FBQzNIcEIsWUFBTUEsTUFBTTNCLFNBQVMsR0FBR0YsUUFBUUw7V0FDM0I7QUFDTGtDLFlBQU01QyxLQUFLO1FBQUNlLE9BQU9MO01BQUksQ0FBQTtJQUN4QjtFQUNGLFdBQVUsQ0FBQzBCLGNBQWMrQyxZQUFZekUsS0FBSztBQUN6Q2tDLFVBQU01QyxLQUFLO01BQUNlLE9BQU9vRTtJQUFRLENBQUE7RUFDNUI7QUFFRCxTQUFPdkM7QUFDUjtBQUVELFNBQVNpRCxrQkFBa0I5RSxPQUFPK0QsWUFBWSxFQUFDZ0IsWUFBWUMsWUFBVyxHQUFHO0FBQ3ZFLFFBQU1DLE1BQU1DLFVBQVVGLFdBQVc7QUFDakMsUUFBTUcsU0FBU0osYUFBYWxGLEtBQUt1RixJQUFJSCxHQUFHLElBQUlwRixLQUFLd0YsSUFBSUosR0FBRyxNQUFNO0FBQzlELFFBQU0vRSxTQUFTLE9BQU82RCxjQUFjLEtBQUsvRCxPQUFPRTtBQUNoRCxTQUFPTCxLQUFLMEIsSUFBSXdDLGFBQWFvQixPQUFPakYsTUFBTTtBQUMzQztBQUVjLElBQU1vRixrQkFBTixjQUE4QmxGLE1BQUs7RUFFaERDLFlBQVlDLEtBQUs7QUFDZixVQUFNQSxHQUFHO0FBR1QsU0FBS2lGLFFBQVEvRTtBQUViLFNBQUtnRixNQUFNaEY7QUFFWCxTQUFLRCxjQUFjQztBQUVuQixTQUFLaUYsWUFBWWpGO0FBQ2pCLFNBQUtDLGNBQWM7RUFDcEI7RUFFRE0sTUFBTWpDLEtBQUtDLE9BQU87QUFDaEIsUUFBSWlDLGNBQWNsQyxHQUFHLEdBQUc7QUFDdEIsYUFBTztJQUNSO0FBQ0QsU0FBSyxPQUFPQSxRQUFRLFlBQVlBLGVBQWU0RyxXQUFXLENBQUN6RSxTQUFTLENBQUNuQyxHQUFHLEdBQUc7QUFDekUsYUFBTztJQUNSO0FBRUQsV0FBTyxDQUFDQTtFQUNUO0VBRUQ2Ryx5QkFBeUI7QUFDdkIsVUFBTSxFQUFDQyxZQUFXLElBQUksS0FBS25FO0FBQzNCLFVBQU0sRUFBQ0wsWUFBWUMsV0FBVSxJQUFJLEtBQUtDLGNBQWE7QUFDbkQsUUFBSSxFQUFDQyxLQUFLNUIsSUFBRyxJQUFJO0FBRWpCLFVBQU1rRyxTQUFTQyxDQUFBQSxNQUFNdkUsTUFBTUgsYUFBYUcsTUFBTXVFO0FBQzlDLFVBQU1DLFNBQVNELENBQUFBLE1BQU1uRyxNQUFNMEIsYUFBYTFCLE1BQU1tRztBQUU5QyxRQUFJRixhQUFhO0FBQ2YsWUFBTUksVUFBVUMsS0FBSzFFLEdBQUc7QUFDeEIsWUFBTTJFLFVBQVVELEtBQUt0RyxHQUFHO0FBRXhCLFVBQUlxRyxVQUFVLEtBQUtFLFVBQVUsR0FBRztBQUM5QkgsZUFBTyxDQUFDO2lCQUNDQyxVQUFVLEtBQUtFLFVBQVUsR0FBRztBQUNyQ0wsZUFBTyxDQUFDO01BQ1Q7SUFDRjtBQUVELFFBQUl0RSxRQUFRNUIsS0FBSztBQUNmLFVBQUlpQyxTQUFTakMsUUFBUSxJQUFJLElBQUlFLEtBQUtzRyxJQUFJeEcsTUFBTSxJQUFJO0FBRWhEb0csYUFBT3BHLE1BQU1pQyxNQUFNO0FBRW5CLFVBQUksQ0FBQ2dFLGFBQWE7QUFDaEJDLGVBQU90RSxNQUFNSyxNQUFNO01BQ3BCO0lBQ0Y7QUFDRCxTQUFLTCxNQUFNQTtBQUNYLFNBQUs1QixNQUFNQTtFQUNaO0VBRUR5RyxlQUFlO0FBQ2IsVUFBTUMsV0FBVyxLQUFLNUUsUUFBUUk7QUFFOUIsUUFBSSxFQUFDeUUsZUFBZUMsU0FBUSxJQUFJRjtBQUNoQyxRQUFJOUM7QUFFSixRQUFJZ0QsVUFBVTtBQUNaaEQsaUJBQVcxRCxLQUFLeUUsS0FBSyxLQUFLM0UsTUFBTTRHLFFBQVEsSUFBSTFHLEtBQUswRSxNQUFNLEtBQUtoRCxNQUFNZ0YsUUFBUSxJQUFJO0FBQzlFLFVBQUloRCxXQUFXLEtBQU07QUFDbkJpRCxnQkFBUUMsS0FBSyxVQUFVLEtBQUs1RCxzQkFBc0IwRCwwQ0FBMENoRCxtQ0FBbUM7QUFDL0hBLG1CQUFXO01BQ1o7V0FDSTtBQUNMQSxpQkFBVyxLQUFLbUQsaUJBQWdCO0FBQ2hDSixzQkFBZ0JBLGlCQUFpQjtJQUNsQztBQUVELFFBQUlBLGVBQWU7QUFDakIvQyxpQkFBVzFELEtBQUswQixJQUFJK0UsZUFBZS9DLFFBQVE7SUFDNUM7QUFFRCxXQUFPQTtFQUNSO0VBS0RtRCxtQkFBbUI7QUFDakIsV0FBT2hCLE9BQU9pQjtFQUNmO0VBRURoRixhQUFhO0FBQ1gsVUFBTWlGLE9BQU8sS0FBS25GO0FBQ2xCLFVBQU00RSxXQUFXTyxLQUFLL0U7QUFNdEIsUUFBSTBCLFdBQVcsS0FBSzZDLGFBQVk7QUFDaEM3QyxlQUFXMUQsS0FBS0YsSUFBSSxHQUFHNEQsUUFBUTtBQUUvQixVQUFNc0QsMEJBQTBCO01BQzlCdEQ7TUFDQTdCLFFBQVFrRixLQUFLbEY7TUFDYkgsS0FBS3FGLEtBQUtyRjtNQUNWNUIsS0FBS2lILEtBQUtqSDtNQUNWMEQsV0FBV2dELFNBQVNoRDtNQUNwQkQsTUFBTWlELFNBQVNFO01BQ2ZqRCxPQUFPK0MsU0FBUy9DO01BQ2hCRSxXQUFXLEtBQUtzRCxXQUFVO01BQzFCL0IsWUFBWSxLQUFLN0MsYUFBWTtNQUM3QjhDLGFBQWFxQixTQUFTckIsZUFBZTtNQUNyQ3ZCLGVBQWU0QyxTQUFTNUMsa0JBQWtCOztBQUU1QyxVQUFNUCxZQUFZLEtBQUs2RCxVQUFVO0FBQ2pDLFVBQU1sRixRQUFRbUIsZ0JBQWM2RCx5QkFBeUIzRCxTQUFTO0FBSTlELFFBQUkwRCxLQUFLbEYsV0FBVyxTQUFTO0FBQzNCc0YseUJBQW1CbkYsT0FBTyxNQUFNLE9BQU87SUFDeEM7QUFFRCxRQUFJK0UsS0FBS0ssU0FBUztBQUNoQnBGLFlBQU1vRixRQUFPO0FBRWIsV0FBSzFCLFFBQVEsS0FBSzVGO0FBQ2xCLFdBQUs2RixNQUFNLEtBQUtqRTtXQUNYO0FBQ0wsV0FBS2dFLFFBQVEsS0FBS2hFO0FBQ2xCLFdBQUtpRSxNQUFNLEtBQUs3RjtJQUNqQjtBQUVELFdBQU9rQztFQUNSO0VBS0RJLFlBQVk7QUFDVixVQUFNSixRQUFRLEtBQUtBO0FBQ25CLFFBQUkwRCxRQUFRLEtBQUtoRTtBQUNqQixRQUFJaUUsTUFBTSxLQUFLN0Y7QUFFZixVQUFNc0MsVUFBUztBQUVmLFFBQUksS0FBS1IsUUFBUUcsVUFBVUMsTUFBTTNCLFFBQVE7QUFDdkMsWUFBTTBCLFVBQVU0RCxNQUFNRCxTQUFTMUYsS0FBS0YsSUFBSWtDLE1BQU0zQixTQUFTLEdBQUcsQ0FBQyxJQUFJO0FBQy9EcUYsZUFBUzNEO0FBQ1Q0RCxhQUFPNUQ7SUFDUjtBQUNELFNBQUtyQixjQUFjZ0Y7QUFDbkIsU0FBS0UsWUFBWUQ7QUFDakIsU0FBSy9FLGNBQWMrRSxNQUFNRDtFQUMxQjtFQUVEeEQsaUJBQWlCL0IsT0FBTztBQUN0QixXQUFPa0gsYUFBYWxILE9BQU8sS0FBS21ILE1BQU0xRixRQUFRMkYsUUFBUSxLQUFLM0YsUUFBUUksTUFBTXdGLE1BQU07RUFDaEY7O0FDOVNZLElBQU1DLGNBQU4sY0FBMEJoQyxnQkFBZTtFQWN0RG5FLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNJLEtBQUs1QixJQUFHLElBQUksS0FBSzZCLFVBQVUsSUFBSTtBQUV0QyxTQUFLRCxNQUFNTixlQUFTTSxHQUFHLElBQUlBLE1BQU07QUFDakMsU0FBSzVCLE1BQU1zQixlQUFTdEIsR0FBRyxJQUFJQSxNQUFNO0FBR2pDLFNBQUtnRyx1QkFBc0I7RUFDNUI7RUFNRGUsbUJBQW1CO0FBQ2pCLFVBQU0zQixhQUFhLEtBQUs3QyxhQUFZO0FBQ3BDLFVBQU1oQyxTQUFTNkUsYUFBYSxLQUFLd0MsUUFBUSxLQUFLQztBQUM5QyxVQUFNeEMsY0FBY0UsVUFBVSxLQUFLekQsUUFBUUksTUFBTW1ELFdBQVc7QUFDNUQsVUFBTUcsU0FBU0osYUFBYWxGLEtBQUt1RixJQUFJSixXQUFXLElBQUluRixLQUFLd0YsSUFBSUwsV0FBVyxNQUFNO0FBQzlFLFVBQU15QyxXQUFXLEtBQUtDLHdCQUF3QixDQUFDO0FBQy9DLFdBQU83SCxLQUFLeUUsS0FBS3BFLFNBQVNMLEtBQUswQixJQUFJLElBQUlrRyxTQUFTRSxhQUFheEMsS0FBSyxDQUFDO0VBQ3BFO0VBR0QvQyxpQkFBaUJwQyxPQUFPO0FBQ3RCLFdBQU9BLFVBQVUsT0FBT3FDLE1BQU0sS0FBS0Msb0JBQW9CdEMsUUFBUSxLQUFLTyxlQUFlLEtBQUtFLFdBQVc7RUFDcEc7RUFFRCtCLGlCQUFpQkMsT0FBTztBQUN0QixXQUFPLEtBQUtsQyxjQUFjLEtBQUttQyxtQkFBbUJELEtBQUssSUFBSSxLQUFLaEM7RUFDakU7O0FBMUNELGNBRm1CNkcsYUFFWnpFLE1BQUs7QUFLWixjQVBtQnlFLGFBT1p4RSxZQUFXO0VBQ2hCakIsT0FBTztJQUNMa0IsVUFBVTZFLE1BQU1DLFdBQVdDO0VBQzVCOztBQ1JMLElBQU1DLGFBQWFqQyxDQUFBQSxNQUFLakcsS0FBSzBFLE1BQU15RCxNQUFNbEMsQ0FBQyxDQUFDO0FBQzNDLElBQU1tQyxpQkFBaUIsQ0FBQ25DLEdBQUdvQyxNQUFNckksS0FBSzJFLElBQUksSUFBSXVELFdBQVdqQyxDQUFDLElBQUlvQyxDQUFDO0FBRS9ELFNBQVNDLFFBQVFDLFNBQVM7QUFDeEIsUUFBTUMsU0FBU0QsVUFBV3ZJLEtBQUsyRSxJQUFJLElBQUl1RCxXQUFXSyxPQUFPLENBQUM7QUFDMUQsU0FBT0MsV0FBVztBQUNuQjtBQUVELFNBQVNDLE1BQU0vRyxLQUFLNUIsS0FBSzRJLFVBQVU7QUFDakMsUUFBTUMsWUFBWTNJLEtBQUsyRSxJQUFJLElBQUkrRCxRQUFRO0FBQ3ZDLFFBQU1oRCxRQUFRMUYsS0FBSzBFLE1BQU1oRCxNQUFNaUgsU0FBUztBQUN4QyxRQUFNaEQsTUFBTTNGLEtBQUt5RSxLQUFLM0UsTUFBTTZJLFNBQVM7QUFDckMsU0FBT2hELE1BQU1EO0FBQ2Q7QUFFRCxTQUFTa0QsU0FBU2xILEtBQUs1QixLQUFLO0FBQzFCLFFBQU0rSSxRQUFRL0ksTUFBTTRCO0FBQ3BCLE1BQUlnSCxXQUFXUixXQUFXVyxLQUFLO0FBQy9CLFNBQU9KLE1BQU0vRyxLQUFLNUIsS0FBSzRJLFFBQVEsSUFBSSxJQUFJO0FBQ3JDQTtFQUNEO0FBQ0QsU0FBT0QsTUFBTS9HLEtBQUs1QixLQUFLNEksUUFBUSxJQUFJLElBQUk7QUFDckNBO0VBQ0Q7QUFDRCxTQUFPMUksS0FBSzBCLElBQUlnSCxVQUFVUixXQUFXeEcsR0FBRyxDQUFDO0FBQzFDO0FBU0QsU0FBU3lCLGNBQWNDLG1CQUFtQixFQUFDMUIsS0FBSzVCLElBQUcsR0FBRztBQUNwRDRCLFFBQU1vSCxnQkFBZ0IxRixrQkFBa0IxQixLQUFLQSxHQUFHO0FBQ2hELFFBQU1NLFFBQVEsQ0FBQTtBQUNkLFFBQU0rRyxTQUFTYixXQUFXeEcsR0FBRztBQUM3QixNQUFJc0gsTUFBTUosU0FBU2xILEtBQUs1QixHQUFHO0FBQzNCLE1BQUkwRCxZQUFZd0YsTUFBTSxJQUFJaEosS0FBSzJFLElBQUksSUFBSTNFLEtBQUtzRyxJQUFJMEMsR0FBRyxDQUFDLElBQUk7QUFDeEQsUUFBTXRDLFdBQVcxRyxLQUFLMkUsSUFBSSxJQUFJcUUsR0FBRztBQUNqQyxRQUFNQyxPQUFPRixTQUFTQyxNQUFNaEosS0FBSzJFLElBQUksSUFBSW9FLE1BQU0sSUFBSTtBQUNuRCxRQUFNckQsUUFBUTFGLEtBQUtDLE9BQU95QixNQUFNdUgsUUFBUXpGLFNBQVMsSUFBSUE7QUFDckQsUUFBTXpCLFNBQVMvQixLQUFLMEUsT0FBT2hELE1BQU11SCxRQUFRdkMsV0FBVyxFQUFFLElBQUlBLFdBQVc7QUFDckUsTUFBSXdDLGNBQWNsSixLQUFLMEUsT0FBT2dCLFFBQVEzRCxVQUFVL0IsS0FBSzJFLElBQUksSUFBSXFFLEdBQUcsQ0FBQztBQUNqRSxNQUFJN0ksUUFBUTJJLGdCQUFnQjFGLGtCQUFrQjFCLEtBQUsxQixLQUFLQyxPQUFPZ0osT0FBT2xILFNBQVNtSCxjQUFjbEosS0FBSzJFLElBQUksSUFBSXFFLEdBQUcsS0FBS3hGLFNBQVMsSUFBSUEsU0FBUztBQUN4SSxTQUFPckQsUUFBUUwsS0FBSztBQUNsQmtDLFVBQU01QyxLQUFLO01BQUNlO01BQU9nSixPQUFPYixRQUFRbkksS0FBSztNQUFHK0k7SUFBWSxDQUFBO0FBQ3RELFFBQUlBLGVBQWUsSUFBSTtBQUNyQkEsb0JBQWNBLGNBQWMsS0FBSyxLQUFLO1dBQ2pDO0FBQ0xBO0lBQ0Q7QUFDRCxRQUFJQSxlQUFlLElBQUk7QUFDckJGO0FBQ0FFLG9CQUFjO0FBQ2QxRixrQkFBWXdGLE9BQU8sSUFBSSxJQUFJeEY7SUFDNUI7QUFDRHJELFlBQVFILEtBQUtDLE9BQU9nSixPQUFPbEgsU0FBU21ILGNBQWNsSixLQUFLMkUsSUFBSSxJQUFJcUUsR0FBRyxLQUFLeEYsU0FBUyxJQUFJQTtFQUNyRjtBQUNELFFBQU00RixXQUFXTixnQkFBZ0IxRixrQkFBa0J0RCxLQUFLSyxLQUFLO0FBQzdENkIsUUFBTTVDLEtBQUs7SUFBQ2UsT0FBT2lKO0lBQVVELE9BQU9iLFFBQVFjLFFBQVE7SUFBR0Y7RUFBWSxDQUFBO0FBRW5FLFNBQU9sSDtBQUNSO0FBRWMsSUFBTXFILG1CQUFOLGNBQStCOUksTUFBSztFQWlCakRDLFlBQVlDLEtBQUs7QUFDZixVQUFNQSxHQUFHO0FBR1QsU0FBS2lGLFFBQVEvRTtBQUViLFNBQUtnRixNQUFNaEY7QUFFWCxTQUFLRCxjQUFjQztBQUNuQixTQUFLQyxjQUFjO0VBQ3BCO0VBRURNLE1BQU1qQyxLQUFLQyxPQUFPO0FBQ2hCLFVBQU1pQixRQUFRc0YsZ0JBQWdCNkQsVUFBVXBJLE1BQU1xSSxNQUFNLE1BQU07TUFBQ3RLO01BQUtDO0lBQU0sQ0FBQTtBQUN0RSxRQUFJaUIsVUFBVSxHQUFHO0FBQ2YsV0FBS3FKLFFBQVE7QUFDYixhQUFPN0k7SUFDUjtBQUNELFdBQU9TLGVBQVNqQixLQUFLLEtBQUtBLFFBQVEsSUFBSUEsUUFBUTtFQUMvQztFQUVEbUIsc0JBQXNCO0FBQ3BCLFVBQU0sRUFBQ0ksS0FBSzVCLElBQUcsSUFBSSxLQUFLNkIsVUFBVSxJQUFJO0FBRXRDLFNBQUtELE1BQU1OLGVBQVNNLEdBQUcsSUFBSTFCLEtBQUtGLElBQUksR0FBRzRCLEdBQUcsSUFBSTtBQUM5QyxTQUFLNUIsTUFBTXNCLGVBQVN0QixHQUFHLElBQUlFLEtBQUtGLElBQUksR0FBR0EsR0FBRyxJQUFJO0FBRTlDLFFBQUksS0FBSzhCLFFBQVFtRSxhQUFhO0FBQzVCLFdBQUt5RCxRQUFRO0lBQ2Q7QUFJRCxRQUFJLEtBQUtBLFNBQVMsS0FBSzlILFFBQVEsS0FBSytILGlCQUFpQixDQUFDckksZUFBUyxLQUFLc0ksUUFBUSxHQUFHO0FBQzdFLFdBQUtoSSxNQUFNQSxRQUFRMEcsZUFBZSxLQUFLMUcsS0FBSyxDQUFDLElBQUkwRyxlQUFlLEtBQUsxRyxLQUFLLEVBQUUsSUFBSTBHLGVBQWUsS0FBSzFHLEtBQUssQ0FBQztJQUMzRztBQUVELFNBQUtvRSx1QkFBc0I7RUFDNUI7RUFFREEseUJBQXlCO0FBQ3ZCLFVBQU0sRUFBQ3ZFLFlBQVlDLFdBQVUsSUFBSSxLQUFLQyxjQUFhO0FBQ25ELFFBQUlDLE1BQU0sS0FBS0E7QUFDZixRQUFJNUIsTUFBTSxLQUFLQTtBQUVmLFVBQU1rRyxTQUFTQyxDQUFBQSxNQUFNdkUsTUFBTUgsYUFBYUcsTUFBTXVFO0FBQzlDLFVBQU1DLFNBQVNELENBQUFBLE1BQU1uRyxNQUFNMEIsYUFBYTFCLE1BQU1tRztBQUU5QyxRQUFJdkUsUUFBUTVCLEtBQUs7QUFDZixVQUFJNEIsT0FBTyxHQUFHO0FBQ1pzRSxlQUFPLENBQUM7QUFDUkUsZUFBTyxFQUFFO2FBQ0o7QUFDTEYsZUFBT29DLGVBQWUxRyxLQUFLLEVBQUUsQ0FBQztBQUM5QndFLGVBQU9rQyxlQUFldEksS0FBSyxDQUFFLENBQUM7TUFDL0I7SUFDRjtBQUNELFFBQUk0QixPQUFPLEdBQUc7QUFDWnNFLGFBQU9vQyxlQUFldEksS0FBSyxFQUFFLENBQUM7SUFDL0I7QUFDRCxRQUFJQSxPQUFPLEdBQUc7QUFFWm9HLGFBQU9rQyxlQUFlMUcsS0FBSyxDQUFFLENBQUM7SUFDL0I7QUFFRCxTQUFLQSxNQUFNQTtBQUNYLFNBQUs1QixNQUFNQTtFQUNaO0VBRURnQyxhQUFhO0FBQ1gsVUFBTWlGLE9BQU8sS0FBS25GO0FBRWxCLFVBQU13QixvQkFBb0I7TUFDeEIxQixLQUFLLEtBQUtnSTtNQUNWNUosS0FBSyxLQUFLNko7O0FBRVosVUFBTTNILFFBQVFtQixjQUFjQyxtQkFBbUIsSUFBSTtBQUluRCxRQUFJMkQsS0FBS2xGLFdBQVcsU0FBUztBQUMzQnNGLHlCQUFtQm5GLE9BQU8sTUFBTSxPQUFPO0lBQ3hDO0FBRUQsUUFBSStFLEtBQUtLLFNBQVM7QUFDaEJwRixZQUFNb0YsUUFBTztBQUViLFdBQUsxQixRQUFRLEtBQUs1RjtBQUNsQixXQUFLNkYsTUFBTSxLQUFLakU7V0FDWDtBQUNMLFdBQUtnRSxRQUFRLEtBQUtoRTtBQUNsQixXQUFLaUUsTUFBTSxLQUFLN0Y7SUFDakI7QUFFRCxXQUFPa0M7RUFDUjtFQU1ERSxpQkFBaUIvQixPQUFPO0FBQ3RCLFdBQU9BLFVBQVVRLFNBQ2IsTUFDQTBHLGFBQWFsSCxPQUFPLEtBQUttSCxNQUFNMUYsUUFBUTJGLFFBQVEsS0FBSzNGLFFBQVFJLE1BQU13RixNQUFNO0VBQzdFO0VBS0RwRixZQUFZO0FBQ1YsVUFBTXNELFFBQVEsS0FBS2hFO0FBRW5CLFVBQU1VLFVBQVM7QUFFZixTQUFLMUIsY0FBY3lILE1BQU16QyxLQUFLO0FBQzlCLFNBQUs5RSxjQUFjdUgsTUFBTSxLQUFLckksR0FBRyxJQUFJcUksTUFBTXpDLEtBQUs7RUFDakQ7RUFFRG5ELGlCQUFpQnBDLE9BQU87QUFDdEIsUUFBSUEsVUFBVVEsVUFBYVIsVUFBVSxHQUFHO0FBQ3RDQSxjQUFRLEtBQUt1QjtJQUNkO0FBQ0QsUUFBSXZCLFVBQVUsUUFBUVosTUFBTVksS0FBSyxHQUFHO0FBQ2xDLGFBQU9xQztJQUNSO0FBQ0QsV0FBTyxLQUFLQyxtQkFBbUJ0QyxVQUFVLEtBQUt1QixNQUMxQyxLQUNDeUcsTUFBTWhJLEtBQUssSUFBSSxLQUFLTyxlQUFlLEtBQUtFLFdBQVc7RUFDekQ7RUFFRCtCLGlCQUFpQkMsT0FBTztBQUN0QixVQUFNZ0gsVUFBVSxLQUFLL0csbUJBQW1CRCxLQUFLO0FBQzdDLFdBQU81QyxLQUFLMkUsSUFBSSxJQUFJLEtBQUtqRSxjQUFja0osVUFBVSxLQUFLaEosV0FBVztFQUNsRTs7QUFySkQsY0FGbUJ5SSxrQkFFWnJHLE1BQUs7QUFLWixjQVBtQnFHLGtCQU9acEcsWUFBVztFQUNoQmpCLE9BQU87SUFDTGtCLFVBQVU2RSxNQUFNQyxXQUFXNkI7SUFDM0JWLE9BQU87TUFDTFcsU0FBUztJQUNWO0VBQ0Y7O0FDOUVMLFNBQVNDLHNCQUFzQmhELE1BQU07QUFDbkMsUUFBTVAsV0FBV08sS0FBSy9FO0FBRXRCLE1BQUl3RSxTQUFTd0QsV0FBV2pELEtBQUtpRCxTQUFTO0FBQ3BDLFVBQU1DLFVBQVVDLFVBQVUxRCxTQUFTMkQsZUFBZTtBQUNsRCxXQUFPOUksZUFBZW1GLFNBQVM0RCxRQUFRNUQsU0FBUzRELEtBQUtDLE1BQU1wSCxTQUFTbUgsS0FBS0MsSUFBSSxJQUFJSixRQUFRdEM7RUFDMUY7QUFDRCxTQUFPO0FBQ1I7QUFFRCxTQUFTMkMsaUJBQWlCQyxLQUFLSCxNQUFNOUssT0FBTztBQUMxQ0EsVUFBUWtMLFFBQVFsTCxLQUFLLElBQUlBLFFBQVE7SUFBQ0E7O0FBQ2xDLFNBQU87SUFDTG1MLEdBQUdDLGFBQWFILEtBQUtILEtBQUtPLFFBQVFyTCxLQUFLO0lBQ3ZDc0wsR0FBR3RMLE1BQU1lLFNBQVMrSixLQUFLdEM7O0FBRTFCO0FBRUQsU0FBUytDLGdCQUFnQkMsT0FBT0MsS0FBS1YsTUFBTTNJLEtBQUs1QixLQUFLO0FBQ25ELE1BQUlnTCxVQUFVcEosT0FBT29KLFVBQVVoTCxLQUFLO0FBQ2xDLFdBQU87TUFDTDRGLE9BQU9xRixNQUFPVixPQUFPO01BQ3JCMUUsS0FBS29GLE1BQU9WLE9BQU87O2FBRVpTLFFBQVFwSixPQUFPb0osUUFBUWhMLEtBQUs7QUFDckMsV0FBTztNQUNMNEYsT0FBT3FGLE1BQU1WO01BQ2IxRSxLQUFLb0Y7O0VBRVI7QUFFRCxTQUFPO0lBQ0xyRixPQUFPcUY7SUFDUHBGLEtBQUtvRixNQUFNVjs7QUFFZDtBQUtELFNBQVNXLG1CQUFtQkMsT0FBTztBQThCakMsUUFBTUMsT0FBTztJQUNYQyxHQUFHRixNQUFNRyxPQUFPSCxNQUFNSSxTQUFTRDtJQUMvQkUsR0FBR0wsTUFBTU0sUUFBUU4sTUFBTUksU0FBU0U7SUFDaENDLEdBQUdQLE1BQU1RLE1BQU1SLE1BQU1JLFNBQVNJO0lBQzlCQyxHQUFHVCxNQUFNbEksU0FBU2tJLE1BQU1JLFNBQVN0STs7QUFFbkMsUUFBTTRJLFNBQVNDLE9BQU9DLE9BQU8sQ0FBQSxHQUFJWCxJQUFJO0FBQ3JDLFFBQU1ZLGFBQWEsQ0FBQTtBQUNuQixRQUFNN0IsVUFBVSxDQUFBO0FBQ2hCLFFBQU04QixhQUFhZCxNQUFNZSxhQUFhM0w7QUFDdEMsUUFBTTRMLGlCQUFpQmhCLE1BQU1ySixRQUFRc0s7QUFDckMsUUFBTUMsa0JBQWtCRixlQUFlRyxvQkFBb0JDLEtBQUtOLGFBQWE7QUFFN0UsV0FBU08sSUFBSSxHQUFHQSxJQUFJUCxZQUFZTyxLQUFLO0FBQ25DLFVBQU12RixPQUFPa0YsZUFBZU0sV0FBV3RCLE1BQU11QixxQkFBcUJGLENBQUMsQ0FBQztBQUNwRXJDLFlBQVFxQyxLQUFLdkYsS0FBS2tEO0FBQ2xCLFVBQU13QyxnQkFBZ0J4QixNQUFNeUIsaUJBQWlCSixHQUFHckIsTUFBTTBCLGNBQWMxQyxRQUFRcUMsSUFBSUgsZUFBZTtBQUMvRixVQUFNUyxTQUFTQyxPQUFPOUYsS0FBS3FELElBQUk7QUFDL0IsVUFBTTBDLFdBQVd4QyxpQkFBaUJXLE1BQU1WLEtBQUtxQyxRQUFRM0IsTUFBTWUsYUFBYU0sRUFBRTtBQUMxRVIsZUFBV1EsS0FBS1E7QUFFaEIsVUFBTUMsZUFBZUMsZ0JBQWdCL0IsTUFBTWdDLGNBQWNYLENBQUMsSUFBSUgsZUFBZTtBQUM3RSxVQUFNckIsUUFBUTlLLEtBQUtDLE1BQU1pTixVQUFVSCxZQUFZLENBQUM7QUFDaEQsVUFBTUksVUFBVXRDLGdCQUFnQkMsT0FBTzJCLGNBQWNXLEdBQUdOLFNBQVNyQyxHQUFHLEdBQUcsR0FBRztBQUMxRSxVQUFNNEMsVUFBVXhDLGdCQUFnQkMsT0FBTzJCLGNBQWNhLEdBQUdSLFNBQVNsQyxHQUFHLElBQUksR0FBRztBQUMzRTJDLGlCQUFhNUIsUUFBUVQsTUFBTTZCLGNBQWNJLFNBQVNFLE9BQU87RUFDMUQ7QUFFRHBDLFFBQU11QyxlQUNKdEMsS0FBS0MsSUFBSVEsT0FBT1IsR0FDaEJRLE9BQU9MLElBQUlKLEtBQUtJLEdBQ2hCSixLQUFLTSxJQUFJRyxPQUFPSCxHQUNoQkcsT0FBT0QsSUFBSVIsS0FBS1EsQ0FBQztBQUluQlQsUUFBTXdDLG1CQUFtQkMscUJBQXFCekMsT0FBT2EsWUFBWTdCLE9BQU87QUFDekU7QUFFRCxTQUFTc0QsYUFBYTVCLFFBQVFULE1BQU1KLE9BQU9xQyxTQUFTRSxTQUFTO0FBQzNELFFBQU05SCxNQUFNdkYsS0FBS3NHLElBQUl0RyxLQUFLdUYsSUFBSXVGLEtBQUssQ0FBQztBQUNwQyxRQUFNdEYsTUFBTXhGLEtBQUtzRyxJQUFJdEcsS0FBS3dGLElBQUlzRixLQUFLLENBQUM7QUFDcEMsTUFBSXNDLElBQUk7QUFDUixNQUFJRSxJQUFJO0FBQ1IsTUFBSUgsUUFBUXpILFFBQVF3RixLQUFLQyxHQUFHO0FBQzFCaUMsU0FBS2xDLEtBQUtDLElBQUlnQyxRQUFRekgsU0FBU0g7QUFDL0JvRyxXQUFPUixJQUFJbkwsS0FBSzBCLElBQUlpSyxPQUFPUixHQUFHRCxLQUFLQyxJQUFJaUMsQ0FBQzthQUMvQkQsUUFBUXhILE1BQU11RixLQUFLSSxHQUFHO0FBQy9COEIsU0FBS0QsUUFBUXhILE1BQU11RixLQUFLSSxLQUFLL0Y7QUFDN0JvRyxXQUFPTCxJQUFJdEwsS0FBS0YsSUFBSTZMLE9BQU9MLEdBQUdKLEtBQUtJLElBQUk4QixDQUFDO0VBQ3pDO0FBQ0QsTUFBSUMsUUFBUTNILFFBQVF3RixLQUFLTSxHQUFHO0FBQzFCOEIsU0FBS3BDLEtBQUtNLElBQUk2QixRQUFRM0gsU0FBU0Y7QUFDL0JtRyxXQUFPSCxJQUFJeEwsS0FBSzBCLElBQUlpSyxPQUFPSCxHQUFHTixLQUFLTSxJQUFJOEIsQ0FBQzthQUMvQkQsUUFBUTFILE1BQU11RixLQUFLUSxHQUFHO0FBQy9CNEIsU0FBS0QsUUFBUTFILE1BQU11RixLQUFLUSxLQUFLbEc7QUFDN0JtRyxXQUFPRCxJQUFJMUwsS0FBS0YsSUFBSTZMLE9BQU9ELEdBQUdSLEtBQUtRLElBQUk0QixDQUFDO0VBQ3pDO0FBQ0Y7QUFFRCxTQUFTSSxxQkFBcUJ6QyxPQUFPYSxZQUFZN0IsU0FBUztBQUN4RCxRQUFNMEQsUUFBUSxDQUFBO0FBQ2QsUUFBTTVCLGFBQWFkLE1BQU1lLGFBQWEzTDtBQUN0QyxRQUFNMEcsT0FBT2tFLE1BQU1ySjtBQUNuQixRQUFNZ00sUUFBUTdELHNCQUFzQmhELElBQUksSUFBSTtBQUM1QyxRQUFNOEcsZ0JBQWdCNUMsTUFBTTBCO0FBQzVCLFFBQU1SLGtCQUFrQnBGLEtBQUttRixZQUFZRSxvQkFBb0JDLEtBQUtOLGFBQWE7QUFFL0UsV0FBU08sSUFBSSxHQUFHQSxJQUFJUCxZQUFZTyxLQUFLO0FBQ25DLFVBQU13QixxQkFBcUI3QyxNQUFNeUIsaUJBQWlCSixHQUFHdUIsZ0JBQWdCRCxRQUFRM0QsUUFBUXFDLElBQUlILGVBQWU7QUFDeEcsVUFBTXJCLFFBQVE5SyxLQUFLQyxNQUFNaU4sVUFBVUYsZ0JBQWdCYyxtQkFBbUJoRCxRQUFRaUQsT0FBTyxDQUFDLENBQUM7QUFDdkYsVUFBTTFELE9BQU95QixXQUFXUTtBQUN4QixVQUFNZ0IsSUFBSVUsVUFBVUYsbUJBQW1CUixHQUFHakQsS0FBS08sR0FBR0UsS0FBSztBQUN2RCxVQUFNbUQsWUFBWUMscUJBQXFCcEQsS0FBSztBQUM1QyxVQUFNTSxPQUFPK0MsaUJBQWlCTCxtQkFBbUJWLEdBQUcvQyxLQUFLSSxHQUFHd0QsU0FBUztBQUVyRU4sVUFBTXZPLEtBQUs7TUFFVGdPLEdBQUdVLG1CQUFtQlY7TUFDdEJFO01BR0FXO01BR0E3QztNQUNBSyxLQUFLNkI7TUFDTC9CLE9BQU9ILE9BQU9mLEtBQUtJO01BQ25CMUgsUUFBUXVLLElBQUlqRCxLQUFLTztJQUNsQixDQUFBO0VBQ0Y7QUFDRCxTQUFPK0M7QUFDUjtBQUVELFNBQVNPLHFCQUFxQnBELE9BQU87QUFDbkMsTUFBSUEsVUFBVSxLQUFLQSxVQUFVLEtBQUs7QUFDaEMsV0FBTztFQUNSLFdBQVVBLFFBQVEsS0FBSztBQUN0QixXQUFPO0VBQ1I7QUFFRCxTQUFPO0FBQ1I7QUFFRCxTQUFTcUQsaUJBQWlCZixHQUFHM0MsR0FBRzJELE9BQU87QUFDckMsTUFBSUEsVUFBVSxTQUFTO0FBQ3JCaEIsU0FBSzNDO0VBQ04sV0FBVTJELFVBQVUsVUFBVTtBQUM3QmhCLFNBQU0zQyxJQUFJO0VBQ1g7QUFDRCxTQUFPMkM7QUFDUjtBQUVELFNBQVNZLFVBQVVWLEdBQUcxQyxJQUFHRSxPQUFPO0FBQzlCLE1BQUlBLFVBQVUsTUFBTUEsVUFBVSxLQUFLO0FBQ2pDd0MsU0FBTTFDLEtBQUk7YUFDREUsUUFBUSxPQUFPQSxRQUFRLElBQUk7QUFDcEN3QyxTQUFLMUM7RUFDTjtBQUNELFNBQU8wQztBQUNSO0FBRUQsU0FBU2UsZ0JBQWdCcEQsT0FBT3FELFlBQVk7QUFDMUMsUUFBTSxFQUFDL0QsS0FBSzNJLFNBQVMsRUFBQ3NLLFlBQVcsRUFBQyxJQUFJakI7QUFFdEMsV0FBU3FCLElBQUlnQyxhQUFhLEdBQUdoQyxLQUFLLEdBQUdBLEtBQUs7QUFDeEMsVUFBTWlDLGNBQWNyQyxZQUFZSyxXQUFXdEIsTUFBTXVCLHFCQUFxQkYsQ0FBQyxDQUFDO0FBQ3hFLFVBQU1NLFNBQVNDLE9BQU8wQixZQUFZbkUsSUFBSTtBQUN0QyxVQUFNLEVBQUNnRCxHQUFHRSxHQUFHVyxXQUFXN0MsTUFBTUssS0FBS0YsT0FBT3hJLE9BQU0sSUFBSWtJLE1BQU13QyxpQkFBaUJuQjtBQUMzRSxVQUFNLEVBQUNrQyxjQUFhLElBQUlEO0FBRXhCLFFBQUksQ0FBQ3BOLGNBQWNxTixhQUFhLEdBQUc7QUFDakMsWUFBTUMsZUFBZUMsY0FBY0gsWUFBWUUsWUFBWTtBQUMzRCxZQUFNeEUsVUFBVUMsVUFBVXFFLFlBQVlwRSxlQUFlO0FBQ3JESSxVQUFJb0UsWUFBWUg7QUFFaEIsWUFBTUksZUFBZXhELE9BQU9uQixRQUFRbUI7QUFDcEMsWUFBTXlELGNBQWNwRCxNQUFNeEIsUUFBUXdCO0FBQ2xDLFlBQU1xRCxnQkFBZ0J2RCxRQUFRSCxPQUFPbkIsUUFBUXZDO0FBQzdDLFlBQU1xSCxpQkFBaUJoTSxTQUFTMEksTUFBTXhCLFFBQVF0QztBQUU5QyxVQUFJaUUsT0FBT29ELE9BQU9QLFlBQVksRUFBRVEsS0FBS2hKLENBQUFBLE1BQUtBLE1BQU0sQ0FBQyxHQUFHO0FBQ2xEc0UsWUFBSTJFLFVBQVM7QUFDYkMsMkJBQW1CNUUsS0FBSztVQUN0QjZDLEdBQUd3QjtVQUNIdEIsR0FBR3VCO1VBQ0hwRSxHQUFHcUU7VUFDSGxFLEdBQUdtRTtVQUNISyxRQUFRWDtRQUNULENBQUE7QUFDRGxFLFlBQUk4RSxLQUFJO2FBQ0g7QUFDTDlFLFlBQUkrRSxTQUFTVixjQUFjQyxhQUFhQyxlQUFlQyxjQUFjO01BQ3RFO0lBQ0Y7QUFFRFEsZUFDRWhGLEtBQ0FVLE1BQU1lLGFBQWFNLElBQ25CYyxHQUNBRSxJQUFLVixPQUFPOUUsYUFBYSxHQUN6QjhFLFFBQ0E7TUFDRTRDLE9BQU9qQixZQUFZaUI7TUFDbkJ2QjtNQUNBd0IsY0FBYztJQUNmLENBQUE7RUFFSjtBQUNGO0FBRUQsU0FBU0MsZUFBZXpFLE9BQU9tRSxRQUFRTyxVQUFVckIsWUFBWTtBQUMzRCxRQUFNLEVBQUMvRCxJQUFHLElBQUlVO0FBQ2QsTUFBSTBFLFVBQVU7QUFFWnBGLFFBQUlxRixJQUFJM0UsTUFBTTRFLFNBQVM1RSxNQUFNNkUsU0FBU1YsUUFBUSxHQUFHVyxHQUFHO1NBQy9DO0FBRUwsUUFBSXRELGdCQUFnQnhCLE1BQU15QixpQkFBaUIsR0FBRzBDLE1BQU07QUFDcEQ3RSxRQUFJeUYsT0FBT3ZELGNBQWNXLEdBQUdYLGNBQWNhLENBQUM7QUFFM0MsYUFBU2hCLElBQUksR0FBR0EsSUFBSWdDLFlBQVloQyxLQUFLO0FBQ25DRyxzQkFBZ0J4QixNQUFNeUIsaUJBQWlCSixHQUFHOEMsTUFBTTtBQUNoRDdFLFVBQUkwRixPQUFPeEQsY0FBY1csR0FBR1gsY0FBY2EsQ0FBQztJQUM1QztFQUNGO0FBQ0Y7QUFFRCxTQUFTNEMsZUFBZWpGLE9BQU9rRixjQUFjZixRQUFRZCxZQUFZOEIsWUFBWTtBQUMzRSxRQUFNN0YsTUFBTVUsTUFBTVY7QUFDbEIsUUFBTW9GLFdBQVdRLGFBQWFSO0FBRTlCLFFBQU0sRUFBQ0gsT0FBQUEsUUFBT2EsVUFBUyxJQUFJRjtBQUUzQixNQUFJLENBQUVSLFlBQVksQ0FBQ3JCLGNBQWUsQ0FBQ2tCLFVBQVMsQ0FBQ2EsYUFBYWpCLFNBQVMsR0FBRztBQUNwRTtFQUNEO0FBRUQ3RSxNQUFJK0YsS0FBSTtBQUNSL0YsTUFBSWdHLGNBQWNmO0FBQ2xCakYsTUFBSThGLFlBQVlBO0FBQ2hCOUYsTUFBSWlHLFlBQVlKLFdBQVdLLElBQUk7QUFDL0JsRyxNQUFJbUcsaUJBQWlCTixXQUFXTztBQUVoQ3BHLE1BQUkyRSxVQUFTO0FBQ2JRLGlCQUFlekUsT0FBT21FLFFBQVFPLFVBQVVyQixVQUFVO0FBQ2xEL0QsTUFBSXFHLFVBQVM7QUFDYnJHLE1BQUlzRyxPQUFNO0FBQ1Z0RyxNQUFJdUcsUUFBTztBQUNaO0FBRUQsU0FBU0Msd0JBQXdCQyxRQUFROVIsT0FBT0ksT0FBTztBQUNyRCxTQUFPMlIsY0FBY0QsUUFBUTtJQUMzQjFSO0lBQ0FKO0lBQ0FnUyxNQUFNO0VBQ1AsQ0FBQTtBQUNGO0FBRWMsSUFBTUMsb0JBQU4sY0FBZ0MxTCxnQkFBZTtFQTBFNURqRixZQUFZQyxLQUFLO0FBQ2YsVUFBTUEsR0FBRztBQUdULFNBQUtvUCxVQUFVbFA7QUFFZixTQUFLbVAsVUFBVW5QO0FBRWYsU0FBS2dNLGNBQWNoTTtBQUVuQixTQUFLcUwsZUFBZSxDQUFBO0FBQ3BCLFNBQUt5QixtQkFBbUIsQ0FBQTtFQUN6QjtFQUVEMkQsZ0JBQWdCO0FBRWQsVUFBTW5ILFVBQVUsS0FBS29CLFdBQVduQixVQUFVSCxzQkFBc0IsS0FBS25JLE9BQU8sSUFBSSxDQUFDO0FBQ2pGLFVBQU02SSxJQUFJLEtBQUsvQyxRQUFRLEtBQUsySixXQUFXcEgsUUFBUXZDO0FBQy9DLFVBQU1rRCxLQUFJLEtBQUtqRCxTQUFTLEtBQUsySixZQUFZckgsUUFBUXRDO0FBQ2pELFNBQUtrSSxVQUFVN1AsS0FBSzBFLE1BQU0sS0FBSzBHLE9BQU9YLElBQUksSUFBSVIsUUFBUW1CLElBQUk7QUFDMUQsU0FBSzBFLFVBQVU5UCxLQUFLMEUsTUFBTSxLQUFLK0csTUFBTWIsS0FBSSxJQUFJWCxRQUFRd0IsR0FBRztBQUN4RCxTQUFLa0IsY0FBYzNNLEtBQUswRSxNQUFNMUUsS0FBSzBCLElBQUkrSSxHQUFHRyxFQUFDLElBQUksQ0FBQztFQUNqRDtFQUVEdEosc0JBQXNCO0FBQ3BCLFVBQU0sRUFBQ0ksS0FBSzVCLElBQUcsSUFBSSxLQUFLNkIsVUFBVSxLQUFLO0FBRXZDLFNBQUtELE1BQU1OLGVBQVNNLEdBQUcsS0FBSyxDQUFDbkMsTUFBTW1DLEdBQUcsSUFBSUEsTUFBTTtBQUNoRCxTQUFLNUIsTUFBTXNCLGVBQVN0QixHQUFHLEtBQUssQ0FBQ1AsTUFBTU8sR0FBRyxJQUFJQSxNQUFNO0FBR2hELFNBQUtnRyx1QkFBc0I7RUFDNUI7RUFNRGUsbUJBQW1CO0FBQ2pCLFdBQU83RyxLQUFLeUUsS0FBSyxLQUFLa0ksY0FBYzVDLHNCQUFzQixLQUFLbkksT0FBTyxDQUFDO0VBQ3hFO0VBRUQyUCxtQkFBbUJ2UCxPQUFPO0FBQ3hCeUQsb0JBQWdCNkQsVUFBVWlJLG1CQUFtQnBQLEtBQUssTUFBTUgsS0FBSztBQUc3RCxTQUFLZ0ssZUFBZSxLQUFLNUwsVUFBUyxFQUMvQm9SLElBQUksQ0FBQ3JSLE9BQU9qQixVQUFVO0FBQ3JCLFlBQU1JLFFBQVFtUyxTQUFhLEtBQUs3UCxRQUFRc0ssWUFBWWhKLFVBQVU7UUFBQy9DO1FBQU9qQjtTQUFRLElBQUk7QUFDbEYsYUFBT0ksU0FBU0EsVUFBVSxJQUFJQSxRQUFRO0lBQ3ZDLENBQUEsRUFDQW9TLE9BQU8sQ0FBQ3pMLEdBQUdxRyxNQUFNLEtBQUtoRixNQUFNcUssa0JBQWtCckYsQ0FBQyxDQUFDO0VBQ3BEO0VBRURzRixNQUFNO0FBQ0osVUFBTTdLLE9BQU8sS0FBS25GO0FBRWxCLFFBQUltRixLQUFLaUQsV0FBV2pELEtBQUttRixZQUFZbEMsU0FBUztBQUM1Q2dCLHlCQUFtQixJQUFJO1dBQ2xCO0FBQ0wsV0FBS3dDLGVBQWUsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUMvQjtFQUNGO0VBRURBLGVBQWVxRSxjQUFjQyxlQUFlQyxhQUFhQyxnQkFBZ0I7QUFDdkUsU0FBS25DLFdBQVc3UCxLQUFLMEUsT0FBT21OLGVBQWVDLGlCQUFpQixDQUFDO0FBQzdELFNBQUtoQyxXQUFXOVAsS0FBSzBFLE9BQU9xTixjQUFjQyxrQkFBa0IsQ0FBQztBQUM3RCxTQUFLckYsZUFBZTNNLEtBQUswQixJQUFJLEtBQUtpTCxjQUFjLEdBQUczTSxLQUFLRixJQUFJK1IsY0FBY0MsZUFBZUMsYUFBYUMsY0FBYyxDQUFDO0VBQ3RIO0VBRUQvRSxjQUFjL04sT0FBTztBQUNuQixVQUFNK1Msa0JBQWtCbEMsT0FBTyxLQUFLL0QsYUFBYTNMLFVBQVU7QUFDM0QsVUFBTTZSLGFBQWEsS0FBS3RRLFFBQVFzUSxjQUFjO0FBRTlDLFdBQU9sRixnQkFBZ0I5TixRQUFRK1Msa0JBQWtCNU0sVUFBVTZNLFVBQVUsQ0FBQztFQUN2RTtFQUVEQyw4QkFBOEJoUyxPQUFPO0FBQ25DLFFBQUlnQixjQUFjaEIsS0FBSyxHQUFHO0FBQ3hCLGFBQU9xQztJQUNSO0FBR0QsVUFBTTRQLGdCQUFnQixLQUFLekYsZUFBZSxLQUFLN00sTUFBTSxLQUFLNEI7QUFDMUQsUUFBSSxLQUFLRSxRQUFRd0YsU0FBUztBQUN4QixjQUFRLEtBQUt0SCxNQUFNSyxTQUFTaVM7SUFDN0I7QUFDRCxZQUFRalMsUUFBUSxLQUFLdUIsT0FBTzBRO0VBQzdCO0VBRURDLDhCQUE4QkMsVUFBVTtBQUN0QyxRQUFJblIsY0FBY21SLFFBQVEsR0FBRztBQUMzQixhQUFPOVA7SUFDUjtBQUVELFVBQU0rUCxpQkFBaUJELFlBQVksS0FBSzNGLGVBQWUsS0FBSzdNLE1BQU0sS0FBSzRCO0FBQ3ZFLFdBQU8sS0FBS0UsUUFBUXdGLFVBQVUsS0FBS3RILE1BQU15UyxpQkFBaUIsS0FBSzdRLE1BQU02UTtFQUN0RTtFQUVEL0YscUJBQXFCdE4sT0FBTztBQUMxQixVQUFNZ04sY0FBYyxLQUFLRixnQkFBZ0IsQ0FBQTtBQUV6QyxRQUFJOU0sU0FBUyxLQUFLQSxRQUFRZ04sWUFBWTdMLFFBQVE7QUFDNUMsWUFBTW1TLGFBQWF0RyxZQUFZaE47QUFDL0IsYUFBTzZSLHdCQUF3QixLQUFLMEIsV0FBVSxHQUFJdlQsT0FBT3NULFVBQVU7SUFDcEU7RUFDRjtFQUVEOUYsaUJBQWlCeE4sT0FBT3dULG9CQUFvQnZHLGtCQUFrQixHQUFHO0FBQy9ELFVBQU1yQixRQUFRLEtBQUttQyxjQUFjL04sS0FBSyxJQUFJNk8sVUFBVTVCO0FBQ3BELFdBQU87TUFDTGlCLEdBQUdwTixLQUFLd0YsSUFBSXNGLEtBQUssSUFBSTRILHFCQUFxQixLQUFLN0M7TUFDL0N2QyxHQUFHdE4sS0FBS3VGLElBQUl1RixLQUFLLElBQUk0SCxxQkFBcUIsS0FBSzVDO01BQy9DaEY7O0VBRUg7RUFFRDZILHlCQUF5QnpULE9BQU9pQixPQUFPO0FBQ3JDLFdBQU8sS0FBS3VNLGlCQUFpQnhOLE9BQU8sS0FBS2lULDhCQUE4QmhTLEtBQUssQ0FBQztFQUM5RTtFQUVEeVMsZ0JBQWdCMVQsT0FBTztBQUNyQixXQUFPLEtBQUt5VCx5QkFBeUJ6VCxTQUFTLEdBQUcsS0FBSzJULGFBQVksQ0FBRTtFQUNyRTtFQUVEQyxzQkFBc0I1VCxPQUFPO0FBQzNCLFVBQU0sRUFBQ2tNLE1BQU1LLEtBQUtGLE9BQU94SSxPQUFNLElBQUksS0FBSzBLLGlCQUFpQnZPO0FBQ3pELFdBQU87TUFDTGtNO01BQ0FLO01BQ0FGO01BQ0F4STs7RUFFSDtFQUtEZ1EsaUJBQWlCO0FBQ2YsVUFBTSxFQUFDQyxpQkFBaUJDLE1BQU0sRUFBQ3RELFNBQVEsRUFBQyxJQUFJLEtBQUsvTjtBQUNqRCxRQUFJb1IsaUJBQWlCO0FBQ25CLFlBQU16SSxNQUFNLEtBQUtBO0FBQ2pCQSxVQUFJK0YsS0FBSTtBQUNSL0YsVUFBSTJFLFVBQVM7QUFDYlEscUJBQWUsTUFBTSxLQUFLeUMsOEJBQThCLEtBQUt2TSxTQUFTLEdBQUcrSixVQUFVLEtBQUszRCxhQUFhM0wsTUFBTTtBQUMzR2tLLFVBQUlxRyxVQUFTO0FBQ2JyRyxVQUFJb0UsWUFBWXFFO0FBQ2hCekksVUFBSThFLEtBQUk7QUFDUjlFLFVBQUl1RyxRQUFPO0lBQ1o7RUFDRjtFQUtEb0MsV0FBVztBQUNULFVBQU0zSSxNQUFNLEtBQUtBO0FBQ2pCLFVBQU14RCxPQUFPLEtBQUtuRjtBQUNsQixVQUFNLEVBQUN1UixZQUFZRixNQUFNRyxPQUFNLElBQUlyTTtBQUNuQyxVQUFNdUgsYUFBYSxLQUFLdEMsYUFBYTNMO0FBRXJDLFFBQUlpTSxHQUFHdkssUUFBUXNSO0FBRWYsUUFBSXRNLEtBQUttRixZQUFZbEMsU0FBUztBQUM1QnFFLHNCQUFnQixNQUFNQyxVQUFVO0lBQ2pDO0FBRUQsUUFBSTJFLEtBQUtqSixTQUFTO0FBQ2hCLFdBQUtoSSxNQUFNc1IsUUFBUSxDQUFDQyxNQUFNclUsVUFBVTtBQUNsQyxZQUFJQSxVQUFVLEdBQUc7QUFDZjZDLG1CQUFTLEtBQUtvUSw4QkFBOEJvQixLQUFLcFQsS0FBSztBQUN0RCxnQkFBTXFULFVBQVUsS0FBS2YsV0FBV3ZULEtBQUs7QUFDckMsZ0JBQU1xUCxjQUFjMEUsS0FBSzFHLFdBQVdpSCxPQUFPO0FBQzNDLGdCQUFNQyxvQkFBb0JMLE9BQU83RyxXQUFXaUgsT0FBTztBQUVuRHRELHlCQUFlLE1BQU0zQixhQUFheE0sUUFBUXVNLFlBQVltRixpQkFBaUI7UUFDeEU7TUFDRixDQUFBO0lBQ0Y7QUFFRCxRQUFJTixXQUFXbkosU0FBUztBQUN0Qk8sVUFBSStGLEtBQUk7QUFFUixXQUFLaEUsSUFBSWdDLGFBQWEsR0FBR2hDLEtBQUssR0FBR0EsS0FBSztBQUNwQyxjQUFNaUMsY0FBYzRFLFdBQVc1RyxXQUFXLEtBQUtDLHFCQUFxQkYsQ0FBQyxDQUFDO0FBQ3RFLGNBQU0sRUFBQ2tELE9BQUFBLFFBQU9hLFVBQVMsSUFBSTlCO0FBRTNCLFlBQUksQ0FBQzhCLGFBQWEsQ0FBQ2IsUUFBTztBQUN4QjtRQUNEO0FBRURqRixZQUFJOEYsWUFBWUE7QUFDaEI5RixZQUFJZ0csY0FBY2Y7QUFFbEJqRixZQUFJaUcsWUFBWWpDLFlBQVltRixVQUFVO0FBQ3RDbkosWUFBSW1HLGlCQUFpQm5DLFlBQVlvRjtBQUVqQzVSLGlCQUFTLEtBQUtvUSw4QkFBOEJwTCxLQUFLL0UsTUFBTW9GLFVBQVUsS0FBSzFGLE1BQU0sS0FBSzVCLEdBQUc7QUFDcEZ1VCxtQkFBVyxLQUFLM0csaUJBQWlCSixHQUFHdkssTUFBTTtBQUMxQ3dJLFlBQUkyRSxVQUFTO0FBQ2IzRSxZQUFJeUYsT0FBTyxLQUFLSCxTQUFTLEtBQUtDLE9BQU87QUFDckN2RixZQUFJMEYsT0FBT29ELFNBQVNqRyxHQUFHaUcsU0FBUy9GLENBQUM7QUFDakMvQyxZQUFJc0csT0FBTTtNQUNYO0FBRUR0RyxVQUFJdUcsUUFBTztJQUNaO0VBQ0Y7RUFLRDhDLGFBQWE7RUFBQTtFQUtiQyxhQUFhO0FBQ1gsVUFBTXRKLE1BQU0sS0FBS0E7QUFDakIsVUFBTXhELE9BQU8sS0FBS25GO0FBQ2xCLFVBQU00RSxXQUFXTyxLQUFLL0U7QUFFdEIsUUFBSSxDQUFDd0UsU0FBU3dELFNBQVM7QUFDckI7SUFDRDtBQUVELFVBQU1rSSxhQUFhLEtBQUtqRixjQUFjLENBQUM7QUFDdkMsUUFBSWxMLFFBQVEyRjtBQUVaNkMsUUFBSStGLEtBQUk7QUFDUi9GLFFBQUl1SixVQUFVLEtBQUtqRSxTQUFTLEtBQUtDLE9BQU87QUFDeEN2RixRQUFJd0osT0FBTzdCLFVBQVU7QUFDckIzSCxRQUFJMEQsWUFBWTtBQUNoQjFELFFBQUlrRixlQUFlO0FBRW5CLFNBQUt6TixNQUFNc1IsUUFBUSxDQUFDQyxNQUFNclUsVUFBVTtBQUNsQyxVQUFJQSxVQUFVLEtBQUssQ0FBQzZILEtBQUtLLFNBQVM7QUFDaEM7TUFDRDtBQUVELFlBQU1tSCxjQUFjL0gsU0FBUytGLFdBQVcsS0FBS2tHLFdBQVd2VCxLQUFLLENBQUM7QUFDOUQsWUFBTTBJLFdBQVdpRixPQUFPMEIsWUFBWW5FLElBQUk7QUFDeENySSxlQUFTLEtBQUtvUSw4QkFBOEIsS0FBS25RLE1BQU05QyxPQUFPaUIsS0FBSztBQUVuRSxVQUFJb08sWUFBWXlGLG1CQUFtQjtBQUNqQ3pKLFlBQUlILE9BQU94QyxTQUFTK0M7QUFDcEJqRCxnQkFBUTZDLElBQUkwSixZQUFZVixLQUFLalUsS0FBSyxFQUFFb0k7QUFDcEM2QyxZQUFJb0UsWUFBWUosWUFBWUM7QUFFNUIsY0FBTXZFLFVBQVVDLFVBQVVxRSxZQUFZcEUsZUFBZTtBQUNyREksWUFBSStFLFNBQ0YsQ0FBQzVILFFBQVEsSUFBSXVDLFFBQVFtQixNQUNyQixDQUFDckosU0FBUzZGLFNBQVN5QyxPQUFPLElBQUlKLFFBQVF3QixLQUN0Qy9ELFFBQVF1QyxRQUFRdkMsT0FDaEJFLFNBQVN5QyxPQUFPSixRQUFRdEMsTUFBTTtNQUVqQztBQUVENEgsaUJBQVdoRixLQUFLZ0osS0FBS2pVLE9BQU8sR0FBRyxDQUFDeUMsUUFBUTZGLFVBQVU7UUFDaEQ0SCxPQUFPakIsWUFBWWlCO01BQ3BCLENBQUE7SUFDRixDQUFBO0FBRURqRixRQUFJdUcsUUFBTztFQUNaO0VBS0RvRCxZQUFZO0VBQUE7O0FBclZaLGNBRm1CL0MsbUJBRVpuTyxNQUFLO0FBS1osY0FQbUJtTyxtQkFPWmxPLFlBQVc7RUFDaEIrRyxTQUFTO0VBR1RtSyxTQUFTO0VBQ1RkLFVBQVU7RUFFVkYsWUFBWTtJQUNWbkosU0FBUztJQUNUcUcsV0FBVztJQUNYcUQsWUFBWSxDQUFBO0lBQ1pDLGtCQUFrQjtFQUNuQjtFQUVEVixNQUFNO0lBQ0p0RCxVQUFVO0VBQ1g7RUFFRHVDLFlBQVk7RUFHWmxRLE9BQU87SUFFTGdTLG1CQUFtQjtJQUVuQjlRLFVBQVU2RSxNQUFNQyxXQUFXQztFQUM1QjtFQUVEaUUsYUFBYTtJQUNYc0MsZUFBZTdOO0lBR2Z3SixpQkFBaUI7SUFHakJILFNBQVM7SUFHVEksTUFBTTtNQUNKQyxNQUFNO0lBQ1A7SUFHRG5ILFNBQVM1RCxPQUFPO0FBQ2QsYUFBT0E7SUFDUjtJQUdEMkssU0FBUztJQUdUbUMsbUJBQW1CO0VBQ3BCOztBQUdILGNBOURtQitFLG1CQThEWmlELGlCQUFnQjtFQUNyQixvQkFBb0I7RUFDcEIscUJBQXFCO0VBQ3JCLGVBQWU7O0FBR2pCLGNBcEVtQmpELG1CQW9FWmtELGVBQWM7RUFDbkJsQixZQUFZO0lBQ1ZtQixXQUFXO0VBQ1o7O0FDaldMLElBQU1DLFlBQVk7RUFDaEJDLGFBQWE7SUFBQ0MsUUFBUTtJQUFNcEssTUFBTTtJQUFHNUIsT0FBTztFQUFLO0VBQ2pEaU0sUUFBUTtJQUFDRCxRQUFRO0lBQU1wSyxNQUFNO0lBQU01QixPQUFPO0VBQUc7RUFDN0NrTSxRQUFRO0lBQUNGLFFBQVE7SUFBTXBLLE1BQU07SUFBTzVCLE9BQU87RUFBRztFQUM5Q21NLE1BQU07SUFBQ0gsUUFBUTtJQUFNcEssTUFBTTtJQUFTNUIsT0FBTztFQUFHO0VBQzlDb00sS0FBSztJQUFDSixRQUFRO0lBQU1wSyxNQUFNO0lBQVU1QixPQUFPO0VBQUc7RUFDOUNxTSxNQUFNO0lBQUNMLFFBQVE7SUFBT3BLLE1BQU07SUFBVzVCLE9BQU87RUFBRTtFQUNoRHNNLE9BQU87SUFBQ04sUUFBUTtJQUFNcEssTUFBTTtJQUFTNUIsT0FBTztFQUFHO0VBQy9DdU0sU0FBUztJQUFDUCxRQUFRO0lBQU9wSyxNQUFNO0lBQVM1QixPQUFPO0VBQUU7RUFDakR3TSxNQUFNO0lBQUNSLFFBQVE7SUFBTXBLLE1BQU07RUFBUzs7QUFNdEMsSUFBTTZLLFFBQTZDdEosdUJBQU91SixLQUFLWixTQUFTO0FBTXhFLFNBQVNhLE9BQU9DLEdBQUczSixHQUFHO0FBQ3BCLFNBQU8ySixJQUFJM0o7QUFDWjtBQU9ELFNBQVN4SyxNQUFNK0osT0FBT3FLLE9BQU87QUFDM0IsTUFBSW5VLGNBQWNtVSxLQUFLLEdBQUc7QUFDeEIsV0FBTztFQUNSO0FBRUQsUUFBTUMsVUFBVXRLLE1BQU11SztBQUN0QixRQUFNLEVBQUNDLFFBQVF4VixPQUFBQSxRQUFPeVYsV0FBVSxJQUFJekssTUFBTTBLO0FBQzFDLE1BQUl4VixRQUFRbVY7QUFFWixNQUFJLE9BQU9HLFdBQVcsWUFBWTtBQUNoQ3RWLFlBQVFzVixPQUFPdFYsS0FBSztFQUNyQjtBQUdELE1BQUksQ0FBQ2lCLGVBQVNqQixLQUFLLEdBQUc7QUFDcEJBLFlBQVEsT0FBT3NWLFdBQVcsV0FDdEJGLFFBQVFyVSxNQUFNZixPQUE0QnNWLE1BQU0sSUFDaERGLFFBQVFyVSxNQUFNZixLQUFLO0VBQ3hCO0FBRUQsTUFBSUEsVUFBVSxNQUFNO0FBQ2xCLFdBQU87RUFDUjtBQUVELE1BQUlGLFFBQU87QUFDVEUsWUFBUUYsV0FBVSxXQUFXMlYsU0FBU0YsVUFBVSxLQUFLQSxlQUFlLFFBQ2hFSCxRQUFRTSxRQUFRMVYsT0FBTyxXQUFXdVYsVUFBVSxJQUM1Q0gsUUFBUU0sUUFBUTFWLE9BQU9GLE1BQUs7RUFDakM7QUFFRCxTQUFPLENBQUNFO0FBQ1Q7QUFVRCxTQUFTMlYsMEJBQTBCQyxTQUFTclUsS0FBSzVCLEtBQUtrVyxVQUFVO0FBQzlELFFBQU1DLE9BQU9mLE1BQU03VTtBQUVuQixXQUFTaU0sSUFBSTRJLE1BQU14VixRQUFRcVcsT0FBTyxHQUFHekosSUFBSTJKLE9BQU8sR0FBRyxFQUFFM0osR0FBRztBQUN0RCxVQUFNNEosV0FBVzNCLFVBQVVXLE1BQU01STtBQUNqQyxVQUFNakksU0FBUzZSLFNBQVN6TixRQUFReU4sU0FBU3pOLFFBQVE1QyxPQUFPc1E7QUFFeEQsUUFBSUQsU0FBU3pCLFVBQVV6VSxLQUFLeUUsTUFBTTNFLE1BQU00QixRQUFRMkMsU0FBUzZSLFNBQVM3TCxLQUFLLEtBQUsyTCxVQUFVO0FBQ3BGLGFBQU9kLE1BQU01STtJQUNkO0VBQ0Y7QUFFRCxTQUFPNEksTUFBTWUsT0FBTztBQUNyQjtBQVdELFNBQVNHLDJCQUEyQm5MLE9BQU9vTCxVQUFVTixTQUFTclUsS0FBSzVCLEtBQUs7QUFDdEUsV0FBU3dNLElBQUk0SSxNQUFNN1UsU0FBUyxHQUFHaU0sS0FBSzRJLE1BQU14VixRQUFRcVcsT0FBTyxHQUFHekosS0FBSztBQUMvRCxVQUFNekksT0FBT3FSLE1BQU01STtBQUNuQixRQUFJaUksVUFBVTFRLE1BQU00USxVQUFVeEosTUFBTXVLLFNBQVNjLEtBQUt4VyxLQUFLNEIsS0FBS21DLElBQUksS0FBS3dTLFdBQVcsR0FBRztBQUNqRixhQUFPeFM7SUFDUjtFQUNGO0FBRUQsU0FBT3FSLE1BQU1hLFVBQVViLE1BQU14VixRQUFRcVcsT0FBTyxJQUFJO0FBQ2pEO0FBTUQsU0FBU1EsbUJBQW1CMVMsTUFBTTtBQUNoQyxXQUFTeUksSUFBSTRJLE1BQU14VixRQUFRbUUsSUFBSSxJQUFJLEdBQUdvUyxPQUFPZixNQUFNN1UsUUFBUWlNLElBQUkySixNQUFNLEVBQUUzSixHQUFHO0FBQ3hFLFFBQUlpSSxVQUFVVyxNQUFNNUksSUFBSW1JLFFBQVE7QUFDOUIsYUFBT1MsTUFBTTVJO0lBQ2Q7RUFDRjtBQUNGO0FBT0QsU0FBU2tLLFFBQVF4VSxPQUFPeVUsTUFBTUMsWUFBWTtBQUN4QyxNQUFJLENBQUNBLFlBQVk7QUFDZjFVLFVBQU15VSxRQUFRO0VBQ2YsV0FBVUMsV0FBV3JXLFFBQVE7QUFDNUIsVUFBTSxFQUFDc1csSUFBSUMsR0FBRSxJQUFJQyxRQUFRSCxZQUFZRCxJQUFJO0FBQ3pDLFVBQU1LLFlBQVlKLFdBQVdDLE9BQU9GLE9BQU9DLFdBQVdDLE1BQU1ELFdBQVdFO0FBQ3ZFNVUsVUFBTThVLGFBQWE7RUFDcEI7QUFDRjtBQVNELFNBQVNDLGNBQWM5TCxPQUFPakosT0FBT3dQLE1BQUt3RixXQUFXO0FBQ25ELFFBQU16QixVQUFVdEssTUFBTXVLO0FBQ3RCLFFBQU0vVixRQUFRLENBQUM4VixRQUFRTSxRQUFRN1QsTUFBTSxHQUFHN0IsT0FBTzZXLFNBQVM7QUFDeEQsUUFBTXJYLE9BQU9xQyxNQUFNQSxNQUFNM0IsU0FBUyxHQUFHRjtBQUNyQyxNQUFJZ0osT0FBT2pLO0FBRVgsT0FBS2lLLFFBQVExSixPQUFPMEosU0FBU3hKLE1BQU13SixRQUFRLENBQUNvTSxRQUFRMEIsSUFBSTlOLE9BQU8sR0FBRzZOLFNBQVMsR0FBRztBQUM1RTlYLFlBQVFzUyxLQUFJckk7QUFDWixRQUFJakssU0FBUyxHQUFHO0FBQ2Q4QyxZQUFNOUMsT0FBT2lLLFFBQVE7SUFDdEI7RUFDRjtBQUNELFNBQU9uSDtBQUNSO0FBUUQsU0FBU2tWLG9CQUFvQmpNLE9BQU8rRCxRQUFRZ0ksV0FBVztBQUNyRCxRQUFNaFYsUUFBUSxDQUFBO0FBRWQsUUFBTXdQLE9BQU0sQ0FBQTtBQUNaLFFBQU15RSxPQUFPakgsT0FBTzNPO0FBQ3BCLE1BQUlpTSxHQUFHbk07QUFFUCxPQUFLbU0sSUFBSSxHQUFHQSxJQUFJMkosTUFBTSxFQUFFM0osR0FBRztBQUN6Qm5NLFlBQVE2TyxPQUFPMUM7QUFDZmtGLElBQUFBLEtBQUlyUixTQUFTbU07QUFFYnRLLFVBQU01QyxLQUFLO01BQ1RlO01BQ0FnSixPQUFPO0lBQ1IsQ0FBQTtFQUNGO0FBSUQsU0FBUThNLFNBQVMsS0FBSyxDQUFDZSxZQUFhaFYsUUFBUStVLGNBQWM5TCxPQUFPakosT0FBT3dQLE1BQUt3RixTQUFTO0FBQ3ZGO0FBRWMsSUFBTUcsWUFBTixjQUF3QjVXLE1BQUs7RUFnRDFDQyxZQUFZNFcsT0FBTztBQUNqQixVQUFNQSxLQUFLO0FBR1gsU0FBS0MsU0FBUztNQUNaQyxNQUFNLENBQUE7TUFDTnRZLFFBQVEsQ0FBQTtNQUNSdVksS0FBSyxDQUFBOztBQUlQLFNBQUtDLFFBQVE7QUFFYixTQUFLQyxhQUFhOVc7QUFDbEIsU0FBSytXLFdBQVcsQ0FBQTtBQUNoQixTQUFLQyxjQUFjO0FBQ25CLFNBQUtoQyxhQUFhaFY7RUFDbkI7RUFFREcsS0FBSzhXLFdBQVc3USxPQUFPLENBQUEsR0FBSTtBQUN6QixVQUFNMFAsT0FBT21CLFVBQVVuQixTQUFTbUIsVUFBVW5CLE9BQU8sQ0FBQTtBQUVqRCxVQUFNbEIsVUFBVSxLQUFLQyxXQUFXLElBQUlxQyxTQUFTQyxNQUFNRixVQUFVQyxTQUFTRSxJQUFJO0FBRTFFeEMsWUFBUXpVLEtBQUtpRyxJQUFJO0FBTWpCaVIsWUFBUXZCLEtBQUt3QixnQkFBZ0IxQyxRQUFRMkMsUUFBTyxDQUFFO0FBRTlDLFNBQUt2QyxhQUFhO01BQ2hCRixRQUFRZ0IsS0FBS2hCO01BQ2J4VixPQUFPd1csS0FBS3hXO01BQ1p5VixZQUFZZSxLQUFLZjs7QUFHbkIsVUFBTTVVLEtBQUs4VyxTQUFTO0FBRXBCLFNBQUtELGNBQWM1USxLQUFLb1I7RUFDekI7RUFPRGpYLE1BQU1qQyxLQUFLQyxPQUFPO0FBQ2hCLFFBQUlELFFBQVEwQixRQUFXO0FBQ3JCLGFBQU87SUFDUjtBQUNELFdBQU9PLE1BQU0sTUFBTWpDLEdBQUc7RUFDdkI7RUFFRG1aLGVBQWU7QUFDYixVQUFNQSxhQUFZO0FBQ2xCLFNBQUtmLFNBQVM7TUFDWkMsTUFBTSxDQUFBO01BQ050WSxRQUFRLENBQUE7TUFDUnVZLEtBQUssQ0FBQTs7RUFFUjtFQUVEalcsc0JBQXNCO0FBQ3BCLFVBQU1NLFVBQVUsS0FBS0E7QUFDckIsVUFBTTJULFVBQVUsS0FBS0M7QUFDckIsVUFBTTNSLE9BQU9qQyxRQUFRNlUsS0FBSzVTLFFBQVE7QUFFbEMsUUFBSSxFQUFDbkMsS0FBSzVCLEtBQUt5QixZQUFZQyxXQUFVLElBQUksS0FBS0MsY0FBYTtBQUszRCxhQUFTNFcsYUFBYXhXLFFBQVE7QUFDNUIsVUFBSSxDQUFDTixjQUFjLENBQUNoQyxNQUFNc0MsT0FBT0gsR0FBRyxHQUFHO0FBQ3JDQSxjQUFNMUIsS0FBSzBCLElBQUlBLEtBQUtHLE9BQU9ILEdBQUc7TUFDL0I7QUFDRCxVQUFJLENBQUNGLGNBQWMsQ0FBQ2pDLE1BQU1zQyxPQUFPL0IsR0FBRyxHQUFHO0FBQ3JDQSxjQUFNRSxLQUFLRixJQUFJQSxLQUFLK0IsT0FBTy9CLEdBQUc7TUFDL0I7SUFDRjtBQUdELFFBQUksQ0FBQ3lCLGNBQWMsQ0FBQ0MsWUFBWTtBQUU5QjZXLG1CQUFhLEtBQUtDLGdCQUFlLENBQUU7QUFJbkMsVUFBSTFXLFFBQVFDLFdBQVcsV0FBV0QsUUFBUUksTUFBTXVXLFdBQVcsVUFBVTtBQUNuRUYscUJBQWEsS0FBSzFXLFVBQVUsS0FBSyxDQUFDO01BQ25DO0lBQ0Y7QUFFREQsVUFBTU4sZUFBU00sR0FBRyxLQUFLLENBQUNuQyxNQUFNbUMsR0FBRyxJQUFJQSxNQUFNLENBQUM2VCxRQUFRTSxRQUFRMkMsS0FBS0MsSUFBRyxHQUFJNVUsSUFBSTtBQUM1RS9ELFVBQU1zQixlQUFTdEIsR0FBRyxLQUFLLENBQUNQLE1BQU1PLEdBQUcsSUFBSUEsTUFBTSxDQUFDeVYsUUFBUW1ELE1BQU1GLEtBQUtDLElBQUcsR0FBSTVVLElBQUksSUFBSTtBQUc5RSxTQUFLbkMsTUFBTTFCLEtBQUswQixJQUFJQSxLQUFLNUIsTUFBTSxDQUFDO0FBQ2hDLFNBQUtBLE1BQU1FLEtBQUtGLElBQUk0QixNQUFNLEdBQUc1QixHQUFHO0VBQ2pDO0VBS0R3WSxrQkFBa0I7QUFDaEIsVUFBTUssTUFBTSxLQUFLQyxtQkFBa0I7QUFDbkMsUUFBSWxYLE1BQU1tRSxPQUFPaUI7QUFDakIsUUFBSWhILE1BQU0rRixPQUFPZ1Q7QUFFakIsUUFBSUYsSUFBSXRZLFFBQVE7QUFDZHFCLFlBQU1pWCxJQUFJO0FBQ1Y3WSxZQUFNNlksSUFBSUEsSUFBSXRZLFNBQVM7SUFDeEI7QUFDRCxXQUFPO01BQUNxQjtNQUFLNUI7O0VBQ2Q7RUFLRGdDLGFBQWE7QUFDWCxVQUFNRixVQUFVLEtBQUtBO0FBQ3JCLFVBQU1rWCxXQUFXbFgsUUFBUTZVO0FBQ3pCLFVBQU1qUSxXQUFXNUUsUUFBUUk7QUFDekIsVUFBTTBVLGFBQWFsUSxTQUFTK1IsV0FBVyxXQUFXLEtBQUtLLG1CQUFrQixJQUFLLEtBQUtHLFVBQVM7QUFFNUYsUUFBSW5YLFFBQVFDLFdBQVcsV0FBVzZVLFdBQVdyVyxRQUFRO0FBQ25ELFdBQUtxQixNQUFNLEtBQUtnSSxZQUFZZ04sV0FBVztBQUN2QyxXQUFLNVcsTUFBTSxLQUFLNkosWUFBWStNLFdBQVdBLFdBQVdyVyxTQUFTO0lBQzVEO0FBRUQsVUFBTXFCLE1BQU0sS0FBS0E7QUFDakIsVUFBTTVCLE1BQU0sS0FBS0E7QUFFakIsVUFBTWtDLFFBQVFnWCxlQUFldEMsWUFBWWhWLEtBQUs1QixHQUFHO0FBS2pELFNBQUswWCxRQUFRc0IsU0FBU2pWLFNBQVMyQyxTQUFTeVMsV0FDcENuRCwwQkFBMEJnRCxTQUFTL0MsU0FBUyxLQUFLclUsS0FBSyxLQUFLNUIsS0FBSyxLQUFLb1osa0JBQWtCeFgsR0FBRyxDQUFDLElBQzNGMFUsMkJBQTJCLE1BQU1wVSxNQUFNM0IsUUFBUXlZLFNBQVMvQyxTQUFTLEtBQUtyVSxLQUFLLEtBQUs1QixHQUFHO0FBQ3ZGLFNBQUsyWCxhQUFhLENBQUNqUixTQUFTMkMsTUFBTVcsV0FBVyxLQUFLME4sVUFBVSxTQUFTN1csU0FDakU0VixtQkFBbUIsS0FBS2lCLEtBQUs7QUFDakMsU0FBSzJCLFlBQVl6QyxVQUFVO0FBRTNCLFFBQUk5VSxRQUFRd0YsU0FBUztBQUNuQnBGLFlBQU1vRixRQUFPO0lBQ2Q7QUFFRCxXQUFPOFAsb0JBQW9CLE1BQU1sVixPQUFPLEtBQUt5VixVQUFVO0VBQ3hEO0VBRUQyQixnQkFBZ0I7QUFHZCxRQUFJLEtBQUt4WCxRQUFReVgscUJBQXFCO0FBQ3BDLFdBQUtGLFlBQVksS0FBS25YLE1BQU13UCxJQUFJK0IsQ0FBQUEsU0FBUSxDQUFDQSxLQUFLcFQsS0FBSyxDQUFDO0lBQ3JEO0VBQ0Y7RUFVRGdaLFlBQVl6QyxhQUFhLENBQUEsR0FBSTtBQUMzQixRQUFJaFIsUUFBUTtBQUNaLFFBQUlDLE1BQU07QUFDVixRQUFJbEcsT0FBT0U7QUFFWCxRQUFJLEtBQUtpQyxRQUFRRyxVQUFVMlUsV0FBV3JXLFFBQVE7QUFDNUNaLGNBQVEsS0FBSzZaLG1CQUFtQjVDLFdBQVcsRUFBRTtBQUM3QyxVQUFJQSxXQUFXclcsV0FBVyxHQUFHO0FBQzNCcUYsZ0JBQVEsSUFBSWpHO2FBQ1A7QUFDTGlHLGlCQUFTLEtBQUs0VCxtQkFBbUI1QyxXQUFXLEVBQUUsSUFBSWpYLFNBQVM7TUFDNUQ7QUFDREUsYUFBTyxLQUFLMlosbUJBQW1CNUMsV0FBV0EsV0FBV3JXLFNBQVMsRUFBRTtBQUNoRSxVQUFJcVcsV0FBV3JXLFdBQVcsR0FBRztBQUMzQnNGLGNBQU1oRzthQUNEO0FBQ0xnRyxlQUFPaEcsT0FBTyxLQUFLMlosbUJBQW1CNUMsV0FBV0EsV0FBV3JXLFNBQVMsRUFBRSxLQUFLO01BQzdFO0lBQ0Y7QUFDRCxVQUFNa1osUUFBUTdDLFdBQVdyVyxTQUFTLElBQUksTUFBTTtBQUM1Q3FGLFlBQVEzRixZQUFZMkYsT0FBTyxHQUFHNlQsS0FBSztBQUNuQzVULFVBQU01RixZQUFZNEYsS0FBSyxHQUFHNFQsS0FBSztBQUUvQixTQUFLN0IsV0FBVztNQUFDaFM7TUFBT0M7TUFBS3RCLFFBQVEsS0FBS3FCLFFBQVEsSUFBSUM7O0VBQ3ZEO0VBU0RvVCxZQUFZO0FBQ1YsVUFBTXhELFVBQVUsS0FBS0M7QUFDckIsVUFBTTlULE1BQU0sS0FBS0E7QUFDakIsVUFBTTVCLE1BQU0sS0FBS0E7QUFDakIsVUFBTThCLFVBQVUsS0FBS0E7QUFDckIsVUFBTWtYLFdBQVdsWCxRQUFRNlU7QUFFekIsVUFBTStDLFFBQVFWLFNBQVNqVixRQUFRaVMsMEJBQTBCZ0QsU0FBUy9DLFNBQVNyVSxLQUFLNUIsS0FBSyxLQUFLb1osa0JBQWtCeFgsR0FBRyxDQUFDO0FBQ2hILFVBQU1nRixXQUFXckYsZUFBZU8sUUFBUUksTUFBTTBFLFVBQVUsQ0FBQztBQUN6RCxVQUFNK1MsVUFBVUQsVUFBVSxTQUFTVixTQUFTcEQsYUFBYTtBQUN6RCxVQUFNZ0UsYUFBYTlELFNBQVM2RCxPQUFPLEtBQUtBLFlBQVk7QUFDcEQsVUFBTXpYLFFBQVEsQ0FBQTtBQUNkLFFBQUl2QyxRQUFRaUM7QUFDWixRQUFJK1UsTUFBTWhUO0FBR1YsUUFBSWlXLFlBQVk7QUFDZGphLGNBQVEsQ0FBQzhWLFFBQVFNLFFBQVFwVyxPQUFPLFdBQVdnYSxPQUFPO0lBQ25EO0FBR0RoYSxZQUFRLENBQUM4VixRQUFRTSxRQUFRcFcsT0FBT2lhLGFBQWEsUUFBUUYsS0FBSztBQUcxRCxRQUFJakUsUUFBUWUsS0FBS3hXLEtBQUs0QixLQUFLOFgsS0FBSyxJQUFJLE1BQVM5UyxVQUFVO0FBQ3JELFlBQU0sSUFBSWlULE1BQU1qWSxNQUFNLFVBQVU1QixNQUFNLHlDQUF5QzRHLFdBQVcsTUFBTThTLEtBQUs7SUFDdEc7QUFFRCxVQUFNOUMsYUFBYTlVLFFBQVFJLE1BQU11VyxXQUFXLFVBQVUsS0FBS3FCLGtCQUFpQjtBQUM1RSxTQUFLbkQsT0FBT2hYLE9BQU9nRSxRQUFRLEdBQUdnVCxPQUFPM1csS0FBSzJXLE9BQU8sQ0FBQ2xCLFFBQVEwQixJQUFJUixNQUFNL1AsVUFBVThTLEtBQUssR0FBRy9WLFNBQVM7QUFDN0YrUyxjQUFReFUsT0FBT3lVLE1BQU1DLFVBQVU7SUFDaEM7QUFFRCxRQUFJRCxTQUFTM1csT0FBTzhCLFFBQVFDLFdBQVcsV0FBVzRCLFVBQVUsR0FBRztBQUM3RCtTLGNBQVF4VSxPQUFPeVUsTUFBTUMsVUFBVTtJQUNoQztBQUdELFdBQU85SyxPQUFPdUosS0FBS25ULEtBQUssRUFBRTZYLEtBQUssQ0FBQ3hFLEdBQUczSixNQUFNMkosSUFBSTNKLENBQUMsRUFBRThGLElBQUlwRSxDQUFBQSxNQUFLLENBQUNBLENBQUM7RUFDNUQ7RUFNRGxMLGlCQUFpQi9CLE9BQU87QUFDdEIsVUFBTW9WLFVBQVUsS0FBS0M7QUFDckIsVUFBTXNELFdBQVcsS0FBS2xYLFFBQVE2VTtBQUU5QixRQUFJcUMsU0FBU2dCLGVBQWU7QUFDMUIsYUFBT3ZFLFFBQVEvTixPQUFPckgsT0FBTzJZLFNBQVNnQixhQUFhO0lBQ3BEO0FBQ0QsV0FBT3ZFLFFBQVEvTixPQUFPckgsT0FBTzJZLFNBQVNiLGVBQWU4QixRQUFRO0VBQzlEO0VBV0RDLG9CQUFvQnZELE1BQU12WCxPQUFPOEMsT0FBT3dGLFFBQVE7QUFDOUMsVUFBTTVGLFVBQVUsS0FBS0E7QUFDckIsVUFBTXFZLFlBQVlyWSxRQUFRSSxNQUFNa0I7QUFFaEMsUUFBSStXLFdBQVc7QUFDYixhQUFPOVgsU0FBSzhYLFdBQVc7UUFBQ3hEO1FBQU12WDtRQUFPOEM7U0FBUSxJQUFJO0lBQ2xEO0FBRUQsVUFBTWtXLFVBQVV0VyxRQUFRNlUsS0FBS3dCO0FBQzdCLFVBQU1wVSxPQUFPLEtBQUsyVDtBQUNsQixVQUFNUixZQUFZLEtBQUtTO0FBQ3ZCLFVBQU15QyxjQUFjclcsUUFBUXFVLFFBQVFyVTtBQUNwQyxVQUFNc1csY0FBY25ELGFBQWFrQixRQUFRbEI7QUFDekMsVUFBTXpELE9BQU92UixNQUFNOUM7QUFDbkIsVUFBTWlLLFFBQVE2TixhQUFhbUQsZUFBZTVHLFFBQVFBLEtBQUtwSztBQUV2RCxXQUFPLEtBQUtxTSxTQUFTaE8sT0FBT2lQLE1BQU1qUCxXQUFXMkIsUUFBUWdSLGNBQWNELFlBQVk7RUFDaEY7RUFLRDNJLG1CQUFtQnZQLE9BQU87QUFDeEIsUUFBSXNLLEdBQUcySixNQUFNMUM7QUFFYixTQUFLakgsSUFBSSxHQUFHMkosT0FBT2pVLE1BQU0zQixRQUFRaU0sSUFBSTJKLE1BQU0sRUFBRTNKLEdBQUc7QUFDOUNpSCxhQUFPdlIsTUFBTXNLO0FBQ2JpSCxXQUFLalUsUUFBUSxLQUFLMGEsb0JBQW9CekcsS0FBS3BULE9BQU9tTSxHQUFHdEssS0FBSztJQUMzRDtFQUNGO0VBTURzWCxtQkFBbUJuWixPQUFPO0FBQ3hCLFdBQU9BLFVBQVUsT0FBT3FDLE9BQU9yQyxRQUFRLEtBQUt1QixRQUFRLEtBQUs1QixNQUFNLEtBQUs0QjtFQUNyRTtFQU1EYSxpQkFBaUJwQyxPQUFPO0FBQ3RCLFVBQU1pYSxVQUFVLEtBQUsxQztBQUNyQixVQUFNM00sTUFBTSxLQUFLdU8sbUJBQW1CblosS0FBSztBQUN6QyxXQUFPLEtBQUtzQyxvQkFBb0IyWCxRQUFRMVUsUUFBUXFGLE9BQU9xUCxRQUFRL1YsTUFBTTtFQUN0RTtFQU1EMUIsaUJBQWlCQyxPQUFPO0FBQ3RCLFVBQU13WCxVQUFVLEtBQUsxQztBQUNyQixVQUFNM00sTUFBTSxLQUFLbEksbUJBQW1CRCxLQUFLLElBQUl3WCxRQUFRL1YsU0FBUytWLFFBQVF6VTtBQUN0RSxXQUFPLEtBQUtqRSxNQUFNcUosT0FBTyxLQUFLakwsTUFBTSxLQUFLNEI7RUFDMUM7RUFPRDJZLGNBQWMvYSxPQUFPO0FBQ25CLFVBQU1nYixZQUFZLEtBQUsxWSxRQUFRSTtBQUMvQixVQUFNdVksaUJBQWlCLEtBQUtoUSxJQUFJMEosWUFBWTNVLEtBQUssRUFBRW9JO0FBQ25ELFVBQU1vRCxRQUFRekYsVUFBVSxLQUFLaEQsYUFBWSxJQUFLaVksVUFBVUUsY0FBY0YsVUFBVW5WLFdBQVc7QUFDM0YsVUFBTXNWLGNBQWN6YSxLQUFLd0YsSUFBSXNGLEtBQUs7QUFDbEMsVUFBTTRQLGNBQWMxYSxLQUFLdUYsSUFBSXVGLEtBQUs7QUFDbEMsVUFBTTZQLGVBQWUsS0FBSzlTLHdCQUF3QixDQUFDLEVBQUV3QztBQUVyRCxXQUFPO01BQ0xJLEdBQUcsaUJBQWtCZ1EsY0FBZ0JFLGVBQWVEO01BQ3BEOVAsR0FBRyxpQkFBa0I4UCxjQUFnQkMsZUFBZUY7O0VBRXZEO0VBT0R2QixrQkFBa0IwQixhQUFhO0FBQzdCLFVBQU05QixXQUFXLEtBQUtsWCxRQUFRNlU7QUFDOUIsVUFBTXdCLGlCQUFpQmEsU0FBU2I7QUFHaEMsVUFBTXpRLFNBQVN5USxlQUFlYSxTQUFTalYsU0FBU29VLGVBQWV6RDtBQUMvRCxVQUFNcUcsZUFBZSxLQUFLYixvQkFBb0JZLGFBQWEsR0FBRzFELG9CQUFvQixNQUFNO01BQUMwRDtJQUFZLEdBQUUsS0FBS25ELFVBQVUsR0FBR2pRLE1BQU07QUFDL0gsVUFBTTZDLE9BQU8sS0FBS2dRLGNBQWNRLFlBQVk7QUFHNUMsVUFBTTdFLFdBQVdoVyxLQUFLMEUsTUFBTSxLQUFLckMsYUFBWSxJQUFLLEtBQUtxRixRQUFRMkMsS0FBS0ksSUFBSSxLQUFLOUMsU0FBUzBDLEtBQUtPLENBQUMsSUFBSTtBQUNoRyxXQUFPb0wsV0FBVyxJQUFJQSxXQUFXO0VBQ2xDO0VBS0Q0RCxvQkFBb0I7QUFDbEIsUUFBSWxELGFBQWEsS0FBS1csT0FBT0MsUUFBUSxDQUFBO0FBQ3JDLFFBQUloTCxHQUFHMko7QUFFUCxRQUFJUyxXQUFXclcsUUFBUTtBQUNyQixhQUFPcVc7SUFDUjtBQUVELFVBQU1vRSxRQUFRLEtBQUtDLHdCQUF1QjtBQUUxQyxRQUFJLEtBQUtwRCxlQUFlbUQsTUFBTXphLFFBQVE7QUFDcEMsYUFBUSxLQUFLZ1gsT0FBT0MsT0FBT3dELE1BQU0sR0FBR0UsV0FBV0MsbUJBQW1CLElBQUk7SUFDdkU7QUFFRCxTQUFLM08sSUFBSSxHQUFHMkosT0FBTzZFLE1BQU16YSxRQUFRaU0sSUFBSTJKLE1BQU0sRUFBRTNKLEdBQUc7QUFDOUNvSyxtQkFBYUEsV0FBV3dFLE9BQU9KLE1BQU14TyxHQUFHME8sV0FBV0MsbUJBQW1CLElBQUksQ0FBQztJQUM1RTtBQUVELFdBQVEsS0FBSzVELE9BQU9DLE9BQU8sS0FBSzZELFVBQVV6RSxVQUFVO0VBQ3JEO0VBS0RrQyxxQkFBcUI7QUFDbkIsVUFBTWxDLGFBQWEsS0FBS1csT0FBT3JZLFVBQVUsQ0FBQTtBQUN6QyxRQUFJc04sR0FBRzJKO0FBRVAsUUFBSVMsV0FBV3JXLFFBQVE7QUFDckIsYUFBT3FXO0lBQ1I7QUFFRCxVQUFNMVgsU0FBUyxLQUFLb0IsVUFBUztBQUM3QixTQUFLa00sSUFBSSxHQUFHMkosT0FBT2pYLE9BQU9xQixRQUFRaU0sSUFBSTJKLE1BQU0sRUFBRTNKLEdBQUc7QUFDL0NvSyxpQkFBV3RYLEtBQUs4QixNQUFNLE1BQU1sQyxPQUFPc04sRUFBRSxDQUFDO0lBQ3ZDO0FBRUQsV0FBUSxLQUFLK0ssT0FBT3JZLFNBQVMsS0FBSzJZLGNBQWNqQixhQUFhLEtBQUt5RSxVQUFVekUsVUFBVTtFQUN2RjtFQU1EeUUsVUFBVW5NLFFBQVE7QUFFaEIsV0FBT29NLGFBQWFwTSxPQUFPNkssS0FBS3pFLE1BQU0sQ0FBQztFQUN4Qzs7QUE1Y0QsY0FGbUIrQixXQUVablUsTUFBSztBQUtaLGNBUG1CbVUsV0FPWmxVLFlBQVc7RUFRaEJwQixRQUFRO0VBRVJnVyxVQUFVLENBQUE7RUFDVnBCLE1BQU07SUFDSmhCLFFBQVE7SUFDUjVSLE1BQU07SUFDTjVELE9BQU87SUFDUHlWLFlBQVk7SUFDWkssU0FBUztJQUNUa0MsZ0JBQWdCLENBQUE7RUFDakI7RUFDRGpXLE9BQU87SUFTTHVXLFFBQVE7SUFFUnJWLFVBQVU7SUFFVmlHLE9BQU87TUFDTFcsU0FBUztJQUNWO0VBQ0Y7O0FDck9MLFNBQVN1UixhQUFZQyxPQUFPQyxLQUFLblUsU0FBUztBQUN4QyxNQUFJdVAsS0FBSztBQUNULE1BQUlDLEtBQUswRSxNQUFNamIsU0FBUztBQUN4QixNQUFJbWIsWUFBWUMsWUFBWUMsWUFBWUM7QUFDeEMsTUFBSXZVLFNBQVM7QUFDWCxRQUFJbVUsT0FBT0QsTUFBTTNFLElBQUk1TCxPQUFPd1EsT0FBT0QsTUFBTTFFLElBQUk3TCxLQUFLO0FBQ2hELE9BQUMsRUFBQzRMLElBQUlDLEdBQUUsSUFBSWdGLGFBQWFOLE9BQU8sT0FBT0MsR0FBRztJQUMzQztBQUNELEtBQUMsRUFBQ3hRLEtBQUt5USxZQUFZL0UsTUFBTWlGLFdBQVUsSUFBSUosTUFBTTNFO0FBQzdDLEtBQUMsRUFBQzVMLEtBQUswUSxZQUFZaEYsTUFBTWtGLFdBQVUsSUFBSUwsTUFBTTFFO1NBQ3hDO0FBQ0wsUUFBSTJFLE9BQU9ELE1BQU0zRSxJQUFJRixRQUFROEUsT0FBT0QsTUFBTTFFLElBQUlILE1BQU07QUFDbEQsT0FBQyxFQUFDRSxJQUFJQyxHQUFFLElBQUlnRixhQUFhTixPQUFPLFFBQVFDLEdBQUc7SUFDNUM7QUFDRCxLQUFDLEVBQUM5RSxNQUFNK0UsWUFBWXpRLEtBQUsyUSxXQUFVLElBQUlKLE1BQU0zRTtBQUM3QyxLQUFDLEVBQUNGLE1BQU1nRixZQUFZMVEsS0FBSzRRLFdBQVUsSUFBSUwsTUFBTTFFO0VBQzlDO0FBRUQsUUFBTWlGLE9BQU9KLGFBQWFEO0FBQzFCLFNBQU9LLE9BQU9ILGNBQWNDLGFBQWFELGVBQWVILE1BQU1DLGNBQWNLLE9BQU9IO0FBQ3BGO0FBRUQsSUFBTUksa0JBQU4sY0FBOEIzRSxVQUFTO0VBWXJDM1csWUFBWTRXLE9BQU87QUFDakIsVUFBTUEsS0FBSztBQUdYLFNBQUsyRSxTQUFTLENBQUE7QUFFZCxTQUFLQyxVQUFVcmI7QUFFZixTQUFLc2IsY0FBY3RiO0VBQ3BCO0VBS0R3WSxjQUFjO0FBQ1osVUFBTXpDLGFBQWEsS0FBS3dGLHVCQUFzQjtBQUM5QyxVQUFNWixRQUFRLEtBQUtTLFNBQVMsS0FBS0ksaUJBQWlCekYsVUFBVTtBQUM1RCxTQUFLc0YsVUFBVVgsYUFBWUMsT0FBTyxLQUFLNVosR0FBRztBQUMxQyxTQUFLdWEsY0FBY1osYUFBWUMsT0FBTyxLQUFLeGIsR0FBRyxJQUFJLEtBQUtrYztBQUN2RCxVQUFNN0MsWUFBWXpDLFVBQVU7RUFDN0I7RUFhRHlGLGlCQUFpQnpGLFlBQVk7QUFDM0IsVUFBTSxFQUFDaFYsS0FBSzVCLElBQUcsSUFBSTtBQUNuQixVQUFNNk4sUUFBUSxDQUFBO0FBQ2QsVUFBTTJOLFFBQVEsQ0FBQTtBQUNkLFFBQUloUCxHQUFHMkosTUFBTW1HLE1BQU1DLE1BQU1DO0FBRXpCLFNBQUtoUSxJQUFJLEdBQUcySixPQUFPUyxXQUFXclcsUUFBUWlNLElBQUkySixNQUFNLEVBQUUzSixHQUFHO0FBQ25EK1AsYUFBTzNGLFdBQVdwSztBQUNsQixVQUFJK1AsUUFBUTNhLE9BQU8yYSxRQUFRdmMsS0FBSztBQUM5QjZOLGNBQU12TyxLQUFLaWQsSUFBSTtNQUNoQjtJQUNGO0FBRUQsUUFBSTFPLE1BQU10TixTQUFTLEdBQUc7QUFFcEIsYUFBTztRQUNMO1VBQUNvVyxNQUFNL1U7VUFBS3FKLEtBQUs7UUFBRTtRQUNuQjtVQUFDMEwsTUFBTTNXO1VBQUtpTCxLQUFLO1FBQUU7O0lBRXRCO0FBRUQsU0FBS3VCLElBQUksR0FBRzJKLE9BQU90SSxNQUFNdE4sUUFBUWlNLElBQUkySixNQUFNLEVBQUUzSixHQUFHO0FBQzlDZ1EsYUFBTzNPLE1BQU1yQixJQUFJO0FBQ2pCOFAsYUFBT3pPLE1BQU1yQixJQUFJO0FBQ2pCK1AsYUFBTzFPLE1BQU1yQjtBQUdiLFVBQUl0TSxLQUFLQyxPQUFPcWMsT0FBT0YsUUFBUSxDQUFDLE1BQU1DLE1BQU07QUFDMUNmLGNBQU1sYyxLQUFLO1VBQUNxWCxNQUFNNEY7VUFBTXRSLEtBQUt1QixLQUFLMkosT0FBTztRQUFHLENBQUE7TUFDN0M7SUFDRjtBQUNELFdBQU9xRjtFQUNSO0VBT0RZLHlCQUF5QjtBQUN2QixRQUFJeEYsYUFBYSxLQUFLVyxPQUFPRSxPQUFPLENBQUE7QUFFcEMsUUFBSWIsV0FBV3JXLFFBQVE7QUFDckIsYUFBT3FXO0lBQ1I7QUFFRCxVQUFNWSxPQUFPLEtBQUtzQyxrQkFBaUI7QUFDbkMsVUFBTXRhLFFBQVEsS0FBS3NaLG1CQUFrQjtBQUNyQyxRQUFJdEIsS0FBS2pYLFVBQVVmLE1BQU1lLFFBQVE7QUFHL0JxVyxtQkFBYSxLQUFLeUUsVUFBVTdELEtBQUs0RCxPQUFPNWIsS0FBSyxDQUFDO1dBQ3pDO0FBQ0xvWCxtQkFBYVksS0FBS2pYLFNBQVNpWCxPQUFPaFk7SUFDbkM7QUFDRG9YLGlCQUFhLEtBQUtXLE9BQU9FLE1BQU1iO0FBRS9CLFdBQU9BO0VBQ1I7RUFNRDRDLG1CQUFtQm5aLE9BQU87QUFDeEIsWUFBUWtiLGFBQVksS0FBS1UsUUFBUTViLEtBQUssSUFBSSxLQUFLNmIsV0FBVyxLQUFLQztFQUNoRTtFQU1EdFosaUJBQWlCQyxPQUFPO0FBQ3RCLFVBQU13WCxVQUFVLEtBQUsxQztBQUNyQixVQUFNOU4sVUFBVSxLQUFLL0csbUJBQW1CRCxLQUFLLElBQUl3WCxRQUFRL1YsU0FBUytWLFFBQVF6VTtBQUMxRSxXQUFPMFYsYUFBWSxLQUFLVSxRQUFRblMsVUFBVSxLQUFLcVMsY0FBYyxLQUFLRCxTQUFTLElBQUk7RUFDaEY7QUFDRjtBQXhIQyxjQUZJRixpQkFFRzlZLE1BQUs7QUFLWixjQVBJOFksaUJBT0c3WSxZQUFXa1UsVUFBVWxVOzs7QXpFakI5QixRQUFNO0FBQUEsRUFDRjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKO0FBVU8sSUFBTSxhQUFOLGNBQXlCLHVCQUFNO0FBQUEsRUFHbEMsWUFBWXNaLE1BQVUsUUFBa0I7QUFDcEMsVUFBTUEsSUFBRztBQUVULFNBQUssU0FBUztBQUVkLFNBQUssUUFBUSxRQUFRLEdBQUcsRUFBRSxhQUFhLElBQUk7QUFDM0MsU0FBSyxRQUFRLGFBQ1Qsa0NBQUFDLFNBQUMsWUFBTyxJQUFHLGlCQUNQLGtDQUFBQSxTQUFDLFlBQU8sT0FBTSxTQUFRLFVBQVEsUUFDekIsRUFBRSxPQUFPLENBQ2QsR0FDQSxrQ0FBQUEsU0FBQyxZQUFPLE9BQU0sYUFBVyxFQUFFLFNBQVMsQ0FBRSxHQUN0QyxrQ0FBQUEsU0FBQyxZQUFPLE9BQU0sVUFBUSxFQUFFLE1BQU0sQ0FBRSxHQUNoQyxrQ0FBQUEsU0FBQyxZQUFPLE9BQU0sY0FBWSxFQUFFLFVBQVUsQ0FBRSxDQUM1QztBQUdKLFNBQUssUUFBUSxNQUFNLFNBQVM7QUFDNUIsU0FBSyxRQUFRLE1BQU0sUUFBUTtBQUUzQixRQUFJLDBCQUFTLFVBQVU7QUFDbkIsV0FBSyxVQUFVLE1BQU0sVUFBVTtBQUFBLElBQ25DO0FBQUEsRUFDSjtBQUFBLEVBRUEsU0FBZTtBQUNYLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsY0FBVSxNQUFNLFlBQVk7QUFHNUIsUUFBSSxPQUFlLEtBQUssSUFBSSxHQUFHLG9CQUFvQixLQUFLLE9BQU8sa0JBQWtCLENBQUM7QUFDbEYsYUFBUyxZQUFZLEdBQUcsYUFBYSxNQUFNLGFBQWE7QUFDcEQsVUFBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxPQUFPLG9CQUFvQixTQUFTLEdBQUc7QUFDbEYsYUFBSyxPQUFPLG1CQUFtQixhQUFhO0FBQUEsTUFDaEQ7QUFBQSxJQUNKO0FBRUEsVUFBTSx5QkFBaUQsRUFBRSxHQUFHLEVBQUU7QUFDOUQsZUFBVyxDQUFDLFdBQVcsUUFBUSxLQUFLLHNCQUFzQixLQUFLLE9BQU8sa0JBQWtCLEdBQUc7QUFDdkYsVUFBSSxhQUFhLEdBQUc7QUFDaEIsK0JBQXVCLE1BQU07QUFBQSxNQUNqQyxPQUFPO0FBQ0gsK0JBQXVCLGFBQWE7QUFBQSxNQUN4QztBQUFBLElBQ0o7QUFFQSxVQUFNLFlBQW1CLEtBQUssT0FBTztBQUNyQyxVQUFNLGlCQUF5QixVQUFVLGFBQWEsVUFBVTtBQUNoRSxXQUFPLEtBQUssSUFBSSxNQUFNLENBQUM7QUFFdkIsY0FBVSxhQUNOLGtDQUFBQSxTQUFDLGFBQ0csa0NBQUFBLFNBQUMsWUFBTyxJQUFHLGlCQUFnQixHQUMzQixrQ0FBQUEsU0FBQyxVQUFLLElBQUcsd0JBQXVCLEdBQ2hDLGtDQUFBQSxTQUFDLFNBQUUsR0FDSCxrQ0FBQUEsU0FBQyxZQUFPLElBQUcsa0JBQWlCLEdBQzVCLGtDQUFBQSxTQUFDLFVBQUssSUFBRyx5QkFBd0IsR0FDakMsa0NBQUFBLFNBQUMsU0FBRSxHQUNILGtDQUFBQSxTQUFDLFlBQU8sSUFBRyxjQUFhLEdBQ3hCLGtDQUFBQSxTQUFDLFVBQUssSUFBRyxxQkFBb0IsR0FDN0Isa0NBQUFBLFNBQUMsU0FBRSxHQUNILGtDQUFBQSxTQUFDLFNBQUksT0FBTSwrQkFDUCxrQ0FBQUEsU0FBQyxZQUFPLElBQUcsa0JBQWlCLENBQ2hDLEdBQ0Esa0NBQUFBLFNBQUMsVUFBSyxJQUFHLHlCQUF3QixDQUNyQztBQUdKO0FBQUEsTUFDSTtBQUFBLE1BQ0E7QUFBQSxNQUNBLEVBQUUsVUFBVTtBQUFBLE1BQ1osRUFBRSxlQUFlO0FBQUEsTUFDakIsT0FBTyxLQUFLLHNCQUFzQjtBQUFBLE1BQ2xDLE9BQU8sT0FBTyxzQkFBc0I7QUFBQSxNQUNwQyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLE1BQU0sUUFBUSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ2hFLEVBQUUsV0FBVztBQUFBLE1BQ2IsRUFBRSxNQUFNO0FBQUEsTUFDUixFQUFFLGlCQUFpQjtBQUFBLElBQ3ZCO0FBRUEsV0FBTyxLQUFLLElBQUksR0FBRyxvQkFBb0IsVUFBVSxTQUFTLENBQUM7QUFDM0QsYUFBUyxXQUFXLEdBQUcsWUFBWSxNQUFNLFlBQVk7QUFDakQsVUFBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssVUFBVSxXQUFXLFFBQVEsR0FBRztBQUN0RSxrQkFBVSxVQUFVLFlBQVk7QUFBQSxNQUNwQztBQUFBLElBQ0o7QUFHQSxVQUFNLG1CQUEyQjtBQUFBLE1BQ3pCLEtBQUs7QUFBQSxRQUNBLHNCQUFzQixVQUFVLFNBQVMsRUFDckMsSUFBSSxDQUFDLENBQUMsVUFBVSxLQUFLLE1BQU0sV0FBVyxLQUFLLEVBQzNDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFDMUIsaUJBQ0E7QUFBQSxNQUNSLElBQUksTUFBTTtBQUFBLE1BQ1Y7QUFBQSxJQUNKLEdBQ0EsbUJBQTJCO0FBQUEsTUFDdkIsS0FBSyxJQUFJLEdBQUcsb0JBQW9CLFVBQVUsU0FBUyxDQUFDLEtBQUs7QUFBQSxNQUN6RDtBQUFBLElBQ0o7QUFFSjtBQUFBLE1BQ0k7QUFBQSxNQUNBO0FBQUEsTUFDQSxFQUFFLFdBQVc7QUFBQSxNQUNiLEVBQUUsZ0JBQWdCO0FBQUEsTUFDbEIsT0FBTyxLQUFLLFVBQVUsU0FBUztBQUFBLE1BQy9CLE9BQU8sT0FBTyxVQUFVLFNBQVM7QUFBQSxNQUNqQyxFQUFFLHFCQUFxQixFQUFFLEtBQUssa0JBQWtCLFNBQVMsaUJBQWlCLENBQUM7QUFBQSxNQUMzRSxFQUFFLE9BQU87QUFBQSxNQUNULEVBQUUsTUFBTTtBQUFBLE1BQ1IsRUFBRSxpQkFBaUI7QUFBQSxJQUN2QjtBQUdBLFVBQU0sUUFBa0Isb0JBQW9CLFVBQVUsS0FBSztBQUMzRCxhQUFTLE9BQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxHQUFHLFFBQVEsS0FBSyxJQUFJLEdBQUcsS0FBSyxHQUFHLFFBQVE7QUFDcEUsVUFBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssVUFBVSxPQUFPLElBQUksR0FBRztBQUM5RCxrQkFBVSxNQUFNLFFBQVE7QUFBQSxNQUM1QjtBQUFBLElBQ0o7QUFDQSxVQUFNLGVBQ0YsS0FBSztBQUFBLE1BQ0Qsc0JBQXNCLFVBQVUsS0FBSyxFQUNoQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxPQUFPLEtBQUssRUFDbkMsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJO0FBQUEsSUFDdEMsS0FBSztBQUVUO0FBQUEsTUFDSTtBQUFBLE1BQ0E7QUFBQSxNQUNBLEVBQUUsT0FBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE9BQU8sS0FBSyxVQUFVLEtBQUs7QUFBQSxNQUMzQixPQUFPLE9BQU8sVUFBVSxLQUFLO0FBQUEsTUFDN0IsRUFBRSxpQkFBaUIsRUFBRSxTQUFTLGFBQWEsQ0FBQztBQUFBLE1BQzVDLEVBQUUsT0FBTztBQUFBLE1BQ1QsRUFBRSxPQUFPO0FBQUEsTUFDVCxFQUFFLGlCQUFpQjtBQUFBLElBQ3ZCO0FBR0EsVUFBTSxrQkFBMEIsS0FBSyxPQUFPLFNBQVM7QUFDckQ7QUFBQSxNQUNJO0FBQUEsTUFDQTtBQUFBLE1BQ0EsRUFBRSxZQUFZO0FBQUEsTUFDZCxFQUFFLGlCQUFpQjtBQUFBLE1BQ25CO0FBQUEsUUFDSSxHQUFHLEVBQUUsZUFBZSxPQUFPLEtBQUs7QUFBQSxVQUMzQixVQUFVLFdBQVcsa0JBQW1CO0FBQUEsUUFDN0M7QUFBQSxRQUNBLEdBQUcsRUFBRSxpQkFBaUIsT0FBTyxLQUFLO0FBQUEsVUFDN0IsVUFBVSxhQUFhLGtCQUFtQjtBQUFBLFFBQy9DO0FBQUEsUUFDQSxHQUFHLEVBQUUsa0JBQWtCLE9BQU8sS0FBSztBQUFBLFVBQzlCLFVBQVUsY0FBYyxrQkFBbUI7QUFBQSxRQUNoRDtBQUFBLE1BQ0o7QUFBQSxNQUNBLENBQUMsVUFBVSxVQUFVLFVBQVUsWUFBWSxVQUFVLFdBQVc7QUFBQSxNQUNoRSxFQUFFLHNCQUFzQixFQUFFLGdCQUFnQixDQUFDO0FBQUEsSUFDL0M7QUFBQSxFQUNKO0FBQUEsRUFFQSxVQUFnQjtBQUNaLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsY0FBVSxNQUFNO0FBQUEsRUFDcEI7QUFDSjtBQUVBLFNBQVMsaUJBQ0wsTUFDQSxVQUNBLE9BQ0EsVUFDQSxRQUNBLE1BQ0EsU0FDQSxjQUFjLElBQ2QsYUFBYSxJQUNiLGFBQWEsSUFDZjtBQUNFLE1BQUksU0FBUyxDQUFDLEdBQ1Ysa0JBQWtCLENBQUMsU0FBUztBQUNoQyxNQUFJLFNBQVMsT0FBTztBQUNoQixhQUFTO0FBQUEsTUFDTCxHQUFHO0FBQUEsUUFDQyxPQUFPO0FBQUEsVUFDSCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsUUFDVjtBQUFBLE1BQ0o7QUFBQSxNQUNBLEdBQUc7QUFBQSxRQUNDLE9BQU87QUFBQSxVQUNILFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKLE9BQU87QUFDSCxzQkFBa0IsQ0FBQyxXQUFXLFdBQVcsT0FBTztBQUFBLEVBQ3BEO0FBRUEsUUFBTSxlQUFlLGFBQWEsbUJBQW1CLGFBQWE7QUFFbEUsUUFBTSxhQUFhLElBQUksUUFBTSxTQUFTLGVBQWUsUUFBUSxHQUF3QjtBQUFBLElBQ2pGO0FBQUEsSUFDQSxNQUFNO0FBQUEsTUFDRixRQUFRLGVBQWUsT0FBTyxNQUFNLEdBQUcsRUFBRSxJQUFJO0FBQUEsTUFDN0MsVUFBVTtBQUFBLFFBQ047QUFBQSxVQUNJLE9BQU87QUFBQSxVQUNQO0FBQUEsVUFDQSxNQUFNLGVBQWUsS0FBSyxNQUFNLEdBQUcsRUFBRSxJQUFJO0FBQUEsUUFDN0M7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLElBQ0EsU0FBUztBQUFBLE1BQ0w7QUFBQSxNQUNBLFNBQVM7QUFBQSxRQUNMLE9BQU87QUFBQSxVQUNILFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxZQUNGLE1BQU07QUFBQSxVQUNWO0FBQUEsUUFDSjtBQUFBLFFBQ0EsVUFBVTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFlBQ0YsTUFBTTtBQUFBLFVBQ1Y7QUFBQSxRQUNKO0FBQUEsUUFDQSxRQUFRO0FBQUEsVUFDSixTQUFTO0FBQUEsUUFDYjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSixDQUFDO0FBRUQsTUFBSSxjQUFjO0FBQ2QsVUFBTSxnQkFBZ0IsU0FBUyxlQUFlLGFBQWE7QUFDM0Qsa0JBQWMsaUJBQWlCLFNBQVMsTUFBTTtBQUMxQyxVQUFJLGdCQUFnQjtBQUNwQixZQUFNLGNBQWMsY0FBYztBQUNsQyxVQUFJLGdCQUFnQixTQUFTO0FBQ3pCLHlCQUFpQixPQUFPLE1BQU0sR0FBRyxFQUFFO0FBQ25DLHVCQUFlLEtBQUssTUFBTSxHQUFHLEVBQUU7QUFBQSxNQUNuQyxXQUFXLGdCQUFnQixXQUFXO0FBQ2xDLHlCQUFpQixPQUFPLE1BQU0sR0FBRyxFQUFFO0FBQ25DLHVCQUFlLEtBQUssTUFBTSxHQUFHLEVBQUU7QUFBQSxNQUNuQyxXQUFXLGdCQUFnQixRQUFRO0FBQy9CLHlCQUFpQixPQUFPLE1BQU0sR0FBRyxHQUFHO0FBQ3BDLHVCQUFlLEtBQUssTUFBTSxHQUFHLEdBQUc7QUFBQSxNQUNwQyxPQUFPO0FBQ0gseUJBQWlCO0FBQ2pCLHVCQUFlO0FBQUEsTUFDbkI7QUFFQSxpQkFBVyxLQUFLLFNBQVM7QUFDekIsaUJBQVcsS0FBSyxTQUFTLEtBQUs7QUFBQSxRQUMxQixPQUFPO0FBQUEsUUFDUDtBQUFBLFFBQ0EsTUFBTTtBQUFBLE1BQ1Y7QUFDQSxpQkFBVyxPQUFPO0FBQUEsSUFDdEIsQ0FBQztBQUFBLEVBQ0w7QUFFQSxXQUFTLGVBQWUsR0FBRyxpQkFBaUIsRUFBRSxZQUFZO0FBQzlEOzs7QTJFalVBLElBQUFDLG1CQUFxRDtBQU85QyxJQUFNLHlCQUF5QjtBQUUvQixJQUFNLHNCQUFOLGNBQWtDLDBCQUFTO0FBQUEsRUFHOUMsWUFBWSxNQUFxQixRQUFrQjtBQUMvQyxVQUFNLElBQUk7QUFFVixTQUFLLFNBQVM7QUFDZCxTQUFLLGNBQWMsS0FBSyxJQUFJLFVBQVUsR0FBRyxhQUFhLE1BQU0sS0FBSyxPQUFPLENBQUMsQ0FBQztBQUMxRSxTQUFLLGNBQWMsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLE1BQU0sS0FBSyxPQUFPLENBQUMsQ0FBQztBQUFBLEVBQ3ZFO0FBQUEsRUFFTyxjQUFzQjtBQUN6QixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRU8saUJBQXlCO0FBQzVCLFdBQU8sRUFBRSxvQkFBb0I7QUFBQSxFQUNqQztBQUFBLEVBRU8sVUFBa0I7QUFDckIsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVPLGFBQWEsTUFBa0I7QUFDbEMsU0FBSyxRQUFRLENBQUMsU0FBUztBQUNuQixXQUFLLFNBQVMsRUFBRSxPQUFPLENBQUMsRUFDbkIsUUFBUSxPQUFPLEVBQ2YsUUFBUSxNQUFNO0FBQ1gsYUFBSyxJQUFJLFVBQVUsbUJBQW1CLHNCQUFzQjtBQUFBLE1BQ2hFLENBQUM7QUFBQSxJQUNULENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFTyxTQUFlO0FBQ2xCLFVBQU0sYUFBMkIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUVsRSxVQUFNLFNBQXNCLFVBQVUscUJBQXFCO0FBQzNELFVBQU0sYUFBMEIsT0FBTyxVQUFVLHFCQUFxQjtBQUV0RSxlQUFXLFdBQVcsS0FBSyxPQUFPLGFBQWE7QUFDM0MsWUFBTSxPQUFtQixLQUFLLE9BQU8sWUFBWTtBQUVqRCxZQUFNLGdCQUFnQixDQUFDLEtBQUssY0FBYyxJQUFJLEtBQUssUUFBUTtBQUUzRCxZQUFNLGVBQTRCLEtBQUs7QUFBQSxRQUNuQztBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKLEVBQUUsdUJBQXVCLHFCQUFxQixFQUFFO0FBRWhELFVBQUksS0FBSyxTQUFTLFNBQVMsR0FBRztBQUMxQixjQUFNLG1CQUFnQyxLQUFLO0FBQUEsVUFDdkM7QUFBQSxVQUNBLEVBQUUsS0FBSztBQUFBLFVBQ1AsQ0FBQyxLQUFLLGNBQWMsSUFBSSxFQUFFLEtBQUssQ0FBQztBQUFBLFVBQ2hDO0FBQUEsVUFDQTtBQUFBLFFBQ0o7QUFFQSxtQkFBVyxXQUFXLEtBQUssVUFBVTtBQUNqQyxnQkFBTSxhQUFhLGNBQWMsUUFBUSxTQUFTLFdBQVc7QUFDN0QsY0FBSSxZQUFZO0FBQ1osaUJBQUssY0FBYyxJQUFJLEtBQUssUUFBUTtBQUNwQyxpQkFBSyxjQUFjLElBQUksRUFBRSxLQUFLLENBQUM7QUFDL0IsaUJBQUssMkJBQTJCLGdCQUFnQjtBQUNoRCxpQkFBSywyQkFBMkIsWUFBWTtBQUFBLFVBQ2hEO0FBQ0EsZUFBSztBQUFBLFlBQ0Q7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0EsQ0FBQyxLQUFLLGNBQWMsSUFBSSxFQUFFLEtBQUssQ0FBQztBQUFBLFlBQ2hDO0FBQUEsWUFDQSxLQUFLO0FBQUEsVUFDVDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBRUEsVUFBSSxLQUFLLGVBQWUsU0FBUyxHQUFHO0FBQ2hDLGNBQU0sTUFBYyxLQUFLLElBQUk7QUFDN0IsWUFBSSxXQUFXO0FBQ2YsWUFBSSxnQkFBb0MsTUFDcEMsY0FBYztBQUNsQixjQUFNLGtCQUEwQixLQUFLLE9BQU8sS0FBSyxTQUFTO0FBRTFELG1CQUFXLFNBQVMsS0FBSyxnQkFBZ0I7QUFDckMsY0FBSSxNQUFNLFdBQVcsVUFBVTtBQUMzQixrQkFBTSxRQUFnQixLQUFLLE1BQU0sTUFBTSxVQUFVLFFBQVEsS0FBSyxPQUFPLElBQUs7QUFFMUUsZ0JBQUksUUFBUSxpQkFBaUI7QUFDekI7QUFBQSxZQUNKO0FBRUEsZ0JBQUksVUFBVSxJQUFJO0FBQ2QsNEJBQWMsRUFBRSxXQUFXO0FBQUEsWUFDL0IsV0FBVyxVQUFVLEdBQUc7QUFDcEIsNEJBQWMsRUFBRSxPQUFPO0FBQUEsWUFDM0IsV0FBVyxVQUFVLEdBQUc7QUFDcEIsNEJBQWMsRUFBRSxVQUFVO0FBQUEsWUFDOUIsT0FBTztBQUNILDRCQUFjLElBQUksS0FBSyxNQUFNLE9BQU8sRUFBRSxhQUFhO0FBQUEsWUFDdkQ7QUFFQSw0QkFBZ0IsS0FBSztBQUFBLGNBQ2pCO0FBQUEsY0FDQTtBQUFBLGNBQ0EsQ0FBQyxLQUFLLGNBQWMsSUFBSSxXQUFXO0FBQUEsY0FDbkM7QUFBQSxjQUNBO0FBQUEsWUFDSjtBQUNBLHVCQUFXLE1BQU07QUFBQSxVQUNyQjtBQUVBLGdCQUFNLGFBQWEsY0FBYyxNQUFNLEtBQUssU0FBUyxXQUFXO0FBQ2hFLGNBQUksWUFBWTtBQUNaLGlCQUFLLGNBQWMsSUFBSSxLQUFLLFFBQVE7QUFDcEMsaUJBQUssY0FBYyxJQUFJLFdBQVc7QUFDbEMsaUJBQUssMkJBQTJCLGFBQWE7QUFDN0MsaUJBQUssMkJBQTJCLFlBQVk7QUFBQSxVQUNoRDtBQUVBLGVBQUs7QUFBQSxZQUNEO0FBQUEsWUFDQSxNQUFNO0FBQUEsWUFDTjtBQUFBLFlBQ0EsQ0FBQyxLQUFLLGNBQWMsSUFBSSxXQUFXO0FBQUEsWUFDbkM7QUFBQSxZQUNBLEtBQUs7QUFBQSxVQUNUO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsVUFBTSxZQUFxQixLQUFLLFlBQVksU0FBUztBQUNyRCxjQUFVLE1BQU07QUFDaEIsY0FBVSxZQUFZLE1BQU07QUFBQSxFQUNoQztBQUFBLEVBRVEsc0JBQ0osVUFDQSxhQUNBLFdBQ0EsUUFDQSxNQUNXO0FBQ1gsVUFBTSxXQUEyQixTQUFTLFVBQVUsWUFBWTtBQUNoRSxVQUFNLGdCQUFnQyxTQUFTLFVBQVUsa0JBQWtCO0FBQzNFLFVBQU0sYUFBNkIsU0FBUyxVQUFVLHFCQUFxQjtBQUMzRSxVQUFNLGlCQUFpQyxjQUFjO0FBQUEsTUFDakQ7QUFBQSxJQUNKO0FBRUEsbUJBQWUsWUFBWTtBQUMzQixRQUFJLFdBQVc7QUFDWCxNQUFDLGVBQWUsV0FBVyxHQUFtQixNQUFNLFlBQVk7QUFBQSxJQUNwRTtBQUVBLGtCQUFjLFVBQVUsMEJBQTBCLEVBQUUsUUFBUSxXQUFXO0FBRXZFLFFBQUksUUFBUTtBQUNSLGVBQVMsTUFBTSxVQUFVO0FBQUEsSUFDN0I7QUFFQSxrQkFBYyxhQUFhLE1BQU07QUFDN0IsaUJBQVcsU0FBUyxXQUFXLFlBQXVDO0FBQ2xFLFlBQUksTUFBTSxNQUFNLFlBQVksV0FBVyxNQUFNLE1BQU0sWUFBWSxJQUFJO0FBQy9ELGdCQUFNLE1BQU0sVUFBVTtBQUN0QixVQUFDLGVBQWUsV0FBVyxHQUFtQixNQUFNLFlBQ2hEO0FBQ0osZUFBSyxjQUFjLE9BQU8sV0FBVztBQUFBLFFBQ3pDLE9BQU87QUFDSCxnQkFBTSxNQUFNLFVBQVU7QUFDdEIsVUFBQyxlQUFlLFdBQVcsR0FBbUIsTUFBTSxZQUFZO0FBQ2hFLGVBQUssY0FBYyxJQUFJLFdBQVc7QUFBQSxRQUN0QztBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRVEsb0JBQ0osVUFDQSxNQUNBLGNBQ0EsUUFDQSxNQUNBLFFBQ0k7QUFDSixVQUFNLFlBQXlCLFNBQzFCLHVCQUF1QixxQkFBcUIsRUFBRSxHQUM5QyxVQUFVLFVBQVU7QUFDekIsUUFBSSxRQUFRO0FBQ1IsZ0JBQVUsTUFBTSxVQUFVO0FBQUEsSUFDOUI7QUFFQSxVQUFNLGVBQTRCLFVBQVUsVUFBVSxnQkFBZ0I7QUFDdEUsUUFBSSxjQUFjO0FBQ2QsbUJBQWEsU0FBUyxXQUFXO0FBQUEsSUFDckM7QUFFQSxpQkFBYSxVQUFVLHdCQUF3QixFQUFFLFFBQVEsS0FBSyxRQUFRO0FBQ3RFLGlCQUFhO0FBQUEsTUFDVDtBQUFBLE1BQ0EsT0FBTyxVQUFzQjtBQUN6QixjQUFNLGVBQWU7QUFDckIsZUFBTyx5QkFBeUIsS0FBSztBQUNyQyxjQUFNLEtBQUssSUFBSSxVQUFVLFFBQVEsRUFBRSxTQUFTLElBQUk7QUFDaEQsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUVBLGlCQUFhO0FBQUEsTUFDVDtBQUFBLE1BQ0EsQ0FBQyxVQUFzQjtBQUNuQixjQUFNLGVBQWU7QUFDckIsY0FBTSxXQUFpQixJQUFJLHNCQUFLO0FBQ2hDLGFBQUssSUFBSSxVQUFVLFFBQVEsYUFBYSxVQUFVLE1BQU0sbUJBQW1CLElBQUk7QUFDL0UsaUJBQVMsZUFBZTtBQUFBLFVBQ3BCLEdBQUcsTUFBTTtBQUFBLFVBQ1QsR0FBRyxNQUFNO0FBQUEsUUFDYixDQUFDO0FBQ0QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUVRLDJCQUEyQixVQUE2QjtBQUM1RCxVQUFNLGlCQUFpQixTQUFTLEtBQUssbUNBQW1DO0FBQ3hFLElBQUMsZUFBZSxXQUFXLEdBQW1CLE1BQU0sWUFBWTtBQUFBLEVBQ3BFO0FBQ0o7OztBQ3BQQSxJQUFBQyxtQkFBOEM7QUFLdkMsSUFBTSxhQUFOLE1BQWlCO0FBQUEsRUFPcEIsWUFBWUMsT0FBYztBQUwxQixTQUFPLFdBQW9CLENBQUM7QUFDNUIsU0FBTyxpQkFBOEIsQ0FBQztBQUV0QyxTQUFPLGdCQUFnQjtBQUduQixTQUFLLFdBQVdBO0FBQ2hCLFNBQUssZ0JBQWdCLG9CQUFJLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUFBLEVBQzVEO0FBQUEsRUFFTyxVQUFVLFdBQXlDO0FBRXRELFNBQUssV0FBVyxLQUFLLFNBQVM7QUFBQSxNQUMxQixDQUFDLEdBQVUsT0FBYyxVQUFVLEVBQUUsU0FBUyxNQUFNLFVBQVUsRUFBRSxTQUFTO0FBQUEsSUFDN0U7QUFHQSxTQUFLLGlCQUFpQixLQUFLLGVBQWUsS0FBSyxDQUFDLEdBQWMsTUFBaUI7QUFDM0UsWUFBTSxTQUFTLEVBQUUsVUFBVSxFQUFFO0FBQzdCLFVBQUksVUFBVSxHQUFHO0FBQ2IsZUFBTztBQUFBLE1BQ1g7QUFDQSxjQUFRLFVBQVUsRUFBRSxLQUFLLFNBQVMsTUFBTSxVQUFVLEVBQUUsS0FBSyxTQUFTO0FBQUEsSUFDdEUsQ0FBQztBQUFBLEVBQ0w7QUFDSjtBQUVPLElBQU0sMkJBQU4sY0FBdUMsbUNBQTBCO0FBQUEsRUFJcEUsWUFBWUMsTUFBVSxVQUFvQjtBQUN0QyxVQUFNQSxJQUFHO0FBSmIsU0FBTyxXQUFxQixDQUFDO0FBS3pCLFNBQUssV0FBVztBQUFBLEVBQ3BCO0FBQUEsRUFFQSxXQUFxQjtBQUNqQixXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsWUFBWSxNQUFzQjtBQUM5QixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsYUFBYSxTQUFpQixHQUFxQztBQUMvRCxTQUFLLE1BQU07QUFDWCxTQUFLLGVBQWUsT0FBTztBQUFBLEVBQy9CO0FBQ0o7OztBQzNDTyxTQUFTQyxPQUNaLE1BQ0EseUJBQ0EsaUNBQ0Esd0JBQ0EsZ0NBQ0EsMkJBQ0EseUJBQ0EsOEJBQzRCO0FBQzVCLE1BQUksV0FBVztBQUNmLFFBQU0sUUFBc0MsQ0FBQztBQUM3QyxNQUFJLFdBQTRCO0FBQ2hDLE1BQUksU0FBUztBQUViLFFBQU0sUUFBa0IsS0FBSyxXQUFXLFFBQVEsSUFBSSxFQUFFLE1BQU0sSUFBSTtBQUNoRSxXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ25DLFFBQUksTUFBTSxHQUFHLFdBQVcsR0FBRztBQUN2QixVQUFJLFVBQVU7QUFDVixjQUFNLEtBQUssQ0FBQyxVQUFVLFVBQVUsTUFBTSxDQUFDO0FBQ3ZDLG1CQUFXO0FBQUEsTUFDZjtBQUVBLGlCQUFXO0FBQ1g7QUFBQSxJQUNKLFdBQVcsTUFBTSxHQUFHLFdBQVcsTUFBTSxLQUFLLENBQUMsTUFBTSxHQUFHLFdBQVcsU0FBUyxHQUFHO0FBQ3ZFLGFBQU8sSUFBSSxJQUFJLE1BQU0sVUFBVSxDQUFDLE1BQU0sR0FBRyxTQUFTLEtBQUs7QUFBRztBQUMxRDtBQUNBO0FBQUEsSUFDSjtBQUVBLFFBQUksU0FBUyxTQUFTLEdBQUc7QUFDckIsa0JBQVk7QUFBQSxJQUNoQjtBQUNBLGdCQUFZLE1BQU07QUFFbEIsUUFDSSxNQUFNLEdBQUcsU0FBUywrQkFBK0IsS0FDakQsTUFBTSxHQUFHLFNBQVMsdUJBQXVCLEdBQzNDO0FBQ0UsaUJBQVcsTUFBTSxHQUFHLFNBQVMsK0JBQStCO0FBRzVELGlCQUFXLE1BQU07QUFDakIsZUFBUztBQUNULFVBQUksSUFBSSxJQUFJLE1BQU0sVUFBVSxNQUFNLElBQUksR0FBRyxXQUFXLFNBQVMsR0FBRztBQUM1RCxvQkFBWSxPQUFPLE1BQU0sSUFBSTtBQUM3QjtBQUFBLE1BQ0o7QUFDQSxZQUFNLEtBQUssQ0FBQyxVQUFVLFVBQVUsTUFBTSxDQUFDO0FBQ3ZDLGlCQUFXO0FBQ1gsaUJBQVc7QUFBQSxJQUNmLFdBQ0ksYUFBYSxTQUNYLDZCQUE2QixZQUFZLEtBQUssTUFBTSxFQUFFLEtBQ25ELDJCQUEyQixnQkFBZ0IsS0FBSyxNQUFNLEVBQUUsS0FDeEQsZ0NBQWdDLFlBQVksS0FBSyxNQUFNLEVBQUUsSUFDaEU7QUFDRTtBQUNBLGVBQVM7QUFBQSxJQUNiLFdBQVcsTUFBTSxPQUFPLHdCQUF3QjtBQUM1QztBQUNBLGVBQVM7QUFBQSxJQUNiLFdBQVcsTUFBTSxPQUFPLGdDQUFnQztBQUNwRDtBQUNBLGVBQVM7QUFBQSxJQUNiLFdBQVcsTUFBTSxHQUFHLFdBQVcsS0FBSyxLQUFLLE1BQU0sR0FBRyxXQUFXLEtBQUssR0FBRztBQUNqRSxZQUFNLGlCQUFpQixNQUFNLEdBQUcsTUFBTSxPQUFPLEVBQUU7QUFDL0MsYUFBTyxJQUFJLElBQUksTUFBTSxVQUFVLENBQUMsTUFBTSxJQUFJLEdBQUcsV0FBVyxjQUFjLEdBQUc7QUFDckU7QUFDQSxvQkFBWSxPQUFPLE1BQU07QUFBQSxNQUM3QjtBQUNBLGtCQUFZLE9BQU87QUFDbkI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUVBLE1BQUksWUFBWSxVQUFVO0FBQ3RCLFVBQU0sS0FBSyxDQUFDLFVBQVUsVUFBVSxNQUFNLENBQUM7QUFBQSxFQUMzQztBQUVBLFNBQU87QUFDWDs7O0FDOUZBLElBQUFDLG1CQUF3QjtBQUVqQixTQUFTLFVBQVU7QUFDdEI7QUFBQSxJQUNJO0FBQUEsSUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUo7QUFDSjs7O0E1RzRCQSxJQUFNLGVBQTJCO0FBQUEsRUFDN0IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVSxDQUFDO0FBQUEsRUFDWCxhQUFhO0FBQ2pCO0FBWUEsSUFBcUIsV0FBckIsY0FBc0Msd0JBQU87QUFBQSxFQUE3QztBQUFBO0FBSUksU0FBTyxXQUFXO0FBRWxCLFNBQU8sY0FBaUQsQ0FBQztBQUd6RCxTQUFPLFdBQW9CLENBQUM7QUFDNUIsU0FBTyxpQkFBOEIsQ0FBQztBQUN0QyxTQUFPLGFBQXFDLENBQUM7QUFDN0MsU0FBUSxnQkFBNEMsQ0FBQztBQUNyRCxTQUFRLFlBQW9DLENBQUM7QUFDN0MsU0FBUSxnQkFBZ0I7QUFDeEIsU0FBTyxnQkFBd0MsQ0FBQztBQUVoRCxTQUFPLFdBQWlCLElBQUksS0FBSyxRQUFRLElBQUk7QUFDN0MsU0FBTyxxQkFBNkMsQ0FBQztBQUFBO0FBQUEsRUFHckQsTUFBTSxTQUF3QjtBQUMxQixVQUFNLEtBQUssZUFBZTtBQUUxQixZQUFRO0FBRVIsU0FBSyxZQUFZLEtBQUssaUJBQWlCO0FBQ3ZDLFNBQUssVUFBVSxVQUFVLElBQUksZUFBZTtBQUM1QyxTQUFLLFVBQVUsYUFBYSxjQUFjLEVBQUUsc0JBQXNCLENBQUM7QUFDbkUsU0FBSyxVQUFVLGFBQWEsdUJBQXVCLEtBQUs7QUFDeEQsU0FBSyxVQUFVLGlCQUFpQixTQUFTLFlBQVk7QUFDakQsVUFBSSxDQUFDLEtBQUssVUFBVTtBQUNoQixjQUFNLEtBQUssS0FBSztBQUNoQixhQUFLLG9CQUFvQjtBQUFBLE1BQzdCO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxjQUFjLGlCQUFpQixFQUFFLGNBQWMsR0FBRyxZQUFZO0FBQy9ELFVBQUksQ0FBQyxLQUFLLFVBQVU7QUFDaEIsY0FBTSxLQUFLLEtBQUs7QUFDaEIsWUFBSSxlQUFlLEtBQUssS0FBSyxJQUFJLEVBQUUsS0FBSztBQUFBLE1BQzVDO0FBQUEsSUFDSixDQUFDO0FBRUQsUUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLDhCQUE4QjtBQUNsRCxXQUFLO0FBQUEsUUFDRCxLQUFLLElBQUksVUFBVSxHQUFHLGFBQWEsQ0FBQyxNQUFNLFlBQTJCO0FBQ2pFLGNBQUksbUJBQW1CLDBCQUFTLFFBQVEsY0FBYyxNQUFNO0FBQ3hELGlCQUFLLFFBQVEsQ0FBQyxTQUFTO0FBQ25CLG1CQUFLLFNBQVMsRUFBRSx1QkFBdUIsQ0FBQyxFQUNuQyxRQUFRLGVBQWUsRUFDdkIsUUFBUSxNQUFNO0FBQ1gscUJBQUssbUJBQW1CLHFCQUE0QjtBQUFBLGNBQ3hELENBQUM7QUFBQSxZQUNULENBQUM7QUFFRCxpQkFBSyxRQUFRLENBQUMsU0FBUztBQUNuQixtQkFBSyxTQUFTLEVBQUUsdUJBQXVCLENBQUMsRUFDbkMsUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsTUFBTTtBQUNYLHFCQUFLLG1CQUFtQixxQkFBNEI7QUFBQSxjQUN4RCxDQUFDO0FBQUEsWUFDVCxDQUFDO0FBRUQsaUJBQUssUUFBUSxDQUFDLFNBQVM7QUFDbkIsbUJBQUssU0FBUyxFQUFFLHVCQUF1QixDQUFDLEVBQ25DLFFBQVEsZUFBZSxFQUN2QixRQUFRLE1BQU07QUFDWCxxQkFBSyxtQkFBbUIscUJBQTRCO0FBQUEsY0FDeEQsQ0FBQztBQUFBLFlBQ1QsQ0FBQztBQUFBLFVBQ0w7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNMO0FBQUEsSUFDSjtBQUVBLFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTSxFQUFFLHNCQUFzQjtBQUFBLE1BQzlCLFVBQVUsWUFBWTtBQUNsQixZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGdCQUFNLEtBQUssS0FBSztBQUNoQixlQUFLLG9CQUFvQjtBQUFBLFFBQzdCO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTSxFQUFFLHNCQUFzQjtBQUFBLE1BQzlCLFVBQVUsTUFBTTtBQUNaLGNBQU0sV0FBeUIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNoRSxZQUFJLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDekMsZUFBSyxtQkFBbUIsc0JBQTZCO0FBQUEsUUFDekQ7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsc0JBQXNCO0FBQUEsTUFDOUIsVUFBVSxNQUFNO0FBQ1osY0FBTSxXQUF5QixLQUFLLElBQUksVUFBVSxjQUFjO0FBQ2hFLFlBQUksWUFBWSxTQUFTLGNBQWMsTUFBTTtBQUN6QyxlQUFLLG1CQUFtQixzQkFBNkI7QUFBQSxRQUN6RDtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU0sRUFBRSxzQkFBc0I7QUFBQSxNQUM5QixVQUFVLE1BQU07QUFDWixjQUFNLFdBQXlCLEtBQUssSUFBSSxVQUFVLGNBQWM7QUFDaEUsWUFBSSxZQUFZLFNBQVMsY0FBYyxNQUFNO0FBQ3pDLGVBQUssbUJBQW1CLHNCQUE2QjtBQUFBLFFBQ3pEO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTSxFQUFFLGtCQUFrQjtBQUFBLE1BQzFCLFVBQVUsWUFBWTtBQUNsQixZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGdCQUFNLEtBQUssS0FBSztBQUNoQixjQUFJLGVBQWUsS0FBSyxLQUFLLElBQUksRUFBRSxLQUFLO0FBQUEsUUFDNUM7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsc0JBQXNCO0FBQUEsTUFDOUIsVUFBVSxZQUFZO0FBQ2xCLGNBQU0sV0FBeUIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNoRSxZQUFJLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDekMsZUFBSyxXQUFXLElBQUksS0FBSyxRQUFRLElBQUk7QUFDckMsZ0JBQU0sV0FBcUIsS0FBSyxhQUFhLFFBQVE7QUFDckQsZ0JBQU0sS0FBSyxxQkFBcUIsVUFBVSxRQUFRO0FBQ2xELGNBQUksZUFBZSxLQUFLLEtBQUssSUFBSSxFQUFFLEtBQUs7QUFBQSxRQUM1QztBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU0sRUFBRSxvQkFBb0I7QUFBQSxNQUM1QixVQUFVLFlBQVk7QUFDbEIsY0FBTSxXQUF5QixLQUFLLElBQUksVUFBVSxjQUFjO0FBQ2hFLFlBQUksWUFBWSxTQUFTLGNBQWMsTUFBTTtBQUN6QyxlQUFLLFdBQVcsSUFBSSxLQUFLLFFBQVEsSUFBSTtBQUNyQyxnQkFBTSxXQUFxQixLQUFLLGFBQWEsUUFBUTtBQUNyRCxnQkFBTSxLQUFLLHFCQUFxQixVQUFVLFVBQVUsT0FBTyxJQUFJO0FBQy9ELGNBQUksZUFBZSxLQUFLLEtBQUssTUFBTSxJQUFJLEVBQUUsS0FBSztBQUFBLFFBQ2xEO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTSxFQUFFLFlBQVk7QUFBQSxNQUNwQixVQUFVLFlBQVk7QUFDbEIsWUFBSSxDQUFDLEtBQUssVUFBVTtBQUNoQixnQkFBTSxLQUFLLEtBQUs7QUFDaEIsY0FBSSxXQUFXLEtBQUssS0FBSyxJQUFJLEVBQUUsS0FBSztBQUFBLFFBQ3hDO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssY0FBYyxJQUFJLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQztBQUVuRCxTQUFLLElBQUksVUFBVSxjQUFjLE1BQU07QUFDbkMsV0FBSyxTQUFTO0FBQ2QsaUJBQVcsWUFBWTtBQUNuQixZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGdCQUFNLEtBQUssS0FBSztBQUFBLFFBQ3BCO0FBQUEsTUFDSixHQUFHLEdBQUk7QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxXQUFpQjtBQUNiLFNBQUssSUFBSSxVQUFVLGdCQUFnQixzQkFBc0IsRUFBRSxRQUFRLENBQUMsU0FBUyxLQUFLLE9BQU8sQ0FBQztBQUFBLEVBQzlGO0FBQUEsRUFFQSxNQUFNLE9BQXNCO0FBQ3hCLFFBQUksS0FBSyxVQUFVO0FBQ2Y7QUFBQSxJQUNKO0FBQ0EsU0FBSyxXQUFXO0FBR2hCLElBQU0sWUFBTTtBQUNaLFNBQUssYUFBYSxDQUFDO0FBQ25CLFNBQUssZ0JBQWdCLENBQUM7QUFDdEIsU0FBSyxZQUFZLENBQUM7QUFDbEIsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxnQkFBZ0IsQ0FBQztBQUN0QixTQUFLLGNBQWMsQ0FBQztBQUdwQixTQUFLLFdBQVcsSUFBSSxLQUFLLFFBQVEsSUFBSTtBQUNyQyxTQUFLLHFCQUFxQixDQUFDO0FBQzNCLFNBQUssWUFBWTtBQUFBLE1BQ2IsT0FBTyxDQUFDO0FBQUEsTUFDUixXQUFXLENBQUM7QUFBQSxNQUNaLFVBQVU7QUFBQSxNQUNWLFlBQVk7QUFBQSxNQUNaLGFBQWE7QUFBQSxJQUNqQjtBQUVBLFVBQU0sTUFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJLENBQUM7QUFDcEMsVUFBTSxZQUFvQixJQUFJLE9BQU8sWUFBWTtBQUVqRCxRQUFJLGNBQWMsS0FBSyxLQUFLLFVBQVU7QUFDbEMsV0FBSyxLQUFLLFdBQVc7QUFDckIsV0FBSyxLQUFLLFdBQVcsQ0FBQztBQUFBLElBQzFCO0FBRUEsVUFBTSxRQUFpQixLQUFLLElBQUksTUFBTSxpQkFBaUI7QUFDdkQsZUFBVyxRQUFRLE9BQU87QUFDdEIsVUFDSSxLQUFLLEtBQUssU0FBUyxvQkFBb0I7QUFBQSxRQUFLLENBQUMsV0FDekMsS0FBSyxLQUFLLFdBQVcsTUFBTTtBQUFBLE1BQy9CLEdBQ0Y7QUFDRTtBQUFBLE1BQ0o7QUFFQSxVQUFJLEtBQUssY0FBYyxLQUFLLFVBQVUsUUFBVztBQUM3QyxhQUFLLGNBQWMsS0FBSyxRQUFRLENBQUM7QUFBQSxNQUNyQztBQUVBLFlBQU0sUUFBUSxLQUFLLElBQUksY0FBYyxjQUFjLEtBQUssU0FBUyxDQUFDO0FBQ2xFLGlCQUFXLGNBQWMsT0FBTztBQUM1QixZQUFJLEtBQUssY0FBYyxnQkFBZ0I7QUFDbkMsZUFBSyxjQUFjLGNBQWMsQ0FBQztBQUd0QyxZQUFJLFdBQVcsTUFBTSxHQUFHLEVBQUUsSUFBSSxFQUFFLFlBQVksTUFBTSxNQUFNO0FBQ3BELGVBQUssY0FBYyxZQUFZLEtBQUs7QUFBQSxZQUNoQyxZQUFZLEtBQUs7QUFBQSxZQUNqQixXQUFXLE1BQU07QUFBQSxVQUNyQixDQUFDO0FBRUQsVUFBTSxXQUFLLEtBQUssTUFBTSxZQUFZLE1BQU0sV0FBVztBQUFBLFFBQ3ZEO0FBQUEsTUFDSjtBQUVBLFlBQU0sV0FBcUIsS0FBSyxhQUFhLElBQUk7QUFDakQsVUFBSSxTQUFTLFdBQVcsR0FBRztBQUN2QixjQUFNLDBCQUFrQyxNQUFNLEtBQUs7QUFBQSxVQUMvQztBQUFBLFVBQ0E7QUFBQSxRQUNKO0FBRUEsWUFBSSwwQkFBMEIsR0FBRztBQUM3QixlQUFLLFdBQVcsS0FBSyxRQUFRO0FBQUEsUUFDakM7QUFBQSxNQUNKO0FBRUEsWUFBTSxpQkFBaUIsS0FBSyxJQUFJLGNBQWMsYUFBYSxJQUFJLEtBQUssQ0FBQztBQUVyRSxZQUFNLGNBQ0YsZUFBZSxlQUFlLENBQUM7QUFDbkMsWUFBTSxXQUFPLDZCQUFXLGNBQWMsS0FBSyxDQUFDO0FBRTVDLFVBQUksZUFBZTtBQUNuQixZQUFNLGtCQUFrQixDQUFDO0FBRXpCLGlCQUFXLGVBQWUsS0FBSyxLQUFLLFNBQVMsY0FBYztBQUN2RCxZQUFJLEtBQUssS0FBSyxDQUFDLFFBQVEsUUFBUSxlQUFlLElBQUksV0FBVyxjQUFjLEdBQUcsQ0FBQyxHQUFHO0FBQzlFLGNBQUksQ0FBQyxPQUFPLFVBQVUsZUFBZSxLQUFLLEtBQUssYUFBYSxXQUFXLEdBQUc7QUFDdEUsaUJBQUssWUFBWSxlQUFlLElBQUksV0FBVyxXQUFXO0FBQUEsVUFDOUQ7QUFDQSwwQkFBZ0IsS0FBSyxXQUFXO0FBQ2hDLHlCQUFlO0FBQ2Y7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNBLFVBQUksY0FBYztBQUNkO0FBQUEsTUFDSjtBQUdBLFVBQ0ksRUFDSSxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsUUFBUSxLQUMxRCxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsYUFBYSxLQUMvRCxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsU0FBUyxJQUVqRTtBQUNFLG1CQUFXLGtCQUFrQixpQkFBaUI7QUFDMUMsZUFBSyxZQUFZLGdCQUFnQixTQUFTLEtBQUssSUFBSTtBQUFBLFFBQ3ZEO0FBQ0E7QUFBQSxNQUNKO0FBRUEsWUFBTSxVQUFrQixPQUNuQixPQUFPLFlBQVksV0FBVyxDQUFDLGNBQWMsY0FBYyxpQkFBaUIsQ0FBQyxFQUM3RSxRQUFRO0FBRWIsaUJBQVcsa0JBQWtCLGlCQUFpQjtBQUMxQyxhQUFLLFlBQVksZ0JBQWdCLGVBQWUsS0FBSyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3RFLFlBQUksV0FBVyxJQUFJLFFBQVEsR0FBRztBQUMxQixlQUFLLFlBQVksZ0JBQWdCO0FBQUEsUUFDckM7QUFBQSxNQUNKO0FBRUEsVUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLEtBQUssWUFBWSxLQUFLLElBQUksR0FBRztBQUNsRSxhQUFLLFdBQVcsS0FBSyxTQUNoQixLQUFLLFdBQVcsS0FBSyxRQUFRLFlBQVksY0FBYztBQUFBLE1BQ2hFLE9BQU87QUFDSCxhQUFLLFdBQVcsS0FBSyxRQUFRLFlBQVk7QUFBQSxNQUM3QztBQUVBLFVBQUksV0FBVyxJQUFJLFFBQVEsR0FBRztBQUMxQixhQUFLO0FBQUEsTUFDVDtBQUVBLFlBQU0sUUFBZ0IsS0FBSyxNQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU0sS0FBSyxPQUFPLElBQUs7QUFDOUUsVUFBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxlQUFlLEtBQUssR0FBRztBQUNsRSxhQUFLLGNBQWMsU0FBUztBQUFBLE1BQ2hDO0FBQ0EsV0FBSyxjQUFjO0FBQUEsSUFDdkI7QUFFQSxJQUFNLFdBQUssTUFBTSxNQUFVLENBQUMsTUFBY0MsVUFBaUI7QUFDdkQsV0FBSyxVQUFVLFFBQVFBLFFBQU87QUFBQSxJQUNsQyxDQUFDO0FBR0QsU0FBSyxTQUFTLGlCQUFpQjtBQUMvQixRQUFJLEtBQUssS0FBSyxTQUFTLG1CQUFtQjtBQUN0QyxjQUFRLElBQUksT0FBTyxFQUFFLE9BQU8sS0FBSyxLQUFLLFVBQVU7QUFDaEQsY0FBUSxJQUFJLE9BQU8sRUFBRSxPQUFPLEtBQUssS0FBSyxRQUFRO0FBQUEsSUFDbEQ7QUFFQSxlQUFXLFdBQVcsS0FBSyxhQUFhO0FBQ3BDLFdBQUssWUFBWSxTQUFTLFVBQVUsS0FBSyxTQUFTO0FBQUEsSUFDdEQ7QUFFQSxRQUFJLEtBQUssS0FBSyxTQUFTLG1CQUFtQjtBQUN0QyxjQUFRO0FBQUEsUUFDSixTQUNJLEVBQUUsbUJBQW1CO0FBQUEsVUFDakIsR0FBRyxLQUFLLElBQUksSUFBSSxJQUFJLFFBQVE7QUFBQSxRQUNoQyxDQUFDO0FBQUEsTUFDVDtBQUFBLElBQ0o7QUFFQSxTQUFLLFVBQVU7QUFBQSxNQUNYLEVBQUUsY0FBYztBQUFBLFFBQ1osZUFBZSxLQUFLO0FBQUEsUUFDcEIsb0JBQW9CLEtBQUssU0FBUztBQUFBLE1BQ3RDLENBQUM7QUFBQSxJQUNMO0FBRUEsUUFBSSxLQUFLLEtBQUssU0FBUztBQUErQixXQUFLLGdCQUFnQixPQUFPO0FBQ2xGLFNBQUssV0FBVztBQUFBLEVBQ3BCO0FBQUEsRUFFQSxNQUFNLG1CQUFtQixNQUFhLFVBQXlDO0FBQzNFLFVBQU0saUJBQWlCLEtBQUssSUFBSSxjQUFjLGFBQWEsSUFBSSxLQUFLLENBQUM7QUFDckUsVUFBTSxjQUNGLGVBQWUsZUFBZSxDQUFDO0FBRW5DLFVBQU0sV0FBTyw2QkFBVyxjQUFjLEtBQUssQ0FBQztBQUM1QyxRQUFJLEtBQUssS0FBSyxTQUFTLG9CQUFvQixLQUFLLENBQUMsV0FBVyxLQUFLLEtBQUssV0FBVyxNQUFNLENBQUMsR0FBRztBQUN2RixVQUFJLHdCQUFPLEVBQUUsd0JBQXdCLENBQUM7QUFDdEM7QUFBQSxJQUNKO0FBRUEsUUFBSSxlQUFlO0FBQ25CLGVBQVcsT0FBTyxNQUFNO0FBQ3BCLFVBQ0ksS0FBSyxLQUFLLFNBQVMsYUFBYTtBQUFBLFFBQzVCLENBQUMsZ0JBQWdCLFFBQVEsZUFBZSxJQUFJLFdBQVcsY0FBYyxHQUFHO0FBQUEsTUFDNUUsR0FDRjtBQUNFLHVCQUFlO0FBQ2Y7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLFFBQUksY0FBYztBQUNkLFVBQUksd0JBQU8sRUFBRSxpQkFBaUIsQ0FBQztBQUMvQjtBQUFBLElBQ0o7QUFFQSxRQUFJLFdBQW1CLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ3JELFFBQUksTUFBYyxVQUFrQjtBQUNwQyxVQUFNLE1BQWMsS0FBSyxJQUFJO0FBRTdCLFFBQ0ksRUFDSSxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsUUFBUSxLQUMxRCxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsYUFBYSxLQUMvRCxPQUFPLFVBQVUsZUFBZSxLQUFLLGFBQWEsU0FBUyxJQUVqRTtBQUNFLFVBQUksWUFBWSxHQUNaLGNBQWMsR0FDZCxpQkFBaUI7QUFFckIsaUJBQVcsV0FBVyxLQUFLLGNBQWMsS0FBSyxTQUFTLENBQUMsR0FBRztBQUN2RCxjQUFNQyxRQUFlLEtBQUssV0FBVyxRQUFRO0FBQzdDLFlBQUlBLE9BQU07QUFDTix1QkFBYSxRQUFRLFlBQVksS0FBSyxVQUFVLFFBQVEsY0FBY0E7QUFDdEUseUJBQWUsS0FBSyxVQUFVLFFBQVEsY0FBYyxRQUFRO0FBQzVELDRCQUFrQixRQUFRO0FBQUEsUUFDOUI7QUFBQSxNQUNKO0FBRUEsWUFBTSxnQkFBZ0IsS0FBSyxJQUFJLGNBQWMsY0FBYyxLQUFLLFNBQVMsQ0FBQztBQUMxRSxpQkFBVyxrQkFBa0IsZUFBZTtBQUN4QyxjQUFNQSxRQUFlLEtBQUssV0FBVztBQUNyQyxZQUFJQSxPQUFNO0FBQ04sdUJBQ0ksY0FBYyxrQkFBa0IsS0FBSyxVQUFVLGtCQUFrQkE7QUFDckUseUJBQWUsS0FBSyxVQUFVLGtCQUFrQixjQUFjO0FBQzlELDRCQUFrQixjQUFjO0FBQUEsUUFDcEM7QUFBQSxNQUNKO0FBRUEsWUFBTSxtQkFDRixLQUFLLEtBQUssU0FBUyxnQkFDbkIsS0FBSyxJQUFJLEdBQUssS0FBSyxJQUFJLGlCQUFpQixHQUFHLElBQUksS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUMvRCxjQUNLLElBQU0sb0JBQW9CLEtBQUssS0FBSyxTQUFTLFlBQzdDLGlCQUFpQixJQUNYLG1CQUFtQixZQUFhLGNBQ2pDLG1CQUFtQixLQUFLLEtBQUssU0FBUztBQUVoRCxVQUFJLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxZQUFZLEtBQUssSUFBSSxHQUFHO0FBQ2xFLGdCQUFRLE9BQU8sS0FBSyxXQUFXLEtBQUssU0FBUztBQUFBLE1BQ2pEO0FBQ0EsYUFBTyxLQUFLLE1BQU0sSUFBSTtBQUN0QixpQkFBVztBQUNYLDBCQUFvQjtBQUFBLElBQ3hCLE9BQU87QUFDSCxpQkFBVyxZQUFZO0FBQ3ZCLGFBQU8sWUFBWTtBQUNuQiwwQkFDSSxNQUNBLE9BQ0ssT0FBTyxZQUFZLFdBQVcsQ0FBQyxjQUFjLGNBQWMsaUJBQWlCLENBQUMsRUFDN0UsUUFBUTtBQUFBLElBQ3JCO0FBRUEsVUFBTSxXQUFtQztBQUFBLE1BQ3JDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxLQUFLLEtBQUs7QUFBQSxNQUNWLEtBQUs7QUFBQSxJQUNUO0FBQ0EsZUFBVyxTQUFTO0FBQ3BCLFdBQU8sU0FBUztBQUVoQixVQUFNLE1BQU0sT0FBTyxPQUFPLE1BQU0sV0FBVyxLQUFLLE9BQU8sR0FBSTtBQUMzRCxVQUFNLFlBQW9CLElBQUksT0FBTyxZQUFZO0FBR2pELFFBQUksc0JBQXNCLEtBQUssUUFBUSxHQUFHO0FBQ3RDLFlBQU0saUJBQWlCLHNCQUFzQixLQUFLLFFBQVE7QUFDMUQsaUJBQVcsU0FBUztBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLEVBQVEsZUFBZSxhQUFhO0FBQUEsZUFDaEI7QUFBQSxXQUFzQjtBQUFBLEVBQ25DLGVBQWU7QUFBQSxNQUMxQjtBQUFBLElBQ0osV0FBVyx3QkFBd0IsS0FBSyxRQUFRLEdBQUc7QUFFL0MsWUFBTSxlQUFlLHdCQUF3QixLQUFLLFFBQVE7QUFDMUQsaUJBQVcsU0FBUztBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLEVBQVEsYUFBYSxhQUFhO0FBQUEsZUFDZDtBQUFBLFdBQXNCO0FBQUE7QUFBQSxNQUM5QztBQUFBLElBQ0osT0FBTztBQUNILGlCQUNJO0FBQUEsVUFBZ0I7QUFBQSxlQUEyQjtBQUFBLFdBQy9CO0FBQUE7QUFBQTtBQUFBLEVBQWdCO0FBQUEsSUFDcEM7QUFFQSxRQUFJLEtBQUssS0FBSyxTQUFTLGtCQUFrQjtBQUNyQyxZQUFNLEtBQUsscUJBQXFCLE1BQU0sQ0FBQyxHQUFHLElBQUk7QUFDOUMsWUFBTSxLQUFLLGVBQWU7QUFBQSxJQUM5QjtBQUNBLFVBQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxNQUFNLFFBQVE7QUFFMUMsUUFBSSx3QkFBTyxFQUFFLG1CQUFtQixDQUFDO0FBRWpDLFVBQU0sS0FBSyxLQUFLO0FBQ2hCLFFBQUksS0FBSyxLQUFLLFNBQVMsY0FBYztBQUNqQyxXQUFLLGVBQWUsS0FBSyxzQkFBc0I7QUFBQSxJQUNuRDtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sc0JBQXFDO0FBQ3ZDLFVBQU0sa0JBQTRCLE9BQU8sS0FBSyxLQUFLLFdBQVc7QUFDOUQsUUFBSSxnQkFBZ0IsV0FBVyxHQUFHO0FBQzlCLFdBQUssZUFBZSxnQkFBZ0IsRUFBRTtBQUFBLElBQzFDLE9BQU87QUFDSCxZQUFNLHFCQUFxQixJQUFJLHlCQUF5QixLQUFLLEtBQUssZUFBZTtBQUNqRix5QkFBbUIsaUJBQWlCLENBQUMsWUFBb0IsS0FBSyxlQUFlLE9BQU87QUFDcEYseUJBQW1CLEtBQUs7QUFBQSxJQUM1QjtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sZUFBZSxTQUFnQztBQUNqRCxRQUFJLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxLQUFLLGFBQWEsT0FBTyxHQUFHO0FBQ2xFLFVBQUksd0JBQU8sRUFBRSxrQkFBa0IsRUFBRSxVQUFVLFFBQVEsQ0FBQyxDQUFDO0FBQ3JEO0FBQUEsSUFDSjtBQUVBLFNBQUsseUJBQXlCO0FBQzlCLFVBQU0sT0FBTyxLQUFLLFlBQVk7QUFFOUIsUUFBSSxLQUFLLGdCQUFnQixHQUFHO0FBQ3hCLFlBQU0sUUFBUSxLQUFLLEtBQUssU0FBUyxpQkFDM0IsS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLEtBQUssYUFBYSxJQUM3QztBQUNOLFlBQU0sS0FBSyxJQUFJLFVBQVUsUUFBUSxFQUFFLFNBQVMsS0FBSyxlQUFlLE9BQU8sSUFBSTtBQUMzRTtBQUFBLElBQ0o7QUFFQSxRQUFJLEtBQUssU0FBUyxTQUFTLEdBQUc7QUFDMUIsWUFBTSxRQUFRLEtBQUssS0FBSyxTQUFTLGlCQUMzQixLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksS0FBSyxTQUFTLE1BQU0sSUFDL0M7QUFDTixXQUFLLElBQUksVUFBVSxRQUFRLEVBQUUsU0FBUyxLQUFLLFNBQVMsTUFBTTtBQUMxRDtBQUFBLElBQ0o7QUFFQSxRQUFJLHdCQUFPLEVBQUUsZUFBZSxDQUFDO0FBQUEsRUFDakM7QUFBQSxFQUVBLGFBQWEsTUFBdUI7QUFDaEMsUUFBSSxXQUFxQixDQUFDO0FBQzFCLFFBQUksS0FBSyxLQUFLLFNBQVMsdUJBQXVCO0FBQzFDLGlCQUFXLEtBQUssS0FBSyxNQUFNLEdBQUc7QUFDOUIsZUFBUyxJQUFJO0FBQ2IsVUFBSSxTQUFTLFdBQVcsR0FBRztBQUN2QixtQkFBVyxDQUFDLEdBQUc7QUFBQSxNQUNuQjtBQUFBLElBQ0osT0FBTztBQUNILFlBQU0saUJBQWlCLEtBQUssSUFBSSxjQUFjLGFBQWEsSUFBSSxLQUFLLENBQUM7QUFDckUsWUFBTSxXQUFPLDZCQUFXLGNBQWMsS0FBSyxDQUFDO0FBRTVDO0FBQU8sbUJBQVcsZUFBZSxLQUFLLEtBQUssU0FBUyxlQUFlO0FBQy9ELHFCQUFXLE9BQU8sTUFBTTtBQUNwQixnQkFBSSxRQUFRLGVBQWUsSUFBSSxXQUFXLGNBQWMsR0FBRyxHQUFHO0FBQzFELHlCQUFXLElBQUksVUFBVSxDQUFDLEVBQUUsTUFBTSxHQUFHO0FBQ3JDLG9CQUFNO0FBQUEsWUFDVjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsSUFDSjtBQUVBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFNLHFCQUNGLE1BQ0EsVUFDQSxXQUFXLE9BQ1gsY0FBYyxPQUNDO0FBbG5CdkI7QUFtbkJRLFFBQUksV0FBbUIsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLElBQUk7QUFDckQsVUFBTSxpQkFBaUIsS0FBSyxJQUFJLGNBQWMsYUFBYSxJQUFJLEtBQUssQ0FBQztBQUNyRSxVQUFNLFdBQTJCLGVBQWUsWUFBWSxDQUFDO0FBQzdELFFBQUksY0FBYyxPQUNkLGdCQUFnQixHQUNoQixpQkFBaUI7QUFDckIsVUFBTSxXQUF1QixLQUFLLEtBQUs7QUFDdkMsVUFBTSxlQUFlO0FBRXJCLFVBQU0sTUFBYyxLQUFLLElBQUk7QUFDN0IsVUFBTSxjQUE0Q0M7QUFBQSxNQUM5QztBQUFBLE1BQ0EsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLElBQ2I7QUFDQSxlQUFXLGNBQWMsYUFBYTtBQUNsQyxpQkFBVztBQUNYLFlBQU0sV0FBcUIsV0FBVyxJQUNsQyxTQUFpQixXQUFXO0FBQ2hDLFVBQUksV0FBbUIsV0FBVztBQUVsQyxVQUFJLENBQUMsU0FBUyx1QkFBdUI7QUFDakMsY0FBTSxpQkFBaUI7QUFDdkIsY0FBTSxnQkFBZSxjQUNoQixNQUFNLGNBQWMsTUFESixtQkFFZixNQUFNLElBQUksR0FDWCxRQUFRLEtBQUssSUFDYixNQUFNO0FBQ1gsWUFBSSxjQUFjO0FBQ2QscUJBQVc7QUFDWCxxQkFBVyxTQUFTLFdBQVcsZ0JBQWdCLEVBQUU7QUFBQSxRQUNyRDtBQUFBLE1BQ0o7QUFFQSxXQUFLLFNBQVMsV0FBVyxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBRXRDLFlBQU0sZUFBdUIsT0FBTyxRQUFRO0FBRTVDLFVBQUksVUFBVTtBQUNWLGFBQUssS0FBSyxTQUFTLEtBQUssWUFBWTtBQUNwQztBQUFBLE1BQ0o7QUFFQSxZQUFNLGlCQUFxQyxDQUFDO0FBQzVDLFVBQUksNEJBQTZCO0FBQzdCLGNBQU1DLFlBQStCLENBQUM7QUFDdEMsWUFBSSxTQUFTLDJCQUEyQjtBQUNwQyxVQUFBQSxVQUFTLEtBQUssR0FBRyxTQUFTLFNBQVMsYUFBYSxDQUFDO0FBQUEsUUFDckQ7QUFDQSxZQUFJLFNBQVMseUJBQXlCO0FBQ2xDLFVBQUFBLFVBQVMsS0FBSyxHQUFHLFNBQVMsU0FBUyxpQkFBaUIsQ0FBQztBQUFBLFFBQ3pEO0FBQ0EsWUFBSSxTQUFTLDhCQUE4QjtBQUN2QyxVQUFBQSxVQUFTLEtBQUssR0FBRyxTQUFTLFNBQVMsYUFBYSxDQUFDO0FBQUEsUUFDckQ7QUFDQSxRQUFBQSxVQUFTLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFDcEIsY0FBSSxFQUFFLFFBQVEsRUFBRSxPQUFPO0FBQ25CLG1CQUFPO0FBQUEsVUFDWDtBQUNBLGNBQUksRUFBRSxRQUFRLEVBQUUsT0FBTztBQUNuQixtQkFBTztBQUFBLFVBQ1g7QUFDQSxpQkFBTztBQUFBLFFBQ1gsQ0FBQztBQUVELFlBQUksT0FBZTtBQUNuQixtQkFBVyxLQUFLQSxXQUFVO0FBQ3RCLGdCQUFNLGdCQUF3QixFQUFFLE9BQzVCLGNBQXNCLGdCQUFnQixFQUFFLEdBQUc7QUFDL0Msa0JBQ0ksU0FBUyxVQUFVLEdBQUcsYUFBYSxJQUNuQyw2Q0FDQSxTQUFTLFVBQVUsV0FBVztBQUNsQyxrQkFBUSxNQUNILFFBQVEsUUFBUSxFQUFFLEVBQ2xCLFFBQVEsVUFBVSxFQUFFLEVBQ3BCLFFBQVEsUUFBUSxFQUFFLEVBQ2xCLFFBQVEsUUFBUSxFQUFFO0FBQ3ZCLGlCQUNJLFNBQVMsVUFBVSxHQUFHLGFBQWEsSUFDbkMsaUNBQ0EsU0FBUyxVQUFVLGVBQWUsV0FBVyxJQUM3QyxZQUNBLFNBQVMsVUFBVSxXQUFXO0FBQ2xDLGlCQUFPLEtBQ0YsUUFBUSxRQUFRLEVBQUUsRUFDbEIsUUFBUSxVQUFVLEVBQUUsRUFDcEIsUUFBUSxRQUFRLEVBQUUsRUFDbEIsUUFBUSxRQUFRLEVBQUU7QUFDdkIseUJBQWUsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDO0FBQUEsUUFDckM7QUFBQSxNQUNKLE9BQU87QUFDSCxZQUFJO0FBQ0osWUFBSSxzQ0FBdUM7QUFDdkMsZ0JBQU0sU0FBUyxRQUFRLFNBQVMsdUJBQXVCO0FBQ3ZELHlCQUFlLEtBQUs7QUFBQSxZQUNoQixTQUFTLFVBQVUsR0FBRyxHQUFHO0FBQUEsWUFDekIsU0FBUyxVQUFVLE1BQU0sU0FBUyx3QkFBd0IsTUFBTTtBQUFBLFVBQ3BFLENBQUM7QUFBQSxRQUNMLFdBQVcseUNBQTBDO0FBQ2pELGdCQUFNLFNBQVMsUUFBUSxTQUFTLCtCQUErQjtBQUMvRCxnQkFBTSxRQUFnQixTQUFTLFVBQVUsR0FBRyxHQUFHLEdBQzNDLFFBQWdCLFNBQVM7QUFBQSxZQUNyQixNQUFNLFNBQVMsZ0NBQWdDO0FBQUEsVUFDbkQ7QUFDSix5QkFBZSxLQUFLLENBQUMsT0FBTyxLQUFLLENBQUM7QUFDbEMseUJBQWUsS0FBSyxDQUFDLE9BQU8sS0FBSyxDQUFDO0FBQUEsUUFDdEMsV0FBVyxxQ0FBc0M7QUFDN0MsZ0JBQU0sU0FBUyxRQUFRLE9BQU8sU0FBUyx5QkFBeUIsSUFBSTtBQUNwRSx5QkFBZSxLQUFLO0FBQUEsWUFDaEIsU0FBUyxVQUFVLEdBQUcsR0FBRztBQUFBLFlBQ3pCLFNBQVMsVUFBVSxNQUFNLElBQUksU0FBUyx1QkFBdUIsTUFBTTtBQUFBLFVBQ3ZFLENBQUM7QUFBQSxRQUNMLFdBQVcsd0NBQXlDO0FBQ2hELGdCQUFNLFNBQVMsUUFBUSxPQUFPLFNBQVMsaUNBQWlDLElBQUk7QUFDNUUsZ0JBQU0sUUFBZ0IsU0FBUyxVQUFVLEdBQUcsR0FBRyxHQUMzQyxRQUFnQixTQUFTO0FBQUEsWUFDckIsTUFBTSxJQUFJLFNBQVMsK0JBQStCO0FBQUEsVUFDdEQ7QUFDSix5QkFBZSxLQUFLLENBQUMsT0FBTyxLQUFLLENBQUM7QUFDbEMseUJBQWUsS0FBSyxDQUFDLE9BQU8sS0FBSyxDQUFDO0FBQUEsUUFDdEM7QUFBQSxNQUNKO0FBRUEsVUFBSSxhQUFpQyxDQUFDLEdBQUcsU0FBUyxTQUFTLDBCQUEwQixDQUFDO0FBQ3RGLFVBQUksV0FBVyxXQUFXO0FBQ3RCLHFCQUFhLENBQUMsR0FBRyxTQUFTLFNBQVMsMkJBQTJCLENBQUM7QUFHbkUsVUFBSSxXQUFXLFNBQVMsZUFBZSxRQUFRO0FBQzNDLGNBQU0sV0FBbUIsU0FBUyxZQUFZLFNBQVMsSUFBSTtBQUMzRCxZQUFJLGNBQXNCLFNBQVMsVUFBVSxHQUFHLFFBQVE7QUFDeEQsaUJBQVMsSUFBSSxHQUFHLElBQUksZUFBZSxRQUFRO0FBQ3ZDLHlCQUFlLElBQUksV0FBVyxHQUFHLE1BQU0sV0FBVyxHQUFHLE1BQU0sV0FBVyxHQUFHO0FBQzdFLHVCQUFlO0FBRWYsY0FBTSxtQkFBbUIsSUFBSSxPQUFPLGtCQUFrQixRQUFRLEdBQUcsSUFBSTtBQUNyRSxtQkFBVyxTQUFTLFFBQVEsa0JBQWtCLE1BQU0sV0FBVztBQUMvRCxzQkFBYztBQUFBLE1BQ2xCO0FBRUEsWUFBTSxVQUFrQixTQUFTLHFCQUMzQixlQUFlLFFBQVEsUUFBUSxJQUMvQjtBQUNOLFlBQU0sV0FBbUIsQ0FBQztBQUMxQixlQUFTLElBQUksR0FBRyxJQUFJLGVBQWUsUUFBUSxLQUFLO0FBQzVDLGNBQU0sUUFBZ0IsZUFBZSxHQUFHLEdBQUcsS0FBSyxHQUM1QyxPQUFlLGVBQWUsR0FBRyxHQUFHLEtBQUs7QUFFN0MsY0FBTSxVQUFnQjtBQUFBLFVBQ2xCLE9BQU8sSUFBSSxXQUFXO0FBQUEsVUFDdEI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLFlBQVk7QUFBQSxVQUNaO0FBQUEsUUFDSjtBQUdBLFlBQUksYUFBYTtBQUNiLGVBQUssVUFBVTtBQUNmLGtCQUFRLFFBQVE7QUFDaEIsZUFBSyxTQUFTLGdCQUFnQixDQUFDLEdBQUcsUUFBUSxHQUFHLE9BQU87QUFBQSxRQUN4RCxXQUFXLElBQUksV0FBVyxRQUFRO0FBQzlCLGdCQUFNLFVBQWtCLE9BQ25CLE9BQU8sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLFlBQVksQ0FBQyxFQUNyRCxRQUFRO0FBQ2IsZ0JBQU0sUUFBZ0IsS0FBSyxNQUFNLFVBQVUsUUFBUSxLQUFLLE9BQU8sSUFBSztBQUNwRSxjQUFJLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxLQUFLLG9CQUFvQixLQUFLLEdBQUc7QUFDdkUsaUJBQUssbUJBQW1CLFNBQVM7QUFBQSxVQUNyQztBQUNBLGVBQUssbUJBQW1CO0FBRXhCLGdCQUFNLFdBQW1CLFNBQVMsV0FBVyxHQUFHLEVBQUUsR0FDOUMsT0FBZSxTQUFTLFdBQVcsR0FBRyxFQUFFO0FBQzVDLGNBQUksQ0FBQyxPQUFPLFVBQVUsZUFBZSxLQUFLLEtBQUssVUFBVSxXQUFXLFFBQVEsR0FBRztBQUMzRSxpQkFBSyxVQUFVLFVBQVUsWUFBWTtBQUFBLFVBQ3pDO0FBQ0EsZUFBSyxVQUFVLFVBQVU7QUFDekIsY0FBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxVQUFVLE9BQU8sSUFBSSxHQUFHO0FBQ25FLGlCQUFLLFVBQVUsTUFBTSxRQUFRO0FBQUEsVUFDakM7QUFDQSxlQUFLLFVBQVUsTUFBTTtBQUNyQiwyQkFBaUI7QUFDakI7QUFFQSxjQUFJLFlBQVksSUFBSTtBQUNoQixpQkFBSyxVQUFVO0FBQUEsVUFDbkIsT0FBTztBQUNILGlCQUFLLFVBQVU7QUFBQSxVQUNuQjtBQUVBLGNBQUksS0FBSyxLQUFLLFNBQVMsU0FBUyxZQUFZLEdBQUc7QUFDM0MsaUJBQUssU0FBUyxlQUFlLENBQUMsR0FBRyxRQUFRLENBQUM7QUFDMUM7QUFBQSxVQUNKO0FBRUEsY0FBSSxXQUFXLEtBQUs7QUFDaEIsb0JBQVEsV0FBVztBQUNuQixvQkFBUSxPQUFPO0FBQ2Ysb0JBQVEsb0JBQW9CLE1BQU07QUFDbEMsaUJBQUssU0FBUyxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsR0FBRyxPQUFPO0FBQUEsVUFDeEQsT0FBTztBQUNILGlCQUFLLFNBQVMsZUFBZSxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBQzFDO0FBQUEsVUFDSjtBQUFBLFFBQ0osT0FBTztBQUNILGVBQUssVUFBVTtBQUNmLGNBQUksS0FBSyxLQUFLLFNBQVMsU0FBUyxPQUFPLFFBQVEsQ0FBQyxHQUFHO0FBQy9DLGlCQUFLLFNBQVMsZUFBZSxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBQzFDO0FBQUEsVUFDSjtBQUNBLGVBQUssU0FBUyxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsR0FBRyxPQUFPO0FBQUEsUUFDeEQ7QUFFQSxpQkFBUyxLQUFLLE9BQU87QUFBQSxNQUN6QjtBQUFBLElBQ0o7QUFFQSxRQUFJLGFBQWE7QUFDYixZQUFNLEtBQUssSUFBSSxNQUFNLE9BQU8sTUFBTSxRQUFRO0FBQUEsSUFDOUM7QUFFQSxRQUFJLGlCQUFpQixHQUFHO0FBQ3BCLFlBQU0sMEJBQWtDLGdCQUFnQjtBQUN4RCxZQUFNLHdCQUFnQyxLQUFLO0FBQUEsUUFDdkM7QUFBQSxRQUNBLEtBQUssSUFBSSxpQkFBaUIsR0FBRyxJQUFJLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDaEQ7QUFDQSxhQUNJLDBCQUEwQix3QkFDMUIsU0FBUyxZQUFZLElBQU07QUFBQSxJQUVuQztBQUVBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFNLGlCQUFnQztBQUNsQyxTQUFLLE9BQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxjQUFjLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDakUsU0FBSyxLQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsS0FBSyxLQUFLLFFBQVE7QUFBQSxFQUMvRTtBQUFBLEVBRUEsTUFBTSxpQkFBZ0M7QUFDbEMsVUFBTSxLQUFLLFNBQVMsS0FBSyxJQUFJO0FBQUEsRUFDakM7QUFBQSxFQUVBLFdBQWlCO0FBQ2IsU0FBSztBQUFBLE1BQ0Q7QUFBQSxNQUNBLENBQUMsU0FBVSxLQUFLLGtCQUFrQixJQUFJLG9CQUFvQixNQUFNLElBQUk7QUFBQSxJQUN4RTtBQUVBLFFBQ0ksS0FBSyxLQUFLLFNBQVMsaUNBQ25CLElBQUksVUFBVSxnQkFBZ0Isc0JBQXNCLEVBQUUsVUFBVSxHQUNsRTtBQUNFLFdBQUssSUFBSSxVQUFVLGFBQWEsS0FBSyxFQUFFLGFBQWE7QUFBQSxRQUNoRCxNQUFNO0FBQUEsUUFDTixRQUFRO0FBQUEsTUFDWixDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSjtBQUVBLFNBQVMsZUFBZSxVQUFrQixVQUFrQztBQUN4RSxRQUFNLFFBQXdCLENBQUM7QUFDL0IsYUFBVyxXQUFXLFVBQVU7QUFDNUIsUUFBSSxRQUFRLFNBQVMsTUFBTSxPQUFPLFVBQVU7QUFDeEM7QUFBQSxJQUNKO0FBRUEsV0FBTyxNQUFNLFNBQVMsS0FBSyxNQUFNLE1BQU0sU0FBUyxHQUFHLFNBQVMsUUFBUSxPQUFPO0FBQ3ZFLFlBQU0sSUFBSTtBQUFBLElBQ2Q7QUFFQSxVQUFNLEtBQUssT0FBTztBQUFBLEVBQ3RCO0FBRUEsTUFBSSxVQUFVO0FBQ2QsYUFBVyxjQUFjLE9BQU87QUFDNUIsZUFBVyxVQUFVLFdBQVcsUUFBUSxRQUFRLGVBQWUsRUFBRSxFQUFFLEtBQUs7QUFDeEUsZUFBVyxXQUFXLFVBQVU7QUFBQSxFQUNwQztBQUNBLFNBQU8sUUFBUSxNQUFNLEdBQUcsRUFBRTtBQUM5QjsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgImNhbGxiYWNrIiwgImFscGhhIiwgImVzYyIsICJTdHJpbmciLCAic3RyIiwgInJlcGxhY2UiLCAibWFwIiwgInMiLCAic2V0SW5uZXJIVE1MQXR0ciIsICJET01BdHRyaWJ1dGVOYW1lcyIsICJzYW5pdGl6ZWQiLCAiaCIsICJuYW1lIiwgImF0dHJzIiwgInN0YWNrIiwgImkiLCAiYXJndW1lbnRzIiwgImxlbmd0aCIsICJwdXNoIiwgImNoaWxkcmVuIiwgInJldmVyc2UiLCAiZW1wdHlUYWdzIiwgImluZGV4T2YiLCAiX19odG1sIiwgImNoaWxkIiwgInBvcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm5hbWVzIiwgImNhbGxiYWNrIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaDEiLCAiaDIiLCAiYXBwIiwgImgiLCAibGluayIsICJkZWNrIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmh0bWwiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOdW1iZXIiLCAibiIsICJpc05hTiIsICJwYXJzZUZsb2F0IiwgImlzRmluaXRlIiwgImFsbW9zdFdob2xlIiwgInJvdW5kZWQiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgImFycmF5IiwgInRhcmdldCIsICJwcm9wZXJ0eSIsICJpbGVuIiwgImxlbmd0aCIsICJtaW4iLCAibWF4IiwgInRvUmFkaWFucyIsICJkZWdyZWVzIiwgInRvRGVncmVlcyIsICJyYWRpYW5zIiwgIl9kZWNpbWFsUGxhY2VzIiwgImlzRmluaXRlTnVtYmVyIiwgInAiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiY2VudHJlUG9pbnQiLCAiYW5nbGVQb2ludCIsICJkaXN0YW5jZUZyb21YQ2VudGVyIiwgImRpc3RhbmNlRnJvbVlDZW50ZXIiLCAicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwgImFuZ2xlIiwgImF0YW4yIiwgImRpc3RhbmNlIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJwdDEiLCAicHQyIiwgIl9ub3JtYWxpemVBbmdsZSIsICJhIiwgIlRBVSIsICJfYW5nbGVCZXR3ZWVuIiwgImFuZ2xlIiwgInN0YXJ0IiwgImVuZCIsICJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCAicyIsICJlIiwgImFuZ2xlVG9TdGFydCIsICJhbmdsZVRvRW5kIiwgInN0YXJ0VG9BbmdsZSIsICJlbmRUb0FuZ2xlIiwgIl9saW1pdFZhbHVlIiwgInZhbHVlIiwgIm1pbiIsICJtYXgiLCAiTWF0aCIsICJfaW50MTZSYW5nZSIsICJfaXNCZXR3ZWVuIiwgImVwc2lsb24iLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibGVuZ3RoIiwgImxvIiwgIm1pZCIsICJfbG9va3VwQnlLZXkiLCAia2V5IiwgImxhc3QiLCAidGkiLCAiX3Jsb29rdXBCeUtleSIsICJfZmlsdGVyQmV0d2VlbiIsICJ2YWx1ZXMiLCAic2xpY2UiLCAiYXJyYXlFdmVudHMiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAiYXJyYXkiLCAibGlzdGVuZXIiLCAiX2NoYXJ0anMiLCAibGlzdGVuZXJzIiwgInB1c2giLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgImZvckVhY2giLCAibWV0aG9kIiwgIl9jYXBpdGFsaXplIiwgImJhc2UiLCAiYXJncyIsICJyZXMiLCAiYXBwbHkiLCAib2JqZWN0IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAic3R1YiIsICJpbmRleE9mIiwgInNwbGljZSIsICJfYXJyYXlVbmlxdWUiLCAiaXRlbXMiLCAic2V0IiwgIlNldCIsICJpIiwgImlsZW4iLCAiYWRkIiwgInNpemUiLCAiQXJyYXkiLCAiZnJvbSIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgIndpbmRvdyIsICJjYWxsYmFjayIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAidGhyb3R0bGVkIiwgImZuIiwgInRoaXNBcmciLCAidGlja2luZyIsICJhcmdzIiwgImNhbGwiLCAiYXBwbHkiLCAiZGVib3VuY2UiLCAiZGVsYXkiLCAidGltZW91dCIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgIl90ZXh0WCIsICJsZWZ0IiwgInJpZ2h0IiwgInJ0bCIsICJjaGVjayIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgIk1hdGgiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaCIsICJpbnRlcnBvbGF0ZSIsICJjb2xvciIsICJpc1BhdHRlcm5PckdyYWRpZW50IiwgInZhbHVlIiwgInR5cGUiLCAidG9TdHJpbmciLCAiY29sb3JMaWIiLCAiZ2V0SG92ZXJDb2xvciIsICJzYXR1cmF0ZSIsICJkYXJrZW4iLCAiaGV4U3RyaW5nIiwgIm51bWJlcnMiLCAiY29sb3JzIiwgImFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzIiwgImRlZmF1bHRzIiwgInNldCIsICJkZWxheSIsICJ1bmRlZmluZWQiLCAiZHVyYXRpb24iLCAiZWFzaW5nIiwgImZuIiwgImZyb20iLCAibG9vcCIsICJ0byIsICJkZXNjcmliZSIsICJfZmFsbGJhY2siLCAiX2luZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInByb3BlcnRpZXMiLCAiYWN0aXZlIiwgImFuaW1hdGlvbiIsICJyZXNpemUiLCAic2hvdyIsICJhbmltYXRpb25zIiwgInZpc2libGUiLCAiaGlkZSIsICJ2IiwgImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwgImF1dG9QYWRkaW5nIiwgInBhZGRpbmciLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJvcHRpb25zIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJsZW5ndGgiLCAibWF4VGljayIsICJtYXgiLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAibWluIiwgImZsb29yIiwgIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsICJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiY2FsbCIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAicmV2ZXJzZSIsICJiZWdpbkF0WmVybyIsICJib3VuZHMiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgImNhbGxiYWNrIiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImFsaWduIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJhcHBseSIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiaXNOYU4iLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAiY2xpcCIsICJ1bmNsaXBBcmVhIiwgInJlbmRlclRleHQiLCAiY3R4IiwgInRleHQiLCAieCIsICJ5IiwgImZvbnQiLCAib3B0cyIsICJsaW5lcyIsICJpc0FycmF5IiwgInN0cm9rZSIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJpIiwgImxpbmUiLCAic2F2ZSIsICJzdHJpbmciLCAic2V0UmVuZGVyT3B0cyIsICJsZW5ndGgiLCAiYmFja2Ryb3AiLCAiZHJhd0JhY2tkcm9wIiwgInN0cm9rZVN0eWxlIiwgImlzTnVsbE9yVW5kZWYiLCAibGluZVdpZHRoIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmVIZWlnaHQiLCAicmVzdG9yZSIsICJ0cmFuc2xhdGlvbiIsICJ0cmFuc2xhdGUiLCAicm90YXRpb24iLCAicm90YXRlIiwgImNvbG9yIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAibWVhc3VyZVRleHQiLCAibGVmdCIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAicmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJ0b3AiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYm90dG9tIiwgImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsICJ5RGVjb3JhdGlvbiIsICJiZWdpblBhdGgiLCAiZGVjb3JhdGlvbldpZHRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAid2lkdGgiLCAiaGVpZ2h0IiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJyZWN0IiwgInciLCAiaCIsICJyYWRpdXMiLCAiYXJjIiwgInRvcExlZnQiLCAiSEFMRl9QSSIsICJQSSIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgInRvcFJpZ2h0IiwgIkxJTkVfSEVJR0hUIiwgIkZPTlRfU1RZTEUiLCAidG9MaW5lSGVpZ2h0IiwgInZhbHVlIiwgInNpemUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAidiIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAiaXNPYmplY3QiLCAia2V5cyIsICJPYmplY3QiLCAicmVhZCIsICJwcm9wIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgIm9wdGlvbnMiLCAiZmFsbGJhY2siLCAiZGVmYXVsdHMiLCAicGFyc2VJbnQiLCAic3R5bGUiLCAiY29uc29sZSIsICJ3YXJuIiwgInVuZGVmaW5lZCIsICJmYW1pbHkiLCAid2VpZ2h0IiwgInRvRm9udFN0cmluZyIsICJyZXNvbHZlIiwgImlucHV0cyIsICJjb250ZXh0IiwgImluZGV4IiwgImluZm8iLCAiY2FjaGVhYmxlIiwgImlsZW4iLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJncmFjZSIsICJiZWdpbkF0WmVybyIsICJtaW4iLCAibWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiTWF0aCIsICJhYnMiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgImFzc2lnbiIsICJjcmVhdGUiLCAiX2NyZWF0ZVJlc29sdmVyIiwgInNjb3BlcyIsICJwcmVmaXhlcyIsICJyb290U2NvcGVzIiwgImdldFRhcmdldCIsICJkZWZpbmVkIiwgIl9yZXNvbHZlIiwgImNhY2hlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2ZhbGxiYWNrIiwgIl9nZXRUYXJnZXQiLCAib3ZlcnJpZGUiLCAic2NvcGUiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAidGFyZ2V0IiwgIl9rZXlzIiwgImdldCIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJpbmNsdWRlcyIsICJvd25LZXlzIiwgInNldCIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAiX2Rlc2NyaXB0b3JzIiwgInNldENvbnRleHQiLCAicmVjZWl2ZXIiLCAiX3Jlc29sdmVXaXRoQ29udGV4dCIsICJhbGxLZXlzIiwgImVudW1lcmFibGUiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAibmFtZSIsICJfY2FwaXRhbGl6ZSIsICJuZWVkc1N1YlJlc29sdmVyIiwgImNvbnN0cnVjdG9yIiwgInByb3RvdHlwZSIsICJoYXNPd25Qcm9wZXJ0eSIsICJjYWxsIiwgImRlc2NyaXB0b3JzIiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgIkVycm9yIiwgIkFycmF5IiwgImZyb20iLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJzIiwgIml0ZW0iLCAicmVzb2x2ZXIiLCAicHVzaCIsICJyZXNvbHZlRmFsbGJhY2siLCAiZ2V0U2NvcGUiLCAia2V5IiwgInBhcmVudCIsICJyZXNvbHZlT2JqZWN0S2V5IiwgImFkZFNjb3BlcyIsICJwYXJlbnRTY29wZXMiLCAicGFyZW50RmFsbGJhY2siLCAiYWxsU2NvcGVzIiwgImFkZFNjb3Blc0Zyb21LZXkiLCAic3ViR2V0VGFyZ2V0IiwgInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsICJrIiwgInN0YXJ0c1dpdGgiLCAiRVBTSUxPTiIsICJOdW1iZXIiLCAiX2lzRG9tU3VwcG9ydGVkIiwgIndpbmRvdyIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudCIsICJwYXJlbnROb2RlIiwgInRvU3RyaW5nIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgIm5vZGUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJwYXJzZUludCIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3R5bGUiLCAic3VmZml4IiwgInJlc3VsdCIsICJpIiwgInBvcyIsICJwYXJzZUZsb2F0IiwgIndpZHRoIiwgImxlZnQiLCAicmlnaHQiLCAiaGVpZ2h0IiwgInRvcCIsICJib3R0b20iLCAidXNlT2Zmc2V0UG9zIiwgIngiLCAieSIsICJ0YXJnZXQiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgImNhbnZhcyIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJsZW5ndGgiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgImJveCIsICJyZWN0IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJjaGFydCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgIk1hdGgiLCAicm91bmQiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAidW5kZWZpbmVkIiwgImNvbnRhaW5lciIsICJjbGllbnRXaWR0aCIsICJjbGllbnRIZWlnaHQiLCAiY29udGFpbmVyU3R5bGUiLCAiY29udGFpbmVyQm9yZGVyIiwgImNvbnRhaW5lclBhZGRpbmciLCAiSU5GSU5JVFkiLCAicm91bmQxIiwgInYiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWF4IiwgImZsb29yIiwgIm1pbiIsICJtYWludGFpbkhlaWdodCIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAiY3R4IiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAib3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAidmFsdWUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAid2lkdGgiLCAieCIsICJzZXRXaWR0aCIsICJ3IiwgInRleHRBbGlnbiIsICJhbGlnbiIsICJ4UGx1cyIsICJ2YWx1ZSIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgInJ0bCIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiY3R4IiwgImRpcmVjdGlvbiIsICJzdHlsZSIsICJvcmlnaW5hbCIsICJjYW52YXMiLCAiZ2V0UHJvcGVydHlWYWx1ZSIsICJnZXRQcm9wZXJ0eVByaW9yaXR5IiwgInNldFByb3BlcnR5IiwgInByZXZUZXh0RGlyZWN0aW9uIiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInVuZGVmaW5lZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAibWV0YSIsICJzdGFja2VkIiwgImdldFN0YWNrS2V5IiwgImluZGV4U2NhbGUiLCAidmFsdWVTY2FsZSIsICJpZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJOdW1iZXIiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiZ2V0T3JDcmVhdGVTdGFjayIsICJzdGFja3MiLCAic3RhY2tLZXkiLCAiaW5kZXhWYWx1ZSIsICJzdWJTdGFjayIsICJnZXRMYXN0SW5kZXhJblN0YWNrIiwgInZTY2FsZSIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpU2NhbGUiLCAiaUF4aXMiLCAiYXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAiaUF4aXNLZXkiLCAidkF4aXNLZXkiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAic2tpcE51bGwiLCAidmFsIiwgImlzTmFOIiwgImluZGV4T2YiLCAiX2dldFN0YWNrQ291bnQiLCAiX2dldFN0YWNrSW5kZXgiLCAibmFtZSIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiYmFzZVZhbHVlIiwgIm1pbkJhckxlbmd0aCIsICJmbG9hdGluZyIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJzdGFydFBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJlbmRQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAic3RhY2tJbmRleCIsICJyZWN0cyIsICJudW1iZXJzIiwgIm92ZXJyaWRlcyIsICJfaW5kZXhfIiwgIm9mZnNldCIsICJncmlkIiwgIl92YWx1ZV8iLCAiYmVnaW5BdFplcm8iLCAiZ2V0UmF0aW9BbmRPZmZzZXQiLCAicm90YXRpb24iLCAiY2lyY3VtZmVyZW5jZSIsICJjdXRvdXQiLCAicmF0aW9YIiwgInJhdGlvWSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiVEFVIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAic3RhcnRYIiwgIk1hdGgiLCAiY29zIiwgInN0YXJ0WSIsICJzaW4iLCAiZW5kWCIsICJlbmRZIiwgImNhbGNNYXgiLCAiYW5nbGUiLCAiYSIsICJiIiwgIl9hbmdsZUJldHdlZW4iLCAibWF4IiwgImNhbGNNaW4iLCAibWluIiwgIm1heFgiLCAibWF4WSIsICJIQUxGX1BJIiwgIm1pblgiLCAiUEkiLCAibWluWSIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiRGF0YXNldENvbnRyb2xsZXIiLCAiY29uc3RydWN0b3IiLCAiY2hhcnQiLCAiZGF0YXNldEluZGV4IiwgImVuYWJsZU9wdGlvblNoYXJpbmciLCAiaW5uZXJSYWRpdXMiLCAidW5kZWZpbmVkIiwgIm91dGVyUmFkaXVzIiwgImxpbmtTY2FsZXMiLCAicGFyc2UiLCAic3RhcnQiLCAiY291bnQiLCAiZGF0YSIsICJnZXREYXRhc2V0IiwgIm1ldGEiLCAiX2NhY2hlZE1ldGEiLCAiX3BhcnNpbmciLCAiX3BhcnNlZCIsICJnZXR0ZXIiLCAiaSIsICJpc09iamVjdCIsICJrZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJpbGVuIiwgIl9nZXRSb3RhdGlvbiIsICJ0b1JhZGlhbnMiLCAib3B0aW9ucyIsICJfZ2V0Q2lyY3VtZmVyZW5jZSIsICJfZ2V0Um90YXRpb25FeHRlbnRzIiwgImRhdGFzZXRzIiwgImxlbmd0aCIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImdldERhdGFzZXRNZXRhIiwgInR5cGUiLCAiX3R5cGUiLCAiY29udHJvbGxlciIsICJ1cGRhdGUiLCAibW9kZSIsICJjaGFydEFyZWEiLCAiYXJjcyIsICJzcGFjaW5nIiwgImdldE1heEJvcmRlcldpZHRoIiwgImdldE1heE9mZnNldCIsICJtYXhTaXplIiwgIndpZHRoIiwgImhlaWdodCIsICJ0b1BlcmNlbnRhZ2UiLCAiY2hhcnRXZWlnaHQiLCAiX2dldFJpbmdXZWlnaHQiLCAiaW5kZXgiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgIm1heFJhZGl1cyIsICJ0b0RpbWVuc2lvbiIsICJyYWRpdXMiLCAicmFkaXVzTGVuZ3RoIiwgIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwgInRvdGFsIiwgImNhbGN1bGF0ZVRvdGFsIiwgIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwgInVwZGF0ZUVsZW1lbnRzIiwgIl9jaXJjdW1mZXJlbmNlIiwgInJlc2V0IiwgIm9wdHMiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGVSb3RhdGUiLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAiaGlkZGVuIiwgImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCAiYW5pbWF0aW9uT3B0cyIsICJjZW50ZXJYIiwgImxlZnQiLCAicmlnaHQiLCAiY2VudGVyWSIsICJ0b3AiLCAiYm90dG9tIiwgImFuaW1hdGVTY2FsZSIsICJzaGFyZWRPcHRpb25zIiwgImluY2x1ZGVPcHRpb25zIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImFyYyIsICJwcm9wZXJ0aWVzIiwgIngiLCAieSIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImFjdGl2ZSIsICJ1cGRhdGVFbGVtZW50IiwgIm1ldGFEYXRhIiwgInZhbHVlIiwgImlzTmFOIiwgImFicyIsICJnZXRMYWJlbEFuZFZhbHVlIiwgImxhYmVscyIsICJmb3JtYXROdW1iZXIiLCAibG9jYWxlIiwgImxhYmVsIiwgImJvcmRlckFsaWduIiwgImJvcmRlcldpZHRoIiwgImhvdmVyQm9yZGVyV2lkdGgiLCAib2Zmc2V0IiwgImhvdmVyT2Zmc2V0IiwgInJpbmdXZWlnaHRPZmZzZXQiLCAidmFsdWVPckRlZmF1bHQiLCAid2VpZ2h0IiwgImlkIiwgImRlZmF1bHRzIiwgImRhdGFzZXRFbGVtZW50VHlwZSIsICJkYXRhRWxlbWVudFR5cGUiLCAiYW5pbWF0aW9ucyIsICJudW1iZXJzIiwgImluZGV4QXhpcyIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgIl9pbmRleGFibGUiLCAib3ZlcnJpZGVzIiwgImFzcGVjdFJhdGlvIiwgInBsdWdpbnMiLCAibGVnZW5kIiwgImdlbmVyYXRlTGFiZWxzIiwgInBvaW50U3R5bGUiLCAiY29sb3IiLCAibWFwIiwgInN0eWxlIiwgImdldFN0eWxlIiwgInRleHQiLCAiZmlsbFN0eWxlIiwgImJhY2tncm91bmRDb2xvciIsICJzdHJva2VTdHlsZSIsICJib3JkZXJDb2xvciIsICJmb250Q29sb3IiLCAibGluZVdpZHRoIiwgIm9uQ2xpY2siLCAiZSIsICJsZWdlbmRJdGVtIiwgInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwgIlBpZUNvbnRyb2xsZXIiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgImlkIiwgImRlZmF1bHRzIiwgImN1dG91dCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgInJhZGl1cyIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAib3ZlcnJpZGUiLCAibWVtYmVycyIsICJPYmplY3QiLCAiYXNzaWduIiwgInByb3RvdHlwZSIsICJjb25zdHJ1Y3RvciIsICJvcHRpb25zIiwgImluaXQiLCAiZm9ybWF0cyIsICJwYXJzZSIsICJmb3JtYXQiLCAiYWRkIiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJheGlzIiwgInZhbHVlIiwgImludGVyc2VjdCIsICJjb250cm9sbGVyIiwgImRhdGEiLCAiX3NvcnRlZCIsICJpU2NhbGUiLCAiX2NhY2hlZE1ldGEiLCAibGVuZ3RoIiwgImxvb2t1cE1ldGhvZCIsICJfcmV2ZXJzZVBpeGVscyIsICJfcmxvb2t1cEJ5S2V5IiwgIl9sb29rdXBCeUtleSIsICJfc2hhcmVkT3B0aW9ucyIsICJlbCIsICJyYW5nZSIsICJnZXRSYW5nZSIsICJzdGFydCIsICJlbmQiLCAibG8iLCAiaGkiLCAiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwgImNoYXJ0IiwgInBvc2l0aW9uIiwgImhhbmRsZXIiLCAibWV0YXNldHMiLCAiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsICJpIiwgImlsZW4iLCAiaW5kZXgiLCAiaiIsICJlbGVtZW50IiwgInNraXAiLCAiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwgInVzZVgiLCAiaW5kZXhPZiIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgIk1hdGgiLCAiYWJzIiwgIngiLCAiZGVsdGFZIiwgInkiLCAic3FydCIsICJwb3ciLCAiZ2V0SW50ZXJzZWN0SXRlbXMiLCAidXNlRmluYWxQb3NpdGlvbiIsICJpbmNsdWRlSW52aXNpYmxlIiwgIml0ZW1zIiwgImlzUG9pbnRJbkFyZWEiLCAiZXZhbHVhdGlvbkZ1bmMiLCAiZGF0YXNldEluZGV4IiwgIl9pc1BvaW50SW5BcmVhIiwgImNoYXJ0QXJlYSIsICJpblJhbmdlIiwgInB1c2giLCAiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAiZ2V0UHJvcHMiLCAiYW5nbGUiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiX2FuZ2xlQmV0d2VlbiIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJwb2ludEluQXJlYSIsICJkaXN0YW5jZSIsICJnZXROZWFyZXN0SXRlbXMiLCAiZ2V0QXhpc0l0ZW1zIiwgInJhbmdlTWV0aG9kIiwgImludGVyc2VjdHNJdGVtIiwgIm1vZGVzIiwgImUiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJlbGVtZW50cyIsICJmb3JFYWNoIiwgIm1ldGEiLCAiZGF0YXNldCIsICJnZXREYXRhc2V0TWV0YSIsICJwb2ludCIsICJuZWFyZXN0IiwgIlNUQVRJQ19QT1NJVElPTlMiLCAiZmlsdGVyQnlQb3NpdGlvbiIsICJhcnJheSIsICJmaWx0ZXIiLCAidiIsICJwb3MiLCAiZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzIiwgImJveCIsICJzb3J0QnlXZWlnaHQiLCAicmV2ZXJzZSIsICJzb3J0IiwgImEiLCAiYiIsICJ2MCIsICJ2MSIsICJ3ZWlnaHQiLCAid3JhcEJveGVzIiwgImJveGVzIiwgImxheW91dEJveGVzIiwgInN0YWNrIiwgInN0YWNrV2VpZ2h0IiwgImhvcml6b250YWwiLCAiaXNIb3Jpem9udGFsIiwgImJ1aWxkU3RhY2tzIiwgImxheW91dHMiLCAic3RhY2tzIiwgIndyYXAiLCAiaW5jbHVkZXMiLCAiX3N0YWNrIiwgImNvdW50IiwgInBsYWNlZCIsICJzaXplIiwgInNldExheW91dERpbXMiLCAicGFyYW1zIiwgInZCb3hNYXhXaWR0aCIsICJoQm94TWF4SGVpZ2h0IiwgImxheW91dCIsICJmdWxsU2l6ZSIsICJmYWN0b3IiLCAid2lkdGgiLCAiYXZhaWxhYmxlV2lkdGgiLCAiaGVpZ2h0IiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImxlZnQiLCAicmlnaHQiLCAidG9wIiwgImJvdHRvbSIsICJjZW50ZXJIb3Jpem9udGFsIiwgImNlbnRlclZlcnRpY2FsIiwgImxlZnRBbmRUb3AiLCAiY29uY2F0IiwgInJpZ2h0QW5kQm90dG9tIiwgInZlcnRpY2FsIiwgImdldENvbWJpbmVkTWF4IiwgIm1heFBhZGRpbmciLCAibWF4IiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImlzT2JqZWN0IiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInVwZGF0ZSIsICJzZXRCb3hEaW1zIiwgInBsYWNlQm94ZXMiLCAidXNlclBhZGRpbmciLCAicGFkZGluZyIsICJkZWZpbmVkIiwgImFkZEJveCIsICJpdGVtIiwgIl9sYXllcnMiLCAieiIsICJkcmF3IiwgInJlbW92ZUJveCIsICJsYXlvdXRJdGVtIiwgInNwbGljZSIsICJjb25maWd1cmUiLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAicmVkdWNlIiwgInRvdGFsIiwgImRpc3BsYXkiLCAiZnJlZXplIiwgIkJhc2VQbGF0Zm9ybSIsICJhY3F1aXJlQ29udGV4dCIsICJjYW52YXMiLCAiYXNwZWN0UmF0aW8iLCAicmVsZWFzZUNvbnRleHQiLCAiY29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgInR5cGUiLCAibGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImdldE1heGltdW1TaXplIiwgImZsb29yIiwgImlzQXR0YWNoZWQiLCAidXBkYXRlQ29uZmlnIiwgImNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgImdldENvbnRleHQiLCAiYW5pbWF0aW9uIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInN0eWxlIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiaW5pdGlhbCIsICJib3hTaXppbmciLCAiZGlzcGxheVdpZHRoIiwgInJlYWRVc2VkU2l6ZSIsICJ1bmRlZmluZWQiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAiZXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiZW50cnkiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAiTWFwIiwgIm9sZERldmljZVBpeGVsUmF0aW8iLCAib25XaW5kb3dSZXNpemUiLCAiZHByIiwgIndpbmRvdyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgInJlc2l6ZSIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJzZXQiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJkZWxldGUiLCAiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCAiY29udGFpbmVyIiwgIl9nZXRQYXJlbnROb2RlIiwgInRocm90dGxlZCIsICJjbGllbnRXaWR0aCIsICJSZXNpemVPYnNlcnZlciIsICJjb250ZW50UmVjdCIsICJyZWxlYXNlT2JzZXJ2ZXIiLCAiZGlzY29ubmVjdCIsICJjcmVhdGVQcm94eUFuZExpc3RlbiIsICJwcm94eSIsICJjdHgiLCAiRG9tUGxhdGZvcm0iLCAicHJvcCIsICJpc051bGxPclVuZGVmIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAia2V5cyIsICJrZXkiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAiYWN0aXZlIiwgInRvb2x0aXBQb3NpdGlvbiIsICJoYXNWYWx1ZSIsICJpc051bWJlciIsICJwcm9wcyIsICJmaW5hbCIsICJhbmltcyIsICIkYW5pbWF0aW9ucyIsICJyZXQiLCAiX3RvIiwgImRlZmF1bHRzIiwgImRlZmF1bHRSb3V0ZXMiLCAiYXV0b1NraXAiLCAic2NhbGUiLCAidGlja3MiLCAidGlja09wdHMiLCAiZGV0ZXJtaW5lZE1heFRpY2tzIiwgImRldGVybWluZU1heFRpY2tzIiwgInRpY2tzTGltaXQiLCAibWluIiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJsYXN0IiwgIm5ld1RpY2tzIiwgInNraXBNYWpvcnMiLCAic3BhY2luZyIsICJjYWxjdWxhdGVTcGFjaW5nIiwgImF2Z01ham9yU3BhY2luZyIsICJyb3VuZCIsICJvZmZzZXQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAiX2xlbmd0aCIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAiZmFjdG9ycyIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJuZXh0IiwgImNlaWwiLCAibWFqb3JTdGFydCIsICJtYWpvckVuZCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJhcnIiLCAibGVuIiwgInJldmVyc2VBbGlnbiIsICJhbGlnbiIsICJvZmZzZXRGcm9tRWRnZSIsICJlZGdlIiwgInNhbXBsZSIsICJudW1JdGVtcyIsICJpbmNyZW1lbnQiLCAiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsICJvZmZzZXRHcmlkTGluZXMiLCAidmFsaWRJbmRleCIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImdhcmJhZ2VDb2xsZWN0IiwgImNhY2hlcyIsICJjYWNoZSIsICJnYyIsICJnY0xlbiIsICJnZXRUaWNrTWFya0xlbmd0aCIsICJkcmF3VGlja3MiLCAiZ2V0VGl0bGVIZWlnaHQiLCAiZmFsbGJhY2siLCAiZm9udCIsICJ0b0ZvbnQiLCAibGluZXMiLCAiaXNBcnJheSIsICJ0ZXh0IiwgImxpbmVIZWlnaHQiLCAiY3JlYXRlU2NhbGVDb250ZXh0IiwgInBhcmVudCIsICJjcmVhdGVDb250ZXh0IiwgImNyZWF0ZVRpY2tDb250ZXh0IiwgInRpY2siLCAidGl0bGVBbGlnbiIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAidGl0bGVBcmdzIiwgInNjYWxlcyIsICJyb3RhdGlvbiIsICJtYXhXaWR0aCIsICJ0aXRsZVgiLCAidGl0bGVZIiwgIl9hbGlnblN0YXJ0RW5kIiwgInBvc2l0aW9uQXhpc0lEIiwgImdldFBpeGVsRm9yVmFsdWUiLCAiSEFMRl9QSSIsICJTY2FsZSIsICJjZmciLCAiaWQiLCAiX21hcmdpbnMiLCAibWF4SGVpZ2h0IiwgInBhZGRpbmdUb3AiLCAicGFkZGluZ0JvdHRvbSIsICJwYWRkaW5nTGVmdCIsICJwYWRkaW5nUmlnaHQiLCAibGFiZWxSb3RhdGlvbiIsICJfcmFuZ2UiLCAiX2dyaWRMaW5lSXRlbXMiLCAiX2xhYmVsSXRlbXMiLCAiX2xhYmVsU2l6ZXMiLCAiX2xvbmdlc3RUZXh0Q2FjaGUiLCAiX3VzZXJNYXgiLCAiX3VzZXJNaW4iLCAiX3N1Z2dlc3RlZE1heCIsICJfc3VnZ2VzdGVkTWluIiwgIl90aWNrc0xlbmd0aCIsICJfYm9yZGVyVmFsdWUiLCAiX2NhY2hlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgIiRjb250ZXh0IiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJyYXciLCAiZ2V0VXNlckJvdW5kcyIsICJmaW5pdGVPckRlZmF1bHQiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAibWluRGVmaW5lZCIsICJpc0Zpbml0ZSIsICJtYXhEZWZpbmVkIiwgImdldE1pbk1heCIsICJjYW5TdGFjayIsICJtZXRhcyIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJnZXRUaWNrcyIsICJnZXRMYWJlbHMiLCAibGFiZWxzIiwgInhMYWJlbHMiLCAieUxhYmVscyIsICJiZWZvcmVVcGRhdGUiLCAiY2FsbCIsICJtYXJnaW5zIiwgImJlZ2luQXRaZXJvIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAic3RhcnRQaXhlbCIsICJlbmRQaXhlbCIsICJfYWxpZ25Ub1BpeGVscyIsICJhbGlnblRvUGl4ZWxzIiwgIl9jYWxsSG9va3MiLCAibmFtZSIsICJub3RpZnlQbHVnaW5zIiwgImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJnZW5lcmF0ZVRpY2tMYWJlbHMiLCAibGFiZWwiLCAiY2FsbGJhY2siLCAiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAibnVtVGlja3MiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAidGlja1dpZHRoIiwgIm1heExhYmVsRGlhZ29uYWwiLCAiX2lzVmlzaWJsZSIsICJsYWJlbFNpemVzIiwgIl9nZXRMYWJlbFNpemVzIiwgIm1heExhYmVsV2lkdGgiLCAid2lkZXN0IiwgIm1heExhYmVsSGVpZ2h0IiwgImhpZ2hlc3QiLCAiX2xpbWl0VmFsdWUiLCAiZ3JpZCIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJtaW5TaXplIiwgInRpdGxlT3B0cyIsICJncmlkT3B0cyIsICJ0aXRsZUhlaWdodCIsICJ0aWNrUGFkZGluZyIsICJhbmdsZVJhZGlhbnMiLCAidG9SYWRpYW5zIiwgImNvcyIsICJzaW4iLCAibGFiZWxIZWlnaHQiLCAibWlycm9yIiwgImxhYmVsV2lkdGgiLCAiX2NhbGN1bGF0ZVBhZGRpbmciLCAiX2hhbmRsZU1hcmdpbnMiLCAiaXNSb3RhdGVkIiwgImxhYmVsc0JlbG93VGlja3MiLCAib2Zmc2V0TGVmdCIsICJvZmZzZXRSaWdodCIsICJpc0Z1bGxTaXplIiwgIl9jb21wdXRlTGFiZWxTaXplcyIsICJ3aWR0aHMiLCAiaGVpZ2h0cyIsICJ3aWRlc3RMYWJlbFNpemUiLCAiaGlnaGVzdExhYmVsU2l6ZSIsICJqbGVuIiwgInRpY2tGb250IiwgImZvbnRTdHJpbmciLCAibmVzdGVkTGFiZWwiLCAiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCAic3RyaW5nIiwgIl9tZWFzdXJlVGV4dCIsICJ2YWx1ZUF0IiwgImlkeCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIk5hTiIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJkZWNpbWFsIiwgIl9pbnQxNlJhbmdlIiwgIl9hbGlnblBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgImJvcmRlciIsICJ0aWNrc0xlbmd0aCIsICJ0bCIsICJib3JkZXJPcHRzIiwgImF4aXNXaWR0aCIsICJheGlzSGFsZldpZHRoIiwgImFsaWduQm9yZGVyVmFsdWUiLCAiYm9yZGVyVmFsdWUiLCAiYWxpZ25lZExpbmVWYWx1ZSIsICJ0eDEiLCAidHkxIiwgInR4MiIsICJ0eTIiLCAieDEiLCAieTEiLCAieDIiLCAieTIiLCAibGltaXQiLCAic3RlcCIsICJvcHRzQXRJbmRleCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJsaW5lV2lkdGgiLCAibGluZUNvbG9yIiwgImNvbG9yIiwgImJvcmRlckRhc2giLCAiZGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAidGlja0NvbG9yIiwgInRpY2tCb3JkZXJEYXNoIiwgInRpY2tCb3JkZXJEYXNoT2Zmc2V0IiwgIl9jb21wdXRlTGFiZWxJdGVtcyIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgImJhY2tncm91bmRDb2xvciIsICJzYXZlIiwgImZpbGxTdHlsZSIsICJmaWxsUmVjdCIsICJyZXN0b3JlIiwgImdldExpbmVXaWR0aEZvclZhbHVlIiwgImZpbmRJbmRleCIsICJ0IiwgIm9wdHMiLCAiZHJhd0dyaWQiLCAiZHJhd0xpbmUiLCAicDEiLCAicDIiLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAibGluZURhc2hPZmZzZXQiLCAiYmVnaW5QYXRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdPbkNoYXJ0QXJlYSIsICJkcmF3Qm9yZGVyIiwgImxhc3RMaW5lV2lkdGgiLCAiZHJhd0xhYmVscyIsICJhcmVhIiwgImNsaXBBcmVhIiwgInJlbmRlclRleHQiLCAidW5jbGlwQXJlYSIsICJkcmF3VGl0bGUiLCAidHoiLCAiZ3oiLCAiYnoiLCAiYXhpc0lEIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJvdmVycmlkZXMiLCAiZ2V0IiwgInVucmVnaXN0ZXIiLCAiaXRlbURlZmF1bHRzIiwgIm1lcmdlIiwgInJvdXRlRGVmYXVsdHMiLCAiZGVzY3JpcHRvcnMiLCAiZGVzY3JpYmUiLCAicm91dGVzIiwgInByb3BlcnR5IiwgInByb3BlcnR5UGFydHMiLCAic3BsaXQiLCAic291cmNlTmFtZSIsICJwb3AiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgInBsdWdpbnMiLCAiX3R5cGVkUmVnaXN0cmllcyIsICJhcmdzIiwgIl9lYWNoIiwgInJlbW92ZSIsICJhZGRDb250cm9sbGVycyIsICJhZGRFbGVtZW50cyIsICJhZGRQbHVnaW5zIiwgImFkZFNjYWxlcyIsICJnZXRDb250cm9sbGVyIiwgIl9nZXQiLCAiZ2V0RWxlbWVudCIsICJnZXRQbHVnaW4iLCAiZ2V0U2NhbGUiLCAicmVtb3ZlQ29udHJvbGxlcnMiLCAicmVtb3ZlRWxlbWVudHMiLCAicmVtb3ZlUGx1Z2lucyIsICJyZW1vdmVTY2FsZXMiLCAibWV0aG9kIiwgInR5cGVkUmVnaXN0cnkiLCAiYXJnIiwgInJlZyIsICJfZ2V0UmVnaXN0cnlGb3JUeXBlIiwgIl9leGVjIiwgIml0ZW1SZWciLCAicmVnaXN0cnkiLCAiY29tcG9uZW50IiwgImNhbWVsTWV0aG9kIiwgIl9jYXBpdGFsaXplIiwgIlBsdWdpblNlcnZpY2UiLCAiX2luaXQiLCAibm90aWZ5IiwgImhvb2siLCAiX2NyZWF0ZURlc2NyaXB0b3JzIiwgIl9ub3RpZnkiLCAiX2Rlc2NyaXB0b3JzIiwgImRlc2NyaXB0b3IiLCAicGx1Z2luIiwgImNhbGxDYWxsYmFjayIsICJjYW5jZWxhYmxlIiwgImludmFsaWRhdGUiLCAiX29sZENhY2hlIiwgIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCAiYWxsIiwgImFsbFBsdWdpbnMiLCAiY3JlYXRlRGVzY3JpcHRvcnMiLCAicHJldmlvdXNEZXNjcmlwdG9ycyIsICJzb21lIiwgImxvY2FsSWRzIiwgImxvY2FsIiwgImdldE9wdHMiLCAicGx1Z2luT3B0cyIsICJwbHVnaW5TY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJzY3JpcHRhYmxlIiwgImluZGV4YWJsZSIsICJhbGxLZXlzIiwgImdldEluZGV4QXhpcyIsICJkYXRhc2V0RGVmYXVsdHMiLCAiZGF0YXNldHMiLCAiZGF0YXNldE9wdGlvbnMiLCAiaW5kZXhBeGlzIiwgImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCAiZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImNvbnNvbGUiLCAiZXJyb3IiLCAiX3Byb3h5IiwgIndhcm4iLCAiZGVmYXVsdElkIiwgImRlZmF1bHRTY2FsZU9wdGlvbnMiLCAibWVyZ2VJZiIsICJkZWZhdWx0SUQiLCAiaW5pdE9wdGlvbnMiLCAiaW5pdERhdGEiLCAiaW5pdENvbmZpZyIsICJrZXlDYWNoZSIsICJrZXlzQ2FjaGVkIiwgIlNldCIsICJjYWNoZWRLZXlzIiwgImNhY2hlS2V5IiwgImdlbmVyYXRlIiwgImFkZElmRm91bmQiLCAib2JqIiwgInJlc29sdmVPYmplY3RLZXkiLCAiQ29uZmlnIiwgIl9jb25maWciLCAiX3Njb3BlQ2FjaGUiLCAiX3Jlc29sdmVyQ2FjaGUiLCAicGxhdGZvcm0iLCAiY2xlYXJDYWNoZSIsICJjbGVhciIsICJkYXRhc2V0U2NvcGVLZXlzIiwgImRhdGFzZXRUeXBlIiwgImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCAidHJhbnNpdGlvbiIsICJkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyIsICJlbGVtZW50VHlwZSIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgIl9jYWNoZWRTY29wZXMiLCAibWFpblNjb3BlIiwgInJlc2V0Q2FjaGUiLCAia2V5TGlzdHMiLCAiY2FjaGVkIiwgIkFycmF5IiwgImZyb20iLCAiaGFzIiwgImNoYXJ0T3B0aW9uU2NvcGVzIiwgInJlc29sdmVOYW1lZE9wdGlvbnMiLCAibmFtZXMiLCAicHJlZml4ZXMiLCAiJHNoYXJlZCIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImdldE93blByb3BlcnR5TmFtZXMiLCAiYWNjIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJhbmltYXRpb25PcHRpb25zIiwgIm9uQ29tcGxldGUiLCAib25BbmltYXRpb25Qcm9ncmVzcyIsICJvblByb2dyZXNzIiwgImdldENhbnZhcyIsICJnZXRFbGVtZW50QnlJZCIsICJpbnN0YW5jZXMiLCAiZ2V0Q2hhcnQiLCAidmFsdWVzIiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgIm1vdmUiLCAiaW50S2V5IiwgImRldGVybWluZUxhc3RFdmVudCIsICJsYXN0RXZlbnQiLCAiaW5DaGFydEFyZWEiLCAiaXNDbGljayIsICJnZXREYXRhc2V0QXJlYSIsICJ4U2NhbGUiLCAieVNjYWxlIiwgIkNoYXJ0IiwgImludmFsaWRhdGVQbHVnaW5zIiwgInVzZXJDb25maWciLCAiaW5pdGlhbENhbnZhcyIsICJleGlzdGluZ0NoYXJ0IiwgInVpZCIsICJfb3B0aW9ucyIsICJfYXNwZWN0UmF0aW8iLCAiX21ldGFzZXRzIiwgIl9zdGFja3MiLCAiX2FjdGl2ZSIsICJfbGFzdEV2ZW50IiwgIl9saXN0ZW5lcnMiLCAiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCAiX3NvcnRlZE1ldGFzZXRzIiwgIl9wbHVnaW5zIiwgIl9oaWRkZW5JbmRpY2VzIiwgImF0dGFjaGVkIiwgIl9hbmltYXRpb25zRGlzYWJsZWQiLCAiX2RvUmVzaXplIiwgImRlYm91bmNlIiwgIm1vZGUiLCAicmVzaXplRGVsYXkiLCAiX2RhdGFDaGFuZ2VzIiwgImFuaW1hdG9yIiwgImxpc3RlbiIsICJfaW5pdGlhbGl6ZSIsICJtYWludGFpbkFzcGVjdFJhdGlvIiwgInJlc3BvbnNpdmUiLCAicmV0aW5hU2NhbGUiLCAiYmluZEV2ZW50cyIsICJjbGVhckNhbnZhcyIsICJzdG9wIiwgInJ1bm5pbmciLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJtYXAiLCAiaXNSYWRpYWwiLCAiZHBvc2l0aW9uIiwgImR0eXBlIiwgInNjYWxlVHlwZSIsICJzY2FsZUNsYXNzIiwgImhhc1VwZGF0ZWQiLCAiX3VwZGF0ZU1ldGFzZXRzIiwgIm51bURhdGEiLCAibnVtTWV0YSIsICJfZGVzdHJveURhdGFzZXRNZXRhIiwgInNsaWNlIiwgIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cyIsICJfZGF0YXNldCIsICJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCAibmV3Q29udHJvbGxlcnMiLCAib3JkZXIiLCAidmlzaWJsZSIsICJpc0RhdGFzZXRWaXNpYmxlIiwgInVwZGF0ZUluZGV4IiwgImxpbmtTY2FsZXMiLCAiQ29udHJvbGxlckNsYXNzIiwgImRhdGFzZXRFbGVtZW50VHlwZSIsICJkYXRhRWxlbWVudFR5cGUiLCAiX3Jlc2V0RWxlbWVudHMiLCAicmVzZXQiLCAiYW5pbXNEaXNhYmxlZCIsICJfdXBkYXRlU2NhbGVzIiwgIl9jaGVja0V2ZW50QmluZGluZ3MiLCAiX3VwZGF0ZUhpZGRlbkluZGljZXMiLCAiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwgImdldE1heE92ZXJmbG93IiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgIl91cGRhdGUiLCAibGF5ZXJzIiwgIl9kcmF3RGF0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJmaWx0ZXJWaXNpYmxlIiwgIl9kcmF3RGF0YXNldCIsICJjbGlwIiwgIl9jbGlwIiwgInVzZUNsaXAiLCAiZGlzYWJsZWQiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJoaWRkZW4iLCAieEF4aXNJRCIsICJ5QXhpc0lEIiwgIl9wYXJzZWQiLCAiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJkYXRhSW5kZXgiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgImhpZGUiLCAic2hvdyIsICJfZGVzdHJveSIsICJfc3RvcCIsICJkZXN0cm95IiwgInRvQmFzZTY0SW1hZ2UiLCAidG9EYXRhVVJMIiwgImJpbmRVc2VyRXZlbnRzIiwgImJpbmRSZXNwb25zaXZlRXZlbnRzIiwgImxpc3RlbmVycyIsICJfYWRkIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJfcmVtb3ZlIiwgImRldGFjaGVkIiwgInVwZGF0ZUhvdmVyU3R5bGUiLCAicHJlZml4IiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiX2VsZW1lbnRzRXF1YWwiLCAiaXNQbHVnaW5FbmFibGVkIiwgInBsdWdpbklkIiwgInJlcGxheSIsICJob3Zlck9wdGlvbnMiLCAiaG92ZXIiLCAiZGVhY3RpdmF0ZWQiLCAiYWN0aXZhdGVkIiwgImV2ZW50RmlsdGVyIiwgIl9oYW5kbGVFdmVudCIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiX2lzQ2xpY2tFdmVudCIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAidmVyc2lvbiIsICJjbGlwQXJjIiwgInBpeGVsTWFyZ2luIiwgIm91dGVyUmFkaXVzIiwgImlubmVyUmFkaXVzIiwgImFuZ2xlTWFyZ2luIiwgImFyYyIsICJjbG9zZVBhdGgiLCAidG9SYWRpdXNDb3JuZXJzIiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInBhcnNlQm9yZGVyUmFkaXVzIiwgImFuZ2xlRGVsdGEiLCAibyIsICJib3JkZXJSYWRpdXMiLCAiaGFsZlRoaWNrbmVzcyIsICJpbm5lckxpbWl0IiwgImNvbXB1dGVPdXRlckxpbWl0IiwgInZhbCIsICJvdXRlckFyY0xpbWl0IiwgIm91dGVyU3RhcnQiLCAib3V0ZXJFbmQiLCAiaW5uZXJTdGFydCIsICJpbm5lckVuZCIsICJyVGhldGFUb1hZIiwgInIiLCAidGhldGEiLCAicGF0aEFyYyIsICJjaXJjdWxhciIsICJpbm5lclIiLCAic3BhY2luZ09mZnNldCIsICJhbHBoYSIsICJub1NwYWNpbmdJbm5lclJhZGl1cyIsICJub1NwYWNpbmdPdXRlclJhZGl1cyIsICJhdk5vZ1NwYWNpbmdSYWRpdXMiLCAiYWRqdXN0ZWRBbmdsZSIsICJiZXRhIiwgIlBJIiwgImFuZ2xlT2Zmc2V0IiwgIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwgIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsICJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCAib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInBDZW50ZXIiLCAicDQiLCAiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInA4IiwgIm91dGVyU3RhcnRYIiwgIm91dGVyU3RhcnRZIiwgIm91dGVyRW5kWCIsICJvdXRlckVuZFkiLCAiZHJhd0FyYyIsICJmdWxsQ2lyY2xlcyIsICJjaXJjdW1mZXJlbmNlIiwgImZpbGwiLCAiaXNOYU4iLCAiVEFVIiwgImJvcmRlcldpZHRoIiwgImJvcmRlckpvaW5TdHlsZSIsICJpbm5lciIsICJib3JkZXJBbGlnbiIsICJsaW5lSm9pbiIsICJBcmNFbGVtZW50IiwgImNoYXJ0WCIsICJjaGFydFkiLCAickFkanVzdCIsICJfY2lyY3VtZmVyZW5jZSIsICJiZXR3ZWVuQW5nbGVzIiwgIndpdGhpblJhZGl1cyIsICJfaXNCZXR3ZWVuIiwgImhhbGZBbmdsZSIsICJoYWxmUmFkaXVzIiwgInRyYW5zbGF0ZSIsICJmaXgiLCAicmFkaXVzT2Zmc2V0IiwgImJvcmRlckNvbG9yIiwgImdldEJhckJvdW5kcyIsICJiYXIiLCAidXNlRmluYWxQb3NpdGlvbiIsICJ4IiwgInkiLCAiYmFzZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAiZ2V0UHJvcHMiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImhhbGYiLCAiaG9yaXpvbnRhbCIsICJNYXRoIiwgIm1pbiIsICJtYXgiLCAic2tpcE9yTGltaXQiLCAic2tpcCIsICJ2YWx1ZSIsICJfbGltaXRWYWx1ZSIsICJwYXJzZUJvcmRlcldpZHRoIiwgIm1heFciLCAibWF4SCIsICJvcHRpb25zIiwgImJvcmRlcldpZHRoIiwgImJvcmRlclNraXBwZWQiLCAibyIsICJ0b1RSQkwiLCAidCIsICJyIiwgImIiLCAibCIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJlbmFibGVCb3JkZXJSYWRpdXMiLCAiYm9yZGVyUmFkaXVzIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAiaXNPYmplY3QiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgImJvcmRlciIsICJyYWRpdXMiLCAib3V0ZXIiLCAidyIsICJoIiwgImlubmVyIiwgImluUmFuZ2UiLCAic2tpcFgiLCAic2tpcFkiLCAic2tpcEJvdGgiLCAiX2lzQmV0d2VlbiIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAiY3R4IiwgInJlY3QiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNmZyIsICJ1bmRlZmluZWQiLCAiaW5mbGF0ZUFtb3VudCIsICJPYmplY3QiLCAiYXNzaWduIiwgImRyYXciLCAiYm9yZGVyQ29sb3IiLCAiYmFja2dyb3VuZENvbG9yIiwgImFkZFJlY3RQYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJzYXZlIiwgImJlZ2luUGF0aCIsICJjbGlwIiwgImZpbGxTdHlsZSIsICJmaWxsIiwgInJlc3RvcmUiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJnZXRDZW50ZXJQb2ludCIsICJnZXRSYW5nZSIsICJheGlzIiwgImlkIiwgImRlZmF1bHRzIiwgInBvaW50U3R5bGUiLCAiZGVmYXVsdFJvdXRlcyIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJmb250U2l6ZSIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJNYXRoIiwgIm1pbiIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJtYXgiLCAiaXRlbXNFcXVhbCIsICJhIiwgImIiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgIkxlZ2VuZCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbmZpZyIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJjaGFydCIsICJvcHRpb25zIiwgImN0eCIsICJsZWdlbmRJdGVtcyIsICJ1bmRlZmluZWQiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJtYXhIZWlnaHQiLCAibWF4V2lkdGgiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ3aWR0aCIsICJfbWFyZ2lucyIsICJwb3NpdGlvbiIsICJ3ZWlnaHQiLCAiZnVsbFNpemUiLCAidXBkYXRlIiwgIm1hcmdpbnMiLCAic2V0RGltZW5zaW9ucyIsICJidWlsZExhYmVscyIsICJmaXQiLCAiaXNIb3Jpem9udGFsIiwgImxhYmVscyIsICJjYWxsIiwgImdlbmVyYXRlTGFiZWxzIiwgImZpbHRlciIsICJpdGVtIiwgImRhdGEiLCAic29ydCIsICJyZXZlcnNlIiwgImRpc3BsYXkiLCAibGFiZWxGb250IiwgInRvRm9udCIsICJmb250IiwgInNpemUiLCAidGl0bGVIZWlnaHQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJzdHJpbmciLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAicGFkZGluZyIsICJoaXRib3hlcyIsICJsaW5lSGVpZ2h0IiwgInRvdGFsSGVpZ2h0IiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAicm93IiwgImZvckVhY2giLCAibGVnZW5kSXRlbSIsICJpIiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJ0ZXh0IiwgImxlbmd0aCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJwdXNoIiwgImFkanVzdEhpdEJveGVzIiwgImFsaWduIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJfYWxpZ25TdGFydEVuZCIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJ4IiwgImRyYXciLCAiY2xpcEFyZWEiLCAiX2RyYXciLCAidW5jbGlwQXJlYSIsICJvcHRzIiwgImRlZmF1bHRDb2xvciIsICJkZWZhdWx0cyIsICJjb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdUaXRsZSIsICJsaW5lV2lkdGgiLCAiZHJhd0xlZ2VuZEJveCIsICJ5IiwgImlzTmFOIiwgInNhdmUiLCAidmFsdWVPckRlZmF1bHQiLCAiZmlsbFN0eWxlIiwgImxpbmVDYXAiLCAibGluZURhc2hPZmZzZXQiLCAibGluZUpvaW4iLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAicmFkaXVzIiwgIlNRUlQyIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAiYm9yZGVyV2lkdGgiLCAiY2VudGVyWCIsICJ4UGx1cyIsICJjZW50ZXJZIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImJlZ2luUGF0aCIsICJPYmplY3QiLCAidmFsdWVzIiwgInNvbWUiLCAidiIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAidyIsICJoIiwgInJlY3QiLCAiZmlsbCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJmaWxsVGV4dCIsICJyZW5kZXJUZXh0IiwgInN0cmlrZXRocm91Z2giLCAiaGlkZGVuIiwgImxpbmUiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAiZm9udENvbG9yIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZU9wdHMiLCAidGl0bGUiLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAicmVkdWNlIiwgImFjYyIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiX2lzQmV0d2VlbiIsICJoYW5kbGVFdmVudCIsICJlIiwgImlzTGlzdGVuZWQiLCAidHlwZSIsICJob3ZlcmVkSXRlbSIsICJwcmV2aW91cyIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgIm9uSG92ZXIiLCAib25DbGljayIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJsYWJlbEhlaWdodCIsICJpZCIsICJfZWxlbWVudCIsICJzdGFydCIsICJfYXJncyIsICJsZWdlbmQiLCAibGF5b3V0cyIsICJjb25maWd1cmUiLCAiYWRkQm94IiwgInN0b3AiLCAicmVtb3ZlQm94IiwgImJlZm9yZVVwZGF0ZSIsICJhZnRlclVwZGF0ZSIsICJhZnRlckV2ZW50IiwgImFyZ3MiLCAicmVwbGF5IiwgImV2ZW50IiwgImNpIiwgImlzRGF0YXNldFZpc2libGUiLCAiaGlkZSIsICJzaG93IiwgImRhdGFzZXRzIiwgInVzZUJvcmRlclJhZGl1cyIsICJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwgIm1hcCIsICJtZXRhIiwgInN0eWxlIiwgImNvbnRyb2xsZXIiLCAiZ2V0U3R5bGUiLCAibGFiZWwiLCAiYmFja2dyb3VuZENvbG9yIiwgInZpc2libGUiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJib3JkZXJDb2xvciIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInN0YXJ0c1dpdGgiLCAiaW5jbHVkZXMiLCAiVGl0bGUiLCAiX3BhZGRpbmciLCAibGluZUNvdW50IiwgImlzQXJyYXkiLCAidGV4dFNpemUiLCAicG9zIiwgIl9kcmF3QXJncyIsICJvZmZzZXQiLCAidGl0bGVYIiwgInRpdGxlWSIsICJQSSIsICJmb250T3B0cyIsICJ0cmFuc2xhdGlvbiIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgImRlZmF1bHRSb3V0ZXMiLCAiX2luZGV4YWJsZSIsICJXZWFrTWFwIiwgInNldCIsICJnZXQiLCAiZGVsZXRlIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAiaXRlbXMiLCAibGVuIiwgImNvdW50IiwgImVsIiwgImVsZW1lbnQiLCAiaGFzVmFsdWUiLCAidG9vbHRpcFBvc2l0aW9uIiwgIm5lYXJlc3QiLCAiZXZlbnRQb3NpdGlvbiIsICJtaW5EaXN0YW5jZSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAibmVhcmVzdEVsZW1lbnQiLCAiY2VudGVyIiwgImdldENlbnRlclBvaW50IiwgImQiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInRwIiwgInB1c2hPckNvbmNhdCIsICJiYXNlIiwgInRvUHVzaCIsICJBcnJheSIsICJwcm90b3R5cGUiLCAiYXBwbHkiLCAic3BsaXROZXdsaW5lcyIsICJzdHIiLCAiU3RyaW5nIiwgImluZGV4T2YiLCAic3BsaXQiLCAiY3JlYXRlVG9vbHRpcEl0ZW0iLCAiZ2V0RGF0YXNldE1ldGEiLCAidmFsdWUiLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJwYXJzZWQiLCAiZ2V0UGFyc2VkIiwgInJhdyIsICJmb3JtYXR0ZWRWYWx1ZSIsICJkYXRhc2V0IiwgImdldERhdGFzZXQiLCAiZGF0YUluZGV4IiwgImdldFRvb2x0aXBTaXplIiwgInRvb2x0aXAiLCAiYm9keSIsICJmb290ZXIiLCAiYm9keUZvbnQiLCAiZm9vdGVyRm9udCIsICJ0aXRsZUxpbmVDb3VudCIsICJmb290ZXJMaW5lQ291bnQiLCAiYm9keUxpbmVJdGVtQ291bnQiLCAiY29tYmluZWRCb2R5TGVuZ3RoIiwgImJvZHlJdGVtIiwgImJlZm9yZSIsICJsaW5lcyIsICJhZnRlciIsICJiZWZvcmVCb2R5IiwgImFmdGVyQm9keSIsICJ0aXRsZVNwYWNpbmciLCAidGl0bGVNYXJnaW5Cb3R0b20iLCAiYm9keUxpbmVIZWlnaHQiLCAiZGlzcGxheUNvbG9ycyIsICJib2R5U3BhY2luZyIsICJmb290ZXJNYXJnaW5Ub3AiLCAiZm9vdGVyU3BhY2luZyIsICJ3aWR0aFBhZGRpbmciLCAibWF4TGluZVdpZHRoIiwgImVhY2giLCAiY29uY2F0IiwgImJveFBhZGRpbmciLCAiZGV0ZXJtaW5lWUFsaWduIiwgImRvZXNOb3RGaXRXaXRoQWxpZ24iLCAieEFsaWduIiwgImNhcmV0IiwgImNhcmV0U2l6ZSIsICJjYXJldFBhZGRpbmciLCAiZGV0ZXJtaW5lWEFsaWduIiwgInlBbGlnbiIsICJjaGFydFdpZHRoIiwgImNoYXJ0QXJlYSIsICJkZXRlcm1pbmVBbGlnbm1lbnQiLCAiYWxpZ25YIiwgImFsaWduWSIsICJwYWRkaW5nQW5kU2l6ZSIsICJnZXRCYWNrZ3JvdW5kUG9pbnQiLCAiYWxpZ25tZW50IiwgImNvcm5lclJhZGl1cyIsICJ0b3BMZWZ0IiwgInRvcFJpZ2h0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAiX2xpbWl0VmFsdWUiLCAiZ2V0QWxpZ25lZFgiLCAiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCAiY2FsbGJhY2siLCAiY3JlYXRlVG9vbHRpcENvbnRleHQiLCAicGFyZW50IiwgInRvb2x0aXBJdGVtcyIsICJjcmVhdGVDb250ZXh0IiwgIm92ZXJyaWRlQ2FsbGJhY2tzIiwgImNhbGxiYWNrcyIsICJjb250ZXh0IiwgIm92ZXJyaWRlIiwgImRlZmF1bHRDYWxsYmFja3MiLCAiYmVmb3JlVGl0bGUiLCAibm9vcCIsICJsYWJlbENvdW50IiwgIm1vZGUiLCAiYWZ0ZXJUaXRsZSIsICJiZWZvcmVMYWJlbCIsICJ0b29sdGlwSXRlbSIsICJpc051bGxPclVuZGVmIiwgImxhYmVsQ29sb3IiLCAibGFiZWxUZXh0Q29sb3IiLCAiYm9keUNvbG9yIiwgImxhYmVsUG9pbnRTdHlsZSIsICJhZnRlckxhYmVsIiwgImJlZm9yZUZvb3RlciIsICJhZnRlckZvb3RlciIsICJpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayIsICJhcmciLCAicmVzdWx0IiwgIlRvb2x0aXAiLCAib3BhY2l0eSIsICJfYWN0aXZlIiwgIl9ldmVudFBvc2l0aW9uIiwgIl9zaXplIiwgIl9jYWNoZWRBbmltYXRpb25zIiwgIl90b29sdGlwSXRlbXMiLCAiJGFuaW1hdGlvbnMiLCAiJGNvbnRleHQiLCAiZGF0YVBvaW50cyIsICJjYXJldFgiLCAiY2FyZXRZIiwgImxhYmVsQ29sb3JzIiwgImxhYmVsUG9pbnRTdHlsZXMiLCAibGFiZWxUZXh0Q29sb3JzIiwgImluaXRpYWxpemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgImNhY2hlZCIsICJzZXRDb250ZXh0IiwgImdldENvbnRleHQiLCAiZW5hYmxlZCIsICJhbmltYXRpb24iLCAiYW5pbWF0aW9ucyIsICJBbmltYXRpb25zIiwgIl9jYWNoZWFibGUiLCAiZnJlZXplIiwgImdldFRpdGxlIiwgImdldEJlZm9yZUJvZHkiLCAiZ2V0Qm9keSIsICJib2R5SXRlbXMiLCAic2NvcGVkIiwgImdldEFmdGVyQm9keSIsICJnZXRGb290ZXIiLCAiX2NyZWF0ZUl0ZW1zIiwgImFjdGl2ZSIsICJhcnJheSIsICJpdGVtU29ydCIsICJjaGFuZ2VkIiwgInByb3BlcnRpZXMiLCAicG9zaXRpb25BbmRTaXplIiwgImFzc2lnbiIsICJiYWNrZ3JvdW5kUG9pbnQiLCAiZXh0ZXJuYWwiLCAiZHJhd0NhcmV0IiwgInRvb2x0aXBQb2ludCIsICJjYXJldFBvc2l0aW9uIiwgImdldENhcmV0UG9zaXRpb24iLCAibGluZVRvIiwgIngxIiwgInkxIiwgIngyIiwgInkyIiwgIngzIiwgInkzIiwgInB0WCIsICJwdFkiLCAicHQiLCAidGl0bGVBbGlnbiIsICJ0aXRsZUNvbG9yIiwgIl9kcmF3Q29sb3JCb3giLCAiY29sb3JYIiwgInJ0bENvbG9yWCIsICJ5T2ZmU2V0IiwgImNvbG9yWSIsICJtdWx0aUtleUJhY2tncm91bmQiLCAiZHJhd1BvaW50IiwgImlzT2JqZWN0IiwgIm91dGVyWCIsICJpbm5lclgiLCAiZmlsbFJlY3QiLCAic3Ryb2tlUmVjdCIsICJkcmF3Qm9keSIsICJib2R5QWxpZ24iLCAieExpbmVQYWRkaW5nIiwgImZpbGxMaW5lT2ZUZXh0IiwgImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwgInRleHRDb2xvciIsICJqIiwgImlsZW4iLCAiamxlbiIsICJkcmF3Rm9vdGVyIiwgImZvb3RlckFsaWduIiwgImZvb3RlckNvbG9yIiwgImRyYXdCYWNrZ3JvdW5kIiwgInRvb2x0aXBTaXplIiwgIm1vdmVUbyIsICJxdWFkcmF0aWNDdXJ2ZVRvIiwgImNsb3NlUGF0aCIsICJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwgImFuaW1zIiwgImFuaW1YIiwgImFuaW1ZIiwgInBvaW50IiwgIl90byIsICJfd2lsbFJlbmRlciIsICJhYnMiLCAiaGFzVG9vbHRpcENvbnRlbnQiLCAiZ2xvYmFsQWxwaGEiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJFcnJvciIsICJfZWxlbWVudHNFcXVhbCIsICJwb3NpdGlvbkNoYW5nZWQiLCAiX3Bvc2l0aW9uQ2hhbmdlZCIsICJfaWdub3JlUmVwbGF5RXZlbnRzIiwgImluQ2hhcnRBcmVhIiwgIl9nZXRBY3RpdmVFbGVtZW50cyIsICJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwgImFmdGVySW5pdCIsICJyZXNldCIsICJhZnRlckRyYXciLCAibm90aWZ5UGx1Z2lucyIsICJjYW5jZWxhYmxlIiwgInVzZUZpbmFsUG9zaXRpb24iLCAiZHVyYXRpb24iLCAiZWFzaW5nIiwgIm51bWJlcnMiLCAiX2ZhbGxiYWNrIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiYWRkSWZTdHJpbmciLCAibGFiZWxzIiwgInJhdyIsICJpbmRleCIsICJhZGRlZExhYmVscyIsICJwdXNoIiwgInVuc2hpZnQiLCAibGFiZWwiLCAiaXNOYU4iLCAiZmluZE9yQWRkTGFiZWwiLCAiZmlyc3QiLCAiaW5kZXhPZiIsICJsYXN0IiwgImxhc3RJbmRleE9mIiwgInZhbGlkSW5kZXgiLCAibWF4IiwgIl9saW1pdFZhbHVlIiwgIk1hdGgiLCAicm91bmQiLCAiX2dldExhYmVsRm9yVmFsdWUiLCAidmFsdWUiLCAiZ2V0TGFiZWxzIiwgImxlbmd0aCIsICJDYXRlZ29yeVNjYWxlIiwgIlNjYWxlIiwgImNvbnN0cnVjdG9yIiwgImNmZyIsICJfc3RhcnRWYWx1ZSIsICJ1bmRlZmluZWQiLCAiX3ZhbHVlUmFuZ2UiLCAiX2FkZGVkTGFiZWxzIiwgImluaXQiLCAic2NhbGVPcHRpb25zIiwgImFkZGVkIiwgInNwbGljZSIsICJwYXJzZSIsICJpc051bGxPclVuZGVmIiwgImlzRmluaXRlIiwgInZhbHVlT3JEZWZhdWx0IiwgImRldGVybWluZURhdGFMaW1pdHMiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgImdldFVzZXJCb3VuZHMiLCAibWluIiwgImdldE1pbk1heCIsICJvcHRpb25zIiwgImJvdW5kcyIsICJidWlsZFRpY2tzIiwgIm9mZnNldCIsICJ0aWNrcyIsICJzbGljZSIsICJnZXRMYWJlbEZvclZhbHVlIiwgImNhbGwiLCAiY29uZmlndXJlIiwgImlzSG9yaXpvbnRhbCIsICJfcmV2ZXJzZVBpeGVscyIsICJnZXRQaXhlbEZvclZhbHVlIiwgIk5hTiIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAicGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VQaXhlbCIsICJib3R0b20iLCAiaWQiLCAiZGVmYXVsdHMiLCAiY2FsbGJhY2siLCAiZ2VuZXJhdGVUaWNrcyIsICJnZW5lcmF0aW9uT3B0aW9ucyIsICJkYXRhUmFuZ2UiLCAiTUlOX1NQQUNJTkciLCAic3RlcCIsICJwcmVjaXNpb24iLCAiY291bnQiLCAibWF4VGlja3MiLCAibWF4RGlnaXRzIiwgImluY2x1ZGVCb3VuZHMiLCAidW5pdCIsICJtYXhTcGFjZXMiLCAicm1pbiIsICJybWF4IiwgImNvdW50RGVmaW5lZCIsICJtaW5TcGFjaW5nIiwgInNwYWNpbmciLCAibmljZU51bSIsICJmYWN0b3IiLCAibmljZU1pbiIsICJuaWNlTWF4IiwgIm51bVNwYWNlcyIsICJjZWlsIiwgImZsb29yIiwgInBvdyIsICJhbG1vc3RXaG9sZSIsICJhbG1vc3RFcXVhbHMiLCAiZGVjaW1hbFBsYWNlcyIsICJfZGVjaW1hbFBsYWNlcyIsICJqIiwgInJlbGF0aXZlTGFiZWxTaXplIiwgImhvcml6b250YWwiLCAibWluUm90YXRpb24iLCAicmFkIiwgInRvUmFkaWFucyIsICJyYXRpbyIsICJzaW4iLCAiY29zIiwgIkxpbmVhclNjYWxlQmFzZSIsICJzdGFydCIsICJlbmQiLCAiX2VuZFZhbHVlIiwgIk51bWJlciIsICJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwgImJlZ2luQXRaZXJvIiwgInNldE1pbiIsICJ2IiwgInNldE1heCIsICJtaW5TaWduIiwgInNpZ24iLCAibWF4U2lnbiIsICJhYnMiLCAiZ2V0VGlja0xpbWl0IiwgInRpY2tPcHRzIiwgIm1heFRpY2tzTGltaXQiLCAic3RlcFNpemUiLCAiY29uc29sZSIsICJ3YXJuIiwgImNvbXB1dGVUaWNrTGltaXQiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAib3B0cyIsICJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsICJfbWF4RGlnaXRzIiwgIl9yYW5nZSIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAicmV2ZXJzZSIsICJmb3JtYXROdW1iZXIiLCAiY2hhcnQiLCAibG9jYWxlIiwgImZvcm1hdCIsICJMaW5lYXJTY2FsZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAidGlja0ZvbnQiLCAiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCAibGluZUhlaWdodCIsICJUaWNrcyIsICJmb3JtYXR0ZXJzIiwgIm51bWVyaWMiLCAibG9nMTBGbG9vciIsICJsb2cxMCIsICJjaGFuZ2VFeHBvbmVudCIsICJtIiwgImlzTWFqb3IiLCAidGlja1ZhbCIsICJyZW1haW4iLCAic3RlcHMiLCAicmFuZ2VFeHAiLCAicmFuZ2VTdGVwIiwgInN0YXJ0RXhwIiwgInJhbmdlIiwgImZpbml0ZU9yRGVmYXVsdCIsICJtaW5FeHAiLCAiZXhwIiwgImJhc2UiLCAic2lnbmlmaWNhbmQiLCAibWFqb3IiLCAibGFzdFRpY2siLCAiTG9nYXJpdGhtaWNTY2FsZSIsICJwcm90b3R5cGUiLCAiYXBwbHkiLCAiX3plcm8iLCAiX3N1Z2dlc3RlZE1pbiIsICJfdXNlck1pbiIsICJfdXNlck1heCIsICJkZWNpbWFsIiwgImxvZ2FyaXRobWljIiwgImVuYWJsZWQiLCAiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwgImRpc3BsYXkiLCAicGFkZGluZyIsICJ0b1BhZGRpbmciLCAiYmFja2Ryb3BQYWRkaW5nIiwgImZvbnQiLCAic2l6ZSIsICJtZWFzdXJlTGFiZWxTaXplIiwgImN0eCIsICJpc0FycmF5IiwgInciLCAiX2xvbmdlc3RUZXh0IiwgInN0cmluZyIsICJoIiwgImRldGVybWluZUxpbWl0cyIsICJhbmdsZSIsICJwb3MiLCAiZml0V2l0aFBvaW50TGFiZWxzIiwgInNjYWxlIiwgIm9yaWciLCAibCIsICJsZWZ0IiwgIl9wYWRkaW5nIiwgInIiLCAicmlnaHQiLCAidCIsICJ0b3AiLCAiYiIsICJsaW1pdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJsYWJlbFNpemVzIiwgInZhbHVlQ291bnQiLCAiX3BvaW50TGFiZWxzIiwgInBvaW50TGFiZWxPcHRzIiwgInBvaW50TGFiZWxzIiwgImFkZGl0aW9uYWxBbmdsZSIsICJjZW50ZXJQb2ludExhYmVscyIsICJQSSIsICJpIiwgInNldENvbnRleHQiLCAiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCAicG9pbnRQb3NpdGlvbiIsICJnZXRQb2ludFBvc2l0aW9uIiwgImRyYXdpbmdBcmVhIiwgInBsRm9udCIsICJ0b0ZvbnQiLCAidGV4dFNpemUiLCAiYW5nbGVSYWRpYW5zIiwgIl9ub3JtYWxpemVBbmdsZSIsICJnZXRJbmRleEFuZ2xlIiwgInRvRGVncmVlcyIsICJoTGltaXRzIiwgIngiLCAidkxpbWl0cyIsICJ5IiwgInVwZGF0ZUxpbWl0cyIsICJzZXRDZW50ZXJQb2ludCIsICJfcG9pbnRMYWJlbEl0ZW1zIiwgImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwgIml0ZW1zIiwgImV4dHJhIiwgIm91dGVyRGlzdGFuY2UiLCAicG9pbnRMYWJlbFBvc2l0aW9uIiwgIkhBTEZfUEkiLCAieUZvckFuZ2xlIiwgInRleHRBbGlnbiIsICJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsICJsZWZ0Rm9yVGV4dEFsaWduIiwgImFsaWduIiwgImRyYXdQb2ludExhYmVscyIsICJsYWJlbENvdW50IiwgIm9wdHNBdEluZGV4IiwgImJhY2tkcm9wQ29sb3IiLCAiYm9yZGVyUmFkaXVzIiwgInRvVFJCTENvcm5lcnMiLCAiZmlsbFN0eWxlIiwgImJhY2tkcm9wTGVmdCIsICJiYWNrZHJvcFRvcCIsICJiYWNrZHJvcFdpZHRoIiwgImJhY2tkcm9wSGVpZ2h0IiwgInZhbHVlcyIsICJzb21lIiwgImJlZ2luUGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAicmFkaXVzIiwgImZpbGwiLCAiZmlsbFJlY3QiLCAicmVuZGVyVGV4dCIsICJjb2xvciIsICJ0ZXh0QmFzZWxpbmUiLCAicGF0aFJhZGl1c0xpbmUiLCAiY2lyY3VsYXIiLCAiYXJjIiwgInhDZW50ZXIiLCAieUNlbnRlciIsICJUQVUiLCAibW92ZVRvIiwgImxpbmVUbyIsICJkcmF3UmFkaXVzTGluZSIsICJncmlkTGluZU9wdHMiLCAiYm9yZGVyT3B0cyIsICJsaW5lV2lkdGgiLCAic2F2ZSIsICJzdHJva2VTdHlsZSIsICJzZXRMaW5lRGFzaCIsICJkYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAiY2xvc2VQYXRoIiwgInN0cm9rZSIsICJyZXN0b3JlIiwgImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwgInBhcmVudCIsICJjcmVhdGVDb250ZXh0IiwgInR5cGUiLCAiUmFkaWFsTGluZWFyU2NhbGUiLCAic2V0RGltZW5zaW9ucyIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAiZ2VuZXJhdGVUaWNrTGFiZWxzIiwgIm1hcCIsICJjYWxsQ2FsbGJhY2siLCAiZmlsdGVyIiwgImdldERhdGFWaXNpYmlsaXR5IiwgImZpdCIsICJsZWZ0TW92ZW1lbnQiLCAicmlnaHRNb3ZlbWVudCIsICJ0b3BNb3ZlbWVudCIsICJib3R0b21Nb3ZlbWVudCIsICJhbmdsZU11bHRpcGxpZXIiLCAic3RhcnRBbmdsZSIsICJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsICJzY2FsaW5nRmFjdG9yIiwgImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwgImRpc3RhbmNlIiwgInNjYWxlZERpc3RhbmNlIiwgInBvaW50TGFiZWwiLCAiZ2V0Q29udGV4dCIsICJkaXN0YW5jZUZyb21DZW50ZXIiLCAiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwgImdldEJhc2VQb3NpdGlvbiIsICJnZXRCYXNlVmFsdWUiLCAiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwgImRyYXdCYWNrZ3JvdW5kIiwgImJhY2tncm91bmRDb2xvciIsICJncmlkIiwgImRyYXdHcmlkIiwgImFuZ2xlTGluZXMiLCAiYm9yZGVyIiwgInBvc2l0aW9uIiwgImZvckVhY2giLCAidGljayIsICJjb250ZXh0IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkcmF3Qm9yZGVyIiwgImRyYXdMYWJlbHMiLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJtZWFzdXJlVGV4dCIsICJkcmF3VGl0bGUiLCAiYW5pbWF0ZSIsICJkZWZhdWx0Um91dGVzIiwgImRlc2NyaXB0b3JzIiwgIl9mYWxsYmFjayIsICJJTlRFUlZBTFMiLCAibWlsbGlzZWNvbmQiLCAiY29tbW9uIiwgInNlY29uZCIsICJtaW51dGUiLCAiaG91ciIsICJkYXkiLCAid2VlayIsICJtb250aCIsICJxdWFydGVyIiwgInllYXIiLCAiVU5JVFMiLCAia2V5cyIsICJzb3J0ZXIiLCAiYSIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiaXNOdW1iZXIiLCAic3RhcnRPZiIsICJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwgIm1pblVuaXQiLCAiY2FwYWNpdHkiLCAiaWxlbiIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgIm51bVRpY2tzIiwgImRpZmYiLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgImxvIiwgImhpIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgImFkZCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJwcm9wcyIsICJfY2FjaGUiLCAiZGF0YSIsICJhbGwiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJzY2FsZU9wdHMiLCAiYWRhcHRlcnMiLCAiX2RhdGUiLCAiZGF0ZSIsICJtZXJnZUlmIiwgImRpc3BsYXlGb3JtYXRzIiwgImZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJiZWZvcmVMYXlvdXQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJzb3VyY2UiLCAiRGF0ZSIsICJub3ciLCAiZW5kT2YiLCAiYXJyIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJORUdBVElWRV9JTkZJTklUWSIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiYXV0b1NraXAiLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAiYWZ0ZXJBdXRvU2tpcCIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJsaW1pdCIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiRXJyb3IiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAic29ydCIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgIl90aWNrRm9ybWF0RnVuY3Rpb24iLCAiZm9ybWF0dGVyIiwgIm1pbm9yRm9ybWF0IiwgIm1ham9yRm9ybWF0IiwgIm9mZnNldHMiLCAiX2dldExhYmVsU2l6ZSIsICJ0aWNrc09wdHMiLCAidGlja0xhYmVsV2lkdGgiLCAibWF4Um90YXRpb24iLCAiY29zUm90YXRpb24iLCAic2luUm90YXRpb24iLCAidGlja0ZvbnRTaXplIiwgImV4YW1wbGVUaW1lIiwgImV4YW1wbGVMYWJlbCIsICJtZXRhcyIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJjb250cm9sbGVyIiwgImdldEFsbFBhcnNlZFZhbHVlcyIsICJjb25jYXQiLCAibm9ybWFsaXplIiwgIl9hcnJheVVuaXF1ZSIsICJpbnRlcnBvbGF0ZSIsICJ0YWJsZSIsICJ2YWwiLCAicHJldlNvdXJjZSIsICJuZXh0U291cmNlIiwgInByZXZUYXJnZXQiLCAibmV4dFRhcmdldCIsICJfbG9va3VwQnlLZXkiLCAic3BhbiIsICJUaW1lU2VyaWVzU2NhbGUiLCAiX3RhYmxlIiwgIl9taW5Qb3MiLCAiX3RhYmxlUmFuZ2UiLCAiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsICJidWlsZExvb2t1cFRhYmxlIiwgInByZXYiLCAiY3VyciIsICJuZXh0IiwgImFwcCIsICJoIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAibmFtZSIsICJhcHAiLCAicGFyc2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgInJhbmsiLCAiZWFzZSIsICJwYXJzZSIsICJzaWJsaW5ncyJdCn0K
