"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[78869],{840463:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>r,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"computer-science/operating-system/cache-access-patterns","title":"Cache Access Patterns (Writing Policies)","description":"When a system writes data to cache, it must at some point write that data to the backing store as well. The timing of this write is controlled by what is known as thewrite policy.","source":"@site/docs/computer-science/operating-system/cache-access-patterns.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/cache-access-patterns","permalink":"/computer-science/operating-system/cache-access-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/cache-access-patterns.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1699511710000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Computer Organization","permalink":"/computer-science/operating-system/basic-computer-organization"},"next":{"title":"Cache Coherence","permalink":"/computer-science/operating-system/cache-coherence-invalidation"}}');var s=i(474848),a=i(28453);const r={},c="Cache Access Patterns (Writing Policies)",o={},h=[{value:"Write-through",id:"write-through",level:2},{value:"Write-back (write-behind)",id:"write-back-write-behind",level:2},{value:"Write-around",id:"write-around",level:2}];function d(e){const t={h1:"h1",h2:"h2",header:"header",img:"img",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"cache-access-patterns-writing-policies",children:"Cache Access Patterns (Writing Policies)"})}),"\n",(0,s.jsx)(t.p,{children:"When a system writes data to cache, it must at some point write that data to the backing store as well. The timing of this write is controlled by what is known as thewrite policy."}),"\n",(0,s.jsx)(t.h2,{id:"write-through",children:"Write-through"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"image",src:i(928221).A+"",width:"831",height:"540"})}),"\n",(0,s.jsx)(t.p,{children:"write is done synchronously both to the cache and to the backing store. The significance here is not the order in which it happens or whether it happens in parallel. The significance is that I/O completion is only confirmed once the data has been written to both places."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Advantage:"})}),"\n",(0,s.jsx)(t.p,{children:"Ensures fast retrieval while making sure the data is in the backing store and is not lost in case the cache is disrupted."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Disadvantage:"})}),"\n",(0,s.jsx)(t.p,{children:"Writing data will experience latency as you have to write to two places every time."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is it good for?"})}),"\n",(0,s.jsx)(t.p,{children:"The write-through policy is good for applications that has more reads than writes. This will result in slightly higher write latency but low read latency. So, it's ok to spend a bit longer writing once, but then benefit from reading frequently with low latency."}),"\n",(0,s.jsx)(t.h2,{id:"write-back-write-behind",children:"Write-back (write-behind)"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"image",src:i(418322).A+"",width:"784",height:"543"})}),"\n",(0,s.jsx)(t.p,{children:"Initially, writing is done only to the cache. The write to the backing store is postponed until the modified content is about to be replaced by another cache block."}),"\n",(0,s.jsx)(t.p,{children:"Using the write-back policy, data is written to the cache and immediately I/O completion is confirmed. The data is then typically also written to the backing store in the background but the completion confirmation is not blocked on that."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Advantage:"})}),"\n",(0,s.jsx)(t.p,{children:"Low latency and high throughput for write-intensive applications."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Disadvantage:"})}),"\n",(0,s.jsx)(t.p,{children:"There is data availability risk because the cache could fail (and so suffer from data loss) before the data is persisted to the backing store. This result in the data being lost."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is it good for?"})}),"\n",(0,s.jsx)(t.p,{children:"The write-back policy is the best performer for mixed workloads as both read and write I/O have similar response time levels. In reality, you can add resiliency (e.g. by duplicating writes) to reduce the likelihood of data loss."}),"\n",(0,s.jsx)(t.h2,{id:"write-around",children:"Write-around"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"image",src:i(802607).A+"",width:"999",height:"656"})}),"\n",(0,s.jsx)(t.p,{children:"Using the write-around policy, data is written only to the backing store without writing to the cache. So, I/O completion is confirmed as soon as the data is written to the backing store."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Advantage:"})}),"\n",(0,s.jsx)(t.p,{children:"Good for not flooding the cache with data that may not subsequently be re-read."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Disadvantage:"})}),"\n",(0,s.jsx)(t.p,{children:"Reading recently written data will result in a cache miss (and so a higher latency) because the data can only be read from the slower backing store."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is it good for?"})}),"\n",(0,s.jsx)(t.p,{children:"The write-around policy is good for applications that don't frequently re-read recently written data. This will result in lower write latency but higher read latency which is a acceptable trade-off for these scenarios."})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},928221:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/Caches-Caching-image1-1d4198f22acf58aeef7874ce80b11ac2.jpg"},418322:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/Caches-Caching-image2-7e91bd4a06786242c3072b5dbcf16db2.jpg"},802607:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/Caches-Caching-image3-342e4883d26c2401e3b383581b1fc283.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>c});var n=i(296540);const s={},a=n.createContext(s);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);