"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[84020],{200123:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"data-structures/general/mutable-immutable-data-structures","title":"Mutable/Immutable Data Structures","description":"Immutable Data Structure","source":"@site/docs/data-structures/general/mutable-immutable-data-structures.md","sourceDirName":"data-structures/general","slug":"/data-structures/general/mutable-immutable-data-structures","permalink":"/data-structures/general/mutable-immutable-data-structures","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/general/mutable-immutable-data-structures.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Endianness","permalink":"/data-structures/general/endianness"},"next":{"title":"Graph","permalink":"/data-structures/graph/"}}');var s=a(474848),n=a(28453);const i={},o="Mutable/Immutable Data Structures",u={},l=[{value:"Immutable Data Structure",id:"immutable-data-structure",level:2},{value:"Summary",id:"summary",level:2},{value:"Mutable Data Structure",id:"mutable-data-structure",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"mutableimmutable-data-structures",children:"Mutable/Immutable Data Structures"})}),"\n",(0,s.jsx)(t.h2,{id:"immutable-data-structure",children:"Immutable Data Structure"}),"\n",(0,s.jsxs)(t.p,{children:['The obvious advantage of the immutable data structures is that the storage overhead can be minimized: we do not have to reserve any extra space for data that is going to be inserted later or for the cases when the updated records require more space than the originally written ones.\nKeeping the data structure immutable favors the sequential writes: data is written on disk in a single pass, append-only. The mutable data structure will be pre-allocated in a single pass, but the subsequent writes will be random. Some structures require node splitting, that will relocate already written parts. After some time, randomly written file might require defragmentation.\nSome databases, instead of doing in-place updates, just mark the outdated record as "deleted" (so that it will eventually be garbage-collected) and append new records to the specially designated update area of the file. While this is a nice compromise, sometimes writes fill up all the designated space and overflow areas have to be created. All of this might slow down both subsequent reads and writes.\nAnother advantage of immutable files is that data can be read from the disk without any segment locking between operations, which significantly simplifies concurrent access. In contrast, mutable data structures employ hierarchical ',(0,s.jsx)(t.a,{href:"http://15721.courses.cs.cmu.edu/spring2017/papers/06-latching/a16-graefe.pdf",children:"locks and latches"})," in order to ensure on disk data structure integrity, allow multiple readers at the same time but give exclusive ownership for parts of tree to writers.\nBoth mutable and immutable data structures require some housekeeping in order to optimize performance but for different reasons. Since amount of allocated files constantly grows, immutable data structures have to merge and rewrite files in order to make sure that the least amount of files is hit during the query, as the requested record might be spread across multiple files. On the other hand, mutable files may have to be rewritten partially or completely to decrease fragmentation, merge overflow areas and reclaim space occupied by updated or deleted records (as their new contents were written elsewhere). Of course, the exact scope of work done by the housekeeping process heavily depends on the concrete implementation."]}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.p,{children:"Using immutable data structures can often simplify the work of programmer. When using immutable on-disk structures, you trade the need to occasionally merge your tables for better space management (by avoiding overflow pages and boosting space occupancy to 100%), concurrency (because readers and writers are never compete over the same file, therefore requiring no mutual exclusion) and potentially simpler implementations."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f",children:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f"})}),"\n",(0,s.jsx)(t.h2,{id:"mutable-data-structure",children:"Mutable Data Structure"}),"\n",(0,s.jsx)(t.p,{children:"Mutable storage is often implemented using Heap Table File, combined with some sort of index.\nExample"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"B-Tree"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-storage-part-4-b-trees-30791060741",children:"https://medium.com/databasss/on-disk-storage-part-4-b-trees-30791060741"})})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var r=a(296540);const s={},n=r.createContext(s);function i(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);