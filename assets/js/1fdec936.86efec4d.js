"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[20060],{128481:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"technologies/apache-spark/07-joins","title":"Joins","description":"What Factors affect Join Operations?","source":"@site/docs/technologies/apache-spark/07-joins.md","sourceDirName":"technologies/apache-spark","slug":"/technologies/apache-spark/07-joins","permalink":"/technologies/apache-spark/07-joins","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache-spark/07-joins.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1734554726000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sliding Window Analytics","permalink":"/technologies/apache-spark/06-sliding-window-analytics"},"next":{"title":"Examples","permalink":"/technologies/apache-spark/08-examples"}}');var t=i(474848),o=i(28453);const a={},r="Joins",l={},h=[{value:"What Factors affect Join Operations?",id:"what-factors-affect-join-operations",level:3},{value:"Spark strategies for join execution",id:"spark-strategies-for-join-execution",level:3},{value:"Hash Join",id:"hash-join",level:3},{value:"Sort Merge Joins",id:"sort-merge-joins",level:2},{value:"Broadcast Joins / Map End Join",id:"broadcast-joins--map-end-join",level:2},{value:"Shuffle Hash Join",id:"shuffle-hash-join",level:2},{value:"Shuffle Sort Merge Join",id:"shuffle-sort-merge-join",level:2},{value:"Cartesian Join",id:"cartesian-join",level:2},{value:"Broadcast Nested Loop Join",id:"broadcast-nested-loop-join",level:2},{value:"Spark Join Selection Strategy",id:"spark-join-selection-strategy",level:2},{value:"Case-I Equivalence Join Condition",id:"case-i-equivalence-join-condition",level:3},{value:"Case-II Non-Equivalence Join Conditions",id:"case-ii-non-equivalence-join-conditions",level:3},{value:"Takeaways",id:"takeaways",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"joins",children:"Joins"})}),"\n",(0,t.jsx)(n.h3,{id:"what-factors-affect-join-operations",children:"What Factors affect Join Operations?"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dataset Size -"})," The size of the datasets participating in the join will directly affect the join operation performance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Condition of Join -"})," The condition of join derives from the logical comparison of the fields in the datasets. These conditions can be categorized as Equivalence condition ",(0,t.jsx)(n.code,{children:"( = )"})," or Non-Equivalence condition ",(0,t.jsx)(n.code,{children:"( >, <, \u2265, \u2264, <>)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type of Join -"})," After selecting the condition of Join, we need to check for the type of join which is categorized as ",(0,t.jsx)(n.em,{children:"Inner, Outer, Semi, or Cross Join"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"spark-strategies-for-join-execution",children:"Spark strategies for join execution"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Broadcast Hash Join"}),"\n",(0,t.jsx)(n.li,{children:"Shuffle Hash Join"}),"\n",(0,t.jsx)(n.li,{children:"Shuffle Sort Merge Join"}),"\n",(0,t.jsx)(n.li,{children:"Cartesian Join"}),"\n",(0,t.jsx)(n.li,{children:"Broadcast Nested Loop Join"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hash-join",children:"Hash Join"}),"\n",(0,t.jsxs)(n.p,{children:["In the case of a Hash Join, a hash table is created based on the join key of the smaller dataset and then looping over the larger dataset to match the hashed join key fields. It only supports the equivalence join condition. And this strategy is applied at the ",(0,t.jsx)(n.strong,{children:"per node level (all partitions on the nodes where the dataset is available)."})," The creation of the hash table improves the searching. Once the hash table is created for the smaller dataset, loop over the larger dataset and based on the join key attribute, search the hash value in the smaller dataset ",(0,t.jsx)(n.strong,{children:"(O(1) operation)."})]}),"\n",(0,t.jsx)(n.h2,{id:"sort-merge-joins",children:"Sort Merge Joins"}),"\n",(0,t.jsxs)(n.p,{children:["When Spark translates an operation in the execution plan as a Sort Merge Join it enables an all-to-all communication strategy among the nodes: the Driver Node will orchestrate the Executors, each of which will hold a particular set of joining keys. Before running the actual operation, the partitions are first sorted (this operation is obviously heavy itself). As you can imagine this kind of strategy can be expensive: nodes need to use the network to share data; note that Sort Merge Joins tend to ",(0,t.jsx)(n.strong,{children:"minimize data movements"})," in the cluster, especially compared to Shuffle Hash Joins."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(316985).A+"",width:"644",height:"501"})}),"\n",(0,t.jsx)(n.p,{children:"In a Sort Merge Join partitions are sorted on the join key prior to the join operation."}),"\n",(0,t.jsx)(n.h2,{id:"broadcast-joins--map-end-join",children:"Broadcast Joins / Map End Join"}),"\n",(0,t.jsx)(n.p,{children:"Broadcast joins happen when Spark decides to send a copy of a table to all the executor nodes. The intuition here is that, if we broadcast one of the datasets, Spark no longer needs an all-to-all communication strategy and each Executor will be self-sufficient in joining the big dataset records in each node, with the small (broadcasted) table. We'll see that this simple idea improves performance... usually."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(426222).A+"",width:"561",height:"611"})}),"\n",(0,t.jsx)(n.p,{children:"In a Broadcast Join a copy of the small table is sent to all the Executors. Each executor will then perform the join without the need of network communication"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"broadcasted dataset should fit"})," in the driver as well as executor nodes. The ",(0,t.jsx)(n.strong,{children:"driver first gets the dataset"})," from the executor side and then ",(0,t.jsx)(n.strong,{children:"broadcasts the datasets to all the worker nodes"})," where the partitions for the larger dataset are present."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Equivalence Join condition"})," and ",(0,t.jsx)(n.strong,{children:"join types except Full Outer Join"})," is supported."]}),"\n",(0,t.jsx)(n.li,{children:"The property is configurable and has a max limit of 8GB."}),"\n",(0,t.jsx)(n.li,{children:"The table is cached on the driver node as well on the executor nodes and if a large table is broadcasted then it will be a network intensive operation leading to performance degradation."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Broadcast Hash Join Implementation",src:i(98278).A+"",width:"998",height:"452"})}),"\n",(0,t.jsx)(n.h2,{id:"shuffle-hash-join",children:"Shuffle Hash Join"}),"\n",(0,t.jsxs)(n.p,{children:["Shuffle Hash Join involves a two-phase process, the shuffle and hash join phase. Datasets with the same join key are ",(0,t.jsx)(n.strong,{children:"moved"})," to the same executor node and then on the executor node, create a hash table for the smaller table and apply ",(0,t.jsx)(n.strong,{children:"Hash"})," Join."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The join keys need ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"NOT"})})," be sortable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Equivalence Join condition"})," and ",(0,t.jsx)(n.strong,{children:"join types except Full Outer Join"})," is supported."]}),"\n",(0,t.jsx)(n.li,{children:"This is an expensive join as it involves shuffling as well as creating a hash table on the dataset participating in the join operation."}),"\n",(0,t.jsx)(n.li,{children:"To enable this join to need to set Shuffle Sort Merge Join to false"}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"spark.sql.join.preferSortMergeJoin=false (Default value is true)"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Shuffle Hash Join",src:i(295923).A+"",width:"999",height:"529"})}),"\n",(0,t.jsx)(n.h2,{id:"shuffle-sort-merge-join",children:"Shuffle Sort Merge Join"}),"\n",(0,t.jsxs)(n.p,{children:["Shuffle Sort Merge Join as the name suggest involves a shuffle and sort-merge phase. Datasets with the same join key are ",(0,t.jsx)(n.strong,{children:"moved"})," to the same executor node and then on the executor node, the dataset partitions on the node are ",(0,t.jsx)(n.strong,{children:"sorted"})," by the join keys and then ",(0,t.jsx)(n.strong,{children:"merged"})," based on the join keys."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["This is the default join strategy in Apache Spark since Spark 2.3. It can be disabled using ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"spark.sql.join.preferSortMergeJoin=false."})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Equivalence Join condition"})," and ",(0,t.jsx)(n.strong,{children:"join types except Full Outer Join"})," is supported."]}),"\n",(0,t.jsx)(n.li,{children:"The join keys need to be sortable."}),"\n",(0,t.jsx)(n.li,{children:"All join types are supported."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Shuffle Sort Merge Join",src:i(622526).A+"",width:"999",height:"529"})}),"\n",(0,t.jsx)(n.h2,{id:"cartesian-join",children:"Cartesian Join"}),"\n",(0,t.jsx)(n.p,{children:"If the participating datasets do not specify the join key(on condition), the cartesian product strategy will be picked."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Only inner join types are supported."}),"\n",(0,t.jsx)(n.li,{children:"Supports equivalence and non-equivalence join conditions."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"broadcast-nested-loop-join",children:"Broadcast Nested Loop Join"}),"\n",(0,t.jsx)(n.p,{children:"This join strategy is selected when no suitable join mechanism to choose from. In other words, if the join condition and hint type are not mentioned, then this join is chosen."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Supports equivalence and non-equivalence join conditions."}),"\n",(0,t.jsx)(n.li,{children:"All join types are supported."}),"\n",(0,t.jsx)(n.li,{children:"This is a very expensive join and Spark automatically optimizes the join by looking for an appropriate dataset that can be broadcasted."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"spark-join-selection-strategy",children:"Spark Join Selection Strategy"}),"\n",(0,t.jsx)(n.h3,{id:"case-i-equivalence-join-condition",children:"Case-I Equivalence Join Condition"}),"\n",(0,t.jsx)(n.p,{children:"Look at the join hints in the following order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.em,{children:"Broadcast Hint"})," -"]})," Pick Broadcast Hash Join if join type is supported."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Sort Merge Hint"})})," - Pick Sort-Merge to join if join keys are sortable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Shuffle Hash Hint"})})," - Pick Shuffle Hash Join if join type is supported."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Shuffle Replicate NL Hint"})})," - Pick Cartesian Product if join type is inner like."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If no hints are applicable"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If one of the datasets is small enough to be broadcasted and join type is supported then pick ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Broadcast Hash Join"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If join keys are sortable then pick ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Sort Merge Join"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If one of the datasets is small enough to build a Hash table, and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"spark.sql.join.preferSortMergeJoin=false"})}),", choose ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Shuffle Hash Join"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If the join type is inner type, then pick ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Cartesian Product Join"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Call the ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Broadcast Nested Loop Join"})})," if none of the options satisfies."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"case-ii-non-equivalence-join-conditions",children:"Case-II Non-Equivalence Join Conditions"}),"\n",(0,t.jsx)(n.p,{children:"Look at the join hints in the following order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Broadcast Hint -"})})," Pick the Broadcast Nested Loop Join."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Shuffle Replicate NL Hint"})})," - Pick Cartesian Product if the join type is inner like."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"takeaways",children:"Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joins can be difficult to tune since performance are bound to both the code and the Spark configuration (number of executors, memory, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Some of the most common issues with joins are all-to-all communication between the nodes and data skewness"}),"\n",(0,t.jsx)(n.li,{children:"We can avoid all-to-all communication using broadcasting of small tables or of medium-sized tables if we have enough memory in the cluster"}),"\n",(0,t.jsx)(n.li,{children:"Broadcasting is not always beneficial to performance: we need to have an eye for the Spark config"}),"\n",(0,t.jsx)(n.li,{children:"Broadcasting can make the code unstable if broadcast tables grow through time"}),"\n",(0,t.jsx)(n.li,{children:"Skewness leads to an uneven workload on the cluster, resulting in a very small subset of tasks to take much longer than the average"}),"\n",(0,t.jsx)(n.li,{children:"There are multiple ways to fight skewness, one is repartitioning."}),"\n",(0,t.jsx)(n.li,{children:"We can create our own repartitioning key, e.g. using the key salting technique"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"spark-join-summary",src:i(115852).A+"",width:"998",height:"133"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://towardsdatascience.com/the-art-of-joining-in-spark-dcbd33d693c",children:"https://towardsdatascience.com/the-art-of-joining-in-spark-dcbd33d693c"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://medium.com/@ghoshsiddharth25/apache-spark-join-strategies-deep-dive-26bf7e85db28",children:"Join Strategies in Apache Spark- Deep Dive | by Siddharth Ghosh | Medium"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://towardsdatascience.com/strategies-of-spark-join-c0e7b4572bcf",children:"Spark Join Strategies - How & What? | by Jyoti Dhiman | Towards Data Science"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://www.databricks.com/session_na20/on-improving-broadcast-joins-in-apache-spark-sql",children:"On Improving Broadcast Joins in Apache Spark SQL - Databricks"})})})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},115852:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Pasted image 20230327110541-391e955363a6388cb478337ed58f7e8b.jpg"},98278:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Pasted image 20230327110925-5264fb0dfed7eaff13812a127886e8d1.jpg"},295923:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Pasted image 20230327111057-443eda800ceff9924f38529b69b7a5c3.jpg"},622526:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Pasted image 20230327111131-507130241914dd4f9d60dd1f1bc4322e.jpg"},316985:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Technologies-Apache-Joins-image1-e77b67eec2ab3581067fe2877b64baba.jpg"},426222:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Technologies-Apache-Joins-image2-36599f145156baebdcf3a0169533f21c.jpg"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var s=i(296540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);