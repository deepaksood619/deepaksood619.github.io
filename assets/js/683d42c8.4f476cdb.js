"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[81607],{144005:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>h,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"algorithms/graphtheory/depth-first-search-dfs","title":"Depth First Search (DFS)","description":"Time Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.","source":"@site/docs/algorithms/graphtheory/depth-first-search-dfs.md","sourceDirName":"algorithms/graphtheory","slug":"/algorithms/graphtheory/depth-first-search-dfs","permalink":"/algorithms/graphtheory/depth-first-search-dfs","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/graphtheory/depth-first-search-dfs.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1692586856000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Connected Components","permalink":"/algorithms/graphtheory/connected-components"},"next":{"title":"Dijkstra\'s Algorithm","permalink":"/algorithms/graphtheory/dijkstra-algorithm"}}');var n=t(474848),s=t(28453);const a={},h="Depth First Search (DFS)",l={},d=[{value:"DFS Traversal of a Graph vs Tree",id:"dfs-traversal-of-a-graph-vs-tree",level:3},{value:"DFS Traversal Types",id:"dfs-traversal-types",level:2},{value:"Pre-order",id:"pre-order",level:2},{value:"In-order",id:"in-order",level:2},{value:"Post-order",id:"post-order",level:2},{value:"Algorithm for DFS in a graph",id:"algorithm-for-dfs-in-a-graph",level:2},{value:"Non-Recursive",id:"non-recursive",level:2},{value:"Properties",id:"properties",level:2},{value:"Union-Find vs DFS",id:"union-find-vs-dfs",level:2},{value:"Depth First Search",id:"depth-first-search",level:2},{value:"Properties",id:"properties-1",level:2},{value:"Example",id:"example",level:2},{value:"Links",id:"links",level:2}];function o(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"depth-first-search-dfs",children:"Depth First Search (DFS)"})}),"\n",(0,n.jsx)(i.p,{children:"Time Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph."}),"\n",(0,n.jsx)(i.p,{children:'DFS "is an algorithm for traversing or searching tree data structure. One starts at the root and explores as far as possible along each branch before backtracking.'}),"\n",(0,n.jsx)(i.h3,{id:"dfs-traversal-of-a-graph-vs-tree",children:"DFS Traversal of a Graph vs Tree"}),"\n",(0,n.jsx)(i.p,{children:"In the graph, there might be cycles and disconnectivity. Unlike the graph, the tree does not contain a cycle and are always connected. So DFS of a tree is relatively easier. We can simply begin from a node, then traverse its adjacent (or children) without caring about cycles. And if we begin from a single node (root), and traverse this way, it is guaranteed that we traverse the whole tree as there is no dis-connectivity,"}),"\n",(0,n.jsx)(i.h2,{id:"dfs-traversal-types",children:"DFS Traversal Types"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"Pre-order [Root, Left, Right]"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"In-order [Left, Root, Right]"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"Post-order [Left, Right, Root]"})}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"pre-order",children:"Pre-order"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(118612).A+"",width:"950",height:"428"})}),"\n",(0,n.jsx)(i.p,{children:"The result for this algorithm will be 1--2--3--4--5--6--7."}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Print the value of the node."}),"\n",(0,n.jsx)(i.li,{children:"Go to the left child and print it. This is if, and only if, it has a left child."}),"\n",(0,n.jsx)(i.li,{children:"Go to the right child and print it. This is if, and only if, it has a right child."}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"def pre_order(self):\n    print(self.value)\n\n    if self.left_child:\n        self.left_child.pre_order()\n\n    if self.right_child:\n        self.right_child.pre_order()\n"})}),"\n",(0,n.jsx)(i.h2,{id:"in-order",children:"In-order"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(64675).A+"",width:"948",height:"432"})}),"\n",(0,n.jsx)(i.p,{children:"The result of the in-order algorithm for this tree example is 3--2--4--1--6--5--7."}),"\n",(0,n.jsx)(i.p,{children:"The left first, the middle second, and the right last."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"def in_order(self):\n    if self.left_child:\n        self.left_child.in_order()\n\n    print(self.value)\n\n    if self.right_child:\n        self.right_child.in_order()\n"})}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Go to the left child and print it. This is if, and only if, it has a left child."}),"\n",(0,n.jsx)(i.li,{children:"Print the node's value"}),"\n",(0,n.jsx)(i.li,{children:"Go to the right child and print it. This is if, and only if, it has a right child."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"post-order",children:"Post-order"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(174566).A+"",width:"942",height:"414"})}),"\n",(0,n.jsx)(i.p,{children:"The result of the post order algorithm for this tree example is 3--4--2--6--7--5--1."}),"\n",(0,n.jsx)(i.p,{children:"The left first, the right second, and the middle last."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"def post_order(self):\n    if self.left_child:\n        self.left_child.post_order()\n\n    if self.right_child:\n        self.right_child.post_order()\n\n    print(self.value)\n"})}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Go to the left child and print it. This is if, and only if, it has a left child."}),"\n",(0,n.jsx)(i.li,{children:"Go to the right child and print it. This is if, and only if, it has a right child."}),"\n",(0,n.jsx)(i.li,{children:"Print the node's value"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"algorithm-for-dfs-in-a-graph",children:"Algorithm for DFS in a graph"}),"\n",(0,n.jsx)(i.p,{children:"DFS(to visit a vertex v)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Mark v as visited"}),"\n",(0,n.jsx)(i.li,{children:"Recursively visit all unmarked vertices w adjacent to v"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(374413).A+"",width:"1040",height:"768"})}),"\n",(0,n.jsx)(i.h2,{id:"non-recursive",children:"Non-Recursive"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-java",children:"public void dfs(Graph G, int v) {\n    Stack<Integer> stack = new Stack<Integer>();\n    stack.push(v);\n    while(!stack.isEmpty()) {\n        v = stack.pop();\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w])\n                stack.push(w);\n        }\n    }\n}\n"})}),"\n",(0,n.jsx)(i.h2,{id:"properties",children:"Properties"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"DFS marks all vertices connected to s in time proportional to the sum of their degrees."}),"\n",(0,n.jsx)(i.li,{children:"After DFS, we can find vertices connected to s in constant time and can find a path to s (if one exists) in time proportional to its length."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"union-find-vs-dfs",children:"Union-Find vs DFS"}),"\n",(0,n.jsx)(i.p,{children:"The union-find algorithm is best suited for situations where the equivalence relationship is changing, i.e., there are \"Union\" operations which need to be performed on your set of partitions. Given a fixed undirected graph, you don't have the equivalence relationships changing at all - the edges are all fixed. OTOH, if you have a graph with new edges being added, DFS won't cut it. While DFS is asymptotically faster than union-find, in practice, the likely deciding factor would be the actual problem that you are trying to solve."}),"\n",(0,n.jsx)(i.p,{children:"Static graph - DFS"}),"\n",(0,n.jsx)(i.p,{children:"Dynamic graph - Union-find"}),"\n",(0,n.jsx)(i.h2,{id:"depth-first-search",children:"Depth First Search"}),"\n",(0,n.jsx)(i.p,{children:"Maze Graph"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(629520).A+"",width:"930",height:"752"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(713247).A+"",width:"990",height:"742"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(5186).A+"",width:"822",height:"716"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(556025).A+"",width:"1034",height:"840"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(569148).A+"",width:"1102",height:"856"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(374413).A+"",width:"1040",height:"768"})}),"\n",(0,n.jsx)(i.h2,{id:"properties-1",children:"Properties"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"DFS marks all vertices connected to s in time proportional to the sum of their degrees."}),"\n",(0,n.jsx)(i.li,{children:"After DFS, we can find vertices connected to s in constant time and can find a path to s (if one exists) in time proportional to its length."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"example",children:"Example"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Flood fill (Photoshop magic wand)"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Depth-first_search",children:"DFS | Wikipedia"})})]})}function c(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},118612:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image1-49b72a435ed1bcbe12512356095a89a9.jpg"},64675:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image2-2c8d94248eae3f654a19c2664a65a598.jpg"},174566:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image3-c1b312b09d4bdb614edf89744f1786e9.jpg"},374413:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image4-d2b3a757a5f7b9bbc055c6107016aa17.jpg"},629520:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image5-7916e9088096253c6f9973b0540810fe.jpg"},713247:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image6-40045b55a50464c7756549b24d618d2c.jpg"},5186:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image7-f545fc2df636aa328a377b77b0e3e3d3.jpg"},556025:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image8-aeb7b9715273151548890e7d391edf10.jpg"},569148:(e,i,t)=>{t.d(i,{A:()=>r});const r=t.p+"assets/images/Depth-First-Search-(DFS)-image9-4686981af7235a6dc07315aa73c3e0ba.jpg"},28453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>h});var r=t(296540);const n={},s=r.createContext(n);function a(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function h(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);