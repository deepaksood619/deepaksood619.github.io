"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[50363],{149465:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var i=n(785893),s=n(511151);const r={},a="Structural - Bridge",o={id:"computer-science/programming-paradigms/structural-bridge",title:"Structural - Bridge",description:"Bridge is a structural design pattern that divides one or more classes into two separate hierarchies - abstraction and implementation, allowing them to be changed independently of each other",source:"@site/docs/computer-science/programming-paradigms/structural-bridge.md",sourceDirName:"computer-science/programming-paradigms",slug:"/computer-science/programming-paradigms/structural-bridge",permalink:"/computer-science/programming-paradigms/structural-bridge",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-paradigms/structural-bridge.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Structural - Adapter",permalink:"/computer-science/programming-paradigms/structural-adapter"},next:{title:"Structural - Decorator",permalink:"/computer-science/programming-paradigms/structural-decorator"}},c={},l=[{value:"Situations in which the Bridge pattern can help out",id:"situations-in-which-the-bridge-pattern-can-help-out",level:2},{value:"Pros",id:"pros",level:2},{value:"Cons",id:"cons",level:2},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"structural---bridge",children:"Structural - Bridge"}),"\n",(0,i.jsx)(t.p,{children:"Bridge is a structural design pattern that divides one or more classes into two separate hierarchies - abstraction and implementation, allowing them to be changed independently of each other"}),"\n",(0,i.jsx)(t.p,{children:"Let's take a simple example. You have a class called Figure that has the subclasses - Circle and Square. You want to expand the shapes hierarchy in color, that is, to have the Red and Blue figures. But to combine all of this, you'll have to create 4 combinations of subclasses, like BlueCircle and RedSquare."}),"\n",(0,i.jsx)(t.p,{children:"When adding new types of shapes and colors, the number of combinations will grow exponentially. For example, to introduce triangles into the program, you'll have to create two new subclasses of triangles for each color. After this, a new color will require the creation of three classes for all kinds of figures. It only gets worse. Visually, it can be featured as:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(650363).Z+"",width:"480",height:"340"})}),"\n",(0,i.jsx)(t.p,{children:"The root of the problem lies in the fact that we're trying to expand the classes of shapes in two independent planes - in form and color, which leads to the class tree growth."}),"\n",(0,i.jsx)(t.p,{children:'The Bridge pattern suggests replacing inheritance with delegation. In order to do this, one of these "planes" needs to be established as a separate hierarchy and you\'ll have to refer to the object of this hierarchy, instead of storing its state and behavior within one class.'}),"\n",(0,i.jsx)(t.p,{children:"Thus, we can make Color a separate class with the Red and Blue subclasses. The Figure class gets a link to the Color object and can delegate the work to it, if necessary. This connection will become the bridge between Figure and Color. When adding new color classes, you won't need to touch the shape classes, and vice versa. Schematically it will look like this:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(601113).Z+"",width:"460",height:"200"})}),"\n",(0,i.jsx)(t.h2,{id:"situations-in-which-the-bridge-pattern-can-help-out",children:"Situations in which the Bridge pattern can help out"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"When you want to divide a monolithic class that contains several different implementations of some kind of functionality (for example, if the class can work with the different database systems)"}),"\n",(0,i.jsx)(t.p,{children:"The larger the class, the harder it is to understand its code, and the more it drags out the development. In addition, changes made to one of the implementations lead to editing the entire class, which can cause random errors in the code. The bridge allows you to divide a monolithic class into several separate hierarchies. After that you can change their code independently from each other. This simplifies the work on the code and reduces the likelihood of making errors."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"When a class needs to be expanded in two independent planes"}),"\n",(0,i.jsx)(t.p,{children:"The bridge proposes to allocate one of these planes to a separate hierarchy of classes, storing a link to one of its objects in the original class."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"When you want to be able to change the implementation during the execution of the program"}),"\n",(0,i.jsx)(t.p,{children:"The bridge allows you to replace the implementation even during the program execution, since a particular implementation is not included in the abstraction class."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"By the way, because of this point Bridge is often confused with Strategy. Note that this function is the lowest on the scale on importance for Bridge, since its main task is structural."}),"\n",(0,i.jsx)(t.h2,{id:"pros",children:"Pros"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Allows to build platform-independent programs."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Hides unnecessary or dangerous implementation details from the client code."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"cons",children:"Cons"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Complicates the program code due to the introduction of additional classes."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://py.checkio.org/blog/design-patterns-part-3",children:"https://py.checkio.org/blog/design-patterns-part-3"})})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},650363:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Structural-Bridge-image1-8e735e753425215c7ca23859d17732bc.jpg"},601113:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Structural-Bridge-image2-ce0c049061c4b7816d07147a0609989f.jpg"},511151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>a});var i=n(667294);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);