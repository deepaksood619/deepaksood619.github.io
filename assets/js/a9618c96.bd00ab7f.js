"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[53950],{805183:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var n=s(785893),r=s(511151);const i={},o="Secrets",a={id:"devops/kubernetes/concepts-and-overview/configuration/secrets",title:"Secrets",description:"Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image.",source:"@site/docs/devops/kubernetes/concepts-and-overview/configuration/secrets.md",sourceDirName:"devops/kubernetes/concepts-and-overview/configuration",slug:"/devops/kubernetes/concepts-and-overview/configuration/secrets",permalink:"/devops/kubernetes/concepts-and-overview/configuration/secrets",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/kubernetes/concepts-and-overview/configuration/secrets.md",tags:[],version:"current",lastUpdatedAt:1707138374,formattedLastUpdatedAt:"Feb 5, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Configuration",permalink:"/devops/kubernetes/concepts-and-overview/configuration/"},next:{title:"Policies",permalink:"/devops/kubernetes/concepts-and-overview/policies"}},c={},d=[{value:"Built-in Secrets",id:"built-in-secrets",level:2},{value:"Creating a Secret Usingkubectl",id:"creating-a-secret-usingkubectl",level:2},{value:"Mounted Secrets are updated automatically",id:"mounted-secrets-are-updated-automatically",level:2},{value:"Immutable Secrets and ConfigMaps",id:"immutable-secrets-and-configmaps",level:2},{value:"Security properties",id:"security-properties",level:2},{value:"Protections",id:"protections",level:3},{value:"Risks",id:"risks",level:3},{value:"Secrets env variables vs volume mounts",id:"secrets-env-variables-vs-volume-mounts",level:2},{value:"Secret Sprawl",id:"secret-sprawl",level:2},{value:"EncryptionConfiguration",id:"encryptionconfiguration",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"secrets",children:"Secrets"}),"\n",(0,n.jsxs)(t.p,{children:["Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/",children:"Pod"})," definition or in a ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/glossary/?all=true#term-image",children:"container image"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"To use a secret, a Pod needs to reference the secret. A secret can be used with a Pod in three ways:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["As ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod",children:"files"})," in a ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes/",children:"volume"})," mounted on one or more of its containers."]}),"\n",(0,n.jsxs)(t.li,{children:["As ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables",children:"container environment variable"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["By the ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/#using-imagepullsecrets",children:"kubelet when pulling images"})," for the Pod."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"built-in-secrets",children:"Built-in Secrets"}),"\n",(0,n.jsx)(t.p,{children:"Service accounts automatically create and attach Secrets with API credentials"}),"\n",(0,n.jsx)(t.p,{children:"Kubernetes automatically creates secrets which contain credentials for accessing the API and automatically modifies your Pods to use this type of secret."}),"\n",(0,n.jsx)(t.p,{children:"The automatic creation and use of API credentials can be disabled or overridden if desired. However, if all you need to do is securely access the API server, this is the recommended workflow."}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-secret-usingkubectl",children:"Creating a Secret Usingkubectl"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt"})}),"\n",(0,n.jsx)(t.h2,{id:"mounted-secrets-are-updated-automatically",children:"Mounted Secrets are updated automatically"}),"\n",(0,n.jsxs)(t.p,{children:["When a secret currently consumed in a volume is updated, projected keys are eventually updated as well. The kubelet checks whether the mounted secret is fresh on every periodic sync. However, the kubelet uses its local cache for getting the current value of the Secret. The type of the cache is configurable using the ConfigMap And SecretChangeDetectionStrategy field in the ",(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go",children:"KubeletConfiguration struct"}),". A Secret can be either propagated by watch (default), ttl-based, or simply redirecting all requests directly to the API server. As a result, the total delay from the moment when the Secret is updated to the moment when new keys are projected to the Pod can be as long as the kubelet sync period + cache propagation delay, where the cache propagation delay depends on the chosen cache type (it equals to watch propagation delay, ttl of cache, or zero correspondingly)."]}),"\n",(0,n.jsxs)(t.p,{children:["Note: A container using a Secret as a ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes#using-subpath",children:"subPath"})," volume mount will not receive Secret updates."]}),"\n",(0,n.jsx)(t.h2,{id:"immutable-secrets-and-configmaps",children:"Immutable Secrets and ConfigMaps"}),"\n",(0,n.jsx)(t.p,{children:"The Kubernetes alpha featureImmutable Secrets and ConfigMaps provides an option to set individual Secrets and ConfigMaps as immutable. For clusters that extensively use Secrets (at least tens of thousands of unique Secret to Pod mounts), preventing changes to their data has the following advantages:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"protects you from accidental (or unwanted) updates that could cause applications outages"}),"\n",(0,n.jsx)(t.li,{children:"improves performance of your cluster by significantly reducing load on kube-apiserver, by closing watches for secrets marked as immutable."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Note",":Once"," a Secret or ConfigMap is marked as immutable, it is not possible to revert this change nor to mutate the contents of the data field. You can only delete and recreate the Secret. Existing Pods maintain a mount point to the deleted Secret - it is recommended to recreate these pods."]}),"\n",(0,n.jsx)(t.h2,{id:"security-properties",children:"Security properties"}),"\n",(0,n.jsx)(t.h3,{id:"protections",children:"Protections"}),"\n",(0,n.jsx)(t.p,{children:"Because secrets can be created independently of the Pods that use them, there is less risk of the secret being exposed during the workflow of creating, viewing, and editing Pods. The system can also take additional precautions with Secrets, such as avoiding writing them to disk where possible."}),"\n",(0,n.jsx)(t.p,{children:"A secret is only sent to a node if a Pod on that node requires it. The kubelet stores the secret into atmpfsso that the secret is not written to disk storage. Once the Pod that depends on the secret is deleted, the kubelet will delete its local copy of the secret data as well."}),"\n",(0,n.jsx)(t.p,{children:"There may be secrets for several Pods on the same node. However, only the secrets that a Pod requests are potentially visible within its containers. Therefore, one Pod does not have access to the secrets of another Pod."}),"\n",(0,n.jsxs)(t.p,{children:["There may be several containers in a Pod. However, each container in a Pod has to request the secret volume in itsvolumeMountsfor it to be visible within the container. This can be used to construct useful ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/#use-case-secret-visible-to-one-container-in-a-pod",children:"security partitions at the Pod level"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"On most Kubernetes distributions, communication between users and the API server, and from the API server to the kubelets, is protected by SSL/TLS. Secrets are protected when transmitted over these channels."}),"\n",(0,n.jsxs)(t.p,{children:["You can enable ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/",children:"encryption at rest"})," for secret data, so that the secrets are not stored in the clear into ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/",children:"etcd"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"risks",children:"Risks"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["In the API server, secret data is stored in ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/",children:"etcd"}),"; therefore:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Administrators should enable encryption at rest for cluster data (requires v1.13 or later)."}),"\n",(0,n.jsx)(t.li,{children:"Administrators should limit access to etcd to admin users."}),"\n",(0,n.jsx)(t.li,{children:"Administrators may want to wipe/shred disks used by etcd when no longer in use."}),"\n",(0,n.jsx)(t.li,{children:"If running etcd in a cluster, administrators should make sure to use SSL/TLS for etcd peer-to-peer communication."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"If you configure the secret through a manifest (JSON or YAML) file which has the secret data encoded as base64, sharing this file or checking it in to a source repository means the secret is compromised. Base64 encoding isnotan encryption method and is considered the same as plain text."}),"\n",(0,n.jsx)(t.li,{children:"Applications still need to protect the value of secret after reading it from the volume, such as not accidentally logging it or transmitting it to an untrusted party."}),"\n",(0,n.jsx)(t.li,{children:"A user who can create a Pod that uses a secret can also see the value of that secret. Even if the API server policy does not allow that user to read the Secret, the user could run a Pod which exposes the secret."}),"\n",(0,n.jsx)(t.li,{children:"Currently, anyone with root permission on any node can read any secret from the API server, by impersonating the kubelet. It is a planned feature to only send secrets to nodes that actually require them, to restrict the impact of a root exploit on a single node."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret",children:"https://kubernetes.io/docs/concepts/configuration/secret"})}),"\n",(0,n.jsx)(t.h2,{id:"secrets-env-variables-vs-volume-mounts",children:"Secrets env variables vs volume mounts"}),"\n",(0,n.jsx)(t.p,{children:"Kubernetes secrets exposed by environment variables may be able to be enumerated on the host via /proc/. If this is the case it's probably safer to load them via volume mounts."}),"\n",(0,n.jsx)(t.p,{children:"In an multi container pod, each container inside a pod has to request the secret volume in itsvolumeMountsfor it to be visible within the container. This can be used to construct useful security partition at pod level."}),"\n",(0,n.jsxs)(t.p,{children:["In some systems when the process crashes it ",(0,n.jsx)(t.strong,{children:"logs all the environment variable"}),". So that's a bad thing"]}),"\n",(0,n.jsx)(t.h2,{id:"secret-sprawl",children:"Secret Sprawl"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://www.youtube.com/watch?v=DQtbC88ArRI",children:"https://www.youtube.com/watch?v=DQtbC88ArRI"})}),"\n",(0,n.jsx)(t.h2,{id:"encryptionconfiguration",children:"EncryptionConfiguration"}),"\n",(0,n.jsxs)(t.p,{children:["In order to encrypt secrets, you must create an ",(0,n.jsx)(t.strong,{children:"EncryptionConfiguration"})," object with a key and proper identity. Then, the kube-apiserver needs the ",(0,n.jsx)(t.strong,{children:"--encryption-provider-config"})," flag set to a previously configured provider, such as aes cbc or ksm. Once this is enabled, you need to recreate every secret, as they are encrypted upon write. Multiple keys are possible.Each key for a provider is tried during decryption. The first key of the first provider is used for encryption. To rotate keys, first create a new key, restart (all) kube-apiserver processes, then recreate every secret."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data",children:"https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data"})})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},511151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>o});var n=s(667294);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);