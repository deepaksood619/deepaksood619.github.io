"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[94384],{485974:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"data-structures/hierarchical-data-structure/2-3-search-trees","title":"2-3 Search Trees","description":"Properties","source":"@site/docs/data-structures/hierarchical-data-structure/2-3-search-trees.md","sourceDirName":"data-structures/hierarchical-data-structure","slug":"/data-structures/hierarchical-data-structure/2-3-search-trees","permalink":"/data-structures/hierarchical-data-structure/2-3-search-trees","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hierarchical-data-structure/2-3-search-trees.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1681237065000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Hierarchical Data Structure","permalink":"/data-structures/hierarchical-data-structure/"},"next":{"title":"AVL Tree","permalink":"/data-structures/hierarchical-data-structure/avl-tree"}}');var a=r(474848),s=r(28453);const i={},o="2-3 Search Trees",c={},l=[{value:"Properties",id:"properties",level:2},{value:"Search",id:"search",level:2},{value:"Insertion into a 3-node at bottom",id:"insertion-into-a-3-node-at-bottom",level:2},{value:"Height of a 2-3 tree increases only when root node of the tree splits",id:"height-of-a-2-3-tree-increases-only-when-root-node-of-the-tree-splits",level:2},{value:"Tree height",id:"tree-height",level:2},{value:"Direct implementation is complicated, because",id:"direct-implementation-is-complicated-because",level:2}];function d(e){const t={em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"2-3-search-trees",children:"2-3 Search Trees"})}),"\n",(0,a.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Every non-leaf is a 2-node or a 3-node. A 2-node contains one data item and has two children. A 3-node contains two data items and has 3 children."}),"\n",(0,a.jsx)(t.li,{children:"All leaves are at the same level (the bottom level)"}),"\n",(0,a.jsx)(t.li,{children:"All data is kept in sorted order"}),"\n",(0,a.jsxs)(t.li,{children:["Every non-leaf node will contain 1 or 2 fields.",(0,a.jsx)(t.strong,{children:"2-3 Tree"})]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Allow 1 or 2 keys per node -"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"2-node: one key, two children"}),"\n",(0,a.jsx)(t.li,{children:"3-node: two keys, three children"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Symmetric order: Inorder traversal yields keys in ascending order"}),"\n",(0,a.jsx)(t.p,{children:"Perfect balance: Every path from root to null links has same length"}),"\n",(0,a.jsx)(t.p,{children:"Each transformation maintains symmetric order and perfect balance"}),"\n",(0,a.jsx)(t.h2,{id:"search",children:"Search"}),"\n",(0,a.jsx)(t.p,{children:"\u30fbCompare search key against keys in node.\n\u30fbFind interval containing search key.\n\u30fbFollow associated link (recursively)."}),"\n",(0,a.jsx)(t.h2,{id:"insertion-into-a-3-node-at-bottom",children:"Insertion into a 3-node at bottom"}),"\n",(0,a.jsx)(t.p,{children:"\u30fbAdd new key to 3-node to create temporary 4-node.\n\u30fbMove middle key in 4-node into parent.\n\u30fbRepeat up the tree, as necessary.\n\u30fbIf you reach the root and it's a 4-node, split it into three 2-nodes."}),"\n",(0,a.jsx)(t.h2,{id:"height-of-a-2-3-tree-increases-only-when-root-node-of-the-tree-splits",children:"Height of a 2-3 tree increases only when root node of the tree splits"}),"\n",(0,a.jsx)(t.h2,{id:"tree-height",children:"Tree height"}),"\n",(0,a.jsxs)(t.p,{children:["\u30fbWorst case: lg ",(0,a.jsx)(t.em,{children:"N"}),". [all 2-nodes]\n\u30fbBest case: log3 ",(0,a.jsx)(t.em,{children:"N"})," \u2248 .631 lg ",(0,a.jsx)(t.em,{children:"N"}),". [all 3-nodes]\n\u30fbBetween 12 and 20 for a million nodes.\n\u30fbBetween 18 and 30 for a billion nodes."]}),"\n",(0,a.jsx)(t.p,{children:"Guaranteed logarithmic performance for search and insert"}),"\n",(0,a.jsx)(t.h2,{id:"direct-implementation-is-complicated-because",children:"Direct implementation is complicated, because"}),"\n",(0,a.jsx)(t.p,{children:"\u30fbMaintaining multiple node types is cumbersome\n\u30fbNeed multiple compares to move down tree\n\u30fbNeed to move back up the tree to split 4-nodes\n\u30fbLarge number of cases for splitting"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:r(443475).A+"",width:"999",height:"577"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},443475:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/2-3-Search-Trees-image1-57bc9f1cae4a58e39c61c6e81af8f9fb.jpg"},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>o});var n=r(296540);const a={},s=n.createContext(a);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);