"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[98168],{211169:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var i=n(785893),o=n(511151);const s={},a="Flow Control",r={id:"networking/protocols/tcp-connection-oriented-protocol/flow-control",title:"Flow Control",description:"Flow Control basically means that TCP will ensure that a sender is not overwhelming a receiver by sending packets faster than it can consume. It's pretty similar to what's normally called Back pressure in the Distributed Systems literature. The idea is that a node receiving data will send some kind of feedback to the node sending the data to let it know about its current condition.",source:"@site/docs/networking/protocols/tcp-connection-oriented-protocol/flow-control.md",sourceDirName:"networking/protocols/tcp-connection-oriented-protocol",slug:"/networking/protocols/tcp-connection-oriented-protocol/flow-control",permalink:"/networking/protocols/tcp-connection-oriented-protocol/flow-control",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/networking/protocols/tcp-connection-oriented-protocol/flow-control.md",tags:[],version:"current",lastUpdatedAt:1701797352,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TCP (Connection Oriented Protocol)",permalink:"/networking/protocols/tcp-connection-oriented-protocol/"},next:{title:"UDP",permalink:"/networking/protocols/udp"}},c={},l=[{value:"rwnd - Receiver Window and cwnd - Congestion Window",id:"rwnd---receiver-window-and-cwnd---congestion-window",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"The sliding window",id:"the-sliding-window",level:2},{value:"Visualizing the Receive Window",id:"visualizing-the-receive-window",level:2},{value:"The persist timer",id:"the-persist-timer",level:2},{value:"Recap",id:"recap",level:2},{value:"TCP Slow Start",id:"tcp-slow-start",level:2},{value:"Flow Control vs Congestion Control",id:"flow-control-vs-congestion-control",level:2},{value:"TCP Backlog",id:"tcp-backlog",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"flow-control",children:"Flow Control"}),"\n",(0,i.jsxs)(t.p,{children:["Flow Control basically means that TCP will ensure that a sender is not overwhelming a receiver by sending packets faster than it can consume. It's pretty similar to what's normally called ",(0,i.jsx)(t.em,{children:"Back pressure"})," in the Distributed Systems literature. The idea is that a node receiving data will send some kind of feedback to the node sending the data to let it know about its current condition."]}),"\n",(0,i.jsxs)(t.p,{children:["It's important to understand that this is not the same as ",(0,i.jsx)(t.em,{children:"Congestion Control"}),". Although there's some overlap between the mechanisms TCP uses to provide both services, they are distinct features. Congestion control is about preventing a node from overwhelming the network (i.e. the links between two nodes), while Flow Control is about the end-node."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Additive increase, Multiplicative decrease"})}),"\n",(0,i.jsx)(t.h2,{id:"rwnd---receiver-window-and-cwnd---congestion-window",children:"rwnd - Receiver Window and cwnd - Congestion Window"}),"\n",(0,i.jsxs)(t.p,{children:["Congestion Window (cwnd) is a TCP state variable that limits the amount of data the ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Transmission_Control_Protocol",children:"TCP"})," can send into the network before receiving an ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)",children:"ACK"}),". The Receiver Window (rwnd) is a variable that advertises the amount of data that the destination side can receive. Together, the two variables are used to regulate data flow in TCP connections, minimize congestion, and improve network performance."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://blog.stackpath.com/glossary-cwnd-and-rwnd",children:"https://blog.stackpath.com/glossary-cwnd-and-rwnd"})}),"\n",(0,i.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(t.p,{children:"When we need to send data over a network, this is normally what happens."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(388348).Z+"",width:"783",height:"685"})}),"\n",(0,i.jsx)(t.p,{children:"The sender application writes data to a socket, the transport layer (in our case, TCP) will wrap this data in a segment and hand it to the network layer (e.g.IP), that will somehow route this packet to the receiving node."}),"\n",(0,i.jsx)(t.p,{children:"On the other side of this communication, the network layer will deliver this piece of data toTCP, that will make it available to the receiver application as an exact copy of the data sent, meaning if will not deliver packets out of order, and will wait for a retransmission in case it notices a gap in the byte stream."}),"\n",(0,i.jsx)(t.p,{children:"If we zoom in, we will see something like this."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(553685).Z+"",width:"854",height:"499"})}),"\n",(0,i.jsx)(t.p,{children:"TCP stores the data it needs to send in thesend buffer, and the data it receives in thereceive buffer. When the application is ready, it will then read data from the receive buffer."}),"\n",(0,i.jsx)(t.p,{children:"Flow Control is all about making sure we don't send more packets when the receive buffer is already full, as the receiver wouldn't be able to handle them and would need to drop these packets."}),"\n",(0,i.jsxs)(t.p,{children:["To control the amount of data thatTCPcan send, the receiver will advertise its",(0,i.jsx)(t.strong,{children:"Receive Window (rwnd)"}),", that is, the spare room in the receive buffer."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(393689).Z+"",width:"643",height:"475"})}),"\n",(0,i.jsx)(t.p,{children:"Every time TCP receives a packet, it needs to send an ack message to the sender, acknowledging it received that packet correctly, and with this ack message it sends the value of the current receive window, so the sender knows if it can keep sending data."}),"\n",(0,i.jsx)(t.h2,{id:"the-sliding-window",children:"The sliding window"}),"\n",(0,i.jsx)(t.p,{children:"TCP uses a sliding window protocol to control the number of bytes in flight it can have. In other words, the number of bytes that were sent but not yet acked."}),"\n",(0,i.jsx)(t.p,{children:"Let's say we want to send a 150000 bytes file from node A to node B. TCP could break this file down into 100 packets, 1500 bytes each. Now let's say that when the connection between node A and B is established, node B advertises a receive window of 45000 bytes, because it really wants to help us with our math here."}),"\n",(0,i.jsx)(t.p,{children:"Seeing that, TCPknows it can send the first 30 packets (1500 * 30 = 45000) before it receives an acknowledgment. If it gets anackmessage for the first 10 packets (meaning we now have only 20 packets in flight), and the receive window present in theseackmessages is still 45000, it can send the next 10 packets, bringing the number of packets in flight back to 30, that is the limit defined by the receive window. In other words, at any given point in time it can have 30 packets in flight, that were sent but not yetacked."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(657168).Z+"",width:"695",height:"157"})}),"\n",(0,i.jsx)(t.p,{children:"Example of a sliding window. As soon as packet 3 is acked, we can slide the window to the right and send the packet 8."}),"\n",(0,i.jsx)(t.p,{children:"Now, if for some reason the application reading these packets in node B slows down, TCP will still ack the packets that were correctly received, but as these packets need to be stored in the receive buffer until the application decides to read them, the receive window will be smaller, so even if TCP receives the acknowledgment for the next 10 packets (meaning there are currently 20 packets, or 30000 bytes, in flight), but the receive window value received in this ack is now 30000 (instead of 45000), it will not send more packets, as the number of bytes in flight is already equal to the latest receive window advertised."}),"\n",(0,i.jsx)(t.p,{children:"The sender will always keep this invariant:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"LastByteSent - LastByteAcked <= ReceiveWindowAdvertised"})}),"\n",(0,i.jsx)(t.h2,{id:"visualizing-the-receive-window",children:"Visualizing the Receive Window"}),"\n",(0,i.jsx)(t.p,{children:"Just to see this behavior in action, let's write a very simple application that reads data from a socket and watch how the receive window behaves when we make this application slower. We will use Wireshark to see these packets, netcat to send data to this application, and ago program to read data from the socket."}),"\n",(0,i.jsx)(t.p,{children:"Here's the simple go program that reads and prints the data received:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n"bufio"\n"fmt"\n"net"\n)\n\nfunc main() {\n listener, _ := net.Listen("tcp", "localhost:3040")\n conn, _ := listener.Accept()\n\n for {\n  message, _ := bufio.NewReader(conn).ReadBytes(\'n\')\n  fmt.Println(string(message))\n }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"This program will simply listen to connections on port 3040 and print the string received."}),"\n",(0,i.jsx)(t.p,{children:"We can then use net cat to send data to this application:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"$ nc localhost 3040"})}),"\n",(0,i.jsx)(t.p,{children:'Now let\'s run this command to create a stream of data. It will simply add the string "foo" to a file, that we will use to send to this application:'}),"\n",(0,i.jsx)(t.p,{children:'$ while true; do echo "foo" > stream.txt; done\nAnd now let\'s send this data to the application:'}),"\n",(0,i.jsx)(t.p,{children:"tail -f stream.txt | nc localhost 3040"}),"\n",(0,i.jsx)(t.p,{children:"The application is still fast enough to keep up with the work, though. So let's make it a bit slower to see what happens:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n"bufio"\n"fmt"\n"net"\n"time"\n)\n\nfunc main() {\n    listener, _ := net.Listen("tcp", "localhost:3040")\n    conn, _ := listener.Accept()\n\n    for {\n            message, _ := bufio.NewReader(conn).ReadBytes(\'n\')\n            fmt.Println(string(message))\n            + time.Sleep(1 * time.Second)\n        }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Now we are sleeping for 1 second before we read data from the receive buffer. If we run netcat again and observe Wireshark, it doesn't take long until the receive buffer is full and TCP starts advertising a 0 window size:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(983227).Z+"",width:"2840",height:"1970"})}),"\n",(0,i.jsx)(t.p,{children:"At this moment TCP will stop transmitting data, as the receiver's buffer is full."}),"\n",(0,i.jsx)(t.h2,{id:"the-persist-timer",children:"The persist timer"}),"\n",(0,i.jsxs)(t.p,{children:["There's still one problem, though. After the receiver advertises a zero window, if it doesn't send any otherackmessage to the sender (or if theackis lost), it will never know when it can start sending data again. We will have a deadlock situation, where the receiver is waiting for more data, and the sender is waiting for a message saying it can start sending data again.\nTo solve this problem, whenTCPreceives a zero-window message it starts the ",(0,i.jsx)(t.em,{children:"persist timer"}),", that will periodically send a small packet to the receiver (usually calledWindowProbe), so it has a chance to advertise a nonzero window size."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(389508).Z+"",width:"2840",height:"1970"})}),"\n",(0,i.jsx)(t.p,{children:"When there's some spare space in the receiver's buffer again it can advertise a non-zero window size and the transmission can continue."}),"\n",(0,i.jsx)(t.h2,{id:"recap",children:"Recap"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"TCP's flow control is a mechanism to ensure the sender is not overwhelming the receiver with more data than it can handle;"}),"\n",(0,i.jsx)(t.li,{children:"With everyackmessage the receiver advertises its current receive window;"}),"\n",(0,i.jsx)(t.li,{children:"The receive window is the spare space in the receive buffer, that is, rwnd = ReceiveBuffer - (LastByteReceived -- LastByteReadByApplication);"}),"\n",(0,i.jsx)(t.li,{children:"TCPwill use a sliding window protocol to make sure it never has more bytes in flight than the window advertised by the receiver;"}),"\n",(0,i.jsx)(t.li,{children:"When the window size is 0, TCPwill stop transmitting data and will start the persist timer;"}),"\n",(0,i.jsx)(t.li,{children:"It will then periodically send a smallWindowProbemessage to the receiver to check if it can start receiving data again;"}),"\n",(0,i.jsx)(t.li,{children:"When it receives a non-zero window size, it resumes the transmission."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.brianstorti.com/tcp-flow-control",children:"https://www.brianstorti.com/tcp-flow-control"})}),"\n",(0,i.jsx)(t.h2,{id:"tcp-slow-start",children:"TCP Slow Start"}),"\n",(0,i.jsx)(t.p,{children:"Slow start is a mechanism which balances the speed of a TCP network connection. It escalates the amount of data transmitted until it finds the network's maximum carrying capacity.cwdnstands for the Congestion Window."}),"\n",(0,i.jsxs)(t.p,{children:["BitTorrent uses tcp slow start slow start increases total throughput by keeping networks busy as in \"sliding window\" and also it solves end-to-end flow control by allowing the receiver to restrict transmission until it has sufficient buffer space to accommodate more data. Whenever the receiver sends ACK, the available buffer space is attached to the ACK (which is known as 'window advertisement'), so that the sender can decide its window size.\nIn TCP, the window size is defined as the minimum value between ",(0,i.jsx)(t.strong,{children:"cwnd(congestion window size)"})," and window advertisement.At any time, the window size cannot be greater thanmaximum cwndwhich is fixed."]}),"\n",(0,i.jsx)(t.p,{children:'Not only when the sender starts to transmit at the first time, but also after collision and after idle periods between the sender and the receiver, TCP transmits its data in "slow start" fashion.'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(124748).Z+"",width:"880",height:"498"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_HYUNAH/D-Research/slow-start-tcp.html",children:"https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_HYUNAH/D-Research/slow-start-tcp.html"})}),"\n",(0,i.jsx)(t.h2,{id:"flow-control-vs-congestion-control",children:"Flow Control vs Congestion Control"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(529230).Z+"",width:"1101",height:"474"})}),"\n",(0,i.jsx)(t.h2,{id:"tcp-backlog",children:"TCP Backlog"}),"\n",(0,i.jsx)(t.p,{children:"Wait, what is the TCP backlog? An application wishing to accept incoming TCP connections must issue thelistensyscall. This syscall instructs the OS to proceed with the TCP 3-way handshake when it receives initial SYN packets. During a handshake, metadata for a connection is maintained in a queue called the TCP backlog. The length of this queue dictates how many TCP connections can be establishing concurrently. The application issues accept syscalls to dequeue connections once they are established; this action frees space in the backlog for new connections."}),"\n",(0,i.jsx)(t.p,{children:"A backlog length of 1 means the queue will be full while just a single connection is establishing and then waiting to be dequeued. When the queue is full, the OS will drop initial SYN packets from other new connections. A client will resend an initial SYN packet if it doesn't receive a response, but after a couple attempts, it will stop and report failure to connect."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(765151).Z+"",width:"600",height:"330"})}),"\n",(0,i.jsx)(t.p,{children:"Why would setting the backlog length to 1 occasionally result in HTTP 502s? Most of the time, there are already established connections between the ALB and our API service, so the backlog length does not matter. However, when our service is unusually idle or is about to be upgraded, these connections are closed. A burst of API requests from just a single client at this point could cause the ALB to attempt to establish new TCP connections concurrently. Contention for the single slot in the TCP backlog would cause some of these connections to eventually report failure. The ALB responds to this failure by returning HTTP 502."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html",children:"http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html"})}),"\n",(0,i.jsxs)(t.p,{children:["When an application puts a socket into LISTEN state using the ",(0,i.jsx)(t.a,{href:"http://linux.die.net/man/2/listen",children:"listen"})," syscall, it needs to specify a backlog for that socket. The backlog is usually described as the limit for the queue of incoming connections."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(876278).Z+"",width:"660",height:"400"})}),"\n",(0,i.jsxs)(t.p,{children:["Because of the 3-way handshake used by TCP, an incoming connection goes through an intermediate state SYN RECEIVED before it reaches the ESTABLISHED state and can be returned by the ",(0,i.jsx)(t.a,{href:"http://linux.die.net/man/2/accept",children:"accept"})," syscall to the application (see the part of the ",(0,i.jsx)(t.a,{href:"http://commons.wikimedia.org/wiki/File:Tcp_state_diagram_fixed.svg",children:"TCP state diagram"})," reproduced above). This means that a TCP/IP stack has two options to implement the backlog queue for a socket in LISTEN state:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The implementation uses a single queue, the size of which is determined by thebacklogargument of thelistensyscall. When a SYN packet is received, it sends back a SYN/ACK packet and adds the connection to the queue. When the corresponding ACK is received, the connection changes its state to ESTABLISHED and becomes eligible for handover to the application. This means that the queue can contain connections in two different state: SYN RECEIVED and ESTABLISHED. Only connections in the latter state can be returned to the application by theacceptsyscall."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The implementation uses two queues, a SYN queue (or incomplete connection queue) and an accept queue (or complete connection queue). Connections in state SYN RECEIVED are added to the SYN queue and later moved to the accept queue when their state changes to ESTABLISHED, i.e. when the ACK packet in the 3-way handshake is received. As the name implies, theacceptcall is then implemented simply to consume connections from the accept queue. In this case, thebacklogargument of thelistensyscall determines the size of the accept queue."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'Note that a "listen backlog" of 100 connections doesn\'t mean that your server can only handle 100 simultaneous (or total) connections - this is instead dependent on the number of configured processes or threads. The listen backlog is a socket setting telling the kernel how to limit the number of outstanding (as yet unaccapted) connections in the listen queue of a listening socket. If the number of pending connections exceeds the specified size, new ones are automatically rejected. A functioning server regularly servicing its connections should not require a large backlog size'})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},388348:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image1-7f4f606d5992f1ed9bd762e0f67856a0.jpg"},876278:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image10-12ec335a29f8a460fcd241e98b71a9c2.jpg"},553685:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image2-9f89a6bfb73421fb9f210a21df3797b1.jpg"},393689:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image3-06a26a103236e56c1311671009f2424c.jpg"},657168:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image4-c68ad2ee1e5e79834edc70b4b0848f23.jpg"},983227:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image5-9297b4b27074a6cf10593dd2fe76aa7c.jpg"},389508:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image6-0d99f11d7f3e6b40ffd6947205af189f.jpg"},124748:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image7-a01f1c4202c66caea9d1d971cc9acf6a.jpg"},529230:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image8-3a3e6cb5954f004cfc0c64f09d876b8b.jpg"},765151:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/TCP-Connection-Oriented-Protocol_Flow-Control-image9-68f7abedb117b78725c25764d34bf9f8.jpg"},511151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var i=n(667294);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);