"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[7522],{703688:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(785893),n=t(511151);const s={},r="Hudi",o={id:"technologies/apache/apache-hudi",title:"Hudi",description:"Hudi - Hadoop Upserts Deletes and Incremental",source:"@site/docs/technologies/apache/apache-hudi.md",sourceDirName:"technologies/apache",slug:"/technologies/apache/apache-hudi",permalink:"/technologies/apache/apache-hudi",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache/apache-hudi.md",tags:[],version:"current",lastUpdatedAt:1731503026,formattedLastUpdatedAt:"Nov 13, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Apache Hive",permalink:"/technologies/apache/apache-hive"},next:{title:"Apache Projects",permalink:"/technologies/apache/apache-projects"}},l={},c=[{value:"Hudi Features",id:"hudi-features",level:2},{value:"Original Motivation",id:"original-motivation",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Storage Type",id:"storage-type",level:2},{value:"Copy On Write (COW)",id:"copy-on-write-cow",level:3},{value:"Merge on read (MOR)",id:"merge-on-read-mor",level:3},{value:"Choosing Between COW and MOR",id:"choosing-between-cow-and-mor",level:3},{value:"Links",id:"links",level:2}];function d(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h1,{id:"hudi",children:"Hudi"}),"\n",(0,a.jsx)(i.p,{children:"Hudi - Hadoop Upserts Deletes and Incremental"}),"\n",(0,a.jsx)(i.p,{children:"Apache Hudi ingests & manages storage of large analytical datasets over DFS (hdfs or cloud stores)."}),"\n",(0,a.jsx)(i.p,{children:"Apache Hudi is a transactional data lake platform that brings database and data warehouse capabilities to the data lake. Hudi reimagines slow old-school batch data processing with a powerful new incremental processing framework for low latency minute-level analytics."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Apache Hudi",src:t(677417).Z+"",width:"2957",height:"1041"})}),"\n",(0,a.jsx)(i.h2,{id:"hudi-features",children:"Hudi Features"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Mutability support for all data lake workloads -"})," Quickly update & delete data with Hudi\u2019s fast, pluggable indexing. This includes streaming workloads, with full support for out-of-order data, bursty traffic & data deduplication."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Improved efficiency by incrementally processing new data -"})," Replace old-school batch pipelines with incremental streaming on your data lake. Experience faster ingestion and lower processing times for analytical workloads."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"ACID Transactional guarantees to your data lake -"})," Bring transactional guarantees to your data lake, with consistent, atomic writes and concurrency controls tailored for longer-running lake transactions."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Unlock historical data with time travel -"})," Query historical data with the ability to roll back to a table version; debug data versions to understand what changed over time; audit data changes by viewing the commit history."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Interoperable multi-cloud ecosystem support -"})," Extensive ecosystem support with plug-and-play options for popular data sources & query engines. Build future-proof architectures interoperable with your vendor of choice."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Comprehensive table services for high-performance analytics"})," - Fully automated table services that continuously schedule & orchestrate clustering, compaction, cleaning, file sizing & indexing to ensure tables are always ready."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"A rich platform to build your lakehouse faster"})," - Effortlessly build your lakehouse with built-in tools for auto ingestion from services like Debezium and Kafka and auto catalog sync for easy discoverability & more."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Query acceleration through multi-modal indexes"})," - Experience faster write transactions on huge/wide tables & faster query performance with first-of-its kind multi-modal indexing subsystem."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Resilient Pipelines with schema evolution & enforcement"})," - Easily change the current schema of a Hudi table to adapt to the data that is changing over time and ensure pipeline resilience by failing fast and avoiding data corruption."]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"original-motivation",children:"Original Motivation"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Batch ingestion is too slow"}),"\n",(0,a.jsx)(i.li,{children:"Rewrite entire table/partition several times a day"}),"\n",(0,a.jsx)(i.li,{children:"ETLs off raw data have no smarts to recompute"}),"\n",(0,a.jsx)(i.li,{children:"Late arriving data is a nightmare"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Streaming vs batch",src:t(963885).Z+"",width:"1600",height:"1152"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Streaming vs batch vs incremental stack",src:t(644978).Z+"",width:"1600",height:"1182"})}),"\n",(0,a.jsx)(i.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Hudi Architecture",src:t(567622).Z+"",width:"900",height:"930"})}),"\n",(0,a.jsx)(i.h2,{id:"storage-type",children:"Storage Type"}),"\n",(0,a.jsx)(i.h3,{id:"copy-on-write-cow",children:"Copy On Write (COW)"}),"\n",(0,a.jsx)(i.p,{children:"Queries: Snapshot, Incremental"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"copy on write",src:t(613181).Z+"",width:"1802",height:"806"})}),"\n",(0,a.jsx)(i.h3,{id:"merge-on-read-mor",children:"Merge on read (MOR)"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"merge on read",src:t(750957).Z+"",width:"2524",height:"1302"})}),"\n",(0,a.jsx)(i.h3,{id:"choosing-between-cow-and-mor",children:"Choosing Between COW and MOR"}),"\n",(0,a.jsx)(i.p,{children:"The choice between COW and MOR in Apache Hudi largely depends on your specific requirements."}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Read vs. Write Frequency:"})," If your workload is read-heavy, COW may be the better choice due to its optimized read performance. Conversely, for write-heavy applications where data is ingested frequently, MOR can handle the load more efficiently."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Data Consistency:"})," If your application requires strong consistency and atomicity during writes, COW is preferable. MOR is better suited for scenarios where eventual consistency is acceptable."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Use Case:"})," For analytical workloads and batch processing, COW shines. For real-time data processing and streaming applications, MOR is often the way to go."]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://hudi.apache.org",children:"https://hudi.apache.org"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://blog.harshdaiya.com/apache-hudi-a-deep-dive-with-python-code-examples",children:"Apache Hudi: A Deep Dive with Python Code Examples"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://medium.com/@siladityaghosh/apache-hudi-vs-delta-lake-choosing-the-right-tool-for-your-data-lake-on-aws-8b97c66a5a12",children:"Apache Hudi vs. Delta Lake: Choosing the Right Tool for Your Data Lake on AWS | by Siladitya Ghosh | Medium"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://opstree.com/blog/2024/10/22/time-travel-queries-in-apache-hudi/",children:"Exploring Time Travel Queries in Apache Hudi - DEVOPS DONE RIGHT.."})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://opstree.com/blog/2024/11/12/understanding-cow-and-mor-in-apache-hudi-choosing-the-right-storage-strategy/",children:"Understanding COW and MOR in Apache Hudi: Choosing the Right Storage Strategy\xa0 - DEVOPS DONE RIGHT.."})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,n.a)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},677417:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Pasted image 20240801225724-a53f54cd58d0492b04b6e4742f8f94c7.png"},963885:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Screenshot 2024-10-07 at 3.27.21 PM-65ed3f402a35a67b23dbec208988d980.jpg"},644978:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Screenshot 2024-10-07 at 3.28.04 PM-df2215edac623be6d3316bfd31ad9f38.jpg"},567622:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Screenshot 2024-10-07 at 3.31.50 PM-bde0e03988fad9614ab77c5561dce705.jpg"},613181:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Screenshot 2024-10-07 at 3.32.25 PM-cebfacb825673eb0e0f3d977915239e6.jpg"},750957:(e,i,t)=>{t.d(i,{Z:()=>a});const a=t.p+"assets/images/Screenshot 2024-10-07 at 3.34.05 PM-b41ba2a8aa325e0ba82308643d17c126.jpg"},511151:(e,i,t)=>{t.d(i,{Z:()=>o,a:()=>r});var a=t(667294);const n={},s=a.createContext(n);function r(e){const i=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);