"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[35741],{878568:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"technologies/kafka/log-compaction","title":"Log Compaction","description":"Kafka log compaction is a retention policy that keeps only the latest message for each key in a topic partition, creating a log with a complete snapshot of the final values, rather than deleting by time or size.","source":"@site/docs/technologies/kafka/log-compaction.md","sourceDirName":"technologies/kafka","slug":"/technologies/kafka/log-compaction","permalink":"/technologies/kafka/log-compaction","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/log-compaction.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1769598990000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kafka without Zookeeper (Kafka with KRaft Mode)","permalink":"/technologies/kafka/kraft"},"next":{"title":"Migration / Mirroring / Replication","permalink":"/technologies/kafka/migration-mirroring-replication"}}');var i=a(474848),n=a(28453);const s={},r="Log Compaction",c={},l=[{value:"Topic compaction",id:"topic-compaction",level:2},{value:"Important",id:"important",level:2},{value:"Compaction enables deletes",id:"compaction-enables-deletes",level:2},{value:"When Compaction is triggered",id:"when-compaction-is-triggered",level:3},{value:"Compaction guarantees",id:"compaction-guarantees",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Links",id:"links",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"log-compaction",children:"Log Compaction"})}),"\n",(0,i.jsxs)(t.p,{children:["Kafka log compaction is a r",(0,i.jsx)(t.strong,{children:"etention policy that keeps only the latest message for each key in a topic partition"}),", creating a log with a complete snapshot of the final values, rather than deleting by time or size."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"cleanup.policy=compact"})}),"\n",(0,i.jsxs)(t.li,{children:["Configurable through broker settings like ",(0,i.jsx)(t.code,{children:"log.cleaner.max.compaction.lag.ms"})," and ",(0,i.jsx)(t.code,{children:"log.roll.hours"})," to control cleaning frequency and intensity."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Log compaction is a mechanism to give finer-grained per-record retention, rather than the coarser-grained time-based retention. The idea is to selectively remove records where we have a more recent update with the same primary key. This way the log is guaranteed to have at least the last state for each key."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:a(956423).A+"",width:"998",height:"478"})}),"\n",(0,i.jsx)(t.h2,{id:"topic-compaction",children:"Topic compaction"}),"\n",(0,i.jsx)(t.p,{children:"Topic compaction is a mechanism that allows you to retain the latest value for each message key in a topic, while discarding older values. It guarantees that the latest value for each message key is always retained within the log of data contained in that topic, making it ideal for use cases such as restoring state after system failure or reloading caches after application restarts. Continue reading to learn about log compaction and retention in more detail and to understand how they work to preserve the accuracy of data streams."}),"\n",(0,i.jsx)(t.p,{children:"Log compaction is a mechanism to provide finer-grained per-record retention instead of coarser-grained time-based retention. Records with the same primary key are selectively removed when there is a more recent update. This way the log is guaranteed to have at least the last state for each key."}),"\n",(0,i.jsx)(t.p,{children:"This retention policy can be set per-topic, so a single cluster can have some topics where retention is enforced by size or time and other topics where retention is enforced by compaction."}),"\n",(0,i.jsx)(t.h2,{id:"important",children:"Important"}),"\n",(0,i.jsx)(t.p,{children:"Compacted topics must have records with keys in order to implement record retention."}),"\n",(0,i.jsx)(t.p,{children:"Compaction in Kafka does not guarantee there is only one record with the same key at any one time. There may be multiple records with the same key, including the tombstone, because compaction timing is non-deterministic. Compaction is only done when the topic partition satisfies a few certain conditions, such as dirty ratio, or records in inactive segment files, etc."}),"\n",(0,i.jsx)(t.h2,{id:"compaction-enables-deletes",children:"Compaction enables deletes"}),"\n",(0,i.jsxs)(t.p,{children:["Compaction also enables deletes. A message with a key and a null payload (note that a string value of null is not sufficient) will be treated as a delete from the log. These null payload messages are also called tombstones. Similar to when a new message with the same key arrives, this delete marker results in the deletion of the previous message with the same key. However, delete markers (tombstones) are special in that they are also cleaned out of the log after a period of time to free up space. This point is time is marked as the\xa0",(0,i.jsx)(t.strong,{children:"Delete Retention Point"}),"\xa0in the previous image, and is configured with\xa0",(0,i.jsx)(t.code,{children:"delete.retention.ms"}),"\xa0on a topic."]}),"\n",(0,i.jsx)(t.h3,{id:"when-compaction-is-triggered",children:"When Compaction is triggered"}),"\n",(0,i.jsx)(t.p,{children:"A topic partition is compacted if one of the following is true:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"\ufeff\ufeff\ufeffdirty / total \u203a min.cleanable.dirty.ratio and message timestamp >= current time - min.compaction.lag.ms"}),"\n",(0,i.jsx)(t.li,{children:"\ufeff\ufeff\ufeffmessage timestamp \u2039 current time - max.compaction.lag.ms"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"compaction-guarantees",children:"Compaction guarantees"}),"\n",(0,i.jsx)(t.p,{children:"Log compaction guarantees the following:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Any consumer that stays caught-up to the head of the log will see every message that is written; these messages will have sequential offsets. The topic\u2019s\xa0",(0,i.jsx)(t.code,{children:"min-compaction-lag-ms"}),"\xa0can be used to guarantee the minimum length of time must pass after a message is written before it could be compacted. That is, it provides a lower bound on how long each message will remain in the (uncompacted) head. The topic\u2019s\xa0",(0,i.jsx)(t.code,{children:"max-compaction-lag-ms"}),"\xa0can be used to guarantee the maximum delay between the time a message is written and the time the message becomes eligible for compaction."]}),"\n",(0,i.jsx)(t.li,{children:"Ordering of messages is always maintained. Compaction will never reorder messages, just remove some."}),"\n",(0,i.jsx)(t.li,{children:"The offset for a message never changes. It is the permanent identifier for a position in the log."}),"\n",(0,i.jsxs)(t.li,{children:["Any consumer progressing from the start of the log will see at least the final state of all records in the order they were written. Additionally, all delete markers for deleted records will be seen, provided the consumer reaches the head of the log in a time period less than the topic\u2019s\xa0",(0,i.jsx)(t.code,{children:"delete.retention.ms"}),"\xa0setting (the default is 24 hours). In other words: since the removal of delete markers happens concurrently with reads, it is possible for a consumer to miss delete markers if it lags by more than\xa0",(0,i.jsx)(t.code,{children:"delete.retention.ms"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Database change subscriptions."})," You may have a data set in multiple data systems and often one of these systems is a database. For example you might have the cache, search cluster, and Hadoop. If you are handling the real-time updates you only need the recent log, but if you want to be able to reload the cache or restore a failed search node you may need a complete data set."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Event sourcing."})," While not enabled by compaction, compaction does ensure you always know the latest state of each key, which is important for event sourcing."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Journaling for high-availability."})," A process that does local computation can be made fault-tolerant by logging out changes that it makes to its local state so another process can reload these changes and carry on if it should fail. A concrete example of this is handling counts, aggregations, and other \u201cgroup by\u201d-like processing in a stream processing system. Kafka Streams uses this feature for this purpose."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"links",children:"Links"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://medium.com/data-science/log-compacted-topics-in-apache-kafka-b1aa1e4665a7",children:"Log Compacted Topics in Apache Kafka | by Seyed Morteza Mousavi | TDS Archive | Medium"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://docs.confluent.io/kafka/design/log_compaction.html",children:"Kafka Log Compaction | Confluent Documentation"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=VAkhYxu1qII",children:"Apache Kafka\xae Topic Compaction - YouTube"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},956423:(e,t,a)=>{a.d(t,{A:()=>o});const o=a.p+"assets/images/Technologies-Kafka-Intro-image2-c12fa0caa622b02bd4f66c29ea9242f8.jpg"},28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>r});var o=a(296540);const i={},n=o.createContext(i);function s(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);