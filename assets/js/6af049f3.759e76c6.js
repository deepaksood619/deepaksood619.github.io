"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[10890],{961007:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"data-structures/hierarchical-data-structure/binomial-heap","title":"Binomial Heap","description":"Key Points","source":"@site/docs/data-structures/hierarchical-data-structure/binomial-heap.md","sourceDirName":"data-structures/hierarchical-data-structure","slug":"/data-structures/hierarchical-data-structure/binomial-heap","permalink":"/data-structures/hierarchical-data-structure/binomial-heap","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hierarchical-data-structure/binomial-heap.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1700454456000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Binary Tree","permalink":"/data-structures/hierarchical-data-structure/binary-tree"},"next":{"title":"Fibonacci Heap","permalink":"/data-structures/hierarchical-data-structure/fibonacci-heap"}}');var t=i(474848),o=i(28453);const r={},s="Binomial Heap",l={},h=[{value:"Key Points",id:"key-points",level:2},{value:"What is a Binomial Tree?",id:"what-is-a-binomial-tree",level:2},{value:"Structure of a Binomial Heap",id:"structure-of-a-binomial-heap",level:2},{value:"Examples Binomial Heap",id:"examples-binomial-heap",level:2},{value:"Binary Representation of a number and Binomial Heaps",id:"binary-representation-of-a-number-and-binomial-heaps",level:2},{value:"Operations of Binomial Heap",id:"operations-of-binomial-heap",level:2},{value:"Union operation in Binomial Heap",id:"union-operation-in-binomial-heap",level:2}];function d(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binomial-heap",children:"Binomial Heap"})}),"\n",(0,t.jsx)(n.h2,{id:"key-points",children:"Key Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Faster union or merge operation of two binary heaps"}),"\n",(0,t.jsxs)(n.li,{children:["Implementation of mergeable heap abstract data type\nBinomial Heap is to extension of ",(0,t.jsx)(n.a,{href:"http://geeksquiz.com/binary-heap/",children:"Binary Heap"})," that provides faster union or merge operation together with other operations provided by Binary Heap.\n",(0,t.jsx)(n.em,{children:"A Binomial Heap is a collection of Binomial Trees"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-a-binomial-tree",children:"What is a Binomial Tree?"}),"\n",(0,t.jsx)(n.p,{children:"A Binomial Tree of order 0 has 1 node. A Binomial Tree of order k can be constructed by taking two binomial trees of order k-1, and making one as leftmost child of other."}),"\n",(0,t.jsx)(n.p,{children:"A Binomial Tree of order k has following properties."}),"\n",(0,t.jsx)(n.p,{children:"a) It has exactly 2^k^nodes."}),"\n",(0,t.jsx)(n.p,{children:"b) It has depth as k."}),"\n",(0,t.jsx)(n.p,{children:"c) There are exactly ^k^Cinodes at depth i for i = 0, 1, . . . , k."}),"\n",(0,t.jsx)(n.p,{children:"d) The root has degree k and children of root are themselves Binomial Trees with order k-1, k-2,.. 0 from left to right."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(296404).A+"",width:"1000",height:"772"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(726115).A+"",width:"1000",height:"462"})}),"\n",(0,t.jsx)(n.h2,{id:"structure-of-a-binomial-heap",children:"Structure of a Binomial Heap"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A Binomial Heap is a set of Binomial Trees where each Binomial Tree follows Min Heap property."}),"\n",(0,t.jsx)(n.li,{children:"And there can be at-most one Binomial Tree of any degree."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"examples-binomial-heap",children:"Examples Binomial Heap"}),"\n",(0,t.jsx)(n.p,{children:"12------------10--------------------20\n/  / |\n15 50 70 50 40\n| / | |\n30 80 85 65\n|\n100\nA Binomial Heap with 13 nodes. It is a collection of 3\nBinomial Trees of orders 0, 2 and 3 from left to right."}),"\n",(0,t.jsx)(n.p,{children:"10--------------------20\n/  / |\n15 50 70 50 40\n| / | |\n30 80 85 65\n|\n100"}),"\n",(0,t.jsx)(n.p,{children:"A Binomial Heap with 12 nodes. It is a collection of 2\nBinomial Trees of orders 2 and 3 from left to right."}),"\n",(0,t.jsx)(n.h2,{id:"binary-representation-of-a-number-and-binomial-heaps",children:"Binary Representation of a number and Binomial Heaps"}),"\n",(0,t.jsx)(n.p,{children:"A Binomial Heap with n nodes has number of Binomial Trees equal to the number of set bits in Binary representation of n. For example let n be 13, there 3 set bits in binary representation of n (00001101), hence 3 Binomial Trees. We can also relate degree of these Binomial Trees with positions of set bits. With this relation we can conclude that there are O(Logn) Binomial Trees in a Binomial Heap with 'n' nodes."}),"\n",(0,t.jsx)(n.h2,{id:"operations-of-binomial-heap",children:"Operations of Binomial Heap"}),"\n",(0,t.jsx)(n.p,{children:"The main operation in Binomial Heap is union(), all other operations mainly use this operation. The union() operation is to combine two Binomial Heaps into one."}),"\n",(0,t.jsx)(n.h2,{id:"union-operation-in-binomial-heap",children:"Union operation in Binomial Heap"}),"\n",(0,t.jsx)(n.p,{children:"Given two Binomial Heaps H1 and H2, union(H1, H2) creates a single Binomial Heap."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The first step is to simply merge the two Heaps in non-decreasing order of degrees"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"After the simple merge, we need to make sure that there is at-most one Binomial Tree of any order. To do this, we need to combine Binomial Trees of same order. We traverse the list of merged roots, we keep track of three pointers, prev, x and next-x. There can be following 4 cases when we traverse the list of roots"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"-----Case 1: Orders of x and next-x are not same, we simply move ahead."}),"\n",(0,t.jsx)(n.p,{children:"In following 3 cases orders of x and next-x are same."}),"\n",(0,t.jsx)(n.p,{children:"-----Case 2: If order of next-next-x is also same, move ahead."}),"\n",(0,t.jsx)(n.p,{children:"-----Case 3: If key of x is smaller than or equal to key of next-x, then make next-x as a child of x by linking it with x."}),"\n",(0,t.jsx)(n.p,{children:"-----Case 4: If key of x is greater, then make x as child of next."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"insert(H, k): Inserts a key 'k' to Binomial Heap 'H'. This operation first creates a Binomial Heap with single key 'k', then calls union on H and the new Binomial heap"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"getMin(H): A simple way to getMin() is to traverse the list of root of Binomial Trees and return the minimum key. This implementation requires O(Logn) time. It can be optimized to O(1) by maintaining a pointer to minimum key root"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"extractMin(H): This operation also uses union(). We first call getMin() to find the minimum key Binomial Tree, then we remove the node and create a new Binomial Heap by connecting all subtrees of the removed minimum node. Finally we call union() on H and the newly created Binomial Heap. This operation requires O(Logn) time"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"delete(H): Like Binary Heap, delete operation first reduces the key to minus infinite, then calls extractMin()"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"decreaseKey(H): decreaseKey() is also similar to Binary Heap. We compare the decreases key with it parent and if parent's key is more, we swap keys and recur for parent. We stop when we either reach a node whose parent has smaller key or we hit the root node. Time complexity of decreaseKey() is O(Logn)"}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},296404:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/Binomial-Heap-image1-33a52ed207a1e559177a2f14de335477.jpg"},726115:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/Binomial-Heap-image2-0b090b52087f13e30e507d476cb8d306.jpg"},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var a=i(296540);const t={},o=a.createContext(t);function r(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);