"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[83189],{233023:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"technologies/kafka/kafka-streams","title":"Kafka Streams","description":"Topics live in Kafka\'s storage layer - they are part of the Kafka \\"filesystem\\" powered by the brokers. In contrast, streams and tables are concepts of Kafka\'s processing layer, used in tools like ksqlDB and Kafka Streams. These tools process your events stored in \\"raw\\" topics by turning them into streams and tables - a process that is conceptually very similar to how a relational database turns the bytes in files on disk into an RDBMS table for you to work with.","source":"@site/docs/technologies/kafka/kafka-streams.md","sourceDirName":"technologies/kafka","slug":"/technologies/kafka/kafka-streams","permalink":"/technologies/kafka/kafka-streams","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/kafka-streams.md","tags":[],"version":"current","lastUpdatedBy":"Deeapak Sood","lastUpdatedAt":1766218856000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kafka Schema Registry","permalink":"/technologies/kafka/kafka-schema-registry"},"next":{"title":"Kafka Topic/Replication","permalink":"/technologies/kafka/kafka-topic-replication"}}');var n=a(474848),i=a(28453);const r={},o="Kafka Streams",l={},c=[{value:"KSTREAM VS. KTABLE",id:"kstream-vs-ktable",level:2},{value:"KSQL",id:"ksql",level:2},{value:"Kafka Streams (Definitive Guide)",id:"kafka-streams-definitive-guide",level:2},{value:"References",id:"references",level:2},{value:"Others",id:"others",level:2}];function d(e){const s={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"kafka-streams",children:"Kafka Streams"})}),"\n",(0,n.jsxs)(s.p,{children:["Topics live in Kafka's storage layer - they are part of the Kafka \"filesystem\" powered by the brokers. In contrast, streams and tables are concepts of Kafka's processing layer, used in tools like ",(0,n.jsx)(s.a,{href:"https://ksqldb.io/",children:"ksqlDB"})," and ",(0,n.jsx)(s.a,{href:"https://docs.confluent.io/current/streams/index.html",children:"Kafka Streams"}),'. These tools process your events stored in "raw" topics by turning them into streams and tables - a process that is conceptually very similar to how a relational database turns the bytes in files on disk into an RDBMS table for you to work with.']}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(458924).A+"",width:"1000",height:"520"})}),"\n",(0,n.jsx)(s.p,{children:"An event stream in Kafka is a topic with a schema. Keys and values of events are no longer opaque byte arrays but have specific types, so we know what's in the data. Like a topic, a stream is unbounded."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(319547).A+"",width:"960",height:"383"})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://www.confluent.io/blog/kafka-streams-tables-part-3-event-processing-fundamentals",children:"https://www.confluent.io/blog/kafka-streams-tables-part-3-event-processing-fundamentals"})}),"\n",(0,n.jsx)(s.p,{children:"Kafka Streams is a client library for processing and analyzing data stored in Kafka. It builds upon important stream processing concepts such as properly distinguishing between event time and processing time, windowing support, exactly-once processing semantics and simple yet efficient management of application state."}),"\n",(0,n.jsxs)(s.p,{children:["Kafka Streams has a ",(0,n.jsx)(s.strong,{children:"low barrier to entry"}),": You can quickly write and run a small-scale proof-of-concept on a single machine; and you only need to run additional instances of your application on multiple machines to scale up to high-volume production workloads. Kafka Streams transparently handles the load balancing of multiple instances of the same application by leveraging Kafka's parallelism model."]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Building blocks -"})," Filtering, Grouping, Aggregating, Joining"]}),"\n",(0,n.jsx)(s.h2,{id:"kstream-vs-ktable",children:"KSTREAM VS. KTABLE"}),"\n",(0,n.jsx)(s.p,{children:"There are two key concepts in Kafka Streams: KStream and KTable. A topic can be viewed as either of the two. Their differences are summarized in the table below."}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{}),(0,n.jsx)(s.th,{children:(0,n.jsx)(s.strong,{children:"KSTREAM"})}),(0,n.jsx)(s.th,{children:(0,n.jsx)(s.strong,{children:"KTABLE"})})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"CONCEPT"})}),(0,n.jsx)(s.td,{children:"Each record is treated as an append to the stream."}),(0,n.jsx)(s.td,{children:"Each record is treated as an update to an existing key"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"USAGE"})}),(0,n.jsx)(s.td,{children:"Model append-only data such as click streams."}),(0,n.jsx)(s.td,{children:"Model updatable reference data such as user profiles"})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"The following example illustrates the difference between the two:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"(key , value) records"}),(0,n.jsx)(s.th,{children:"Sum of values As KStream"}),(0,n.jsx)(s.th,{children:"Sum of values As KTable"})]})}),(0,n.jsx)(s.tbody,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:'("k1", 2) ("k1", 5)'}),(0,n.jsx)(s.td,{children:"7"}),(0,n.jsx)(s.td,{children:"5"})]})})]}),"\n",(0,n.jsx)(s.p,{children:'When a topic is viewed as a KStream, there are two independent records and thus the sum of the values is 7. On the other hand, if the topic is viewed as a KTable, the second record is treated as an update to the first record since they have the same key "k1". Therefore, only the second record is retained in the stream and the sum is 5 instead.'}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://kafka.apache.org/documentation/streams/",children:"Apache Kafka Streams"})}),"\n",(0,n.jsx)(s.h2,{id:"ksql",children:"KSQL"}),"\n",(0,n.jsx)(s.p,{children:"KSQL is an open source streaming SQL engine that implements continuous, interactive queries against Apache Kafka. It's built using the Kafka Streams API and further simplifies the job of"}),"\n",(0,n.jsx)(s.p,{children:"a developer."}),"\n",(0,n.jsx)(s.h2,{id:"kafka-streams-definitive-guide",children:"Kafka Streams (Definitive Guide)"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"data stream / event stream -"})," is an abstraction representing an unbounded dataset. Unbounded means infinite and ever growing.","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Event streams are ordered"}),"\n",(0,n.jsx)(s.li,{children:"Immutable data records"}),"\n",(0,n.jsx)(s.li,{children:"Event streams are replayable"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["Stream-processing concepts","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Time"}),"\n",(0,n.jsx)(s.li,{children:"State"}),"\n",(0,n.jsx)(s.li,{children:"Stream-Table Duality"}),"\n",(0,n.jsx)(s.li,{children:"Time Windows"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["Stream-processing design patterns","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Single-Event Processing"}),"\n",(0,n.jsx)(s.li,{children:"Processing with local state"}),"\n",(0,n.jsx)(s.li,{children:"Multiphase processing/repartitioning"}),"\n",(0,n.jsx)(s.li,{children:"Processing with external lookup: Stream-Table Join"}),"\n",(0,n.jsx)(s.li,{children:"Streaming Join"}),"\n",(0,n.jsx)(s.li,{children:"Reprocessing"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["Kafka Streams: Architecture Overview","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Building a Topology"}),"\n",(0,n.jsx)(s.li,{children:"Scaling the topology"}),"\n",(0,n.jsx)(s.li,{children:"Surviving failures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"references",children:"References"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://kafka.apache.org/documentation/streams",children:"https://kafka.apache.org/documentation/streams"})}),"\n",(0,n.jsx)(s.p,{children:"Apache Kafka by DZone Refcardz"}),"\n",(0,n.jsx)(s.h2,{id:"others",children:"Others"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://github.com/robinhood/faust",children:"https://github.com/robinhood/faust"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},458924:(e,s,a)=>{a.d(s,{A:()=>t});const t=a.p+"assets/images/Technologies-Kafka-Kafka-Streams-image1-143cf59fe1bac775f36eda408e6a2c27.jpg"},319547:(e,s,a)=>{a.d(s,{A:()=>t});const t=a.p+"assets/images/Technologies-Kafka-Kafka-Streams-image2-38fac9e302fb6579036ab31eef755010.jpg"},28453:(e,s,a)=>{a.d(s,{R:()=>r,x:()=>o});var t=a(296540);const n={},i=t.createContext(n);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);