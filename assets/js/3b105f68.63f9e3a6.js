"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[19528],{192159:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"algorithms/searching-sorting/timsort","title":"TimSort","description":"- Hybrid algorithm which uses binary insertion sort and improved merge sort by using galloping in a combination.","source":"@site/docs/algorithms/searching-sorting/timsort.md","sourceDirName":"algorithms/searching-sorting","slug":"/algorithms/searching-sorting/timsort","permalink":"/algorithms/searching-sorting/timsort","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/searching-sorting/timsort.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"System Sort","permalink":"/algorithms/searching-sorting/system-sort"},"next":{"title":"String Algorithms","permalink":"/algorithms/string-algorithms/"}}');var i=s(474848),n=s(28453);const a={},o="TimSort",l={},d=[{value:"Why Tim sort is fast",id:"why-tim-sort-is-fast",level:2},{value:"What if N is large",id:"what-if-n-is-large",level:2},{value:"Why Compute MIN_RUN",id:"why-compute-min_run",level:2},{value:"Merging",id:"merging",level:2},{value:"Galloping: (of a process or time) progress rapidly in a seemingly uncontrollable manner",id:"galloping-of-a-process-or-time-progress-rapidly-in-a-seemingly-uncontrollable-manner",level:2},{value:"References",id:"references",level:2}];function h(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"timsort",children:"TimSort"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Hybrid algorithm which uses binary insertion sort and improved merge sort by using galloping in a combination."}),"\n",(0,i.jsx)(r.li,{children:"Stable Algorithm"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Timsort was implemented by Tim Peters in 2002, it has been a standard sorting algorithm for Python since Python 2.3. Python's sorted and list.sort function uses Tim sort. Java uses Timsort in JDK for sorting non primitive types. Android platform and GNU Octave also uses it as a default sorting algorithm."}),"\n",(0,i.jsx)(r.p,{children:"Timsort is a stable algorithm and beats every other sorting algorithm in time. It has O(n logn) time complexity for worst case unlike quick sort and O(n) for best case scenarios unlike merge sort and heap sort."}),"\n",(0,i.jsx)(r.p,{children:"In real world scenarios, most of the times input array is naturally ordered array hence merge sort and quick sort aren't the efficient choice. Tim sort shines when data is ordered and of course when data is random."}),"\n",(0,i.jsx)(r.h2,{id:"why-tim-sort-is-fast",children:"Why Tim sort is fast"}),"\n",(0,i.jsx)(r.p,{children:"Tim sort is a hybrid algorithm which uses Binary insertion sort and improved merge sort by using galloping in a combination. Binary insertion sort is best method to sort when data is already or partially sorted and merge sort is best when input is large."}),"\n",(0,i.jsx)(r.p,{children:"Binary insertion sort uses Binary search to insert a new value in a sorted array. Binary search reduces number of comparisons thus more efficient than linear search."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"image",src:s(933784).A+"",width:"880",height:"489"})}),"\n",(0,i.jsx)(r.p,{children:"In above example, Binary insertion sort requires 2 iteration to find location to insert 8 whereas linear search would find location in 4th iteration."}),"\n",(0,i.jsx)(r.p,{children:"N : Number of elements inside input array."}),"\n",(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(r.code,{children:"N <= 64"})," then Tim sort uses binary insertion sort to sort the elements"]}),"\n",(0,i.jsx)(r.h2,{id:"what-if-n-is-large",children:"What if N is large"}),"\n",(0,i.jsx)(r.p,{children:"An input array is divided into different sub-arrays, count of elements inside a sub-array is defined as aRUN, minimum value of such runs is a MIN_RUN."}),"\n",(0,i.jsx)(r.p,{children:"A RUN can be either ascending or strictly descending. If elements are decreasing then in place swapping converts them into ascending order, elements that have equal values aren't swapped to maintain stability"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"image",src:s(730119).A+"",width:"880",height:"336"})}),"\n",(0,i.jsx)(r.p,{children:"A run smaller than min run is extended to make count equal to min run. Now this new run is sorted using binary insertion sort which has a best run time on partially ordered data. Ultimately, every run should be greater or equal to the min run and it shouldn't be less than 2."}),"\n",(0,i.jsx)(r.h2,{id:"why-compute-min_run",children:"Why Compute MIN_RUN"}),"\n",(0,i.jsx)(r.p,{children:"MIN_RUN ensures that input array is split in such a way that when merge happens, it happens in a perfectly balanced manner."}),"\n",(0,i.jsx)(r.p,{children:"Let's understand it with an example below-:"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"image",src:s(762378).A+"",width:"880",height:"386"})}),"\n",(0,i.jsx)(r.p,{children:"In left diagram above, we have 4 sub-arrays of size 2 which perform perfectly balanced merge at each step. In right diagram, we have 5 sub-arrays of size 2 which doesn't allow perfect balanced merge to happen."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Perfectly balanced merge allows one on one comparisons between items. An unbalanced merge can cause extra comparisons and impacts performance"})}),"\n",(0,i.jsx)(r.p,{children:"Ideally, Timsort wants value of min run to be such that N / MIN_RUN equals to power of 2 or close to it so that when merge happens it gets a perfectly balanced merge for example When an input array has 256 elements Tim Sort would like to divide array into equal sized sub-arrays. 256 / 32 will give us 8 equal sized sub-arrays that perform perfectly balanced merge."}),"\n",(0,i.jsx)(r.h2,{id:"merging",children:"Merging"}),"\n",(0,i.jsx)(r.p,{children:"At this point an input array has been divided into different sub-arrays and now they should be merged back to produce final sorted array. Unlike merge sort, Tim sort uses stack to store recent runs."}),"\n",(0,i.jsx)(r.p,{children:"Timsort tries to delay merging as long as possible in order to exploit patterns that come up later but at the same time it likes to merge as soon as possible because all the unmerged arrays are stored inside stacks and storing consumes memory which could hurt for a large array."}),"\n",(0,i.jsx)(r.p,{children:"If we consider three sub-arrays A, B and C from left to right then Tim sort complies with below 2 variants to call merge_collapse() function to decide whether current run should be merged with preceding runs or not."}),"\n",(0,i.jsxs)(r.p,{children:["1.",(0,i.jsx)(r.code,{children:"A > B + C"}),"\n2. ",(0,i.jsx)(r.code,{children:"B > C"})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"image",src:s(599097).A+"",width:"880",height:"488"})}),"\n",(0,i.jsx)(r.p,{children:"Merging two sub-arrays in place efficiently is very difficult and slow but if we have a temporary array this process can be faster and easier to implement. Tim sort uses temp array to perform merge between two arrays."}),"\n",(0,i.jsx)(r.h2,{id:"galloping-of-a-process-or-time-progress-rapidly-in-a-seemingly-uncontrollable-manner",children:"Galloping: (of a process or time) progress rapidly in a seemingly uncontrollable manner"}),"\n",(0,i.jsx)(r.p,{children:"Galloping is another technique used by Tim sort to further reduce comparisons while merging in order to increase efficiency of algorithm."}),"\n",(0,i.jsx)(r.p,{children:"While merging two sub arrays in a sorted manner Tim sort perform galloping. Galloping improves merging runtime by reducing comparisons. Java uses constant value '7' before it switches to Gallop mode. Galloping utilizes binary search to make less comparisons during merge procedure."}),"\n",(0,i.jsx)(r.p,{children:"In below example, 101 is searched inside array A for 7 times and every time array B wins after 7th time Gallop mode is switched on which forces binary search for 101 inside A."}),"\n",(0,i.jsx)(r.p,{children:"Now we compare 101 directly with A[mid] = 50 thus save lot of comparisons."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"image",src:s(612220).A+"",width:"880",height:"390"})}),"\n",(0,i.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://dev.to/s_awdesh/timsort-fastest-sorting-algorithm-for-real-world-problems--2jhd",children:"https://dev.to/s_awdesh/timsort-fastest-sorting-algorithm-for-real-world-problems--2jhd"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://svn.python.org/projects/python/trunk/Objects/listsort.txt",children:"https://svn.python.org/projects/python/trunk/Objects/listsort.txt"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://skerritt.blog/timsort-the-fastest-sorting-algorithm-youve-never-heard-of",children:"https://skerritt.blog/timsort-the-fastest-sorting-algorithm-youve-never-heard-of"})})]})}function c(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},933784:(e,r,s)=>{s.d(r,{A:()=>t});const t=s.p+"assets/images/TimSort-image1-f1a2355c75d4df8954451eff40cf1447.jpg"},730119:(e,r,s)=>{s.d(r,{A:()=>t});const t=s.p+"assets/images/TimSort-image2-572f254973395be125bd365bb78dfd25.jpg"},762378:(e,r,s)=>{s.d(r,{A:()=>t});const t=s.p+"assets/images/TimSort-image3-08ef7dfcc2f1a191abc4dbafaf982524.jpg"},599097:(e,r,s)=>{s.d(r,{A:()=>t});const t=s.p+"assets/images/TimSort-image4-fcfb333f3ded35a03c2ce75a06cc3e0f.jpg"},612220:(e,r,s)=>{s.d(r,{A:()=>t});const t=s.p+"assets/images/TimSort-image5-d19235d68701d130f259be5c831cce8b.jpg"},28453:(e,r,s)=>{s.d(r,{R:()=>a,x:()=>o});var t=s(296540);const i={},n=t.createContext(i);function a(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);