"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[90203],{733248:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"algorithms/bit-manipulation/examples","title":"Examples","description":"1. Check if a number is power of two","source":"@site/docs/algorithms/bit-manipulation/examples.md","sourceDirName":"algorithms/bit-manipulation","slug":"/algorithms/bit-manipulation/examples","permalink":"/algorithms/bit-manipulation/examples","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/bit-manipulation/examples.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Bit Manipulation","permalink":"/algorithms/bit-manipulation/"},"next":{"title":"General","permalink":"/algorithms/bit-manipulation/general"}}');var i=t(474848),a=t(28453);const o={},r="Examples",l={},h=[];function c(e){const n={code:"code",del:"del",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"examples",children:"Examples"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Check if a number is power of two"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"bool isPowerOfTwo = x && !(x & (x - 1))"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Count number of one in a number"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"int count = 0;\n\nwhile(x) {\n    x = x & (x-1);\n    count++;\n}\n\nreturn count;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Check if ith bit is set"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"void isSet(int n) {\n    return (n & (1 << i))\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Generate all possible subsets of a set"}),"\n",(0,i.jsx)(n.p,{children:"There are 2^N subsets of a set with n elements"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"possibleSubsets(A, N):\n    for i = 0 to 2^N:\n        for j = 0 to N:\n            if jth bit is set in i:\n                print A[j]\n        print \u2018\\n\u2019\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Find the largest power of 2 which is less than or equal to the given number N"}),"\n",(0,i.jsx)(n.p,{children:"Set all the bits in the number to 1. then the number will be (P + 1)/2."}),"\n",(0,i.jsxs)(n.p,{children:["Ex - N = 10 (1010)",(0,i.jsx)(n.del,{children:"2"}),"\nP - (1111)",(0,i.jsx)(n.del,{children:"2"})," = 15\nAns - (P + 1)/2 = 8"]}),"\n",(0,i.jsx)(n.p,{children:"So to change all the bits to 1."}),"\n",(0,i.jsx)(n.p,{children:"N = N | (N >> 1)\nN = N | (N >> 2)\nN = N | (N >> 4)\nN = N | (N >> 8)"}),"\n",(0,i.jsx)(n.p,{children:"// this will return (N+1)/2\nreturn (N+1) >> 1;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Given a number N. Flip all bits in its binary representation."}),"\n",(0,i.jsxs)(n.p,{children:["Solution ",(0,i.jsx)(n.code,{children:"1:N^((1<<32)-1)"}),", considering N is a 32 bit integer\nExplanation - Since XORing with 1 works as a toggle switch."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Given two numbersAandB. Swapandwithout using arithmetic operator and without using third variable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"A=A^B\nB=A^B\nA=A^B\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Problem - The problem asks to find the logical XOR of all the sub-sequences of an array and then print the logical OR of these XOR's."}),"\n",(0,i.jsx)(n.p,{children:"Ok, so lets try to do as the problem says. We find all subsequences (using maybe a recursive method) and find the xor of all the numbers. There are 2Nof those."}),"\n",(0,i.jsx)(n.p,{children:"Once done, we can find the OR of all the xor's. Clearly this method will fail even for as small a number as N = 30."}),"\n",(0,i.jsx)(n.p,{children:"This is where a little experience and observation helps. Sometimes look at the world upside down, and things will be more clear. What I want to say is that - Finally we are computing the OR of 2Nnumbers. And we know (from the above definition), that even if one of the 2Nnumbers has a 1 in a particular bit, then the resultant at that bit will also be 1. That means instead of taking out the OR of so many numbers, lets just take out the OR of the N given numbers. If any of those N numbers has a 1 at a bit p, then the result at bit p is a 1, and we dont need to check the other 2Nor so, numbers for that bit p. And what about the bit positions that have a 0 for all the N numbers? Shouldn't I take out the XOR's now? No, you dont have to, the resultant bit will be 0 at that position. Why? Because for a particular subsequence to have XOR of 1 at that position, there has to be odd number of 1's in that subsequence. But there are no 1's at all. So there is no chance of a 1 in any of the subsequence XOR's."}),"\n",(0,i.jsx)(n.p,{children:"Therefore, the answer in one line is the OR of all N Numbers."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(296540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);