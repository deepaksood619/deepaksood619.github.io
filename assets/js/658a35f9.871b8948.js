"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[99078],{205392:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"devops/terraform/documentation","title":"Documentation","description":"Providers","source":"@site/docs/devops/terraform/documentation.md","sourceDirName":"devops/terraform","slug":"/devops/terraform/documentation","permalink":"/devops/terraform/documentation","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/terraform/documentation.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1771485259000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Confluent Provider","permalink":"/devops/terraform/confluent-provider"},"next":{"title":"Examples","permalink":"/devops/terraform/examples"}}');var i=n(474848),t=n(28453);const s={},a="Documentation",c={},d=[{value:"Providers",id:"providers",level:2},{value:"Resources",id:"resources",level:2},{value:"Dependencies (Implicit and Explicit)",id:"dependencies-implicit-and-explicit",level:2},{value:"Difference between Explicit and Implicit Dependency",id:"difference-between-explicit-and-implicit-dependency",level:4},{value:"Non-dependent resources",id:"non-dependent-resources",level:2},{value:"Provisioners",id:"provisioners",level:2},{value:"local-exec",id:"local-exec",level:3},{value:"remote-exec",id:"remote-exec",level:3},{value:"Failed Provisioners and Tainted Resources",id:"failed-provisioners-and-tainted-resources",level:3},{value:"Destroy Provisioners",id:"destroy-provisioners",level:3},{value:"Modules",id:"modules",level:2},{value:"Remote Backend",id:"remote-backend",level:2}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"documentation",children:"Documentation"})}),"\n",(0,i.jsx)(r.h2,{id:"providers",children:"Providers"}),"\n",(0,i.jsx)(r.p,{children:'The provider block is used to configure the named provider, in our case "aws". A provider is responsible for creating and managing resources. A provider is a plugin that Terraform uses to translate the API interactions with the service. A provider is responsible for understanding API interactions and exposing resources. Because Terraform can interact with any API, almost any infrastructure type can be represented as a resource in Terraform.'}),"\n",(0,i.jsx)(r.p,{children:"Multiple provider blocks can exist if a Terraform configuration manages resources from different providers. To add multiple providers in your configuration, declare the providers and create resources associated with those providers. If your configuration creates a new AWS instance in your environment and you need to add that instance to your Datadog monitoring, you would declare the providers sequentially and then declare your resources for each. In the example below, using multiple providers enables us to pass the instance information directly into the monitoring query."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'provider "docker" {\n  host = "unix:///var/run/docker.sock"\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsx)(r.p,{children:"The resource block defines a resource that exists within the infrastructure. A resource might be a physical component such as an EC2 instance, or it can be a logical resource such as a Heroku application."}),"\n",(0,i.jsx)(r.p,{children:'The resource block has two strings before opening the block: the resource type and the resource name. In our example, the resource type is "aws_instance" and the name is "example." The prefix of the type maps to the provider. In our case "aws_instance" automatically tells Terraform that it is managed by the "aws" provider.'}),"\n",(0,i.jsx)(r.h2,{id:"dependencies-implicit-and-explicit",children:"Dependencies (Implicit and Explicit)"}),"\n",(0,i.jsxs)(r.p,{children:["By studying the resource attributes used in interpolation expressions, Terraform can automatically infer when one resource depends on another. In the example above, the reference to ",(0,i.jsx)(r.code,{children:"aws_instance.example.id"})," creates an implicit dependency on the aws_instance named example."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Terraform uses this dependency information to determine the correct order in which to create the different resources."})," In the example above, Terraform knows that the ",(0,i.jsx)(r.code,{children:"aws_instance"})," must be created before the ",(0,i.jsx)(r.code,{children:"aws_eip"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"Implicit dependencies via interpolation expressions are the primary way to inform Terraform about these relationships, and should be used whenever possible."}),"\n",(0,i.jsxs)(r.p,{children:["Sometimes there are dependencies between resources that are not visible to Terraform. The ",(0,i.jsx)(r.code,{children:"depends_on"})," argument is accepted by any resource and accepts a list of resources to create explicit dependencies for."]}),"\n",(0,i.jsx)(r.p,{children:"For example, perhaps an application we will run on our EC2 instance expects to use a specific Amazon S3 bucket, but that dependency is configured inside the application code and thus not visible to Terraform. In that case, we can use depends_on to explicitly declare the dependency."}),"\n",(0,i.jsx)(r.h4,{id:"difference-between-explicit-and-implicit-dependency",children:"Difference between Explicit and Implicit Dependency"}),"\n",(0,i.jsxs)(r.p,{children:["In Terraform, explicit dependencies are declared using the ",(0,i.jsx)(r.code,{children:"depends_on"})," attribute within resource blocks, providing a clear and intentional specification of relationships between resources. This allows for fine-grained control over the order of resource creation. In contrast, implicit dependencies are automatically inferred by Terraform based on the order of resource declarations in the configuration file, simplifying the configuration by letting the tool manage the order of resource operations without the need for explicit declarations. While explicit dependencies enhance clarity and control, implicit dependencies offer a more automated and concise approach to managing resource relationships in infrastructure as code."]}),"\n",(0,i.jsx)(r.h2,{id:"non-dependent-resources",children:"Non-dependent resources"}),"\n",(0,i.jsx)(r.p,{children:"If new resource does not depend on any other resource, it can be created in parallel with the other resources. Where possible, Terraform will perform operations concurrently to reduce the total time taken to apply changes."}),"\n",(0,i.jsx)(r.h2,{id:"provisioners",children:"Provisioners"}),"\n",(0,i.jsx)(r.p,{children:"Provisioners to initialize instances when they're created."}),"\n",(0,i.jsxs)(r.p,{children:["If you're using an image-based infrastructure (perhaps with images created with ",(0,i.jsx)(r.a,{href:"https://www.packer.io/",children:"Packer"}),"), then what you've learned so far is good enough. But if you need to do some initial setup on your instances, then provisioners let you upload files, run shell scripts, or install and trigger other software like configuration management tools, etc."]}),"\n",(0,i.jsxs)(r.p,{children:["This adds a provisioner block within the resource block. Multiple provisioner blocks can be added to define multiple provisioning steps. Terraform supports ",(0,i.jsx)(r.a,{href:"https://www.terraform.io/docs/provisioners/index.html",children:"multiple provisioners"}),", but for this example we are using the local-exec provisioner."]}),"\n",(0,i.jsx)(r.h3,{id:"local-exec",children:"local-exec"}),"\n",(0,i.jsx)(r.p,{children:"The local-exec provisioner executes a command locally on the machine running Terraform."}),"\n",(0,i.jsx)(r.h3,{id:"remote-exec",children:"remote-exec"}),"\n",(0,i.jsx)(r.p,{children:"Another useful provisioner is remote-exec which invokes a script on a remote resource after it is created. This can be used to run a configuration management tool, bootstrap into a cluster, etc. In order to use a remote-exec provisioner, you must choose an ssh or winrm connection in the form of a connection block within the provisioner."}),"\n",(0,i.jsx)(r.h3,{id:"failed-provisioners-and-tainted-resources",children:"Failed Provisioners and Tainted Resources"}),"\n",(0,i.jsx)(r.p,{children:'If a resource successfully creates but fails during provisioning, Terraform will error and mark the resource as "tainted". A resource that is tainted has been physically created, but can\'t be considered safe to use since provisioning failed.'}),"\n",(0,i.jsx)(r.p,{children:"When you generate your next execution plan, Terraform will not attempt to restart provisioning on the same resource because it isn't guaranteed to be safe. Instead, Terraform will remove any tainted resources and create new resources, attempting to provision them again after creation."}),"\n",(0,i.jsx)(r.p,{children:"Terraform also does not automatically roll back and destroy the resource during the apply when the failure happens, because that would go against the execution plan: the execution plan would've said a resource will be created, but does not say it will ever be deleted. If you create an execution plan with a tainted resource, however, the plan will clearly state that the resource will be destroyed because it is tainted."}),"\n",(0,i.jsx)(r.h3,{id:"destroy-provisioners",children:"Destroy Provisioners"}),"\n",(0,i.jsx)(r.p,{children:"Provisioners can also be defined that run only during a destroy operation. These are useful for performing system cleanup, extracting data, etc."}),"\n",(0,i.jsx)(r.p,{children:"For many resources, using built-in cleanup mechanisms is recommended if possible (such as init scripts), but provisioners can be used if necessary."}),"\n",(0,i.jsx)(r.h2,{id:"modules",children:"Modules"}),"\n",(0,i.jsx)(r.p,{children:"Up to this point, we've been configuring Terraform by editing Terraform configurations directly. As our infrastructure grows, this practice has a few key problems: a lack of organization, a lack of reusability, and difficulties in management for teams."}),"\n",(0,i.jsx)(r.p,{children:"Modules in Terraform are self-contained packages of Terraform configurations that are managed as a group. Modules are used to create reusable components, improve organization, and to treat pieces of infrastructure as a black box."}),"\n",(0,i.jsx)(r.h2,{id:"remote-backend",children:"Remote Backend"}),"\n",(0,i.jsxs)(r.p,{children:["Terraform supports team-based workflows with a feature known as ",(0,i.jsx)(r.a,{href:"https://www.terraform.io/docs/backends/index.html",children:"remote backends"}),". Remote backends allow Terraform to use a shared storage space for state data, so any member of your team can use Terraform to manage the same infrastructure."]})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var o=n(296540);const i={},t=o.createContext(i);function s(e){const r=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(t.Provider,{value:r},e.children)}}}]);