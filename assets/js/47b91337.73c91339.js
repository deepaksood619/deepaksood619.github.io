"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[75721],{903565:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"data-structures/trie/standard-trie","title":"Standard Trie","description":"Radix Tree / Prefix Tree (Because pre-order traversal would give the nodes in lexicographical order)","source":"@site/docs/data-structures/trie/standard-trie.md","sourceDirName":"data-structures/trie","slug":"/data-structures/trie/standard-trie","permalink":"/data-structures/trie/standard-trie","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/trie/standard-trie.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1700454456000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"R-way Tries","permalink":"/data-structures/trie/r-way-tries"},"next":{"title":"Suffix Array","permalink":"/data-structures/trie/suffix-array"}}');var a=r(474848),n=r(28453);const i={},o="Standard Trie",d={},c=[{value:"Pros",id:"pros",level:2},{value:"Cons",id:"cons",level:2}];function l(e){const t={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"standard-trie",children:"Standard Trie"})}),"\n",(0,a.jsx)(t.p,{children:"Radix Tree / Prefix Tree (Because pre-order traversal would give the nodes in lexicographical order)"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Autocomplete function"}),"\n",(0,a.jsx)(t.li,{children:"Ordered tree structure having one or more relations between the elements"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"pros",children:"Pros"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"M - length of the string"}),"\n",(0,a.jsx)(t.li,{children:"No worry about collision"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"cons",children:"Cons"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Lots of space\nA trie also known as radix tree or prefix tree, is an ordered tree structure that stores sets or arrays having one or more relations between the elements.\nUnlike a binary search tree, an element of a trie isn't an independent entity, but more of a sequence of states following one another.\nThe best example that uses the trie data structure is the autocomplete function of smartphones: the entry node represents the empty character as you press space, then it gives suggestions of words (represented as leaves) that can be obtained extending the current character sequence (path between the current node and a leaf)."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:r(769046).A+"",width:"876",height:"742"})}),"\n",(0,a.jsx)(t.p,{children:"A node that has avalue associatedrepresents a word with a higher or lower chance to be picked by the autocomplete function.\nLooking up data in atrieis fast; the worst case takesO(m), wheremis the length of the string, and you don't have to worry about two different words ending up in the same location(collision).\nThe drawback is thattriescan take up a lot of space because they save each intermediate step. It is also hard to prevent adding long, meaningless sequences of characters to the trie.\nThey are also calledprefix treesbecause apre-order traversalwould visit the nodes inlexicographical order."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:r(18657).A+"",width:"1272",height:"899"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},769046:(e,t,r)=>{r.d(t,{A:()=>s});const s=r.p+"assets/images/Standard-Trie-image1-7b9cd66a2018ec14e6707a7c9280bb4b.jpg"},18657:(e,t,r)=>{r.d(t,{A:()=>s});const s=r.p+"assets/images/Standard-Trie-image2-fb80e8899fffc67b8f2ed89918161b7b.jpg"},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>o});var s=r(296540);const a={},n=s.createContext(a);function i(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);