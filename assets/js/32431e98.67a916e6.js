"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[99190],{896044:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"technologies/apache-hadoop/others","title":"Others","description":"Traditionally, Hadoop saves its data internally in flat sequence files, which is a binary storage format for key value pairs. It has the benefit of being more compact than text and fits well the map-reduce output format. Sequence files can be compressed on value, or block level, to improve its IO profile further. Unfortunately, sequence files are not an optimal solution for Hive since it saves a complete row as a single binary value. Consequently, Hive has to read a full row and decompress it even if only one column is being requested.","source":"@site/docs/technologies/apache-hadoop/others.md","sourceDirName":"technologies/apache-hadoop","slug":"/technologies/apache-hadoop/others","permalink":"/technologies/apache-hadoop/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache-hadoop/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1739572825000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MapReduce Examples","permalink":"/technologies/apache-hadoop/mapreduce-examples"},"next":{"title":"Apache Spark","permalink":"/technologies/apache-spark/"}}');var n=a(474848),s=a(28453);const r={},i="Others",l={},c=[{value:"Azkaban",id:"azkaban",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"others",children:"Others"})}),"\n",(0,n.jsx)(t.p,{children:"Traditionally, Hadoop saves its data internally in flat sequence files, which is a binary storage format for key value pairs. It has the benefit of being more compact than text and fits well the map-reduce output format. Sequence files can be compressed on value, or block level, to improve its IO profile further. Unfortunately, sequence files are not an optimal solution for Hive since it saves a complete row as a single binary value. Consequently, Hive has to read a full row and decompress it even if only one column is being requested."}),"\n",(0,n.jsx)(t.h2,{id:"azkaban",children:(0,n.jsx)(t.a,{href:"https://azkaban.github.io/",children:"Azkaban"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Azkaban"})," is a batch workflow job scheduler created at LinkedIn to run Hadoop jobs. Azkaban resolves the ordering through job dependencies and provides an easy to use web user interface to maintain and track your workflows."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>i});var o=a(296540);const n={},s=o.createContext(n);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);