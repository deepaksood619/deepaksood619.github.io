"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[25354],{39941:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>n,metadata:()=>o,toc:()=>l});var s=a(785893),r=a(511151);const n={},i="SSTables, Sorted String Tables",o={id:"data-structures/others/sstables-sorted-string-tables",title:"SSTables, Sorted String Tables",description:"The advantage of the Sorted String Tables is their simplicity: they are easy to write, search and read. SSTables are a persistent ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. They have some nice properties like, for example, the random point-queries (i.e. finding a value by key) can be done quickly by looking up the primary index sequential scans (i.e. iterating over all key/value pairs in a specified key range) can be done efficiently by just reading the records one after the other.",source:"@site/docs/data-structures/others/sstables-sorted-string-tables.md",sourceDirName:"data-structures/others",slug:"/data-structures/others/sstables-sorted-string-tables",permalink:"/data-structures/others/sstables-sorted-string-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/others/sstables-sorted-string-tables.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"LSM (Log Structured Merge Trees)",permalink:"/data-structures/others/lsm-log-structured-merge-trees"},next:{title:"Trie",permalink:"/data-structures/trie/"}},d={},l=[];function c(e){const t={a:"a",h1:"h1",img:"img",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"sstables-sorted-string-tables",children:"SSTables, Sorted String Tables"}),"\n",(0,s.jsxs)(t.p,{children:["The advantage of the ",(0,s.jsx)(t.a,{href:"https://static.googleusercontent.com/media/research.google.com/en/archive/bigtable-osdi06.pdf",children:"Sorted String Tables"})," is their simplicity: they are easy to write, search and read. SSTables are a persistent ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. They have some nice properties like, for example, the random point-queries (i.e. finding a value by key) can be done quickly by looking up the primary index sequential scans (i.e. iterating over all key/value pairs in a specified key range) can be done efficiently by just reading the records one after the other.\nUsually the SSTable has two parts: index and data blocks. Data block consists from the key/value pairs concatenated one after another. The index block contains primary keys and offsets, pointing to the offset in the data block where the actual record can be found. Primary index can be implemented using a format optimised for quick searches, like a B-Tree, for example."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"image",src:a(574245).Z+"",width:"626",height:"288"})}),"\n",(0,s.jsxs)(t.p,{children:["SSTable is a persistent ordered immutable data structures. It usually consist of Index and Data blocks, where index block can be represented by a quick lookup data structure, holding offsets to the values in the Data block; the Data block holds concatenated key/value pairs, enabling fast sequential rangescans.\nSince SSTable is immutable, insert, update or delete operations would require rewriting the whole file, since it's optimised for reads, written sequentially and has no reserved empty space that would allow any in-place modifications.\nMany databases use SSTables:",(0,s.jsx)(t.a,{href:"https://github.com/facebook/rocksdb/wiki/Terminology",children:"RocksDB"})," and ",(0,s.jsx)(t.a,{href:"https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlManageOndisk.html",children:"Cassandra"}),", just to name a few, but there are plenty other examples. Cassandra, starting with version 3.4, incorporated ",(0,s.jsx)(t.a,{href:"https://github.com/apache/cassandra/blob/trunk/doc/SASI",children:"SSTable Attached Secondary Indexes"}),", a concept built on top SSTables and LSM Trees, that simplifies the secondary index maintenance by coupling the index building to memory-resident table flush and SSTable merge process."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f",children:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f"})})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},574245:(e,t,a)=>{a.d(t,{Z:()=>s});const s=a.p+"assets/images/SSTables-Sorted-String-Tables-image1-78e4588bef99864c9145f6db6ee2358b.jpg"},511151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>i});var s=a(667294);const r={},n=s.createContext(r);function i(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);