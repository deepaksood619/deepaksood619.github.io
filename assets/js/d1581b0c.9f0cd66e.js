"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[80623],{281710:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"courses/mordern-algorithm-design","title":"Mordern Algorithm Design","description":"1. Randomization","source":"@site/docs/courses/mordern-algorithm-design.md","sourceDirName":"courses","slug":"/courses/mordern-algorithm-design","permalink":"/courses/mordern-algorithm-design","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/courses/mordern-algorithm-design.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1706784574000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Microsoft Excel / Google Sheets","permalink":"/courses/microsoft-excel-google-sheets"},"next":{"title":"Nutanix Hybrid Cloud","permalink":"/courses/nutanix-hybrid-cloud"}}');var r=t(474848),a=t(28453);const s={},o="Mordern Algorithm Design",l={},h=[{value:"Optimal Stopping Problem",id:"optimal-stopping-problem",level:2},{value:"Apartment hunting - 37%",id:"apartment-hunting---37",level:2},{value:"Secretary Problem",id:"secretary-problem",level:2}];function p(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"mordern-algorithm-design",children:"Mordern Algorithm Design"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Randomization"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Amortized Analysis"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Disjoint Set"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Suffix Tree and Suffix Array"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Linear Programming"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Maximum Flow Algorithms"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Bipartite Matching and Stable Matching"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Approximation Algorithms"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Streaming Algorithms"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"sliding window sampling algorithms"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"External Memory Algorithm"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Online Algorithms"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Web Search Algorithms"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Data Compression Algorithms"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"optimal-stopping-problem",children:"Optimal Stopping Problem"}),"\n",(0,r.jsxs)(i.p,{children:["In ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mathematics",children:"mathematics"}),", the theory ofoptimal stoppingorearly stoppingis concerned with the problem of choosing a time to take a particular action, in order to ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimization_(mathematics)",children:"maximise"})," an expected reward or minimise an expected cost. Optimal stopping problems can be found in areas of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Statistics",children:"statistics"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Economics",children:"economics"}),", and ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mathematical_finance",children:"mathematical finance"}),"(related to the pricing of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/American_options",children:"American options"}),"). A key example of an optimal stopping problem is the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Secretary_problem",children:"secretary problem"}),". Optimal stopping problems can often be written in the form of a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bellman_equation",children:"Bellman equation"}),", and are therefore often solved using ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Dynamic_programming",children:"dynamic programming"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"apartment-hunting---37",children:"Apartment hunting - 37%"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimal_stopping",children:"https://en.wikipedia.org/wiki/Optimal_stopping"})}),"\n",(0,r.jsx)(i.h2,{id:"secretary-problem",children:"Secretary Problem"}),"\n",(0,r.jsxs)(i.p,{children:["Thesecretary problemis a problem that demonstrates a scenario involving ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimal_stopping",children:"optimal stopping"})," theory.The problem has been studied extensively in the fields of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Applied_probability",children:"applied probability"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Statistics",children:"statistics"}),", and ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Decision_theory",children:"decision theory"}),". It is also known as themarriage problem, thesultan's dowry problem, thefussy suitor problem, the googol game, and thebest choice problem."]}),"\n",(0,r.jsxs)(i.p,{children:["The basic form of the problem is the following: imagine an administrator who wants to hire the best secretary out ofnrankable applicants for a position. The applicants are interviewed one by one in random order. A decision about each particular applicant is to be made immediately after the interview. Once rejected, an applicant cannot be recalled. During the interview, the administrator can rank the applicant among all applicants interviewed so far, but is unaware of the quality of yet unseen applicants. The question is about the optimal strategy (",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Stopping_rule",children:"stopping rule"}),") to maximize the probability of selecting the best applicant. If the decision can be deferred to the end, this can be solved by the simple maximum ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Selection_algorithm",children:"selection algorithm"})," of tracking the running maximum (and who achieved it), and selecting the overall maximum at the end. The difficulty is that the decision must be made immediately."]}),"\n",(0,r.jsxs)(i.p,{children:["The problem has an elegant solution, and the shortest rigorous proof known so far is provided by the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Odds_algorithm",children:"odds algorithm"}),"(Bruss 2000). An easy analysis implies that the optimal win probability is always at least1/e, and that the latter holds even in a much greater generality (2003). The optimal stopping rule prescribes always rejecting the first ~n/e applicants that are interviewed (where ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/E_(mathematical_constant)",children:"e"})," is the base of the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Natural_logarithm",children:"natural logarithm"}),") and then stopping at the first applicant who is better than every applicant interviewed so far (or continuing to the last applicant if this never occurs). Sometimes this strategy is called the 1/estopping rule, because the probability of stopping at the best applicant with this strategy is about1/ealready for moderate values ofn. One reason why the secretary problem has received so much attention is that the optimal policy for the problem (the stopping rule) is simple and selects the single best candidate about 37% of the time, irrespective of whether there are 100 or 100 million applicants."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Secretary_problem",children:"https://en.wikipedia.org/wiki/Secretary_problem"})})]})}function d(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>s,x:()=>o});var n=t(296540);const r={},a=n.createContext(r);function s(e){const i=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(a.Provider,{value:i},e.children)}}}]);