"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[18969],{667703:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"computer-science/operating-system/coroutines","title":"Coroutines","description":"Coroutines are general control structures where flow control is cooperatively passed between two different routines without returning.","source":"@site/docs/computer-science/operating-system/coroutines.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/coroutines","permalink":"/computer-science/operating-system/coroutines","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/coroutines.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Concurrency / Threading","permalink":"/computer-science/operating-system/concurrency-threading"},"next":{"title":"CPU | GPU | TPU","permalink":"/computer-science/operating-system/cpu-gpu-tpu"}}');var r=t(474848),o=t(28453);const s={},a="Coroutines",c={},l=[{value:"Comparison with subroutines",id:"comparison-with-subroutines",level:2},{value:"Comparison with threads",id:"comparison-with-threads",level:2},{value:"Comparison with generators",id:"comparison-with-generators",level:2},{value:"Comparison with mutual recursion",id:"comparison-with-mutual-recursion",level:2},{value:"Implementations",id:"implementations",level:2},{value:"References",id:"references",level:2}];function h(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"coroutines",children:"Coroutines"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.a,{href:"https://www.geeksforgeeks.org/coroutine-in-python/",children:"Coroutines"})," are general control structures where flow control is cooperatively passed between two different routines without returning.\nCoroutinesare ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_program",children:"computer program"})," components that generalize ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Subroutine",children:"subroutines"})," for ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Non-preemptive_multitasking",children:"non-preemptive multitasking"}),", by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cooperative_multitasking",children:"cooperative tasks"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Exception_handling",children:"exceptions"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Event_loop",children:"event loops"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Iterator",children:"iterators"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Lazy_evaluation",children:"infinite lists"})," and ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Pipeline_(software)",children:"pipes"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"comparison-with-subroutines",children:"Comparison with subroutines"}),"\n",(0,r.jsxs)(i.p,{children:["Subroutines are special cases of coroutines.When subroutines are invoked, execution begins at the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another coroutine.Thus, a coroutine instance holds state, and varies between invocations; there can be multiple instances of a given coroutine at once. The difference between calling another coroutine by means of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Yield_(multithreading)",children:'"yielding"'})," to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.\nAny subroutine can be translated to a coroutine which does not callyield."]}),"\n",(0,r.jsx)(i.h2,{id:"comparison-with-threads",children:"Comparison with threads"}),"\n",(0,r.jsxs)(i.p,{children:["Coroutines are very similar to ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Thread_(computing)",children:"threads"}),". However, coroutines are ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cooperative_multitasking",children:"cooperatively"})," multitasked, whereas threads are typically ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Preemptive_multitasking",children:"preemptively"}),(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Multitasking",children:"multitasked"}),". This means that coroutines provide ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Concurrency_(computer_science)",children:"concurrency"})," but not ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Parallel_computing",children:"parallelism"}),". The advantages of coroutines over threads are that they may be used in a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hard_realtime",children:"hard-realtime"})," context (",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Context_switch",children:"switching"})," between coroutines need not involve any ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/System_calls",children:"system calls"})," or any ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Blocking_(computing)",children:"blocking"})," calls whatsoever), there is no need for synchronisation primitives such as ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mutex",children:"mutexes"}),", semaphores, etc. in order to guard ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Critical_sections",children:"critical sections"}),", and there is no need for support from the operating system.\nIt is possible to implement coroutines using preemptively-scheduled threads, in a way that will be transparent to the calling code, but some of the advantages (particularly the suitability for hard-realtime operation and relative cheapness of switching between them) will be lost."]}),"\n",(0,r.jsx)(i.h2,{id:"comparison-with-generators",children:"Comparison with generators"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Generator_(computer_science)",children:"Generators"}),", also known as semicoroutines, are a subset of coroutines. Specifically, while both can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.That is, since generators are primarily used to simplify the writing of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Iterator",children:"iterators"}),", theyieldstatement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine."]}),"\n",(0,r.jsx)(i.h2,{id:"comparison-with-mutual-recursion",children:"Comparison with mutual recursion"}),"\n",(0,r.jsxs)(i.p,{children:["Using coroutines for state machines or concurrency is similar to using ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mutual_recursion",children:"mutual recursion"})," with ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tail_call",children:"tail calls"}),", as in both cases the control changes to a different one of a set of routines. However, coroutines are more flexible and generally more efficient. Since coroutines yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tail_call_elimination",children:"tail call elimination"})," is implemented), while passing control between coroutines uses the existing contexts and can be implemented simply by a jump."]}),"\n",(0,r.jsx)(i.h2,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Goroutine in Golang"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"lightweight threads / suspending functions in Kotlin"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Coroutine",children:"https://en.wikipedia.org/wiki/Coroutine"})})]})}function u(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>s,x:()=>a});var n=t(296540);const r={},o=n.createContext(r);function s(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);