"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[80299],{794179:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=r(785893),n=r(511151);const s={},c="Creational - Abstract Factory",i={id:"computer-science/programming-paradigms/creational-abstract-factory",title:"Creational - Abstract Factory",description:"An abstract factory is a generative design pattern that allows you to create families of related objects without getting attached to specific classes of created objects. The pattern is being implemented by creating an abstract class (for example - Factory), which is represented as an interface for creating system components. Then the classes that implement this interface are being written.",source:"@site/docs/computer-science/programming-paradigms/creational-abstract-factory.md",sourceDirName:"computer-science/programming-paradigms",slug:"/computer-science/programming-paradigms/creational-abstract-factory",permalink:"/computer-science/programming-paradigms/creational-abstract-factory",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-paradigms/creational-abstract-factory.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concurrency - Reactor",permalink:"/computer-science/programming-paradigms/concurrency-reactor"},next:{title:"Creational - Object Pool",permalink:"/computer-science/programming-paradigms/creational-object-pool"}},o={},l=[{value:"References",id:"references",level:2}];function p(e){const t={a:"a",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"creational---abstract-factory",children:"Creational - Abstract Factory"}),"\n",(0,a.jsx)(t.p,{children:"An abstract factory is a generative design pattern that allows you to create families of related objects without getting attached to specific classes of created objects. The pattern is being implemented by creating an abstract class (for example - Factory), which is represented as an interface for creating system components. Then the classes that implement this interface are being written.\nPros:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"isolates specific classes;"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"simplifies the replacement of the product families;"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"guarantees the products' compatibility."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Cons:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"it's difficult to add support for the new kinds of products."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://py.checkio.org/blog/design-patterns-part-1",children:"https://py.checkio.org/blog/design-patterns-part-1"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},511151:(e,t,r)=>{r.d(t,{Z:()=>i,a:()=>c});var a=r(667294);const n={},s=a.createContext(n);function c(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);