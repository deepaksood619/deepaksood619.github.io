"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[96349],{647233:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"databases/sql-databases/postgres/replication","title":"Replication","description":"Types","source":"@site/docs/databases/sql-databases/postgres/replication.md","sourceDirName":"databases/sql-databases/postgres","slug":"/databases/sql-databases/postgres/replication","permalink":"/databases/sql-databases/postgres/replication","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/sql-databases/postgres/replication.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1734522786000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Parameters / Configurations / Optimizations","permalink":"/databases/sql-databases/postgres/parameters-configuration-optimization"},"next":{"title":"Table Partitioning","permalink":"/databases/sql-databases/postgres/table-partitioning"}}');var t=s(474848),a=s(28453);const r={},l="Replication",o={},c=[{value:"Types",id:"types",level:3},{value:"Streaming Replication",id:"streaming-replication",level:4},{value:"Physical Replication",id:"physical-replication",level:4},{value:"Logical Replication",id:"logical-replication",level:4},{value:"Bi-Directional Replication (BDR)",id:"bi-directional-replication-bdr",level:4},{value:"Bi-directional Replication (BDR)",id:"bi-directional-replication-bdr-1",level:3},{value:"Multiple Masters to Single Slave (Multi-Source Replication)",id:"multiple-masters-to-single-slave-multi-source-replication",level:2},{value:"Dump and Restore",id:"dump-and-restore",level:2},{value:"Links",id:"links",level:2}];function d(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"replication",children:"Replication"})}),"\n",(0,t.jsx)(i.h3,{id:"types",children:"Types"}),"\n",(0,t.jsx)(i.h4,{id:"streaming-replication",children:"Streaming Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Uses a continuous stream of write-ahead logs (WAL) from the primary server to the standby server(s)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates entire database clusters at the block level."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Generally used for read-only failover. Failover to a standby server in case the primary server fails."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Synchronous replication can be achieved by waiting for acknowledgments from the standby, ensuring transaction durability."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Commonly used for high availability and disaster recovery."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"physical-replication",children:"Physical Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Synchronous or Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates physical blocks of data, similar to streaming replication, but allows for more flexibility in configuration."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates entire data pages at the storage level."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Primarily used for read-only failover, similar to streaming replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Can be synchronous, ensuring that a transaction is committed on both the primary and standby servers before returning to the client."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Suitable for high availability, disaster recovery, and load balancing."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"logical-replication",children:"Logical Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates changes in the database on a logical level, such as tables, rows, or columns."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates changes made to the data, providing more flexibility in what is replicated."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Often used for upgrading databases with minimal downtime or for data distribution across different systems."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Typically asynchronous, so there might be some delay in data replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Useful for selective data replication, upgrades, and data distribution."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"bi-directional-replication-bdr",children:"Bi-Directional Replication (BDR)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates changes bidirectionally between nodes."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Allows for bidirectional replication of changes made to the data."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Can be used for read and write failover, allowing writes on multiple nodes."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Asynchronous replication, so there might be some delay in data replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Useful for multi-master setups where multiple nodes can accept both read and write operations. It enables data consistency across multiple nodes."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Streaming replication and physical replication are more focused on providing high availability and disaster recovery, while logical replication allows for more selective data replication. Bi-Directional Replication (BDR) is a specific implementation of multi-master replication, allowing for bidirectional data synchronization between nodes."}),"\n",(0,t.jsx)(i.h3,{id:"bi-directional-replication-bdr-1",children:"Bi-directional Replication (BDR)"}),"\n",(0,t.jsxs)(i.p,{children:["PostgreSQL supports block-based (physical) replication as well as the row-based (logical) replication. ",(0,t.jsx)(i.strong,{children:"Physical replication is traditionally used to create read-only replicas of a primary instance"}),", and utilized in both self-managed and managed deployments of PostgreSQL. Uses for physical read replicas can include high availability, disaster recovery, and scaling out the reader nodes. Although there is flexibility in the use cases for physical replicas, consider that all data in the database must be replicated from the write instance to its readers."]}),"\n",(0,t.jsxs)(i.p,{children:["In contrast, ",(0,t.jsx)(i.strong,{children:"logical replication allows you to choose a subset of the data to replicate"}),". Additionally, when using logical replication, there is no requirement for the secondary nodes to be read-only. You can configure logical replication to get data for some tables and at the same time, the application can directly write to the same or different tables in the database."]}),"\n",(0,t.jsxs)(i.p,{children:["The publisher- and subscriber-based\xa0",(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/current/logical-replication.html",children:"logical replication feature"}),"\xa0was introduced into core PostgreSQL starting with version 10, but prior to that, PostgreSQL started supporting the\xa0",(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/current/logicaldecoding-explanation.html",children:"logical decoding feature"}),"\xa0from version 9.4. Much of the logical replication capability in core PostgreSQL was based on the work done for the open-source PostgreSQL logical replication extension called\xa0",(0,t.jsx)(i.a,{href:"https://github.com/2ndQuadrant/pglogical",children:"pglogical"}),"."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://aws.amazon.com/blogs/database/postgresql-bi-directional-replication-using-pglogical/",children:"PostgreSQL bi-directional replication using pglogical | AWS Database Blog"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"PostgreSQL\u2019s bidirectional replication"}),"\xa0(Postgres-BDR or BDR) is PostgreSQL\u2019s first open-source multi-master replication system to achieve full production status. BDR was developed by 2ndQuadrant, specially designed for\xa0",(0,t.jsx)(i.strong,{children:"distribution"}),"\xa0in different geographical clusters, using efficient asynchronous logical replication, and\xa0",(0,t.jsx)(i.strong,{children:"supporting"}),"\xa0any node with more than 2 to 48 nodes in the distributed database."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.enterprisedb.com/docs/pgd/4/bdr/",children:"EDB Docs - EDB Postgres Distributed (PGD) v4 - BDR (Bi-Directional Replication)"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/database-blog/converting-asynchronous-synchronous-replication-postgresql",children:"Converting from Asynchronous to Synchronous Replication in PostgreSQL | Severalnines"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/download/products/3-clusteringreplication/",children:"PostgreSQL: Software Catalogue - Clustering/replication"})}),"\n",(0,t.jsx)(i.h2,{id:"multiple-masters-to-single-slave-multi-source-replication",children:"Multiple Masters to Single Slave (Multi-Source Replication)"}),"\n",(0,t.jsx)(i.p,{children:"Multi-Source Replication enables a replication slave to receive transactions from multiple sources simultaneously. Multi-source replication can be used to backup multiple servers to a single server, to merge table shards, and consolidate data from multiple servers to a single server."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{src:"https://severalnines.com/wp-content/uploads/2022/05/07-mysql-rep-wp.jpeg",alt:"image"})}),"\n",(0,t.jsx)(i.p,{children:"MySQL and MariaDB have different implementations of multi-source replication, where MariaDB must have GTID with\xa0gtid-domain-id\xa0configured to distinguish the originating transactions while MySQL uses a separate replication channel for each master the slave replicates from. In MySQL, masters in a multi-source replication topology can be configured to use either global transaction identifier (GTID) based replication, or binary log position-based replication."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/resources/whitepapers/mysql-replication-high-availability/",children:"MySQL replication for high availability | Severalnines"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://dev.mysql.com/doc/refman/8.0/en/replication-multi-source.html",children:"MySQL 8.0 Reference Manual - 19.1.5 MySQL Multi-Source Replication"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/blog/difference-between-mysql-multi-master-and-multi-source-replication/",children:"The Difference Between MySQL Multi-Master and Multi-Source Replication | Severalnines"})}),"\n",(0,t.jsx)(i.h2,{id:"dump-and-restore",children:"Dump and Restore"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://stackoverflow.com/questions/2094963/postgresql-improving-pg-dump-pg-restore-performance",children:"PostgreSQL: improving pg_dump, pg_restore performance - Stack Overflow"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://serverfault.com/questions/1081642/postgresql-13-speed-up-pg-dump-to-5-minutes-instead-of-70-minutes",children:"pg dump - Postgresql 13 - Speed up pg_dump to 5 minutes instead of 70 minutes - Server Fault"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.iseatz.com/blog/speeding-up-postgres-data-dumps",children:"Speeding up Postgres Data Dumps"})}),"\n",(0,t.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/high-availability.html",children:"26. High Availability, Load Balancing, and Replication"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/logical-replication.html",children:"30. Logical Replication"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/replication-origins.html",children:"49. Replication Progress Tracking"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://dbaclass.com/article/edb-failover-managerefm-for-managing-streaming-replication/",children:"EDB failover manager (EFM) for managing streaming replication - DBACLASS DBACLASS"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.interdb.jp/blog/pgsql/pg_vs_my_01/",children:"Difference between PostgreSQL and MySQL: (1) Replication \xb7 Hironobu SUZUKI @ InterDB"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://aws.amazon.com/blogs/database/replicate-data-between-partitioned-and-non-partitioned-tables-using-trigger-functions-in-amazon-rds-for-postgresql-or-amazon-aurora-postgresql/",children:"Replicate data between partitioned and non-partitioned tables using trigger functions in Amazon RDS for PostgreSQL or Amazon Aurora PostgreSQL | AWS Database Blog"})}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,s)=>{s.d(i,{R:()=>r,x:()=>l});var n=s(296540);const t={},a=n.createContext(t);function r(e){const i=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),n.createElement(a.Provider,{value:i},e.children)}}}]);