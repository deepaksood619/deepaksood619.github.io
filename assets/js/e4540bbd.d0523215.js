"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[17963],{695150:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"devops/monitoring/prometheus/rules","title":"Rules","description":"Prometheus supports two types of rules which may be configured and then evaluated at regular intervals: recording rules and alerting rules.","source":"@site/docs/devops/monitoring/prometheus/rules.md","sourceDirName":"devops/monitoring/prometheus","slug":"/devops/monitoring/prometheus/rules","permalink":"/devops/monitoring/prometheus/rules","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/monitoring/prometheus/rules.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Querying","permalink":"/devops/monitoring/prometheus/querying"},"next":{"title":"Service Mesh","permalink":"/devops/monitoring/service-mesh"}}');var n=r(474848),o=r(28453);const i={},l="Rules",a={},u=[{value:"Recording Rules",id:"recording-rules",level:2},{value:"Alerting Rules",id:"alerting-rules",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"rules",children:"Rules"})}),"\n",(0,n.jsxs)(t.p,{children:["Prometheus supports two types of rules which may be configured and then evaluated at regular intervals: recording rules and ",(0,n.jsx)(t.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/",children:"alerting rules"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"recording-rules",children:"Recording Rules"}),"\n",(0,n.jsx)(t.p,{children:"Recording rules allow you to precompute frequently needed or computationally expensive expressions and save their result as a new set of time series. Querying the precomputed result will then often be much faster than executing the original expression every time it is needed. This is especially useful for dashboards, which need to query the same expression repeatedly every time they refresh."}),"\n",(0,n.jsx)(t.p,{children:"Recording and alerting rules exist in a rule group. Rules within a group are run sequentially at a regular interval."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/recording_rules",children:"https://prometheus.io/docs/prometheus/latest/configuration/recording_rules"})}),"\n",(0,n.jsx)(t.h2,{id:"alerting-rules",children:"Alerting Rules"}),"\n",(0,n.jsx)(t.p,{children:"Alerting rules allow you to define alert conditions based on Prometheus expression language expressions and to send notifications about firing alerts to an external service. Whenever the alert expression results in one or more vector elements at a given point in time, the alert counts as active for these elements' label sets."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules",children:"https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules"})})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>l});var s=r(296540);const n={},o=s.createContext(n);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);