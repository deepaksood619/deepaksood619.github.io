"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[8937],{286185:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"databases/concepts/comparisons","title":"Comparisons","description":"image","source":"@site/docs/databases/concepts/comparisons.md","sourceDirName":"databases/concepts","slug":"/databases/concepts/comparisons","permalink":"/databases/concepts/comparisons","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/concepts/comparisons.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1740663042000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Amazon Databases","permalink":"/databases/concepts/amazon-databases"},"next":{"title":"Concurrency Control","permalink":"/databases/concepts/concurrency-control"}}');var o=t(474848),n=t(28453);const r={},i="Comparisons",l={},c=[{value:"Relational vs Non-Relational Databases",id:"relational-vs-non-relational-databases",level:3},{value:"Row Oriented vs Column Oriented (columnar) Databases",id:"row-oriented-vs-column-oriented-columnar-databases",level:2},{value:"Benefits of Columnar Formats",id:"benefits-of-columnar-formats",level:3},{value:"READ-OPTIMIZATION",id:"read-optimization",level:4},{value:"COMPRESSION IMPROVEMENTS",id:"compression-improvements",level:4},{value:"Negatives of Columnar Formats",id:"negatives-of-columnar-formats",level:3}];function d(e){const a={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",strong:"strong",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.header,{children:(0,o.jsx)(a.h1,{id:"comparisons",children:"Comparisons"})}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{alt:"image",src:t(296804).A+"",width:"299",height:"648"})}),"\n",(0,o.jsx)(a.h3,{id:"relational-vs-non-relational-databases",children:"Relational vs Non-Relational Databases"}),"\n",(0,o.jsxs)(a.p,{children:["A ",(0,o.jsx)(a.strong,{children:"relational database"})," is one where data is stored in the form of a table. Each table has a ",(0,o.jsx)(a.strong,{children:"schema"}),", which is the columns and types a record is required to have. Each schema must have at least one primary key that uniquely identifies that record. In other words, there are no duplicate rows in your database. Moreover, each table can be related to other tables using foreign keys.\nOne important aspect of relational databases is that a change in a schema must be applied to all records. This can sometimes cause breakages and big headaches during migrations.",(0,o.jsx)(a.strong,{children:"Non-relational databases"}),"tackle things in a different way. They are inherently schema-less, which means that records can be saved with different schemas and with a different, nested structure. Records can still have primary keys, but a change in the schema is done on an entry-by-entry basis."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.a,{href:"https://www.prisma.io/blog/comparison-of-database-models-1iz9u29nwn37",children:"https://www.prisma.io/blog/comparison-of-database-models-1iz9u29nwn37"})}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.a,{href:"http://www.cattell.net/datastores/Datastores.pdf",children:"http://www.cattell.net/datastores/Datastores.pdf"})}),"\n",(0,o.jsx)(a.h2,{id:"row-oriented-vs-column-oriented-columnar-databases",children:"Row Oriented vs Column Oriented (columnar) Databases"}),"\n",(0,o.jsxs)(a.p,{children:["Here is an example: Say we have a table that stores the following data for 1M users",":user_id",", name, # logins, last_login. So we effectively have 1M rows and 4 columns. A row-oriented data store will physically store each user's data (i.e., each row) contiguously on disk. By contrast, a columnar store will store all of the user_id's together, all of the names together, and so forth, so that each column's data is stored contiguously on disk."]}),"\n",(0,o.jsx)(a.p,{children:'As a result, shallow-and-wide queries will be faster on a row store (e.g., "fetch all data for user X"), while deep-and-narrow queries will be faster on a column store (e.g., "calculate the average number of logins for all users").\nIn particular, columnar stores do really well with narrow queries over very wide data. With such storage, only the designated columns need to be read from disk (rather than bringing in pages of data from disk with the entire rows, then selecting one or a few columns just in memory).'}),"\n",(0,o.jsx)(a.p,{children:"Additionally, because individual columns of data are typically the same type and are often drawn from a more limited domain or range, they typically compress better than an entire wide row of data comprising many different data types and ranges. For example, our column of number of logins would all be of an integer type and may cover a small range of numeric values."}),"\n",(0,o.jsx)(a.p,{children:"Yet columnar stores are not without trade-offs. First of all, inserts take much longer: the system needs to split each record into the appropriate columns and write it to disk accordingly. Second, it is easier for row-based stores to take advantage of an index (e.g., B-tree) to quickly find the appropriate records. Third, with a row-store it is easier to normalize your dataset, such that you can more efficiently store related datasets in other tables."}),"\n",(0,o.jsx)(a.p,{children:"As a result, the choice of row-oriented vs. columnar database greatly depends on your workload. Typically, row-oriented stores are used with transactional (OLTP) workloads, while columnar stores are used with analytical (OLAP) workloads."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.a,{href:"https://blog.timescale.com/blog/building-columnar-compression-in-a-row-oriented-database",children:"https://blog.timescale.com/blog/building-columnar-compression-in-a-row-oriented-database"})}),"\n",(0,o.jsx)(a.h3,{id:"benefits-of-columnar-formats",children:"Benefits of Columnar Formats"}),"\n",(0,o.jsx)(a.h4,{id:"read-optimization",children:"READ-OPTIMIZATION"}),"\n",(0,o.jsx)(a.p,{children:"Let me pretend I want to run a SQL query against this data, for example:"}),"\n",(0,o.jsx)(a.p,{children:'SELECT COUNT(1) from people where last_name = "Rathbone"'}),"\n",(0,o.jsx)(a.p,{children:"With a regular CSV a SQL engine would have to scan every row, parse each column, extract thelast_namevalue, then count allRathbonevalues that it sees.\nIn CCSV, the SQL engine can skip past the first two fields and simply scan line 3, which contains all the last name values available."}),"\n",(0,o.jsx)(a.p,{children:"Why is that good? Well now the SQL engine is only processing around 1/6 of the data, so CCSV just delivered a (theoretical and totally unsubstantiated)600% performance improvement vs regular CSV files."}),"\n",(0,o.jsx)(a.p,{children:"Imagine the same gains against a petabyte-scale dataset. It is not hard to imagine columnar file format optimizations saving a tonne of processing power (and money) compared to regular JSON datasets. This is the core value of columnar file formats."}),"\n",(0,o.jsx)(a.p,{children:"Of course, in reality there is more work that CCSV would need to do to be a viable file format, but that is getting a little into the weeds, so I will not cover those topics here."}),"\n",(0,o.jsx)(a.h4,{id:"compression-improvements",children:"COMPRESSION IMPROVEMENTS"}),"\n",(0,o.jsx)(a.p,{children:"Storing like-data together also has advantages for compression codecs. Many compression codecs (including GZIP and Snappy) have a higher compression-ratio when compressing sequences of similar data. By storing records column-by-column, in many cases each section of column data will contain similar values - that makes it ripe for compression. In fact, each column could be compressed independently of the others to optimize this further."}),"\n",(0,o.jsxs)(a.p,{children:["The final benefit is that compression and dense-packing in columnar databases free up space - space that may be used to sort and index data within the columns. In other words, ",(0,o.jsx)(a.strong,{children:"columnar databases have higher sorting and indexing efficiency"}),", which comes more as a side benefit of having some leftover space from strong compression. It is also, in fact, mutually beneficial: researchers who study columnar databases point out that sorted data compress better than unsorted data, because sorting lowers entropy."]}),"\n",(0,o.jsx)(a.h3,{id:"negatives-of-columnar-formats",children:"Negatives of Columnar Formats"}),"\n",(0,o.jsxs)(a.p,{children:["The biggest negative of columnar formats is that re-constructing a complete record is slower and requires reading segments from each row, one-by-one. It is for this reason that columnar-file-formats initially hit their groove for analytics-style workflows, rather than Map/Reduce style workflows - which by default operate on whole rows of data at a time.\nFor real columnar file formats (like ",(0,o.jsx)(a.a,{href:"http://parquet.apache.org/",children:"Parquet"}),"), this downside is minimized by some clever tricks like breaking the file up into 'row groups' and building extensive metadata, although for particularly wide datasets (like 200+ columns), the speed impact can be fairly significant."]}),"\n",(0,o.jsx)(a.p,{children:"The other downside, is that they are more CPU and ram intensive to write, as the file writer needs to collect a whole bunch of metadata, and reorganize the rows before it can write the file."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.a,{href:"https://blog.matthewrathbone.com/2019/11/21/guide-to-columnar-file-formats.html",children:"https://blog.matthewrathbone.com/2019/11/21/guide-to-columnar-file-formats.html"})})]})}function h(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},296804:(e,a,t)=>{t.d(a,{A:()=>s});const s=t.p+"assets/images/Types-of-Databases-image1-2a8fd3e8dde2959fbc818c7a1c8e151e.jpg"},28453:(e,a,t)=>{t.d(a,{R:()=>r,x:()=>i});var s=t(296540);const o={},n=s.createContext(o);function r(e){const a=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(n.Provider,{value:a},e.children)}}}]);