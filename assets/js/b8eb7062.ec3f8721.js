"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[72021],{990125:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"algorithms/mathematics/mo-algorithm","title":"MO\'s Algorithm","description":"Query Square Root Decomposition","source":"@site/docs/algorithms/mathematics/mo-algorithm.md","sourceDirName":"algorithms/mathematics","slug":"/algorithms/mathematics/mo-algorithm","permalink":"/algorithms/mathematics/mo-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/mathematics/mo-algorithm.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1707138374000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Combinatorial Optimization","permalink":"/algorithms/mathematics/combinatorial-optimization"},"next":{"title":"Powerset","permalink":"/algorithms/mathematics/powerset"}}');var t=s(474848),o=s(28453);const i={},a="MO's Algorithm",l={},c=[{value:"Query Square Root Decomposition",id:"query-square-root-decomposition",level:2},{value:"Problem - We are given an array and a set of query ranges, we are required to find sum of every query range",id:"problem---we-are-given-an-array-and-a-set-of-query-ranges-we-are-required-to-find-sum-of-every-query-range",level:2},{value:"More",id:"more",level:2}];function m(e){const r={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"mos-algorithm",children:"MO's Algorithm"})}),"\n",(0,t.jsx)(r.h2,{id:"query-square-root-decomposition",children:"Query Square Root Decomposition"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Range Query"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Point Update"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Divide the array in sqrt(n) blocks, maintain sum or prefix-sum of each block"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Any range query can be efficiently calculated by summing all sqrt(n) blocks or part of some blocks"}),"\n",(0,t.jsx)(r.li,{children:"Any point update can be done by altering only the sum of that block only"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"image",src:s(743692).A+"",width:"750",height:"512"})}),"\n",(0,t.jsx)(r.h2,{id:"problem---we-are-given-an-array-and-a-set-of-query-ranges-we-are-required-to-find-sum-of-every-query-range",children:"Problem - We are given an array and a set of query ranges, we are required to find sum of every query range"}),"\n",(0,t.jsxs)(r.p,{children:["Naive - A",(0,t.jsx)(r.strong,{children:"Naive Solution"})," is to run a loop from L to R and calculate sum of elements in given range for every query [L, R]"]}),"\n",(0,t.jsx)(r.p,{children:"Time Complexity - O(m*n)"}),"\n",(0,t.jsxs)(r.p,{children:["The idea of",(0,t.jsx)(r.strong,{children:"MO's algorithm"}),"is to pre-process all queries so that result of one query can be used in next query. Below are steps."]}),"\n",(0,t.jsxs)(r.p,{children:["Let**a[0...n-1]",(0,t.jsx)(r.strong,{children:"be input array and"}),"q[0..m-1]**be array of queries."]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Sort all queries in a way that queries with L values from ",(0,t.jsx)(r.strong,{children:"0"})," to ",(0,t.jsx)(r.strong,{children:"\u221an -- 1"})," are put together, then all queries from ",(0,t.jsx)(r.strong,{children:"\u221an"})," to ",(0,t.jsx)(r.strong,{children:"2*\u221an -- 1"}),", and so on. All queries within a block are sorted in increasing order of R values."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Process all queries one by one in a way that every query uses sum computed in previous query."}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Let 'sum' be sum of previous query."}),"\n",(0,t.jsx)(r.li,{children:"Remove extra elements of previous query. For example if previous query is [0, 8] and current query is [3, 9], then we subtract a[0] and a[1] from sum"}),"\n",(0,t.jsx)(r.li,{children:"Add new elements of current query. In the same example as above, we add a[9] to sum."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The great thing about this algorithm is, in step 2, index variable for R change at most",(0,t.jsxs)(r.strong,{children:["O(n * \u221an)",(0,t.jsx)(r.strong,{children:"times throughout the run and same for L changes its value at most"}),"O(m * \u221an)",(0,t.jsx)(r.strong,{children:"times (See below, after the code, for details). All these bounds are possible only because sorted queries first in blocks of"}),"\u221an"]}),"size."]}),"\n",(0,t.jsx)(r.p,{children:"The preprocessing part takes O(m Log m) time."}),"\n",(0,t.jsxs)(r.p,{children:["Processing all queries takes",(0,t.jsx)(r.strong,{children:"O(n * \u221an)"}),"+",(0,t.jsx)(r.strong,{children:"O(m * \u221an)"}),"=**O((m+n) * \u221an)**time."]}),"\n",(0,t.jsx)(r.h2,{id:"more",children:"More"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://www.geeksforgeeks.org/range-minimum-query-for-static-array",children:"https://www.geeksforgeeks.org/range-minimum-query-for-static-array"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query",children:"https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://www.geeksforgeeks.org/mos-algorithm-query-square-root-decomposition-set-1-introduction",children:"https://www.geeksforgeeks.org/mos-algorithm-query-square-root-decomposition-set-1-introduction"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://cp-algorithms.com/data_structures/sqrt_decomposition.html",children:"https://cp-algorithms.com/data_structures/sqrt_decomposition.html"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction",children:"https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction"})})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},743692:(e,r,s)=>{s.d(r,{A:()=>n});const n=s.p+"assets/images/MO's-Algorithm-image1-6c2cbaa4bf3ee55969c9d7bf6461aa50.jpg"},28453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>a});var n=s(296540);const t={},o=n.createContext(t);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);