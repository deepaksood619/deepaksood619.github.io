"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[16822],{99574:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>n,metadata:()=>o,toc:()=>l});var t=r(785893),i=r(511151);const n={},a="Kafka Producers",o={id:"technologies/kafka/kafka-producers",title:"Kafka Producers",description:"The producer is the creator of the message in Kafka",source:"@site/docs/technologies/kafka/kafka-producers.md",sourceDirName:"technologies/kafka",slug:"/technologies/kafka/kafka-producers",permalink:"/technologies/kafka/kafka-producers",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/kafka-producers.md",tags:[],version:"current",lastUpdatedAt:1731947439,formattedLastUpdatedAt:"Nov 18, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Kafka Listeners",permalink:"/technologies/kafka/kafka-listeners"},next:{title:"kafka-python",permalink:"/technologies/kafka/kafka-python"}},h={},l=[{value:"Configurations",id:"configurations",level:3},{value:"Three primary methods of sending messages",id:"three-primary-methods-of-sending-messages",level:3},{value:"Fire-and-forget",id:"fire-and-forget",level:4},{value:"Synchronous send",id:"synchronous-send",level:4},{value:"Asynchronous send",id:"asynchronous-send",level:4},{value:"Serializers",id:"serializers",level:3},{value:"Avro",id:"avro",level:4},{value:"Using Avro records with Kafka",id:"using-avro-records-with-kafka",level:3},{value:"Links",id:"links",level:2}];function d(e){const s={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"kafka-producers",children:"Kafka Producers"}),"\n",(0,t.jsx)(s.p,{children:"The producer is the creator of the message in Kafka"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The producers place the message to a particular topic"}),"\n",(0,t.jsx)(s.li,{children:"The producers also decide which partition to place the message into"}),"\n",(0,t.jsx)(s.li,{children:"Topics should already exist before a message is placed by the producer"}),"\n",(0,t.jsx)(s.li,{children:"Messages are added at one end of the partition"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"image",src:r(206651).Z+"",width:"1128",height:"1248"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"We start producing messages to Kafka by creating a ProducerRecord, which must include the topic we want to send the record to and a value. Optionally, we can also specifiy a key and/or a partition. Once we send the ProducerRecord, the first thing the producer will do is serialize the key and value objects to ByteArrays so they can be send over the network."}),"\n",(0,t.jsx)(s.li,{children:"Next, the data is sent to a partitioner. If we specified a partition in the ProducerRecord, the partitioner doesn't do anything and simply returns the partition we specified. If we didn't, the partitioner will choose a partition for us, usually based on the ProducerRecord key. Once a partition is selected, the producer knows which topic and partition the record will go to. It then adds the record to a batch of records that will also be sent to the same topic and partition. A separate thread is responsible for sending those batches of records to the appropriate Kafka brokers."}),"\n",(0,t.jsx)(s.li,{children:"When the broker receives the messages, it sends back a response. If the messages were successfully written to Kafka, it will return a RecordMetadata object with the topic, partition, and the offset of the record within the partition. If the broker failed to write the messages, it will return an error. When the producer receives an error, it may retry sending the message a few more times before giving up and returning an error."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"configurations",children:"Configurations"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"bootstrap.servers"}),"\n",(0,t.jsx)(s.li,{children:"key.serializer"}),"\n",(0,t.jsx)(s.li,{children:"value.serializer"}),"\n",(0,t.jsx)(s.li,{children:"acks [0, 1 (when leader has received the message), all]"}),"\n",(0,t.jsx)(s.li,{children:"buffer.memory"}),"\n",(0,t.jsx)(s.li,{children:"compression.type"}),"\n",(0,t.jsx)(s.li,{children:"retries"}),"\n",(0,t.jsx)(s.li,{children:"batch.size"}),"\n",(0,t.jsx)(s.li,{children:"linger.ms"}),"\n",(0,t.jsx)(s.li,{children:"client.id"}),"\n",(0,t.jsx)(s.li,{children:"max.in.flight.requests.per.connection"}),"\n",(0,t.jsx)(s.li,{children:"timeout.ms, request.timeout.ms, and metadata.fetch.timeout.ms"}),"\n",(0,t.jsx)(s.li,{children:"max.block.ms"}),"\n",(0,t.jsx)(s.li,{children:"max.request.size"}),"\n",(0,t.jsx)(s.li,{children:"receive.buffer.bytes and send.buffer.bytes"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"three-primary-methods-of-sending-messages",children:"Three primary methods of sending messages"}),"\n",(0,t.jsx)(s.h4,{id:"fire-and-forget",children:"Fire-and-forget"}),"\n",(0,t.jsx)(s.p,{children:"We send a message to the server and don't really care if it arrives succesfully or not. Most of the time, it will arrive successfully, since Kafka is highly available and the producer will retry sending messages automatically. However, some mes\u2010 sages will get lost using this method"}),"\n",(0,t.jsx)(s.h4,{id:"synchronous-send",children:"Synchronous send"}),"\n",(0,t.jsx)(s.p,{children:"We send a message, the send() method returns a Future object, and we use get() to wait on the future and see if the send() was successful or not"}),"\n",(0,t.jsx)(s.h4,{id:"asynchronous-send",children:"Asynchronous send"}),"\n",(0,t.jsx)(s.p,{children:"We call the send() method with a callback function, which gets triggered when it receives a response from the Kafka broker"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.em,{children:"ProducerRecord"})}),"\n",(0,t.jsx)(s.li,{children:"Handling Errors"}),"\n",(0,t.jsx)(s.li,{children:"Configuration options"}),"\n",(0,t.jsx)(s.li,{children:"Different Partitioning Methods, partitioners"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"serializers",children:"Serializers"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Thrift"}),"\n",(0,t.jsx)(s.li,{children:"Protobuf"}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"avro",children:"Avro"}),"\n",(0,t.jsx)(s.p,{children:"One of the most interesting features of Avro, and what makes it a good fit for use in a messaging system like Kafka, is that when the application that is writing messages switches to a new schema, the application reading the data can continue processing messages without requiring any change or update."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Kafka has a binary wire protocol, so anyone can read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka's network port."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"using-avro-records-with-kafka",children:"Using Avro records with Kafka"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Unlike Avro files, where storing the entire schema in the data file is associated with a fairly reasonable overhead, storing the entire schema in each record will usually more than double the record size. However, Avro still requires the entire schema to be present when reading the record, so we need to locate the schema elsewhere. To achieve this, we follow a common architecture pattern and use a ",(0,t.jsx)(s.em,{children:"Schema Registry"}),"."]}),"\n",(0,t.jsx)(s.li,{children:"The idea is to store all the schemas used to write data to Kafka in the registry. Then we simply store the identifier for the schema in the record we produce to Kafka. The consumers can then use the identifier to pull the record out of the schema registry and deserialize the data. The key is that all this work - storing the schema in the reg\u2010 istry and pulling it up when required - is done in the serializers and deserializers. The code that produces data to Kafka simply uses the Avro serializer just like it would any other serializer."}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.img,{alt:"image",src:r(884760).Z+"",width:"996",height:"478"})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Partitions"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Keys serve two goals: they are additional information that gets stored with the message, and they are also used to decide which one of the topic partitions the message will be written to. All messages with the same key will go to the same partition."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"links",children:"Links"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"https://www.jesseyates.com/2020/01/01/high-performance-kafka-producers.html",children:"https://www.jesseyates.com/2020/01/01/high-performance-kafka-producers.html"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"https://developer.confluent.io/courses/architecture/producer-hands-on/",children:"Tutorial: How to Tune the Kafka Producer Client"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"https://developer.confluent.io/tutorials/optimize-producer-throughput/confluent.html",children:"How to optimize your Kafka producer for throughput using Confluent"})})]})}function c(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},206651:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/Technologies-Kafka-Kafka-Producers-image1-02eb8b1e5f74a0a5ccb588e986b185da.jpg"},884760:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/Technologies-Kafka-Kafka-Producers-image2-9f8d6c4dd355e55b675f3b9f8631bf3b.jpg"},511151:(e,s,r)=>{r.d(s,{Z:()=>o,a:()=>a});var t=r(667294);const i={},n=t.createContext(i);function a(e){const s=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);