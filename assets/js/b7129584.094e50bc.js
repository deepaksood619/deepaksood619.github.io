"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[32077],{982232:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"databases-nosql/redis/redis-queues","title":"Redis Queues","description":"Conceptually, a Stream in Redis is a list where you can append entries. Each entry has a unique ID and a value. The ID is auto-generated by default, and it includes a timestamp. The value is a hash. You can query ranges or use blocking commands to read entries as they come. Typical of Redis, you can combine different ingredients to get the result you need. As Niklaus Wirth once said, programs are algorithms plus data structures, and Redis already gives you a bit of both.","source":"@site/docs/databases-nosql/redis/redis-queues.md","sourceDirName":"databases-nosql/redis","slug":"/databases-nosql/redis/redis-queues","permalink":"/databases-nosql/redis/redis-queues","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/redis/redis-queues.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1756371650000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"redis-py","permalink":"/databases-nosql/redis/redis-py"},"next":{"title":"Redis Streams / PUBSUB","permalink":"/databases-nosql/redis/redis-streams-pubsub"}}');var r=t(474848),a=t(28453);const i={},o="Redis Queues",d={},l=[{value:"Message queues",id:"message-queues",level:2},{value:"Reliable queues",id:"reliable-queues",level:2},{value:"Queueing Solutions",id:"queueing-solutions",level:2},{value:"RQ",id:"rq",level:2},{value:"Application",id:"application",level:2},{value:"Scheduling jobs",id:"scheduling-jobs",level:2},{value:"Some interesting job attributes include",id:"some-interesting-job-attributes-include",level:2},{value:"get job",id:"get-job",level:3},{value:"Worker",id:"worker",level:3},{value:"Test app - https://github.com/edkrueger/rq-flask-template",id:"test-app---httpsgithubcomedkruegerrq-flask-template",level:2},{value:"Tools - RQ",id:"tools---rq",level:2},{value:"Delayed Tasks",id:"delayed-tasks",level:2},{value:"requiements.txt",id:"requiementstxt",level:3},{value:"tasks.py",id:"taskspy",level:3},{value:"tasks_runner.py",id:"tasks_runnerpy",level:3}];function u(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"redis-queues",children:"Redis Queues"})}),"\n",(0,r.jsx)(s.p,{children:"Conceptually, a Stream in Redis is a list where you can append entries. Each entry has a unique ID and a value. The ID is auto-generated by default, and it includes a timestamp. The value is a hash. You can query ranges or use blocking commands to read entries as they come. Typical of Redis, you can combine different ingredients to get the result you need. As Niklaus Wirth once said, programs are algorithms plus data structures, and Redis already gives you a bit of both.\nRedis streams are ideal for building history preserving message brokers, message queues, unified logs, and chat systems. Unlike Pub/Sub messages which are fire and forget, Redis streams preserve messages in perpetuity. Redis streams implement consumer groups, a feature that allows a group of clients to cooperate when consuming elements from a stream. For example, consumers in a group can lookup items by ID, have to acknowledge the processing of an item, or claim ownership of a pending message."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://aws.amazon.com/redis/Redis_Streams",children:"https://aws.amazon.com/redis/Redis_Streams"})}),"\n",(0,r.jsx)(s.h2,{id:"message-queues",children:"Message queues"}),"\n",(0,r.jsx)(s.p,{children:'A message queue is conceptually a list. A producer pushes an element from one side, a consumer reads from the other. Multiple producers and consumers can interact with the same queue. In Redis, a rudimentary message queue can be easily implemented with the commands LPUSH (which means "push from the left") and RPOP (which means "pop from the right"). In the best-case scenario -the happy path - the consumer pops an item, works on it, and once it\'s done, the customer is ready to consume and process the next item. A slight improvement would be to use a blocking command for reading. So instead of RPOP you could use BRPOP. If the list is empty, the consumer blocks and waits for an element to arrive. If the timeout elapses, the consumer can retry. So far, so good for this simplistic implementation. The problem, though, doesn\'t lie in the happy path. The issue is what happens when a process crashes while processing an item.'}),"\n",(0,r.jsx)(s.h2,{id:"reliable-queues",children:"Reliable queues"}),"\n",(0,r.jsx)(s.p,{children:"A queue is reliable if it can recover from a failure scenario. If a consumer crashes and the item it was processing is lost, the system is unreliable. A command was added to a previous version of Redis that is tailor-made for this exact situation. The command is BRPOPLPUSH. It not only pops an item, as discussed in the previous implementation, but it also pushes the item to another list. With the commands LPUSH and BRPOPLPUSH, you can design a reliable message queue"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://aws.amazon.com/redis/Redis_Streams_MQ",children:"https://aws.amazon.com/redis/Redis_Streams_MQ"})}),"\n",(0,r.jsx)(s.h2,{id:"queueing-solutions",children:"Queueing Solutions"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["Celery has an optional redis broker.",(0,r.jsx)(s.a,{href:"http://celeryproject.org",children:"http://celeryproject.org"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["resque is an extremely popular redis task queue using redis.",(0,r.jsx)(s.a,{href:"https://github.com/defunkt/resque",children:"https://github.com/defunkt/resque"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:['RQ is a simple and small redis based queue that aims to "take the good stuff from celery and resque" and be much simpler to work with.',(0,r.jsx)(s.a,{href:"http://python-rq.org",children:"http://python-rq.org"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"rq",children:"RQ"}),"\n",(0,r.jsx)(s.p,{children:"RQ (Redis Queue) is a simple Python library for queueing jobs and processing them in the background with workers. It is backed by Redis and it is designed to have a low barrier to entry. It should be integrated in your web stack easily.\npip install rq"}),"\n",(0,r.jsx)(s.h2,{id:"application",children:"Application"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rq.job import Job\njob = redis_queue.enqueue(some_long_function, data)\n\njob = queue.enqueue(count_words_at_url, 'http://nvie.com')\n"})}),"\n",(0,r.jsx)(s.h2,{id:"scheduling-jobs",children:"Scheduling jobs"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"# Schedule job to run at 9:15, October 10th\njob = queue.**enqueue_at**(datetime(2019, 10, 8, 9, 15), say_hello)\n\n# Schedule job to run in 10 seconds\njob = queue.**enqueue_in**(timedelta(seconds=10), say_hello)\n\n## Retrying failed jobs\nfrom rq import Retry\n\n# Retry up to 3 times, failed job will be requeued immediately\nqueue.enqueue(say_hello, retry=Retry(max=3))\n\n# Retry up to 3 times, with configurable intervals between retries\nqueue.enqueue(say_hello, retry=Retry(max=3, interval=[10, 30, 60]))\n"})}),"\n",(0,r.jsx)(s.h2,{id:"some-interesting-job-attributes-include",children:"Some interesting job attributes include"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"job.get_status()Possible values arequeued, started, deferred, finished, andfailed"}),"\n",(0,r.jsx)(s.li,{children:"job.func_name"}),"\n",(0,r.jsx)(s.li,{children:"job.argsarguments passed to the underlying job function"}),"\n",(0,r.jsx)(s.li,{children:"job.kwargskey word arguments passed to the underlying job function"}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"job.result"}),"stores the return value of the job being executed, will returnNoneprior to job execution. Results are kept according to theresult_ttlparameter (500 seconds by default)."]}),"\n",(0,r.jsx)(s.li,{children:"job.enqueued_at (job.enqueued_at.isoformat())"}),"\n",(0,r.jsx)(s.li,{children:"job.started_at (job.started_at.isoformat())"}),"\n",(0,r.jsx)(s.li,{children:"job.ended_at"}),"\n",(0,r.jsx)(s.li,{children:"job.exc_infostores exception information if job doesn't finish successfully."}),"\n",(0,r.jsx)(s.li,{children:"job.id"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"get-job",children:"get job"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"job = Job.fetch(job_id, connection=redis_conn)"})}),"\n",(0,r.jsx)(s.h3,{id:"worker",children:"Worker"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'# Sets up the redis connection and the redis queue.\nimport os\n\nimport redis\n\nfrom rq import Queue\nredis_conn = redis.Redis(\n\nhost=os.getenv("REDIS_HOST", "127.0.0.1"),\n\nport=os.getenv("REDIS_PORT", "6379"),\n\npassword=os.getenv("REDIS_PASSWORD", ""),\n\n)\nredis_queue = Queue(connection=redis_conn)\nIf you use RQ\'s scheduling features, you need to run RQ workers with the scheduler component enabled\n\nrq worker --with-scheduler\nrq worker --url redis://:a6ad92769ef04b711eea18dccfff85ea@redis:6379\nCommands\n\nkeys *\n\n1) "rq:job:61cd0099-f14e-407c-b1c0-f3ce46e5ab67"\n2) "rq:queue:default"\n3) "rq:queues"\n\ntype rq:job:61cd0099-f14e-407c-b1c0-f3ce46e5ab67\n\nhash\n\nhgetall rq:job:61cd0099-f14e-407c-b1c0-f3ce46e5ab67\ntype rq:queue:default\n\nlist\n\nlrange rq:queue:default 0 -1\ntype rq:queues\n\nset\n\nsmembers rq:queues\n\nhttps://github.com/rq/rq\n\nhttps://pypi.org/project/rq\n\nhttps://python-rq.org\n\nhttps://python-rq.org/docs\n\nhttps://python-rq.org/patterns\n\nhttps://python-rq.org/patterns/django\n\nhttps://python-rq.org/patterns/sentry\n'})}),"\n",(0,r.jsxs)(s.h2,{id:"test-app---httpsgithubcomedkruegerrq-flask-template",children:["Test app - ",(0,r.jsx)(s.a,{href:"https://github.com/edkrueger/rq-flask-template",children:"https://github.com/edkrueger/rq-flask-template"})]}),"\n",(0,r.jsx)(s.h2,{id:"tools---rq",children:"Tools - RQ"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://github.com/rq/rq-scheduler",children:"https://github.com/rq/rq-scheduler"})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://github.com/rq/rq-scheduler",children:"RQ Scheduler"})," is a small package that adds job scheduling capabilities to ",(0,r.jsx)(s.a,{href:"https://github.com/nvie/rq",children:"RQ"}),", a ",(0,r.jsx)(s.a,{href:"http://redis.io/",children:"Redis"})," based Python queuing library."]}),"\n",(0,r.jsxs)(s.ol,{start:"2",children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://github.com/Parallels/rq-dashboard",children:"https://github.com/Parallels/rq-dashboard"})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["rq-dashboardis a general purpose, lightweight, ",(0,r.jsx)(s.a,{href:"https://flask.palletsprojects.com/",children:"Flask"}),"-based web front-end to monitor your ",(0,r.jsx)(s.a,{href:"http://python-rq.org/",children:"RQ"})," queues, jobs, and workers in realtime."]}),"\n",(0,r.jsxs)(s.ol,{start:"3",children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://github.com/pranavgupta1234/rqmonitor",children:"https://github.com/pranavgupta1234/rqmonitor"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"RQ Monitor is Flask based more actionable and dynamic web frontend for monitoring your RQ."}),"\n",(0,r.jsx)(s.h2,{id:"delayed-tasks",children:"Delayed Tasks"}),"\n",(0,r.jsx)(s.p,{children:"There are a few different ways that we could potentially add delays to our queue items. Here are the three most straightforward ones:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"We could include an execution time as part of queue items, and if a worker process sees an item with an execution time later than now, it can wait for a brief period and then re-enqueue the item."}),"\n",(0,r.jsx)(s.li,{children:"The worker process could have a local waiting list for any items it has seen that need to be executed in the future, and every time it makes a pass through its while loop, it could check that list for any outstanding items that need to be executed."}),"\n",(0,r.jsxs)(s.li,{children:["Normally when we talk about times, we usually start talking about ",(0,r.jsx)(s.em,{children:"ZSETs"}),". What if, for any item we wanted to execute in the future, we added it to a ",(0,r.jsx)(s.em,{children:"ZSET"})," instead of a",(0,r.jsx)(s.em,{children:"LIST"}),", with its score being the time when we want it to execute? We then have a process that checks for items that should be executed now, and if there are any, the process removes it from the ",(0,r.jsx)(s.em,{children:"ZSET"}),", adding it to the proper ",(0,r.jsx)(s.em,{children:"LIST"}),"queue.\nWe can't wait/re-enqueue items as described in the first, because that'll waste the worker process's time. We also can't create a local waiting list as described in the second option, because if the worker process crashes for an unrelated reason, we lose any pending work items it knew about. We'll instead use a secondaryZSETas described in the third option, because it's simple, straightforward, and we can use a lock to ensure that the move is safe."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"requiementstxt",children:"requiements.txt"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"rpqueue==0.33.2"})}),"\n",(0,r.jsx)(s.h3,{id:"taskspy",children:"tasks.py"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import requests\n\nimport rpqueue\n\nfrom rpqueue import task\nrpqueue.set_redis_connection_settings('redis', '6379', 0, 'a6ad92769ef04b711eea18dccfff85ea')\n\n@task\ndef call_sms_model(cust_id):\n\n    payload = {'cust_id': cust_id}\n\n    resp = requests.get('http://decision_engine:5000/score', params=payload)\n\n    print(f'request: {cust_id}, resp status code: {resp.status_code}, text: {resp.text}')\n"})}),"\n",(0,r.jsx)(s.h3,{id:"tasks_runnerpy",children:"tasks_runner.py"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rpqueue\n\nfrom tasks import call_sms_model\nrpqueue.set_redis_connection_settings('redis', '6379', 0, 'a6ad92769ef04b711eea18dccfff85ea')\n\nrpqueue.execute_tasks(queues=None, threads_per_process=1, processes=1, wait_per_thread=1, module='tasks')\n\n# python -m rpqueue.run --module=tasks --host=redis --port=6379 --db=0 --password=a6ad92769ef04b711eea18dccfff85ea\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks",children:"https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://github.com/josiahcarlson/rpqueue",children:"https://github.com/josiahcarlson/rpqueue"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://josiahcarlson.github.io/rpqueue",children:"https://josiahcarlson.github.io/rpqueue"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://github.com/Parallels/rq-dashboard",children:"https://github.com/Parallels/rq-dashboard"})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>o});var n=t(296540);const r={},a=n.createContext(r);function i(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);