"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[44478],{553805:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"data-warehouses/clickhouse/mergetree-engine-family","title":"MergeTree Engine Family","description":"Table engines from the MergeTree family are the core of ClickHouse data storage capabilities. They provide most features for resilience and high-performance data retrieval: columnar storage, custom partitioning, sparse primary index, secondary data-skipping indexes, etc.","source":"@site/docs/data-warehouses/clickhouse/mergetree-engine-family.md","sourceDirName":"data-warehouses/clickhouse","slug":"/data-warehouses/clickhouse/mergetree-engine-family","permalink":"/data-warehouses/clickhouse/mergetree-engine-family","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-warehouses/clickhouse/mergetree-engine-family.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749575438000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Memory Engine","permalink":"/data-warehouses/clickhouse/memory-engine"},"next":{"title":"Queries","permalink":"/data-warehouses/clickhouse/queries"}}');var s=t(474848),n=t(28453);const a={},c="MergeTree Engine Family",o={},l=[];function d(e){const r={a:"a",code:"code",h1:"h1",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"mergetree-engine-family",children:"MergeTree Engine Family"})}),"\n",(0,s.jsx)(r.p,{children:"Table engines from the MergeTree family are the core of ClickHouse data storage capabilities. They provide most features for resilience and high-performance data retrieval: columnar storage, custom partitioning, sparse primary index, secondary data-skipping indexes, etc."}),"\n",(0,s.jsxs)(r.p,{children:["Base\xa0",(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"MergeTree"}),"\xa0table engine can be considered the default table engine for single-node ClickHouse instances because it is versatile and practical for a wide range of use cases."]}),"\n",(0,s.jsxs)(r.p,{children:["For production usage\xa0",(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication",children:"ReplicatedMergeTree"}),"\xa0is the way to go, because it adds high-availability to all features of regular MergeTree engine. A bonus is automatic data deduplication on data ingestion, so the software can safely retry if there was some network issue during insert."]}),"\n",(0,s.jsx)(r.p,{children:"All other engines of MergeTree family add extra functionality for some specific use cases. Usually, it's implemented as additional data manipulation in background."}),"\n",(0,s.jsxs)(r.p,{children:["The main downside of MergeTree engines is that they are rather heavy-weight. So the typical pattern is to have not so many of them. If you need many small tables, for example for temporary data, consider\xa0",(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/log-family",children:"Log engine family"}),"."]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Page"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/aggregatingmergetree",children:"AggregatingMergeTree"})}),(0,s.jsxs)(r.td,{children:["Replaces all rows with the same primary key (or more accurately, with the same\xa0",(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"sorting key"}),") with a single row (within a single data part) that stores a combination of states of aggregate functions."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/annindexes",children:"Exact and Approximate Nearest Neighbor Search"})}),(0,s.jsx)(r.td,{children:"Documentation for Exact and Approximate Nearest Neighbor Search"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/collapsingmergetree",children:"CollapsingMergeTree"})}),(0,s.jsx)(r.td,{children:"Inherits from MergeTree but adds logic for collapsing rows during the merge process."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/custom-partitioning-key",children:"Custom Partitioning Key"})}),(0,s.jsx)(r.td,{children:"Learn how to add a custom partitioning key to MergeTree tables."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/graphitemergetree",children:"GraphiteMergeTree"})}),(0,s.jsx)(r.td,{children:"Designed for thinning and aggregating/averaging (rollup) Graphite data."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/invertedindexes",children:"Full-text Search using Full-text Indexes"})}),(0,s.jsx)(r.td,{children:"Quickly find search terms in text."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"MergeTree"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"MergeTree"}),"-family table engines are designed for high data ingest rates and huge data volumes."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replacingmergetree",children:"ReplacingMergeTree"})}),(0,s.jsxs)(r.td,{children:["differs from MergeTree in that it removes duplicate entries with the same sorting key value (",(0,s.jsx)(r.code,{children:"ORDER BY"}),"\xa0table section, not\xa0",(0,s.jsx)(r.code,{children:"PRIMARY KEY"}),")."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication",children:"Data Replication"})}),(0,s.jsx)(r.td,{children:"Overview of Data Replication in ClickHouse"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/summingmergetree",children:"SummingMergeTree"})}),(0,s.jsx)(r.td,{children:"SummingMergeTree inherits from the MergeTree engine. Its key feature is the ability to automatically sum numeric data during part merges."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/versionedcollapsingmergetree",children:"VersionedCollapsingMergeTree"})}),(0,s.jsx)(r.td,{children:"Allows for quick writing of object states that are continually changing, and deleting old object states in the background."})]})]})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family",children:"MergeTree Engine Family | ClickHouse Docs"})})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>c});var i=t(296540);const s={},n=i.createContext(s);function a(e){const r=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(n.Provider,{value:r},e.children)}}}]);