"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[13678],{663514:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"languages/sql/join-algorithms","title":"Join Algorithms","description":"nested loop join","source":"@site/docs/languages/sql/join-algorithms.md","sourceDirName":"languages/sql","slug":"/languages/sql/join-algorithms","permalink":"/languages/sql/join-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/sql/join-algorithms.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1739572825000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/languages/sql/intro"},"next":{"title":"Keys","permalink":"/languages/sql/keys"}}');var o=n(474848),r=n(28453);const s={},a="Join Algorithms",h={},l=[{value:"nested loop join",id:"nested-loop-join",level:3},{value:"sort-merge join",id:"sort-merge-join",level:3},{value:"Interesting order",id:"interesting-order",level:4},{value:"hash join",id:"hash-join",level:3},{value:"Hash Join vs Merge Join",id:"hash-join-vs-merge-join",level:3},{value:"Hash joins",id:"hash-joins",level:4},{value:"Merge joins",id:"merge-joins",level:4},{value:"Left Anti Semi Join",id:"left-anti-semi-join",level:3},{value:"Others",id:"others",level:2},{value:"Links",id:"links",level:2}];function d(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"join-algorithms",children:"Join Algorithms"})}),"\n",(0,o.jsx)(i.h3,{id:"nested-loop-join",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Nested_loop_join",children:"nested loop join"})}),"\n",(0,o.jsxs)(i.p,{children:["A nested loop join is a naive ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Algorithm",children:"algorithm"})," that joins two sets by using two nested ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Loop_(computing)",children:"loops"})]}),"\n",(0,o.jsx)(i.p,{children:"For each value in the first data set. SQL Server loops through the second data set looking for matches"}),"\n",(0,o.jsx)(i.h3,{id:"sort-merge-join",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Sort-merge_join",children:"sort-merge join"})}),"\n",(0,o.jsxs)(i.p,{children:["The basic problem of a join algorithm is to find, for each distinct value of the join attribute, the set of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tuple",children:"tuples"})," in each relation which display that value. The key idea of the sort-merge algorithm is to first sort the relations by the join attribute, so that interleaved linear scans will encounter these sets at the same time."]}),"\n",(0,o.jsxs)(i.p,{children:["In practice, the most expensive part of performing a sort-merge join is arranging for both inputs to the algorithm to be presented in sorted order. This can be achieved via an explicit sort operation (often an ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/External_sort",children:"external sort"}),"), or by taking advantage of a pre-existing ordering in one or both of the join relations. The latter condition, called interesting order, can occur because an input to the join might be produced by an index scan of a tree-based index, another merge join, or some other plan operator that happens to produce output sorted on an appropriate key. Interesting orders need not be serendipitous: the optimizer may seek out this possibility and choose a plan that is suboptimal for a specific preceding operation if it yields an interesting order that one or more downstream nodes can exploit."]}),"\n",(0,o.jsx)(i.p,{children:"Used to join two data sets that are already sorted using the same key. A row from each source is obtained. If the rows match they are joined. If the rows do not match the lower vaue row is discarded and a new row is obtained from that source"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Sort-merge_join",children:"https://en.wikipedia.org/wiki/Sort-merge_join"})}),"\n",(0,o.jsx)(i.h4,{id:"interesting-order",children:"Interesting order"}),"\n",(0,o.jsx)(i.p,{children:"An interesting order in a sort-merge join occurs when the inputs to the join are produced by:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"An index scan of a tree-based index"}),"\n",(0,o.jsx)(i.li,{children:"Another merge join"}),"\n",(0,o.jsx)(i.li,{children:"Some other plan operator that produces output sorted on an appropriate key"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"A sort-merge join is a common join algorithm in database systems that uses sorting. It's particularly efficient for large datasets that can't fit in memory. The algorithm works by:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Sorting both relations on the join attribute"}),"\n",(0,o.jsx)(i.li,{children:"Merging the sorted relations by scanning them sequentially"}),"\n",(0,o.jsx)(i.li,{children:"Looking for qualifying tuples"}),"\n",(0,o.jsx)(i.li,{children:"Dividing the data into smaller chunks"}),"\n",(0,o.jsx)(i.li,{children:"Sorting them independently"}),"\n",(0,o.jsx)(i.li,{children:"Merging them in a distributed manner"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"An operator has a flexible order requirement if it has more than one interesting sort order. For example, the merge-join operator has a flexible order requirement because every permutation of the join attributes is an interesting sort order."}),"\n",(0,o.jsx)(i.h3,{id:"hash-join",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hash_join",children:"hash join"})}),"\n",(0,o.jsx)(i.p,{children:"Hash joins are typically more efficient than nested loops joins, except when the probe side of the join is very small. However, hash joins can only be used to compute equijoins."}),"\n",(0,o.jsxs)(i.p,{children:["The task of a join algorithm is to find, for each distinct value of the join attribute, the set of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tuple#Relational_model",children:"tuples"})," in each relation which have that value."]}),"\n",(0,o.jsxs)(i.p,{children:["Hash joins require an ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Equijoin",children:"equijoin"})," predicate (a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Syntactic_predicate",children:"predicate"})," comparing records from one table with those from the other table using a conjunction of equality operators '=' on one or more columns)."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Classic hash join"}),"\n",(0,o.jsx)(i.li,{children:"Grace hash join"}),"\n",(0,o.jsx)(i.li,{children:"Hybrid hash join"}),"\n",(0,o.jsx)(i.li,{children:"Hash anti-join"}),"\n",(0,o.jsx)(i.li,{children:"Hash semi-join"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"A hashtable of the smaller data set is created, then SQL Server loops through the larger data set probing the hashtable for matching values. Used when two large data sets must be joined"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hash_join",children:"https://en.wikipedia.org/wiki/Hash_join"})}),"\n",(0,o.jsx)(i.h3,{id:"hash-join-vs-merge-join",children:"Hash Join vs Merge Join"}),"\n",(0,o.jsx)(i.p,{children:"Hash joins are more efficient for large tables, while merge joins are better for joining sorted tables."}),"\n",(0,o.jsx)(i.h4,{id:"hash-joins",children:"Hash joins"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Can only be used for equi-joins"}),"\n",(0,o.jsx)(i.li,{children:"Are better for joining large amounts of data in an equi-join"}),"\n",(0,o.jsx)(i.li,{children:"Generally perform better than sort merge joins"}),"\n",(0,o.jsx)(i.li,{children:"Use a hash table to join equi joins"}),"\n",(0,o.jsxs)(i.li,{children:["Can cause an overflow condition in the hash table if:","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"The hash index is greater than the main memory"}),"\n",(0,o.jsx)(i.li,{children:"There are multiple tuples with the same join attribute values"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.h4,{id:"merge-joins",children:"Merge joins"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Are faster and use less memory than hash joins"}),"\n",(0,o.jsx)(i.li,{children:"Are more flexible than hash joins"}),"\n",(0,o.jsx)(i.li,{children:"Are used to join sorted tables"}),"\n",(0,o.jsx)(i.li,{children:"Are best for joining large and sorted and non-indexed inputs"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"The PostgreSQL query planner automatically chooses the most appropriate join algorithm based on the query conditions and table statistics."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://www.geeksforgeeks.org/difference-between-hash-join-and-sort-merge-join/",children:"Difference between Hash Join and Sort Merge Join - GeeksforGeeks"})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://www.vertica.com/docs/9.3.x/HTML/Content/Authoring/AnalyzingData/Optimizations/HashJoinsVs.MergeJoins.htm",children:"Hash Joins Versus Merge Joins"})}),"\n",(0,o.jsx)(i.h3,{id:"left-anti-semi-join",children:"Left Anti Semi Join"}),"\n",(0,o.jsxs)(i.p,{children:["Left Anti Semi Join is the opposite of a ",(0,o.jsx)(i.a,{href:"http://sqlity.net/en/1348/a-join-a-day-the-left-semi-join/",children:"Left Semi Join"}),". However, that does not make it a ",(0,o.jsx)(i.a,{href:"http://sqlity.net/en/1354/a-join-a-day-the-right-semi-join/",children:"right semi join"}),'. Instead "Anti" affects which rows are returned and which aren\'t. Like the Left Semi Join, the Left Anti Semi Join returns only rows from the left row source. Each row is also returned at most once. And duplicates are also not eliminated. However, other than the Left Semi Join, the Left Anti Semi Join returns only rows for which no match on the right side exists.']}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://sqlity.net/en/1360/a-join-a-day-the-left-anti-semi-join/",children:"A Join A Day - The Left Anti Semi Join - sqlity.net"})}),"\n",(0,o.jsx)(i.h2,{id:"others",children:"Others"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Left Anti Join - ",(0,o.jsx)(i.a,{href:"https://learn.microsoft.com/en-us/power-query/merge-queries-left-anti",children:"Left anti join - Power Query"})]}),"\n",(0,o.jsxs)(i.li,{children:["Right Anti Join - ",(0,o.jsx)(i.a,{href:"https://learn.microsoft.com/en-us/power-query/merge-queries-right-anti",children:"Right anti join - Power Query"})]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://www.sqlshack.com/internals-of-physical-join-operators-nested-loops-join-hash-match-join-merge-join-in-sql-server/",children:"Internals of Physical Join Operators (Nested Loops Join, Hash Match Join & Merge Join) in SQL Server"})})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>a});var t=n(296540);const o={},r=t.createContext(o);function s(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);