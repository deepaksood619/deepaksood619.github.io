"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[4502],{399250:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"technologies/git/branching-strategies","title":"Branching Strategies","description":"Note: Up until the first public release of a product, it absolutely makes sense to commit all changes directly to the main branch - even if you are a Git flow advocate - for the sake of the speed and simplicity of the development workflow. Since there\'s no production yet, there\'s no possibility of a production bug that the team needs to fix ASAP. Doing all the branching magic that classic Git flow implies is therefore overkill at this stage","source":"@site/docs/technologies/git/branching-strategies.md","sourceDirName":"technologies/git","slug":"/technologies/git/branching-strategies","permalink":"/technologies/git/branching-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/git/branching-strategies.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1746073436000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Git","permalink":"/technologies/git/"},"next":{"title":"Commands","permalink":"/technologies/git/commands"}}');var i=n(474848),o=n(28453);const s={},a="Branching Strategies",h={},l=[{value:"Github Flow",id:"github-flow",level:2},{value:"Git Flow and Trunk Based development",id:"git-flow-and-trunk-based-development",level:2},{value:"Trunk based development",id:"trunk-based-development",level:2},{value:"Git Flow - feature branches (can cause long running branches which can be hard to merge)",id:"git-flow---feature-branches-can-cause-long-running-branches-which-can-be-hard-to-merge",level:2},{value:"Feature Branches",id:"feature-branches",level:2},{value:"Release Branches",id:"release-branches",level:2},{value:"Hotfix Branches",id:"hotfix-branches",level:2},{value:"Enhanced Git Flow",id:"enhanced-git-flow",level:2},{value:"The Forking WorkFlow",id:"the-forking-workflow",level:2},{value:"Tips",id:"tips",level:2},{value:"Workflow: Topic Branches",id:"workflow-topic-branches",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"branching-strategies",children:"Branching Strategies"})}),"\n",(0,i.jsx)(t.p,{children:"Note: Up until the first public release of a product, it absolutely makes sense to commit all changes directly to the main branch - even if you are a Git flow advocate - for the sake of the speed and simplicity of the development workflow. Since there's no production yet, there's no possibility of a production bug that the team needs to fix ASAP. Doing all the branching magic that classic Git flow implies is therefore overkill at this stage"}),"\n",(0,i.jsx)(t.p,{children:"Everything in dev can be merged to master (if it can't it's a good candidate to break the repository)"}),"\n",(0,i.jsx)(t.h2,{id:"github-flow",children:"Github Flow"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Code in master is deployable at all times."}),"\n",(0,i.jsx)(t.li,{children:"When you want to start working on a new task, create a new branch off of master and give it a descriptive name."}),"\n",(0,i.jsx)(t.li,{children:"Commit to that branch locally and regularly send your work to the same-named branch on the server."}),"\n",(0,i.jsx)(t.li,{children:"Open a pull request when you feel your changes are ready to be merged (or even if you aren't so sure, but would like some feedback)."}),"\n",(0,i.jsx)(t.li,{children:"After the new feature is revised and approved, you can merge it into master."}),"\n",(0,i.jsx)(t.li,{children:"Once your changes are merged and pushed to the master, you can and should deploy immediately."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"git-flow-and-trunk-based-development",children:"Git Flow and Trunk Based development"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.toptal.com/software/trunk-based-development-git-flow",children:"https://www.toptal.com/software/trunk-based-development-git-flow"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://martinfowler.com/articles/branching-patterns.html",children:"https://martinfowler.com/articles/branching-patterns.html"})}),"\n",(0,i.jsx)(t.h2,{id:"trunk-based-development",children:"Trunk based development"}),"\n",(0,i.jsx)(t.p,{children:"only a single branch (called trunk) everyone commits to it. Making sure they commit at least once in 24 hours. (Trunk means main development branch)"}),"\n",(0,i.jsx)(t.p,{children:"A source-control branching model, where developers collaborate on code in a single branch called 'trunk' *, resist any pressure to create other long-lived development branches by employing documented techniques. They therefore avoid merge hell, do not break the build, and live happily ever after."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(498806).A+"",width:"712",height:"183"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(369153).A+"",width:"726",height:"366"})}),"\n",(0,i.jsx)(t.h2,{id:"git-flow---feature-branches-can-cause-long-running-branches-which-can-be-hard-to-merge",children:"Git Flow - feature branches (can cause long running branches which can be hard to merge)"}),"\n",(0,i.jsxs)(t.p,{children:["GitHub flow, is supposed to be a very lightweight branching strategy for Git. You can't say the same about GitFlow. It lies on the opposite end of the spectrum, being a more ",(0,i.jsx)(t.strong,{children:"heavy-weight process"}),". So, how does GitFlow work?"]}),"\n",(0,i.jsxs)(t.p,{children:["In short, ",(0,i.jsx)(t.strong,{children:"GitFlow relies on two long-lived branches and some short-lived ones"}),'. The permanent ones are good old master and the new kid on the block, "development." The state of "master" should always be pristine; it reflects the last "good," stable version that\'s in production.']}),"\n",(0,i.jsx)(t.p,{children:'"Development," on the other hand, is always potentially unstable. This is the branch where, well, development happens. And how does it happen? By the use of the supporting branches, which can fall into one of the three following categories:'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Feature branches"}),"\n",(0,i.jsx)(t.li,{children:"Release branches"}),"\n",(0,i.jsx)(t.li,{children:"Hotfix branches"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"feature-branches",children:"Feature Branches"}),"\n",(0,i.jsx)(t.p,{children:'Feature branches are the ones developers create to work on new features. They should always branch off "development." After the feature is complete, the developer should merge the feature back to master.'}),"\n",(0,i.jsx)(t.p,{children:"The next type of supporting branch is the release branch."}),"\n",(0,i.jsx)(t.h2,{id:"release-branches",children:"Release Branches"}),"\n",(0,i.jsx)(t.p,{children:"These branches allow forpreparation of a new release. And besides that, they enable the developer to perform minor bug fixes and to prepare metadata for the release. Since this work is being done in a separate branch, the development branch is free to receive features intended for the next release."}),"\n",(0,i.jsx)(t.p,{children:"When the release branch gets stable enough to become a release, it should be merged into master. Then, the commit on master should be tagged, with the correct version numbers, so it can be easily accessed in the future."}),"\n",(0,i.jsx)(t.p,{children:"Finally, it's time to cover hotfix branches."}),"\n",(0,i.jsx)(t.h2,{id:"hotfix-branches",children:"Hotfix Branches"}),"\n",(0,i.jsx)(t.p,{children:"Hotfix branches are also meant to prepare for a release in production. The difference, though, is that this time the release wasn't planned. Instead, it's due to necessity: a critical bug in production that must be dealt with swiftly."}),"\n",(0,i.jsx)(t.p,{children:"The idea is that work on new features can continue as usual while, at the same time, someone is preparing a fix for the critical production problem."}),"\n",(0,i.jsx)(t.p,{children:"Hotfix branches should be created from master since that branch reflects the last desirable state of the application in production. While the fix is done and ready to go, the branch should be merged to master. But don't just merge it to master: it's also vital that it's merged to \"develop\" because the feature releases will need those corrections as well."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"image",src:n(691108).A+"",width:"1000",height:"1325"})}),"\n",(0,i.jsx)(t.h2,{id:"enhanced-git-flow",children:"Enhanced Git Flow"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Master or single flow problems"})}),"\n",(0,i.jsx)(t.p,{children:"If there's a critical bug in production that needs to be fixed immediately, it would be a major disaster for the development team to have to roll back all the work accrued in the main branch thus far just to deploy the fix. And deploying code without proper testing-whether the code is considered half-baked or well-developed-is clearly not an option."}),"\n",(0,i.jsxs)(t.p,{children:["That's where branching models shine, including Git flow. Any sophisticated branching model should answer questions regarding how to ",(0,i.jsx)(t.strong,{children:"isolate"})," the next release from the version of the system currently used by people, how to ",(0,i.jsx)(t.strong,{children:"update"})," that version with the next release, and how to",(0,i.jsx)(t.strong,{children:"introduce hotfixes"})," of any critical bugs to the current version."]}),"\n",(0,i.jsx)(t.p,{children:'The Git flow process addresses these fundamental scenarios by separating "main" (the production or "current version" branch) and "develop" (the development or "next release" branch) and providing all the rules about using feature/release/hotfix branches. It effectively solves a lot of headaches from the development workflows of release-based products.'}),"\n",(0,i.jsx)(t.p,{children:"But even with projects well-suited to the classic Git flow model, I've suffered the typical problems it can bring:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Git flow is complex, with two long-lived branches, three types of temporary branches, and strict rules on how branches deal with each other. Such complexity makes mistakes more likely and increases the effort required to fix them."}),"\n",(0,i.jsx)(t.li,{children:'Release and hotfix branches require "double merging"-once into main, then into develop. At times you can forget to do both. You can make Git flow branching easier with scripts or VCS GUI client plugins, but you have to set them up first for every machine of every developer involved in a given project.'}),"\n",(0,i.jsx)(t.li,{children:"In CI/CD workflows, you usually end up with two final builds for a release - one from the latest commit of the release branch itself and another one from the merge commit to main. Strictly speaking, you should use the one from the main, but the two are usually identical, creating the potential for confusion."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.toptal.com/gitflow/enhanced-git-flow-explained",children:"https://www.toptal.com/gitflow/enhanced-git-flow-explained"})}),"\n",(0,i.jsx)(t.h2,{id:"the-forking-workflow",children:"The Forking WorkFlow"}),"\n",(0,i.jsx)(t.p,{children:"Under the forking workflow, each developer has two Git repositories: a local one and a server-side one. If you're used to contributing to open-source software projects, you're probably aware of this branching strategy."}),"\n",(0,i.jsx)(t.p,{children:"The forking workflow presents the benefit that developers' contributions can be integrated without the need for a single central repository. Developers can push to their own server-side repositories. The project maintainer can then push to the official repository That way, the maintainer can accept commits from any developer but doesn't have to grant them write access to the official repository."}),"\n",(0,i.jsx)(t.p,{children:'To start working under the forking workflow, a developer would typically fork the "true" repository in order to create a copy of it on the server. This copy serves as their personal public repository - no one can push to it, but they can pull changes from it. After their server-side copy is created, the developer can then perform "Git clone" to get a local copy of their online copy of the original repository.'}),"\n",(0,i.jsx)(t.p,{children:"When developers want to publish a local commit, they push the commit to their ownrepository instead of the official/original one. Then, they submit a pull request to the repository, which lets the project maintainer know that an update is coming their way. The pull request can also serve as discussion thread if there are problems with the contributed code."}),"\n",(0,i.jsx)(t.h2,{id:"tips",children:"Tips"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Start as simple as possible. Advance to more sophisticated approaches when the need emerges, but not before that."}),"\n",(0,i.jsx)(t.li,{children:'Consider picking a strategy that reduces the different "types" of branches available for developers to choose from.'}),"\n",(0,i.jsxs)(t.li,{children:["Consider using ",(0,i.jsx)(t.a,{href:"https://rollout.io/blog/the-future-of-feature-flags-lies-in-infrastructure-as-code/",children:"feature flagging"}),", which can also reduce some of the need people have for excessive branching."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"workflow-topic-branches",children:"Workflow: Topic Branches"}),"\n",(0,i.jsx)(t.p,{children:"A topic branch is a branch that we create and use for work on a feature."}),"\n",(0,i.jsx)(t.p,{children:"Ex -"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'git checkout -b iss14\n# checkout as a new branch "iss14"\n\n# fix the issue\n\n# after fixing the issue\ngit checkout master\ngit merge iss14\n\n# merge the fix\n\n# delete the branch\ngit branch -d iss14\n'})}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://nvie.com/posts/a-successful-git-branching-model",children:"https://nvie.com/posts/a-successful-git-branching-model"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://jeffkreeftmeijer.com/git-flow",children:"https://jeffkreeftmeijer.com/git-flow"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://github.com/nvie/gitflow",children:"https://github.com/nvie/gitflow"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://github.com/danielkummer/git-flow-cheatsheet",children:"https://github.com/danielkummer/git-flow-cheatsheet"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://danielkummer.github.io/git-flow-cheatsheet",children:"https://danielkummer.github.io/git-flow-cheatsheet"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://rollout.io/blog/branching-strategy/",children:(0,i.jsx)(t.strong,{children:"https://rollout.io/blog/branching-strategy/"})})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},498806:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/Technologies-Git-Branching-Strategies-image1-28f657667bb435b6b1e5ead58133d0e8.jpg"},369153:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/Technologies-Git-Branching-Strategies-image2-7a5a80511db9e960dd21cefb2026e6ff.jpg"},691108:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/Technologies-Git-Branching-Strategies-image3-4623ab56bb1abc000c93c28cb4ab2b2c.jpg"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(296540);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);