"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[24920],{278108:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"devops/kubernetes/tools-scaling","title":"Kubernetes Scaling Tools","description":"Kubernetes Autoscaler","source":"@site/docs/devops/kubernetes/tools-scaling.md","sourceDirName":"devops/kubernetes","slug":"/devops/kubernetes/tools-scaling","permalink":"/devops/kubernetes/tools-scaling","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/kubernetes/tools-scaling.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1721845143000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Tasks","permalink":"/devops/kubernetes/tasks"},"next":{"title":"Serverless Tools","permalink":"/devops/kubernetes/tools-serverless"}}');var n=s(474848),a=s(28453);const o={},l="Kubernetes Scaling Tools",i={},c=[{value:"Kubernetes Autoscaler",id:"kubernetes-autoscaler",level:2},{value:"Vertical Pod Autoscaler / VPA",id:"vertical-pod-autoscaler--vpa",level:2},{value:"Goldilocks",id:"goldilocks",level:2},{value:"Karpenter",id:"karpenter",level:2},{value:"Others",id:"others",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"kubernetes-scaling-tools",children:"Kubernetes Scaling Tools"})}),"\n",(0,n.jsx)(t.h2,{id:"kubernetes-autoscaler",children:"Kubernetes Autoscaler"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler",children:"Cluster Autoscaler"}),"- a component that automatically adjusts the size of a Kubernetes Cluster so that all pods have a place to run and there are no unneeded nodes. Works with GCP, AWS and Azure. Version 1.0 (GA) was released with kubernetes 1.8."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler",children:"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/helm/charts/tree/master/stable/cluster-autoscaler",children:"https://github.com/helm/charts/tree/master/stable/cluster-autoscaler"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler",children:"GitHub - kubernetes/autoscaler: Autoscaling components for Kubernetes"})}),"\n",(0,n.jsxs)(t.h2,{id:"vertical-pod-autoscaler--vpa",children:[(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler",children:"Vertical Pod Autoscaler"})," / VPA"]}),"\n",(0,n.jsx)(t.p,{children:"A set of components that automatically adjust the amount of CPU and memory requested by pods running in the Kubernetes Cluster. Current state - beta"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler",children:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://medium.com/infrastructure-adventures/vertical-pod-autoscaler-deep-dive-limitations-and-real-world-examples-9195f8422724",children:"https://medium.com/infrastructure-adventures/vertical-pod-autoscaler-deep-dive-limitations-and-real-world-examples-9195f8422724"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://povilasv.me/vertical-pod-autoscaling-the-definitive-guide/",children:"https://povilasv.me/vertical-pod-autoscaling-the-definitive-guide/#"})}),"\n",(0,n.jsx)(t.h2,{id:"goldilocks",children:"Goldilocks"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/FairwindsOps/goldilocks",children:"https://github.com/FairwindsOps/goldilocks"})}),"\n",(0,n.jsx)(t.p,{children:"Goldilocks is a utility that can help you identify a starting point for resource requests and limits."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://goldilocks.docs.fairwinds.com/",children:"goldilocks Documentation"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler/tree/master/addon-resizer",children:"Addon Resizer"}),"- a simplified version of vertical pod autoscaler that modifies resource requests of a deployment based on the number of nodes in the Kubernetes Cluster. Current state - beta."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/kubernetes/autoscaler",children:"https://github.com/kubernetes/autoscaler"})}),"\n",(0,n.jsx)(t.h2,{id:"karpenter",children:(0,n.jsx)(t.a,{href:"https://karpenter.sh/",children:"Karpenter"})}),"\n",(0,n.jsx)(t.p,{children:"Just-in-time Nodes for Any Kubernetes Cluster"}),"\n",(0,n.jsx)(t.p,{children:"Karpenter automatically launches just the right compute resources to handle your cluster's applications. It is designed to let you take full advantage of the cloud with fast and simple compute provisioning for Kubernetes clusters."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Watching"}),"\xa0for pods that the Kubernetes scheduler has marked as unschedulable"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Evaluating"}),"\xa0scheduling constraints (resource requests, nodeselectors, affinities, tolerations, and topology spread constraints) requested by the pods"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Provisioning"}),"\xa0nodes that meet the requirements of the pods"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Removing"}),"\xa0the nodes when the nodes are no longer needed"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/aws/karpenter-provider-aws",children:"GitHub - aws/karpenter-provider-aws: Karpenter is a Kubernetes Node Autoscaler built for flexibility, performance, and simplicity."})}),"\n",(0,n.jsx)(t.h2,{id:"others",children:"Others"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/devops/kubernetes/keda",children:"Keda"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>l});var r=s(296540);const n={},a=r.createContext(n);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);