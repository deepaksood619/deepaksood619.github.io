"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[98784],{407518:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=r(785893),i=r(511151);const a={},n="LSM (Log Structured Merge Trees)",o={id:"data-structures/others/lsm-log-structured-merge-trees",title:"LSM (Log Structured Merge Trees)",description:"In computer science, the log-structured merge-tree (or LSM tree) is a data structure with performance characteristics that make it attractive for providing indexed access to files with high insert volume, such as transactional log data. LSM trees, like other search trees, maintain key-value pairs. LSM trees maintain data in two or more separate structures, each of which is optimized for its respective underlying storage medium; data is synchronized between the two structures efficiently, in batches.",source:"@site/docs/data-structures/others/lsm-log-structured-merge-trees.md",sourceDirName:"data-structures/others",slug:"/data-structures/others/lsm-log-structured-merge-trees",permalink:"/data-structures/others/lsm-log-structured-merge-trees",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/others/lsm-log-structured-merge-trees.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Large Objects",permalink:"/data-structures/others/large-objects"},next:{title:"SSTables, Sorted String Tables",permalink:"/data-structures/others/sstables-sorted-string-tables"}},d={},l=[{value:"Time complexity in big O notation",id:"time-complexity-in-big-o-notation",level:3},{value:"Anatomy",id:"anatomy",level:2},{value:"Summary",id:"summary",level:2},{value:"Closing Words",id:"closing-words",level:2},{value:"LMS Trees (Copy on Write B-Trees)",id:"lms-trees-copy-on-write-b-trees",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"lsm-log-structured-merge-trees",children:"LSM (Log Structured Merge Trees)"}),"\n",(0,s.jsxs)(t.p,{children:["In ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"}),", the log-structured merge-tree (or LSM tree) is a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Data_structure",children:"data structure"})," with performance characteristics that make it attractive for providing ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Database_index",children:"indexed"})," access to files with high insert volume, such as ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Transaction_log",children:"transactional log data"}),". LSM trees, like other ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Search_tree",children:"search trees"}),", maintain key-value pairs. LSM trees maintain data in two or more separate structures, each of which is optimized for its respective underlying storage medium; data is synchronized between the two structures efficiently, in batches."]}),"\n",(0,s.jsxs)(t.p,{children:["One simple version of the LSM tree is a two-level LSM tree. As described by ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Patrick_O%27Neil",children:"Patrick O'Neil"}),", a two-level LSM tree comprises two ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tree_(data_structure)",children:"tree-like"})," structures, called C0and C1. C0 is smaller and entirely resident in memory, whereas C1 is resident on disk. New records are inserted into the memory-resident C0 component. If the insertion causes the C0 component to exceed a certain size threshold, a contiguous segment of entries is removed from C0 and merged into C1 on disk. The performance characteristics of LSM trees stem from the fact that each component is tuned to the characteristics of its underlying storage medium, and that data is efficiently migrated across media in rolling batches, using an algorithm reminiscent of ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Merge_sort",children:"merge sort"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Most LSM trees used in practice employ multiple levels. Level 0 is kept in main memory, and might be represented using a tree. The on-disk data is organized into sorted runs of data. Each run contains data sorted by the index key. A run can be represented on disk as a single file, or alternatively as a collection of files with non-overlapping key ranges. To perform a query on a particular key to get its associated value, one must search in the Level 0 tree and each run."}),"\n",(0,s.jsxs)(t.p,{children:["A particular key may appear in several runs, and what that means for a query depends on the application. Some applications simply want the newest key-value pair with a given key. Some applications must combine the values in some way to get the proper aggregate value to return. For example, in ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Apache_Cassandra",children:"Apache Cassandra"}),", each value represents a row in a database, and different versions of the row may have different sets of columns."]}),"\n",(0,s.jsx)(t.p,{children:"In order to keep down the cost of queries, the system must avoid a situation where there are too many runs."}),"\n",(0,s.jsxs)(t.p,{children:["Extensions to the 'leveled' method to incorporate ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/B%2B_tree",children:"B+ tree"})," structures have been suggested, for example bLSMand Diff-Index."]}),"\n",(0,s.jsxs)(t.p,{children:["LSM trees are used in data stores such as ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bigtable",children:"Bigtable"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/HBase",children:"HBase"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/LevelDB",children:"LevelDB"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/SQLite4",children:"SQLite4"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tarantool",children:"Tarantool"})," , ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/RocksDB",children:"RocksDB"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/WiredTiger",children:"WiredTiger"})," (MongoDB Engine), ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Apache_Cassandra",children:"Apache Cassandra"}),", ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/InfluxDB",children:"InfluxDB"})," and ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/w/index.php?title=VictoriaMetrics&action=edit&redlink=1",children:"VictoriaMetrics"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"time-complexity-in-big-o-notation",children:"Time complexity in big O notation"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Algorithm"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Average"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Worst case"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Insert"}),(0,s.jsx)(t.td,{children:"O(1)"}),(0,s.jsx)(t.td,{children:"O(1)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Find-min"}),(0,s.jsx)(t.td,{children:"O(N)"}),(0,s.jsx)(t.td,{children:"O(N)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Delete-min"}),(0,s.jsx)(t.td,{children:"O(N)"}),(0,s.jsx)(t.td,{children:"O(N)"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Log-structured_merge-tree",children:"Log-structured merge-tree - Wikipedia"})}),"\n",(0,s.jsx)(t.h2,{id:"anatomy",children:"Anatomy"}),"\n",(0,s.jsxs)(t.p,{children:["In LSM Trees, all the writes are performed against the mutable in-memory data structure (once again, often implemented using a data structure allowing logarithmic time lookup, such as a B-Tree or a ",(0,s.jsx)(t.a,{href:"http://epaperpress.com/sortsearch/download/skiplist.pdf",children:"SkipList"}),'). Whenever the size of the tree reaches a certain threshold (or after some predefined time period elapses, whichever comes first), we write the data the disk, creating a new SSTable. This process is sometimes called "flush". Retrieving the data may require searching all SSTables on disk, checking the in-memory table and merging their contents together before returning the result.']}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"image",src:r(343336).Z+"",width:"1004",height:"277"})}),"\n",(0,s.jsx)(t.p,{children:"Structure of an LSM Tree: a memory-resident table, used for writes. Whenever the memory table is large enough, it's sorted contents are written on disk, becoming an SSTable. Reads are served, hitting all SSTables and the memory-resident table, requiring a merge process to reconcile the data."}),"\n",(0,s.jsx)(t.p,{children:"The merge step during the read is required, since the data can be split in several parts (for example, an insert followed by delete operation, where delete would shadow the originally inserted record; or an insert, followed by the update operation, where a new field is added to the record)."}),"\n",(0,s.jsx)(t.p,{children:"Every data item in SSTable has a timestamp associated with it. For inserts it specifies the write time, for updates - an update time and removal time for deletes."}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.p,{children:"LSM Tree databases are typically write-optimized, since all the writes are performed against the write-ahead log (for durability and fail over) and memory resident tables. Reads are usually slower, because of the merge process and a need to check multiple files on disk.\nBecause of the maintenance, LSM-Trees might result into worse latency, since both CPU and IO bandwidth is spent re-reading and merging tables instead of just serving reads and writes. It's also possible, under a write-heavy workload, to saturate IO by just writes and flushes, stalling the compaction process. Lagging compaction results into slower reads, increasing CPU and IO pressure, making the matters worse. This is something to watch out for."}),"\n",(0,s.jsx)(t.p,{children:"LSM-Trees cause some write amplification: data has to be written to the write-ahead log, then flushed on disk, where it will be eventually re-read and written again during the compaction process. That said, mutable B-Tree structures also suffer from write amplification, so I'd prefer to leave the cost analysis until after we discuss B-Trees and a conjecture that helps understanding that we are just trading read performance against write performance and memory overhead."}),"\n",(0,s.jsx)(t.h2,{id:"closing-words",children:"Closing Words"}),"\n",(0,s.jsxs)(t.p,{children:["As you can see all write operations in LSM Trees are sequential: Write-Ahead Log appends, Memtable flushes, Compactions. Using ",(0,s.jsx)(t.a,{href:"https://github.com/apache/cassandra/blob/trunk/doc/SASI",children:"per-SSTable indexes"})," or pre-sorting data can also help to make at least some read operations sequential. It can only be done to a certain extend as reads have to be performed against multiple files and then merged together."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f",children:"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-io-access-patterns-in-lsm-trees-2ba8dffc05f9",children:"https://medium.com/databasss/on-disk-io-access-patterns-in-lsm-trees-2ba8dffc05f9"})}),"\n",(0,s.jsx)(t.h2,{id:"lms-trees-copy-on-write-b-trees",children:"LMS Trees (Copy on Write B-Trees)"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Take B-Tree, let's make the pages immutable (every page is a new instance appended to old instance)"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree",children:"https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree"})})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},343336:(e,t,r)=>{r.d(t,{Z:()=>s});const s=r.p+"assets/images/LSM-(Log-Structured-Merge-Trees)-image1-31e1993ac29c3ec1a87971e89a58bc5e.jpg"},511151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>n});var s=r(667294);const i={},a=s.createContext(i);function n(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);