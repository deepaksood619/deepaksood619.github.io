"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[59584],{544185:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>n,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"computer-science/operating-system/write-ahead-log-wal","title":"Write Ahead Log, WAL","description":"In computer science, write-ahead logging(WAL) is a family of techniques for providing atomicity) and durability)(two of the ACID properties) in database systems. The changes are first recorded in the log, which must be written to stable storage, before the changes are written to the database.","source":"@site/docs/computer-science/operating-system/write-ahead-log-wal.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/write-ahead-log-wal","permalink":"/computer-science/operating-system/write-ahead-log-wal","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/write-ahead-log-wal.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Unix / Linux","permalink":"/computer-science/operating-system/unix-linux"},"next":{"title":"Others","permalink":"/computer-science/others/"}}');var s=a(474848),r=a(28453);const n={},o="Write Ahead Log, WAL",d={},h=[{value:"InfluxDB WAL",id:"influxdb-wal",level:2},{value:"Batching Writes",id:"batching-writes",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"write-ahead-log-wal",children:"Write Ahead Log, WAL"})}),"\n",(0,s.jsxs)(t.p,{children:["In ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"}),", write-ahead logging(WAL) is a family of techniques for providing ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Atomic_(computer_science)",children:"atomicity"})," and ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Durability_(database_systems)",children:"durability"}),"(two of the ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/ACID",children:"ACID"})," properties) in ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Database_system",children:"database systems"}),". The changes are first recorded in the log, which must be written to stable storage, before the changes are written to the database.\nIn a system using WAL, all modifications are written to a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Database_log",children:"log"})," before they are applied. Usually both redo and undo information is stored in the log.\nThe purpose of this can be illustrated by an example. Imagine a program that is in the middle of performing some operation when the machine it is running on loses power. Upon restart, that program might need to know whether the operation it was performing succeeded, succeeded partially, or failed. If a write-ahead log is used, the program can check this log and compare what it was supposed to be doing when it unexpectedly lost power to what was actually done. On the basis of this comparison, the program could decide to undo what it had started, complete what it had started, or keep things as they are.\nWAL allows updates of a database to be done ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/In-place_algorithm",children:"in-place"}),". Another way to implement atomic updates is with ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Shadow_paging",children:"shadow paging"}),", which is not in-place. The main advantage of doing updates in-place is that it reduces the need to modify indexes and block lists.\n",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics",children:"ARIES"})," is a popular algorithm in the WAL family.\nModern ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/File_system",children:"file systems"})," typically use a variant of WAL for at least file system ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Metadata",children:"metadata"})," called ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Journaling_file_system",children:"journaling"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Write-ahead_logging",children:"https://en.wikipedia.org/wiki/Write-ahead_logging"})}),"\n",(0,s.jsx)(t.h2,{id:"influxdb-wal",children:"InfluxDB WAL"}),"\n",(0,s.jsx)(t.p,{children:"The temporary cache for recently written points. To reduce the frequency with which the permanent storage files are accessed, InfluxDB caches new points in the WAL until their total size or age triggers a flush to more permanent storage. This allows for efficient batching of the writes into the TSM.\nPoints in the WAL can be queried, and they persist through a system reboot. On process start, all points in the WAL must be flushed before the system accepts new writes.\nSome data structures are inherently sequential. For example, a Write Ahead Log used by the databases and filesystems. It is used in order to facilitate durability: changes to the data files are first appended to the log sequentially.\nWhen main storage catches up and records are committed to the data files, commit log segment holding recovery data for it is discarded. If the process dies before the main storage has a chance to catch up, Write Ahead Log is replayed to restore the state database had before restart. If we follow this procedure, data files don't have to be flushed on disk on every operation: operations can be batched together, while still guaranteeing durability. Using Write-Ahead Log significantly reduces amount of writes for both mutable and immutable storage types.\nIt's often advised to use a separate physical device for Write Ahead Log to make sure both memory table flushes and WAL writes are sequential. There are many other reasons to do so, too: to avoid IO saturation, for better failover, more predictable latencies."}),"\n",(0,s.jsx)(t.h2,{id:"batching-writes",children:"Batching Writes"}),"\n",(0,s.jsx)(t.p,{children:"LSM-Trees are using Memory tables, where data is stored before it gets to the main storage, for serving reads and batching writes together. After reaching a size threshold, memory table is written on disk.\nHere, memory table serves as a buffer: read, write and update operations are performed against memory tables, allowing batching a few items together. When data is written on disk, it's done sequentially, in one pass. This amortises a cost of small random writes and converts them into larger sequential allocations on disk, transforming updates of logically unrelated data into physically sequential I/O.\nUnlike Write-Ahead Log (which writes items in the incoming order) Memory Tables pre-sort the data before it reaches disk in order to facilitate sequential read access. Records that are more likely to be read together, are written together."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://medium.com/databasss/on-disk-io-access-patterns-in-lsm-trees-2ba8dffc05f9",children:"https://medium.com/databasss/on-disk-io-access-patterns-in-lsm-trees-2ba8dffc05f9"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://bravenewgeek.com/building-a-distributed-log-from-scratch-part-1-storage-mechanics",children:"https://bravenewgeek.com/building-a-distributed-log-from-scratch-part-1-storage-mechanics"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://youtu.be/uHvR7nOu5m4",children:"Redo, Undo and WAL logs | The Backend Engineering Show"})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>n,x:()=>o});var i=a(296540);const s={},r=i.createContext(s);function n(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);