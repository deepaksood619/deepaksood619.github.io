"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[27970],{820198:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>o});var i=n(785893),r=n(511151);const s={},d="Inverted Index",a={id:"databases/indexing/inverted-index",title:"Inverted Index",description:"In computer science, an inverted index (also referred to as postings file or inverted file) is an index data structure) storing a mapping from content, such as words or numbers, to its locations in a database file), or in a document or a set of documents (named in contrast to a forward index, which maps from documents to content). The purpose of an inverted index is to allow fast full text searches, at a cost of increased processing when a document is added to the database. The inverted file may be the database file itself, rather than its index). It is the most popular data structure used in document retrieval systems, used on a large scale for example in search engines.",source:"@site/docs/databases/indexing/inverted-index.md",sourceDirName:"databases/indexing",slug:"/databases/indexing/inverted-index",permalink:"/databases/indexing/inverted-index",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/indexing/inverted-index.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Indexing",permalink:"/databases/indexing/intro"},next:{title:"MySQL Indexing",permalink:"/databases/indexing/mysql-indexing"}},c={},o=[{value:"Applications",id:"applications",level:2},{value:"Inverted Index in Elasticsearch",id:"inverted-index-in-elasticsearch",level:2}];function h(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"inverted-index",children:"Inverted Index"}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"}),", an inverted index (also referred to as postings file or inverted file) is an ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Index_(database)",children:"index data structure"})," storing a mapping from content, such as words or numbers, to its locations in a ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Table_(database)",children:"database file"}),", or in a document or a set of documents (named in contrast to a ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Forward_index",children:"forward index"}),", which maps from documents to content). The purpose of an inverted index is to allow fast ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Full_text_search",children:"full text searches"}),", at a cost of increased processing when a document is added to the database. The inverted file may be the database file itself, rather than its ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Index_(database)",children:"index"}),". It is the most popular data structure used in ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Document_retrieval",children:"document retrieval"})," systems, used on a large scale for example in ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Search_engine",children:"search engines"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["There are two main variants of inverted indexes: A ",(0,i.jsx)(t.strong,{children:"record-level inverted index"})," (orinverted file indexor justinverted file) contains a list of references to documents for each word. A ",(0,i.jsx)(t.strong,{children:"word-level inverted index"})," (or full inverted indexorinverted list) additionally contains the positions of each word within a document. The latter form offers more functionality (like ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Phrase_search",children:"phrase searches"}),"), but needs more processing power and space to be created."]}),"\n",(0,i.jsx)(t.h2,{id:"applications",children:"Applications"}),"\n",(0,i.jsxs)(t.p,{children:["The inverted index ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Data_structure",children:"data structure"})," is a central component of a typical ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Index_(search_engine)",children:"search engine indexing algorithm"}),". A goal of a search engine implementation is to optimize the speed of the query: find the documents where word X occurs. Once a ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Search_engine_indexing#The_forward_index",children:"forward index"})," is developed, which stores lists of words per document, it is next inverted to develop an inverted index. Querying the forward index would require sequential iteration through each document and to each word to verify a matching document. The time, memory, and processing resources to perform such a query are not always technically realistic. Instead of listing the words per document in the forward index, the inverted index data structure is developed which lists the documents per word."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Inverted_index",children:"https://en.wikipedia.org/wiki/Inverted_index"})}),"\n",(0,i.jsx)(t.h2,{id:"inverted-index-in-elasticsearch",children:"Inverted Index in Elasticsearch"}),"\n",(0,i.jsx)(t.p,{children:"Elasticsearch uses a structure calledaninverted index, which is designed to allow very fast full-text searches. An inverted index consists of a list of all the unique words that appear in any document, and for each word, a list of the documents in which it appears.\nFor example, let's say we have two documents, each with acontentfield containing the following:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The quick brown fox jumped over the lazy dog"}),"\n",(0,i.jsx)(t.li,{children:"Quick brown foxes leap over lazy dogs in summer"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"To create an inverted index, we first split thecontentfield of each document into separate words (which we call terms, or tokens), create a sorted list of all the unique terms, and then list in which document each term appears. The result looks something like this:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Term"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_1"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_2"})})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Quick"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"The"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"brown"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"dog"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"dogs"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"fox"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"foxes"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"in"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"jumped"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"lazy"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"leap"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"over"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"quick"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"summer"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"the"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Now, if we want to search forquick brown, we just need to find the documents in which each term appears:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Term"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_1"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_2"})})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"brown"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"quick"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Total"}),(0,i.jsx)(t.td,{children:"2"}),(0,i.jsx)(t.td,{children:"1"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["Both documents match, but the first document has more matches than the second. If we apply a naive ",(0,i.jsx)(t.strong,{children:"similarity algorithm"})," thatjust counts the number of matching terms, then we can say that the first document is a better match - ismore relevantto our query - than the second document."]}),"\n",(0,i.jsx)(t.p,{children:"But there are a few problems with our current inverted index:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Quick and quick appear as separate terms, while the user probably thinks of them as the same word."}),"\n",(0,i.jsx)(t.li,{children:"fox and foxes are pretty similar, as are dog and dogs; They share the same root word."}),"\n",(0,i.jsx)(t.li,{children:"jumped and leap, while not from the same root word, are similar in meaning. They are synonyms."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"With the preceding index, a search for+Quick +foxwouldn't match any documents. (Remember, a preceding+means that the word must be present.) Both the termQuickand the termfoxhave to be in the same document in order to satisfy the query, but the first doc containsquick foxand the second doc containsQuick foxes."}),"\n",(0,i.jsx)(t.p,{children:"Our user could reasonably expect both documents to match the query. We can do better.\nIf we normalize the terms into a standardformat, then we can find documents that contain terms that are not exactly the same as the user requested, but are similar enough to still be relevant. For instance:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Quickcan be lowercased to becomequick."}),"\n",(0,i.jsxs)(t.li,{children:["foxescan be ",(0,i.jsx)(t.strong,{children:"stemmed"})," --reduced to its root form - to becomefox. Similarly, dogscould be stemmed todog."]}),"\n",(0,i.jsx)(t.li,{children:"jumpedandleapare synonyms and can be indexed as just the single termjump."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Now the index looks like this:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Term"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_1"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Doc_2"})})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"brown"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"dog"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"fox"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"in"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"jump"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"lazy"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"over"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"quick"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"summer"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"the"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"But we're not there yet. Our search for+Quick +foxwouldstillfail, because we no longer have the exact term Quick in our index. However, if we apply the same normalization rules that we used on the content field to our query string, it would become a query for+quick +fox, which would match both documents!"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"This is very important. You can find only terms that exist in your index, so both the indexed text and the query string must be normalized into the same form."})}),"\n",(0,i.jsxs)(t.p,{children:["This process of ",(0,i.jsx)(t.strong,{children:"tokenization"})," and ",(0,i.jsx)(t.strong,{children:"normalization"})," is called ",(0,i.jsx)(t.strong,{children:"analysis"})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.elastic.co/guide/en/elasticsearch/guide/current/inverted-index.html",children:"https://www.elastic.co/guide/en/elasticsearch/guide/current/inverted-index.html"})})]})}function l(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},511151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>d});var i=n(667294);const r={},s=i.createContext(r);function d(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);