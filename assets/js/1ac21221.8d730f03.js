"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[26704],{844732:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"algorithms/algorithmic-complexity/np-hardness","title":"NP Hardness","description":"|  |  |","source":"@site/docs/algorithms/algorithmic-complexity/np-hardness.md","sourceDirName":"algorithms/algorithmic-complexity","slug":"/algorithms/algorithmic-complexity/np-hardness","permalink":"/algorithms/algorithmic-complexity/np-hardness","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/algorithmic-complexity/np-hardness.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Halting Problem","permalink":"/algorithms/algorithmic-complexity/halting-problem"},"next":{"title":"Sub-linear time","permalink":"/algorithms/algorithmic-complexity/sub-linear-time"}}');var o=n(474848),r=n(28453);const s={},a="NP Hardness",l={},h=[{value:"NP Naming Convention",id:"np-naming-convention",level:2},{value:"P",id:"p",level:2},{value:"NP",id:"np",level:2},{value:"NP-hard",id:"np-hard",level:2},{value:"NP-complete",id:"np-complete",level:2},{value:"NP-easy",id:"np-easy",level:2},{value:"NP-equivalent",id:"np-equivalent",level:2},{value:"NP-intermediate",id:"np-intermediate",level:2},{value:"P vs NP Problem",id:"p-vs-np-problem",level:2},{value:"PTAS",id:"ptas",level:2},{value:"PTAS Reduction",id:"ptas-reduction",level:2}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"np-hardness",children:"NP Hardness"})}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{}),(0,o.jsx)(i.th,{})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/P_(complexity)",children:(0,o.jsx)(i.strong,{children:"P"})})}),(0,o.jsxs)(i.td,{children:["The ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Complexity_class",children:"complexity class"})," of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Decision_problem",children:"decision problems"})," that can be solved on a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Deterministic_Turing_machine",children:"deterministic Turing machine"})," in polynomial time"]})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP_(complexity)",children:(0,o.jsx)(i.strong,{children:"NP"})})}),(0,o.jsxs)(i.td,{children:["The complexity class of decision problems that can be solved on a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Non-deterministic_Turing_machine",children:"non-deterministic Turing machine"})," in polynomial time"]})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/ZPP_(complexity)",children:(0,o.jsx)(i.strong,{children:"ZPP"})})}),(0,o.jsxs)(i.td,{children:["The complexity class of decision problems that can be solved with zero error on a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Probabilistic_Turing_machine",children:"probabilistic Turing machine"})," in polynomial time"]})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/RP_(complexity)",children:(0,o.jsx)(i.strong,{children:"RP"})})}),(0,o.jsx)(i.td,{children:"The complexity class of decision problems that can be solved with 1-sided error on a probabilistic Turing machine in polynomial time."})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/BPP_(complexity)",children:(0,o.jsx)(i.strong,{children:"BPP"})})}),(0,o.jsx)(i.td,{children:"The complexity class of decision problems that can be solved with 2-sided error on a probabilistic Turing machine in polynomial time"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/BQP",children:(0,o.jsx)(i.strong,{children:"BQP"})})}),(0,o.jsxs)(i.td,{children:["The complexity class of decision problems that can be solved with 2-sided error on a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Quantum_Turing_machine",children:"quantum Turing machine"})," in polynomial time"]})]})]})]}),"\n",(0,o.jsxs)(i.p,{children:["NP-hardness(",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP_(complexity)",children:"non-deterministic polynomial-time"})," hardness), in ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computational_complexity_theory",children:"computational complexity theory"}),', is the defining property of a class of problems that are informally "at least as hard as the hardest problems in NP". A simple example of an NP-hard problem is the ',(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Subset_sum_problem",children:"subset sum problem"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["A more precise specification is: a problemHis NP-hard when every problemLin NP can be ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Reduction_(complexity)",children:"reduced"})," in ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Polynomial_time",children:"polynomial time"})," toH; that is, assuming a solution for H takes 1 unit time, H\u200e's solution can be used to solveLin polynomial time.As a consequence, finding a polynomial algorithm to solve any NP-hard problem would give polynomial algorithms for all the problems in NP, which is unlikely as many of them are considered difficult."]}),"\n",(0,o.jsxs)(i.p,{children:['A common misconception is that the NP in "NP-hard" stands for "non-polynomial" when in fact it stands for "',(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Non-deterministic_Turing_machine",children:"non-deterministic"}),' polynomial acceptable problems".It is suspected that there are no polynomial-time algorithms for NP-hard problems, but that has not been proven. Moreover, the class ',(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/P_(complexity)",children:"P"}),", in which all problems can be solved in polynomial time, is contained in the ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP_(complexity)",children:"NP"})," class."]}),"\n",(0,o.jsx)(i.h2,{id:"np-naming-convention",children:"NP Naming Convention"}),"\n",(0,o.jsxs)(i.p,{children:["NP-hard problems do not have to be elements of the complexity class NP. As NP plays a central role in ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computational_complexity_theory",children:"computational complexity"}),", it is used as the basis of several classes:"]}),"\n",(0,o.jsx)(i.h2,{id:"p",children:"P"}),"\n",(0,o.jsx)(i.p,{children:"Problems that computer can solve quickly and efficiently (P is a set of problems that are solvable in polynomial time. That is, the number of computational steps is bounded by polynomial function with respect to the problem size. Ex- Bipartite Matching)"}),"\n",(0,o.jsx)(i.h2,{id:"np",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP_(complexity)",children:"NP"})}),"\n",(0,o.jsx)(i.p,{children:"Class of computational decision problems for which a given yes - solution can be verified as a solution in polynomial time by a deterministic Turing machine (or solvable by a non-deterministicTuring machine in polynomial time)."}),"\n",(0,o.jsx)(i.p,{children:"Problems whose solutions can be verified quickly but cannot be obtained quickly"}),"\n",(0,o.jsx)(i.p,{children:"(NP is the set of problem that are verifiable in polynomial time. This includes all the problems in P, of course; however we don't know whether this containment is strict. We know of problems that are efficiently verifiable but not efficiently solvable, but we don't know if the problem is truly intractable. Ex-Clique Problem)"}),"\n",(0,o.jsx)(i.h2,{id:"np-hard",children:"NP-hard"}),"\n",(0,o.jsx)(i.p,{children:"Class of problems which are at least as hard as the hardest problems in NP. Problems that are NP-hard do not have to be elements of NP; indeed, they may not even be decidable."}),"\n",(0,o.jsx)(i.h2,{id:"np-complete",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-complete",children:"NP-complete"})}),"\n",(0,o.jsx)(i.p,{children:"Class of decision problems which contains the hardest problems in NP. Each NP-complete problem has to be in NP."}),"\n",(0,o.jsx)(i.p,{children:"NP-Complete is the set of problems that are the hardest problems in NP. They are referred to as the hardest problem because any problem in NP can efficiently be transformed into NPC. As a result, if someone were to identify an efficient solution to a problem in NPC, then the entire class of NP would be absorbed by P. (Ex - Clique Problem)"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Weakly NP-Complete"}),"\n",(0,o.jsx)(i.li,{children:"Strongly NP-Complete"}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["An ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-complete",children:"NP-complete"})," problem with known pseudo-polynomial time algorithms is called ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Weakly_NP-complete",children:"weakly NP-complete"}),". An ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-complete",children:"NP-complete"})," problem is called ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Strongly_NP-complete",children:"strongly NP-complete"})," if it is proven that it cannot be solved by a pseudo-polynomial time algorithm unless ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/P%3DNP",children:"P=NP"}),". The strong/weak kinds of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-hard",children:"NP-hardness"})," are defined analogously."]}),"\n",(0,o.jsx)(i.h2,{id:"np-easy",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-easy",children:"NP-easy"})}),"\n",(0,o.jsx)(i.p,{children:"At most as hard as NP, but not necessarily in NP."}),"\n",(0,o.jsx)(i.h2,{id:"np-equivalent",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-equivalent",children:"NP-equivalent"})}),"\n",(0,o.jsx)(i.p,{children:"Decision problems that are both NP-hard and NP-easy, but not necessarily in NP."}),"\n",(0,o.jsx)(i.h2,{id:"np-intermediate",children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-intermediate",children:"NP-intermediate"})}),"\n",(0,o.jsx)(i.p,{children:"If P and NP are different, then there exist decision problems in the region of NP that fall between P and the NP-complete problems. (If P and NP are the same class, then NP-intermediate problems do not exist because in this case every NP-complete problem would fall in P, and by definition, every problem in NP can be reduced to an NP-complete problem.)"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-hardness",children:"https://en.wikipedia.org/wiki/NP-hardness"})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"image",src:n(185258).A+"",width:"1000",height:"1000"})}),"\n",(0,o.jsx)(i.h2,{id:"p-vs-np-problem",children:"P vs NP Problem"}),"\n",(0,o.jsx)(i.p,{children:"It is the problem of confirming if every computational problem whose solution can be verified in polynomial time can also be solved in polynomial time."}),"\n",(0,o.jsx)(i.h2,{id:"ptas",children:"PTAS"}),"\n",(0,o.jsxs)(i.p,{children:["In ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"}),", a",(0,o.jsx)(i.strong,{children:"polynomial-time approximation scheme"}),"(",(0,o.jsx)(i.strong,{children:"PTAS"}),") is a type of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Approximation_algorithm",children:"approximation algorithm"})," for ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimization_problem",children:"optimization problems"}),"(most often, ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/NP-hard",children:"NP-hard"})," optimization problems)."]}),"\n",(0,o.jsxs)(i.p,{children:["A PTAS is an algorithm which takes an instance of an optimization problem and a parameter \u03b5>0 and, in polynomial time, produces a solution that is within a factor 1 + \u03b5 of being optimal (or 1 \u2212 \u03b5 for maximization problems). For example, for the Euclidean ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Traveling_salesman_problem",children:"traveling salesman problem"}),", a PTAS would produce a tour with length at most (1+\u03b5)",(0,o.jsx)(i.em,{children:"L"}),", with ",(0,o.jsx)(i.em,{children:"L"})," being the length of the shortest tour.There exists also PTAS for the class of all dense constraint satisfaction problems (CSPs)"]}),"\n",(0,o.jsxs)(i.p,{children:["The running time of a PTAS is required to be polynomial in ",(0,o.jsx)(i.em,{children:"n"})," for every fixed \u03b5 but can be different for different \u03b5. Thus an algorithm running in time ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Big_O_notation",children:(0,o.jsx)(i.em,{children:"O"})}),"(",(0,o.jsx)(i.em,{children:"n"}),"^1/\u03b5^) or even",(0,o.jsx)(i.em,{children:"O"}),"(",(0,o.jsx)(i.em,{children:"n"}),"^exp(1/\u03b5)^) counts as a PTAS."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Polynomial-time_approximation_scheme",children:"https://en.wikipedia.org/wiki/Polynomial-time_approximation_scheme"})}),"\n",(0,o.jsx)(i.h2,{id:"ptas-reduction",children:"PTAS Reduction"}),"\n",(0,o.jsxs)(i.p,{children:["In ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computational_complexity_theory",children:"computational complexity theory"}),", a ",(0,o.jsx)(i.strong,{children:"PTAS reduction"})," is an ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Approximation-preserving_reduction",children:"approximation-preserving reduction"})," that is often used to perform ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Reduction_(complexity)",children:"reductions"})," between solutions to ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimization_problem",children:"optimization problems"}),". It preserves the property that a problem has a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Polynomial_time_approximation_scheme",children:"polynomial time approximation scheme"}),"(PTAS) and is used to define ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Complete_(complexity)",children:"completeness"})," for certain classes of optimization problems such as ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/APX",children:"APX"}),". Notationally, if there is a PTAS reduction from a problem A to a problem B, we write ",(0,o.jsx)(i.code,{children:"A <=~PTAS~ B"})]}),"\n",(0,o.jsxs)(i.p,{children:["With ordinary ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Polynomial-time_many-one_reduction",children:"polynomial-time many-one reductions"}),", if we can describe a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Reduction_(complexity)",children:"reduction"})," from a problem A to a problem B, then any polynomial-time solution for B can be composed with that reduction to obtain a polynomial-time solution for the problem A. Similarly, our goal in defining PTAS reductions is so that given a PTAS reduction from an optimization problem A to a problem B, a PTAS for B can be composed with the reduction to obtain a PTAS for the problem A."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/PTAS_reduction",children:"https://en.wikipedia.org/wiki/PTAS_reduction"})})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},185258:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/NP-Hardness-image2-8bdc75b80c6ceea70082b6dfd869b237.jpg"},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>a});var t=n(296540);const o={},r=t.createContext(o);function s(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);