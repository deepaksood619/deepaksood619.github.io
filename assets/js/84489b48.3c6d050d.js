"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[8210],{286528:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"data-structures/hierarchical-data-structure/fibonacci-heap","title":"Fibonacci Heap","description":"Key Points","source":"@site/docs/data-structures/hierarchical-data-structure/fibonacci-heap.md","sourceDirName":"data-structures/hierarchical-data-structure","slug":"/data-structures/hierarchical-data-structure/fibonacci-heap","permalink":"/data-structures/hierarchical-data-structure/fibonacci-heap","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hierarchical-data-structure/fibonacci-heap.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1681237065000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Binomial Heap","permalink":"/data-structures/hierarchical-data-structure/binomial-heap"},"next":{"title":"Interval Search Tree","permalink":"/data-structures/hierarchical-data-structure/interval-search-tree"}}');var a=n(474848),r=n(28453);const s={},o="Fibonacci Heap",c={},l=[{value:"Key Points",id:"key-points",level:2},{value:"Running Time",id:"running-time",level:2},{value:"Below are some interesting facts about Fibonacci Heap",id:"below-are-some-interesting-facts-about-fibonacci-heap",level:2}];function d(e){const i={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"fibonacci-heap",children:"Fibonacci Heap"})}),"\n",(0,a.jsx)(i.h2,{id:"key-points",children:"Key Points"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Running Time: O(E + V log V)"}),"\n",(0,a.jsx)(i.li,{children:"Find minimum takes constant O(1) amortized time."}),"\n",(0,a.jsx)(i.li,{children:"Insert and decrease key also take constant amortized time"}),"\n",(0,a.jsx)(i.li,{children:"Deletion takes O(log N) amortized time."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Data Structure for Priority Queue Operations, consisting of a collection of Heap Ordered Trees."}),"\n",(0,a.jsxs)(i.p,{children:["A Fibonacci heap is a collection of ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tree_data_structure",children:"trees"})," satisfying the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Minimum-heap_property",children:"minimum-heap property"}),", that is, the key of a child is always greater than or equal to the key of the parent. This implies that the minimum key is always at the root of one of the trees. Compared with binomial heaps, the structure of a Fibonacci heap is more flexible. The trees do not have a prescribed shape and in the extreme case the heap can have every element in a separate tree. This flexibility allows some operations to be executed in a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Lazy_evaluation",children:"lazy"})," manner, postponing the work for later operations. For example, merging heaps is done simply by concatenating the two lists of trees, and operation ",(0,a.jsx)(i.em,{children:"decrease key"})," sometimes cuts a node from its parent and forms a new tree."]}),"\n",(0,a.jsx)(i.p,{children:"Lazily defer consolidation under next delete-min"}),"\n",(0,a.jsx)(i.h2,{id:"running-time",children:"Running Time"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Find Min: ",(0,a.jsx)(i.strong,{children:"\u0398(1)"})," [Same as both Binary and Binomial]"]}),"\n",(0,a.jsxs)(i.li,{children:["Delete Min: ",(0,a.jsx)(i.strong,{children:"O(Log n)"})," [\u0398(Log n) in both Binary and Binomial]"]}),"\n",(0,a.jsxs)(i.li,{children:["Insert: ",(0,a.jsx)(i.strong,{children:"\u0398(1)"})," [\u0398(Log n) in Binary and \u0398(1) in Binomial]"]}),"\n",(0,a.jsxs)(i.li,{children:["Decrease-Key: ",(0,a.jsx)(i.strong,{children:"\u0398(1)"})," [\u0398(Log n) in both Binary and Binomial]"]}),"\n",(0,a.jsxs)(i.li,{children:["Merge: ",(0,a.jsx)(i.strong,{children:"\u0398(1)"})," [\u0398(m Log n) or \u0398(m+n) in Binary and \u0398(Log n) in Binomial]"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"below-are-some-interesting-facts-about-fibonacci-heap",children:"Below are some interesting facts about Fibonacci Heap"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"The reduced time complexity of Decrease-Key has importance in Dijkstra and Prim algorithms. With Binary Heap, time complexity of these algorithms is O(VLogV + ELogV). If Fibonacci Heap is used, then time complexity is improved to O(VLogV + E)"}),"\n",(0,a.jsx)(i.li,{children:"Although Fibonacci Heap looks promising time complexity wise, it has been found slow in practice as hidden constants are high."}),"\n",(0,a.jsx)(i.li,{children:"Fibonacci heap are mainly called so because Fibonacci numbers are used in the running time analysis. Also, every node in Fibonacci Heap has degree at most O(log n) and the size of a subtree rooted in a node of degree k is at least Fk+2, where Fkis the kth Fibonacci number."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>o});var t=n(296540);const a={},r=t.createContext(a);function s(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);