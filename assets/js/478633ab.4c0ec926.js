"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[11229],{512373:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"cloud/aws/compute/amazon-ec2-asg","title":"Amazon EC2 Auto Scaling Group (ASG)","description":"Scale Compute Capacity to Meet Demand","source":"@site/docs/cloud/aws/compute/amazon-ec2-asg.md","sourceDirName":"cloud/aws/compute","slug":"/cloud/aws/compute/amazon-ec2-asg","permalink":"/cloud/aws/compute/amazon-ec2-asg","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/cloud/aws/compute/amazon-ec2-asg.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1761587427000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Compute","permalink":"/cloud/aws/compute/"},"next":{"title":"Amazon EC2 Instance types","permalink":"/cloud/aws/compute/amazon-ec2-instance-types"}}');var a=t(474848),s=t(28453);const o={},c="Amazon EC2 Auto Scaling Group (ASG)",l={},r=[{value:"Predictive Scaling",id:"predictive-scaling",level:3},{value:"Removing Instances",id:"removing-instances",level:3},{value:"Termination Policy",id:"termination-policy",level:2},{value:"When Amazon EC2 Auto Scaling uses termination policies",id:"when-amazon-ec2-auto-scaling-uses-termination-policies",level:3},{value:"Default termination policy",id:"default-termination-policy",level:3},{value:"Instances that use outdated configurations",id:"instances-that-use-outdated-configurations",level:4},{value:"Instances approaching next billing hour",id:"instances-approaching-next-billing-hour",level:4},{value:"Example",id:"example",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"amazon-ec2-auto-scaling-group-asg",children:"Amazon EC2 Auto Scaling Group (ASG)"})}),"\n",(0,a.jsx)(n.p,{children:"Scale Compute Capacity to Meet Demand"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html?icmpid=docs_ec2as_help_panel",children:"Amazon EC2 Auto Scaling lifecycle hooks - Amazon EC2 Auto Scaling"})}),"\n",(0,a.jsx)(n.p,{children:"Auto Scaling Policies"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Simple Scaling"}),"\n",(0,a.jsx)(n.li,{children:"Step Scaling"}),"\n",(0,a.jsx)(n.li,{children:"Target Tracking"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Simple Scaling"})," uses a single, static capacity adjustment in response to an alarm, while ",(0,a.jsx)(n.strong,{children:"Step Scaling"}),' uses predefined, varying adjustments based on the "size" of the alarm breach for more granular control. ',(0,a.jsx)(n.strong,{children:"Target Tracking"})," is the most automated and recommended policy, continuously adjusting capacity to keep a specific metric (like CPU utilization) at a defined target value without requiring you to set thresholds."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://tutorialsdojo.com/step-scaling-vs-simple-scaling-policies-in-amazon-ec2/",children:"Step Scaling vs Simple Scaling Policies vs Target Tracking Policies in Amazon EC2"})}),"\n",(0,a.jsx)(n.h3,{id:"predictive-scaling",children:"Predictive Scaling"}),"\n",(0,a.jsx)(n.p,{children:"Predictive scaling works by analyzing historical load data to detect daily or weekly patterns in traffic flows. It uses this information to forecast future capacity needs so Amazon EC2 Auto Scaling can proactively increase the capacity of your Auto Scaling group to match the anticipated load."}),"\n",(0,a.jsx)(n.p,{children:"Predictive scaling uses machine learning to analyze historical workload patterns and forecast future usage. It can schedule capacity adjustments in advance based on expected demand."}),"\n",(0,a.jsx)(n.p,{children:"Predictive scaling is well suited for situations where you have:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cyclical traffic, such as high use of resources during regular business hours and low use of resources during evenings and weekends"}),"\n",(0,a.jsx)(n.li,{children:"Recurring on-and-off workload patterns, such as batch processing, testing, or periodic data analysis"}),"\n",(0,a.jsx)(n.li,{children:"Applications that take a long time to initialize, causing a noticeable latency impact on application performance during scale-out events"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In general, if you have regular patterns of traffic increases and applications that take a long time to initialize, you should consider using predictive scaling. Predictive scaling can help you scale faster by launching capacity in advance of forecasted load, compared to using only dynamic scaling, which is reactive in nature. Predictive scaling can also potentially save you money on your EC2 bill by helping you avoid the need to over provision capacity."}),"\n",(0,a.jsx)(n.p,{children:"For example, consider an application that has high usage during business hours and low usage overnight. At the start of each business day, predictive scaling can add capacity before the first influx of traffic. This helps your application maintain high availability and performance when going from a period of lower utilization to a period of higher utilization. You don't have to wait for dynamic scaling to react to changing traffic. You also don't have to spend time reviewing your application's load patterns and trying to schedule the right amount of capacity using scheduled scaling."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-predictive-scaling.html",children:"Predictive scaling for Amazon EC2 Auto Scaling - Amazon EC2 Auto Scaling"})}),"\n",(0,a.jsx)(n.h3,{id:"removing-instances",children:"Removing Instances"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-enter-exit-standby.html",children:"Temporarily remove instances from your Auto Scaling group - Amazon EC2 Auto Scaling"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["You can put an instance that is in the\xa0",(0,a.jsx)(n.code,{children:"InService"}),"\xa0state into the\xa0",(0,a.jsx)(n.code,{children:"Standby"}),"\xa0state, update or troubleshoot the instance, and then return the instance to service. Instances that are on standby are still part of the Auto Scaling group, but they do not actively handle load balancer traffic."]}),"\n",(0,a.jsxs)(n.li,{children:["The\xa0",(0,a.jsx)(n.code,{children:"ReplaceUnhealthy"}),"\xa0process terminates instances that are marked as unhealthy and then creates new instances to replace them. Amazon EC2 Auto Scaling stops replacing instances that are marked as unhealthy. Instances that fail EC2 or Elastic Load Balancing health checks are still marked as unhealthy. As soon as you resume the\xa0",(0,a.jsx)(n.code,{children:"ReplaceUnhealthly"}),"\xa0process, Amazon EC2 Auto Scaling replaces instances that were marked unhealthy while this process was suspended."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"termination-policy",children:"Termination Policy"}),"\n",(0,a.jsx)(n.p,{children:"Amazon EC2 Auto Scaling uses termination policies to decide the order for terminating instances. You can use a predefined policy or create a custom policy to meet your specific requirements. By using a custom policy or instance scale in protection, you can also prevent your Auto Scaling group from terminating instances that aren't yet ready to terminate."}),"\n",(0,a.jsx)(n.h3,{id:"when-amazon-ec2-auto-scaling-uses-termination-policies",children:"When Amazon EC2 Auto Scaling uses termination policies"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Scale in events"}),"\n",(0,a.jsx)(n.li,{children:"Instance refresh"}),"\n",(0,a.jsx)(n.li,{children:"Availability Zone rebalancing"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"default-termination-policy",children:"Default termination policy"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Determine which Availability Zones (Azs) have the most instances and at least one instance that is not protected from scale-in."}),"\n",(0,a.jsx)(n.li,{children:"Determine which instances to terminate to align the remaining instances to the allocation strategy for the On-Demand or Spot Instance that is terminating."}),"\n",(0,a.jsxs)(n.li,{children:["Determine whether any of the instances use the oldest launch template or configuration:","\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Determine whether any of the instances use the oldest launch template unless there are instances that use a launch configuration."}),"\n",(0,a.jsx)(n.li,{children:"Determine whether any of the instances use the oldest launch configuration."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"After applying all of the above criteria, if there are multiple unprotected instances to terminate, determine which instances are closest to the next billing hour."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"When Amazon EC2 Auto Scaling needs to terminate an instance, it first identifies which Availability Zone (or Zones) has the most instances and at least one instance that is not protected from scale in. Then, it proceeds to evaluate unprotected instances within the identified Availability Zone as follows:"}),"\n",(0,a.jsx)(n.h4,{id:"instances-that-use-outdated-configurations",children:"Instances that use outdated configurations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"For groups that use a launch template"}),"\xa0\u2013 Determine whether any of the instances use outdated configurations, prioritizing in this order:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"First, check for instances launched with a launch configuration."}),"\n",(0,a.jsx)(n.li,{children:"Then, check for instances launched using a different launch template instead of the current launch template."}),"\n",(0,a.jsx)(n.li,{children:"Finally, check for instances using the oldest version of the current launch template."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For groups that use a launch configuration\xa0\u2013 Determine whether any of the instances use the oldest launch configuration."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If no instances with outdated configurations are found, or there are multiple instances to choose from, Amazon EC2 Auto Scaling considers the next criteria of instances approaching their next billing hour."}),"\n",(0,a.jsx)(n.h4,{id:"instances-approaching-next-billing-hour",children:"Instances approaching next billing hour"}),"\n",(0,a.jsx)(n.p,{children:"Determine whether any of the instances that meet the previous criteria are closest to the next billing hour. If multiple instances are equally close, terminate one at random. This helps you maximize the use of your instances that are billed hourly. However, most EC2 usage is now billed per second, so this optimization provides less benefit."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"AWS Default Termination Policy",src:t(111451).A+"",width:"944",height:"469"})}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Question -"})," Amazon EC2 Auto Scaling needs to terminate an instance from Availability Zone (AZ)\xa0",(0,a.jsx)(n.code,{children:"us-east-1a"}),"\xa0as it has the most number of instances amongst the Availability Zone (AZs) being used currently. There are 4 instances in the Availability Zone (AZ)\xa0",(0,a.jsx)(n.code,{children:"us-east-1a"}),"\xa0like so: Instance A has the oldest launch template, Instance B has the oldest launch configuration, Instance C has the newest launch configuration and Instance D is closest to the next billing hour."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Answer -"})," Per the default termination policy, the first priority is given to any allocation strategy for On-Demand vs Spot instances. As no such information has been provided for the given use-case, so this criterion can be ignored. The next priority is to consider any instance with the ",(0,a.jsx)(n.strong,{children:"oldest launch template"})," unless there is an instance that uses a launch configuration. So this rules out Instance A. Next, you need to consider any instance which has the ",(0,a.jsx)(n.strong,{children:"oldest launch configuration"}),". This implies Instance B will be selected for termination and Instance C will also be ruled out as it has the newest launch configuration. Instance D, which is ",(0,a.jsx)(n.strong,{children:"closest to the next billing hour"}),", is not selected as this criterion is last in the order of priority."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html",children:"Control which Auto Scaling instances terminate during scale in - Amazon EC2 Auto Scaling"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-termination-policies.html",children:"Configure termination policies for Amazon EC2 Auto Scaling - Amazon EC2 Auto Scaling"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},111451:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Pasted image 20251022093028-7808c8f673a967d53e64c0bd24a78688.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(296540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);