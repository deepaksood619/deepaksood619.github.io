"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[58463],{767762:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"languages/c++/others","title":"Others","description":"Log2","source":"@site/docs/languages/c++/others.md","sourceDirName":"languages/c++","slug":"/languages/c++/others","permalink":"/languages/c++/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/c++/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1707138374000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"IO","permalink":"/languages/c++/io"},"next":{"title":"printf","permalink":"/languages/c++/printf"}}');var a=t(474848),r=t(28453);const s={},o="Others",c={},l=[{value:"Log2",id:"log2",level:2},{value:"RAII (Resource Acquisition Is Initialization)",id:"raii-resource-acquisition-is-initialization",level:2},{value:"Array Decay",id:"array-decay",level:2}];function h(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"others",children:"Others"})}),"\n",(0,a.jsx)(i.h2,{id:"log2",children:"Log2"}),"\n",(0,a.jsx)(i.p,{children:"A utility function to find Log n in base 2"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-c++",children:"int log2(int n) {\n  return (n==1)? 0 : 1 + log2(n/2);\n}\n"})}),"\n",(0,a.jsx)(i.h2,{id:"raii-resource-acquisition-is-initialization",children:"RAII (Resource Acquisition Is Initialization)"}),"\n",(0,a.jsxs)(i.p,{children:["Resource acquisition is initialization (RAII)is a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Programming_idiom",children:"programming idiom"})," used in several ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Object-oriented_programming_language",children:"object-oriented languages"})," to describe a particular language behavior. In RAII, holding a resource is a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Class_invariant",children:"class invariant"}),", and is tied to ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Object_lifetime",children:"object lifetime"}),": ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Resource_allocation_(computer)",children:"resource allocation"})," (or acquisition) is done during object creation (specifically initialization), by the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)",children:"constructor"}),", while resource deallocation (release) is done during object destruction (specifically finalization), by the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Destructor_(computer_programming)",children:"destructor"}),". In other words, resource acquisition must succeed for initialization to succeed. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts (holding the resources is a class invariant), and to be held only when the object is alive. Thus if there are no object leaks, there are no ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Resource_leak",children:"resource leaks"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["RAII is associated most prominently with ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/C%2B%2B",children:"C++"})," where it originated, but also ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/D_(programming_language)",children:"D"}),", ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Ada_(programming_language)",children:"Ada"}),", ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Vala_(programming_language)",children:"Vala"}),", and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Rust_(programming_language)",children:"Rust"}),". The technique was developed for ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Exception_safety",children:"exception-safe"}),(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Resource_management_(computing)",children:"resource management"})," in C++during 1984--89, primarily by ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bjarne_Stroustrup",children:"Bjarne Stroustrup"})," and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)",children:"Andrew Koenig"}),", and the term itself was coined by Stroustrup.RAII is generally pronounced as an ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Initialism",children:"initialism"}),', sometimes pronounced as "R, A, double I".']}),"\n",(0,a.jsxs)(i.p,{children:["Other names for this idiom includeConstructor Acquires, Destructor Releases(CADRe)and one particular style of use is calledScope-based Resource Management(SBRM).This latter term is for the special case of ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Automatic_variable",children:"automatic variables"}),". RAII ties resources to objectlifetime, which may not coincide with entry and exit of a scope. (Notably variables allocated on the free store have lifetimes unrelated to any given scope.) However, using RAII for automatic variables (SBRM) is the most common use case."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization",children:"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"})}),"\n",(0,a.jsxs)(i.p,{children:["Resource Acquisition Is Initializationor RAII, is a C++ programming techniquewhich binds the life cycle of a resource that must be acquired before use (allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connection - anything that exists in limited supply) to the ",(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/lifetime",children:"lifetime"})," of an object."]}),"\n",(0,a.jsxs)(i.p,{children:["RAII guarantees that the resource is available to any function that may access the object (resource availability is a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Class_invariant",children:"class invariant"}),", eliminating redundant runtime tests). It also guarantees that all resources are released when the lifetime of their controlling object ends, in reverse order of acquisition. Likewise, if resource acquisition fails (the constructor exits with an exception), all resources acquired by every fully-constructed member and base subobject are released in reverse order of initialization. This leverages the core language features (",(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/lifetime",children:"object lifetime"}),", ",(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/statements",children:"scope exit"}),", ",(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/initializer_list#Initialization_order",children:"order of initialization"})," and ",(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/throw#Stack_unwinding",children:"stack unwinding"}),") to eliminate resource leaks and guarantee exception safety. Another name for this technique isScope-Bound Resource Management(SBRM), after the basic use case where the lifetime of an RAII object ends due to scope exit."]}),"\n",(0,a.jsx)(i.p,{children:"RAII can be summarized as follows:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["encapsulate each resource into a class, where","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"the constructor acquires the resource and establishes all class invariants or throws an exception if that cannot be done,"}),"\n",(0,a.jsx)(i.li,{children:"the destructor releases the resource and never throws exceptions;"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["always use the resource via an instance of a RAII-class that either","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"has automatic storage duration or temporary lifetime itself, or"}),"\n",(0,a.jsx)(i.li,{children:"has lifetime that is bounded by the lifetime of an automatic or temporary object"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Move semantics make it possible to safely transfer resource ownership between objects, across scopes, and in and out of threads, while maintaining resource safety."}),"\n",(0,a.jsx)(i.p,{children:"Classes with open()/close(), lock()/unlock(), or init()/copyFrom()/destroy() member functions are typical examples of non-RAII classes:"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/raii",children:"https://en.cppreference.com/w/cpp/language/raii"})}),"\n",(0,a.jsx)(i.h2,{id:"array-decay",children:"Array Decay"}),"\n",(0,a.jsx)(i.p,{children:"The loss of type and dimensions of an array is known as decay of an array.This generally occurs when we pass the array into function by value or pointer. What it does is, it sends first address to the array which is a pointer, hence the size of array is not the original one, but the one occupied by the pointer in the memory."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented",children:"https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented"})})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>s,x:()=>o});var n=t(296540);const a={},r=n.createContext(a);function s(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);