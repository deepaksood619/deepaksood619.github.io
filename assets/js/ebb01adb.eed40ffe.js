"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[80744],{58679:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"technologies/apache-airflow/parallelism","title":"Parallelism","description":"Here\'s an expanded list of configuration options that are available since Airflow v1.10.2. Some can be set on a per-DAG or per-operator basis, but may also fall back to the setup-wide defaults when they are not specified.","source":"@site/docs/technologies/apache-airflow/parallelism.md","sourceDirName":"technologies/apache-airflow","slug":"/technologies/apache-airflow/parallelism","permalink":"/technologies/apache-airflow/parallelism","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache-airflow/parallelism.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1734022610000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Others","permalink":"/technologies/apache-airflow/others"},"next":{"title":"Apache Hadoop","permalink":"/technologies/apache-hadoop/"}}');var o=r(474848),i=r(28453);const a={},l="Parallelism",t={},c=[{value:"Per queue tasks concurrency airflow",id:"per-queue-tasks-concurrency-airflow",level:2},{value:"1. DAG Level Concurrency (max_active_runs)",id:"1-dag-level-concurrency-max_active_runs",level:3},{value:"2. Task Level Concurrency (concurrency)",id:"2-task-level-concurrency-concurrency",level:3},{value:"3. DAG Concurrency (dag_concurrency)",id:"3-dag-concurrency-dag_concurrency",level:3},{value:"4. Pool Concurrency",id:"4-pool-concurrency",level:3},{value:"Implementing Concurrency Controls",id:"implementing-concurrency-controls",level:3},{value:"DAG Level Concurrency (<code>max_active_runs</code>)",id:"dag-level-concurrency-max_active_runs",level:4},{value:"Task Level Concurrency (<code>concurrency</code>)",id:"task-level-concurrency-concurrency",level:4},{value:"DAG Concurrency (<code>dag_concurrency</code>)",id:"dag-concurrency-dag_concurrency",level:4},{value:"Pool Concurrency",id:"pool-concurrency",level:4},{value:"Managing Task Queues",id:"managing-task-queues",level:3},{value:"Increasing Parallelism vs. Number of Schedulers",id:"increasing-parallelism-vs-number-of-schedulers",level:2},{value:"Increasing Parallelism",id:"increasing-parallelism",level:3},{value:"Increasing Number of Schedulers",id:"increasing-number-of-schedulers",level:3},{value:"What&#39;s the difference between airflow pool and celery queues",id:"whats-the-difference-between-airflow-pool-and-celery-queues",level:2},{value:"Airflow Pools",id:"airflow-pools",level:3},{value:"Celery Queues",id:"celery-queues",level:3},{value:"Key Differences",id:"key-differences",level:3},{value:"Airflow Pool vs Celery Worker Pool",id:"airflow-pool-vs-celery-worker-pool",level:2},{value:"Default Pool in Airflow",id:"default-pool-in-airflow",level:3},{value:"Celery Worker Pool",id:"celery-worker-pool",level:3},{value:"Links",id:"links",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"parallelism",children:"Parallelism"})}),"\n",(0,o.jsx)(n.p,{children:"Here's an expanded list of configuration options that are available since Airflow v1.10.2. Some can be set on a per-DAG or per-operator basis, but may also fall back to the setup-wide defaults when they are not specified."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["Options that can be specified\xa0",(0,o.jsx)(n.strong,{children:"on a per-DAG basis"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"concurrency"}),": the number of task instances allowed to run concurrently across all active runs of the DAG this is set on. Defaults to\xa0",(0,o.jsx)(n.code,{children:"core.dag_concurrency"}),"\xa0if not set"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"max_active_runs"}),": maximum number of active runs for this DAG. The scheduler will not create new active DAG runs once this limit is hit. Defaults to\xa0",(0,o.jsx)(n.code,{children:"core.max_active_runs_per_dag"}),"\xa0if not set"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Examples:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Only allow one run of this DAG to be running at any given time\ndag = DAG('my_dag_id', max_active_runs=1)\n\n# Allow a maximum of 10 tasks to be running across a max of 2 active DAG runs\ndag = DAG('example2', concurrency=10, max_active_runs=2)\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["Options that can be specified\xa0",(0,o.jsx)(n.strong,{children:"on a per-operator basis"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"pool"}),": the pool to execute the task in.\xa0",(0,o.jsx)(n.a,{href:"https://airflow.apache.org/concepts.html#pools",children:"Pools"}),"\xa0can be used to limit parallelism for\xa0",(0,o.jsx)(n.em,{children:"only a subset"}),"\xa0of tasks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"max_active_tis_per_dag"}),": controls the number of concurrent running task instances across dag_runs per task."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"t1 = BaseOperator(pool='my_custom_pool', max_active_tis_per_dag=12)\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["Options that are specified\xa0",(0,o.jsx)(n.strong,{children:"across an entire Airflow setup"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"core.parallelism"}),": maximum number of tasks running across an entire Airflow installation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"core.dag_concurrency"}),": max number of tasks that can be running per DAG (across multiple\xa0",(0,o.jsx)(n.em,{children:"DAG runs"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"core.non_pooled_task_slot_count"}),": number of task slots allocated to tasks not running in a pool"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"core.max_active_runs_per_dag"}),": maximum number of active DAG\xa0",(0,o.jsx)(n.em,{children:"runs"}),", per DAG"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"scheduler.max_threads"}),": how many threads the scheduler process should use to use to schedule DAGs"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"celery.worker_concurrency"}),": max number of task instances that a worker will process at a time\xa0",(0,o.jsx)(n.em,{children:"if using CeleryExecutor"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"celery.sync_parallelism"}),": number of processes CeleryExecutor should use to sync task state"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://stackoverflow.com/questions/56370720/how-to-control-the-parallelism-or-concurrency-of-an-airflow-installation",children:"python - How to control the parallelism or concurrency of an Airflow installation? - Stack Overflow"})}),"\n",(0,o.jsxs)(n.p,{children:["From airflow version 2.2,\xa0",(0,o.jsx)(n.code,{children:"task_concurrency"}),"\xa0parameter is deprecated by\xa0",(0,o.jsx)(n.code,{children:"max_active_tis_per_dag"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"per-queue-tasks-concurrency-airflow",children:"Per queue tasks concurrency airflow"}),"\n",(0,o.jsx)(n.p,{children:"In Apache Airflow, controlling concurrency at different levels is key to managing resources efficiently and ensuring your workflows (DAGs) run smoothly. Concurrency in Airflow refers to the number of tasks or DAGs allowed to run simultaneously. There are several levels at which you can control concurrency:"}),"\n",(0,o.jsx)(n.h3,{id:"1-dag-level-concurrency-max_active_runs",children:"1. DAG Level Concurrency (max_active_runs)"}),"\n",(0,o.jsx)(n.p,{children:"This controls the maximum number of active runs for a DAG. If this number is reached, Airflow will not start new runs of the DAG until others have finished. This is useful for preventing a DAG from consuming too many resources if it's triggered often."}),"\n",(0,o.jsx)(n.h3,{id:"2-task-level-concurrency-concurrency",children:"2. Task Level Concurrency (concurrency)"}),"\n",(0,o.jsx)(n.p,{children:"This sets the maximum number of tasks that can run simultaneously across all instances of a particular DAG. This is useful for managing resource-intensive tasks and ensuring they don't overwhelm your system."}),"\n",(0,o.jsx)(n.h3,{id:"3-dag-concurrency-dag_concurrency",children:"3. DAG Concurrency (dag_concurrency)"}),"\n",(0,o.jsx)(n.p,{children:"This is a global setting in Airflow's configuration that limits the number of tasks that can run concurrently across all DAGs. It's a way to control overall system resource utilization."}),"\n",(0,o.jsx)(n.h3,{id:"4-pool-concurrency",children:"4. Pool Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"Pools are a way to limit concurrency for a group of tasks across multiple DAGs. By assigning tasks to a pool, you can control the maximum number of tasks from that pool that can run at once, regardless of which DAG they belong to. This is especially useful for managing tasks that access a shared resource, like a database, to prevent overloading it."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/pools.html",children:"Pools \u2014 Airflow Documentation"})}),"\n",(0,o.jsx)(n.h3,{id:"implementing-concurrency-controls",children:"Implementing Concurrency Controls"}),"\n",(0,o.jsx)(n.p,{children:"To implement these controls, you would adjust your Airflow configurations or DAG definitions as follows:"}),"\n",(0,o.jsxs)(n.h4,{id:"dag-level-concurrency-max_active_runs",children:["DAG Level Concurrency (",(0,o.jsx)(n.code,{children:"max_active_runs"}),")"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from airflow import DAG\nfrom datetime import datetime\n\ndefault_args = {\n    # Default arguments here\n}\n\ndag = DAG('example_dag',\n          default_args=default_args,\n          description='An example DAG',\n          schedule_interval='0 12 * * *',\n          max_active_runs=2,\n          catchup=False)\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"task-level-concurrency-concurrency",children:["Task Level Concurrency (",(0,o.jsx)(n.code,{children:"concurrency"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["This is set in the Airflow configuration file (",(0,o.jsx)(n.code,{children:"airflow.cfg"}),") under the ",(0,o.jsx)(n.code,{children:"[core]"})," section as ",(0,o.jsx)(n.code,{children:"concurrency"}),". It can also be overridden for each DAG in the DAG definition."]}),"\n",(0,o.jsxs)(n.h4,{id:"dag-concurrency-dag_concurrency",children:["DAG Concurrency (",(0,o.jsx)(n.code,{children:"dag_concurrency"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["Also set in the ",(0,o.jsx)(n.code,{children:"airflow.cfg"})," file under the ",(0,o.jsx)(n.code,{children:"[core]"})," section."]}),"\n",(0,o.jsx)(n.h4,{id:"pool-concurrency",children:"Pool Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"Pools are defined in the Airflow UI under Admin > Pools. You specify the name of the pool and the number of slots it has. To use a pool in a task:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from airflow.operators.dummy_operator import DummyOperator\n\ntask = DummyOperator(\n    task_id='example_task',\n    dag=dag,\n    pool='example_pool'\n)\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"managing-task-queues",children:"Managing Task Queues"}),"\n",(0,o.jsx)(n.p,{children:"Airflow can also control task execution based on queues. Tasks are assigned to queues, and workers pick up tasks based on the queue they are configured to listen to. This can be used to ensure certain workers only execute certain tasks, which can be another way to manage resource allocation and task priority."}),"\n",(0,o.jsx)(n.p,{children:"To specify a queue for a task:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"task = DummyOperator(\n    task_id='example_task',\n    dag=dag,\n    queue='example_queue'\n)\n"})}),"\n",(0,o.jsx)(n.p,{children:"By thoughtfully configuring these concurrency and queue settings, you can optimize Airflow to handle your workloads efficiently, balancing the need for timely execution with the limitations of your system's resources."}),"\n",(0,o.jsx)(n.h2,{id:"increasing-parallelism-vs-number-of-schedulers",children:"Increasing Parallelism vs. Number of Schedulers"}),"\n",(0,o.jsx)(n.h3,{id:"increasing-parallelism",children:"Increasing Parallelism"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Directly increases the number of concurrent tasks managed by a single scheduler."}),"\n",(0,o.jsx)(n.li,{children:"Simpler to implement but has limits based on the scheduler's capacity and system resources."}),"\n",(0,o.jsx)(n.li,{children:"Useful for setups where a single scheduler can handle the workload with increased concurrency."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"increasing-number-of-schedulers",children:"Increasing Number of Schedulers"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Distributes the task execution load across multiple schedulers, enhancing fault tolerance and scalability."}),"\n",(0,o.jsx)(n.li,{children:"Requires additional configuration and management but provides better scalability for large and complex workloads."}),"\n",(0,o.jsx)(n.li,{children:"Essential for highly distributed environments or when a single scheduler becomes a bottleneck."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"whats-the-difference-between-airflow-pool-and-celery-queues",children:"What's the difference between airflow pool and celery queues"}),"\n",(0,o.jsx)(n.p,{children:"Apache Airflow offers several mechanisms to manage the execution and concurrency of tasks, with Airflow Pools and Celery Queues being two of these mechanisms. They serve similar purposes in controlling how tasks are executed but operate in different scopes and manners. Understanding the difference between the two can help in effectively managing task execution and resource allocation."}),"\n",(0,o.jsx)(n.h3,{id:"airflow-pools",children:"Airflow Pools"}),"\n",(0,o.jsx)(n.p,{children:"Airflow Pools are a way to limit the concurrency of a set of tasks across one or more DAGs. They allow you to allocate a specific number of slots to tasks that require similar resources, ensuring that a limited resource (like database connections or memory) isn't overwhelmed by too many tasks at once. When a task is assigned to a pool, it will only run if there is a free slot available in that pool; otherwise, it waits in the queue."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope:"})," Across one or more DAGs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Purpose:"})," To limit the total number of concurrently running tasks that share a common resource to prevent resource overutilization."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configuration:"})," Defined in the Airflow UI or database and assigned to tasks within DAG definitions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case Example:"})," Limiting the number of tasks that can simultaneously execute queries on a database to avoid overloading it."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"celery-queues",children:"Celery Queues"}),"\n",(0,o.jsx)(n.p,{children:"Celery Queues are part of the Celery Executor setup in Airflow, which is used for distributing tasks across multiple workers. Each worker can listen to one or more queues, and tasks can be routed to specific queues. This mechanism allows for the prioritization of tasks, separation of tasks based on their resource requirements, or distribution of tasks across different workers based on their capabilities or workload."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope:"})," Task distribution and execution across multiple workers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Purpose:"})," To distribute tasks among different workers, potentially across different machines, for load balancing, prioritization, or resource-based segregation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configuration:"})," Defined within the DAG file or as part of the task definition, and requires a Celery backend setup."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case Example:"})," Sending image processing tasks to high-CPU workers while routing data analysis tasks to high-memory workers."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Purpose and Functionality:"})," Pools are used to limit concurrency to manage resource utilization within Airflow, ensuring no single resource gets overwhelmed. Celery Queues, on the other hand, are about distributing tasks across workers for load balancing, prioritization, or based on resource capabilities."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Executor Dependency:"})," Airflow Pools work with any executor (LocalExecutor, SequentialExecutor, KubernetesExecutor, etc.), while Celery Queues require the use of the CeleryExecutor."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope of Application:"})," Pools can limit tasks across all DAGs in Airflow, making them a global resource management tool. Celery Queues are more about task distribution and execution strategy, affecting how tasks are processed by workers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management vs. Task Distribution:"})," Pools are directly related to managing access to limited resources (e.g., database connections). Celery Queues are more about managing where and how tasks are executed in a distributed environment."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Both Airflow Pools and Celery Queues are powerful tools for managing task execution in Airflow, and they can be used together to achieve efficient task distribution and resource utilization."}),"\n",(0,o.jsx)(n.h2,{id:"airflow-pool-vs-celery-worker-pool",children:"Airflow Pool vs Celery Worker Pool"}),"\n",(0,o.jsx)(n.h3,{id:"default-pool-in-airflow",children:"Default Pool in Airflow"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Limits the number of tasks that can run concurrently across all DAGs and tasks within an Airflow instance."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope"}),": Controls task-level concurrency within the Airflow environment by managing the number of task slots."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configuration"}),": Managed through the Airflow UI or configuration files; default is 128 slots but can be customized."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),": Ideal for controlling resource allocation and preventing resource contention for tasks within Airflow."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"celery-worker-pool",children:"Celery Worker Pool"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Manages the distribution and execution of tasks across multiple worker nodes in a distributed environment."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope"}),": Operates at the worker node level, handling task execution distributed by the Airflow scheduler."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configuration"}),": Configured via Celery settings, including the number of worker processes and their concurrency."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),": Essential for scaling task execution horizontally by adding more worker nodes, enhancing fault tolerance and scalability."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://www.restack.io/docs/airflow-knowledge-airflow-concurrency-guide",children:"Airflow concurrency essentials \u2014 Restack"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://airflow.apache.org/docs/apache-airflow/stable/faq.html",children:"FAQ \u2014 Airflow Documentation"})}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"airflow.cfg name"}),(0,o.jsx)(n.th,{children:"Environment Variable"}),(0,o.jsx)(n.th,{children:"Default Value"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"parallelism"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AIRFLOW__CORE__PARALLELISM"})}),(0,o.jsx)(n.td,{children:"32"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"dag_concurrency"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AIRFLOW__CORE__DAG_CONCURRENCY"})}),(0,o.jsx)(n.td,{children:"16"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"worker_concurrency"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AIRFLOW__CELERY__WORKER_CONCURRENCY"})}),(0,o.jsx)(n.td,{children:"16"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"max_active_runs_per_dag"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AIRFLOW__CORE__MAX_ACTIVE_RUNS_PER_DAG"})}),(0,o.jsx)(n.td,{children:"16"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"max_threads"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AIRFLOW__SCHEDULER__MAX_THREADS"})}),(0,o.jsx)(n.td,{children:"2"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"parallelism"}),"\xa0is the max number of task instances that can run concurrently on airflow. This means that across all running DAGs, no more than 32 tasks will run at one time."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"dag_concurrency"}),"\xa0is the number of task instances allowed to run concurrently within a\xa0",(0,o.jsx)(n.em,{children:"specific dag"}),". In other words, you could have 2 DAGs running 16 tasks each in parallel, but a single DAG with 50 tasks would also only run 16 tasks - not 32"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"worker_concurrency"}),"\xa0is related, but it determines how many tasks a single celery worker can process. So, if you have 4 workers running at a worker concurrency of 16, you could process up to 16x4=64 tasks at once. Configured with the defaults above, however, only 32 would actually run in parallel. (and only 16 if all tasks are in the same DAG)"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"max_active_runs_per_dag"}),"\xa0The maximum number of active DAG runs per DAG. So if you start a DAG with\xa0",(0,o.jsx)(n.code,{children:"catchup=True"}),", it will start to schedule lot\u2019s of DAG runs concurrently up to this limit."]}),"\n",(0,o.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://forum.astronomer.io/t/dependencies-across-dags/332",children:"Dependencies across DAGs - Airflow - The Apache Airflow Forum by Astronomer"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://docs.astronomer.io/learn/airflow-scaling-workers",children:"Scaling Airflow to optimize performance | Astronomer Documentation"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://towardsdatascience.com/3-steps-to-build-airflow-pipelines-with-efficient-resource-utilisation-b9f399d29fb3",children:"3 steps for Building Airflow Pipelines with Efficient Resource Utilisation | by Vachan Anand | Jul, 2022 | Medium | Towards Data Science"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://hevodata.com/learn/airflow-parallelism",children:"Airflow Parallelism 101: A Comprehensive Guide - Learn | Hevo"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://medium.com/@caxefaizan/be-a-pro-in-scaling-apache-airflow-d9bd3b5c26d0",children:"Be a Pro in Scaling Apache Airflow | by Faizan Qazi | Medium"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(296540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);