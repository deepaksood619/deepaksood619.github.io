"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[22844],{100068:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=s(785893),a=s(511151);const i={},r="Retained Messages",o={id:"networking/mqtt/retained-messages",title:"Retained Messages",description:"In MQTT, the client that publishes a message has no guarantee that a subscribing client actually receives the message. The publishing client can only make sure that the message gets delivered safely to the broker. Basically, the same is true for a subscribing client. The client that connects and subscribes to topics has no guarantee on when the publishing client will publish a message in one of their topics of interest. It can take a few seconds, minutes, or hours for the publisher to send a new message in one of the subscribed topics. Until the next message is published, the subscribing client is totally in the dark about the current status of the topic. This situation is where retained messages come into play.",source:"@site/docs/networking/mqtt/retained-messages.md",sourceDirName:"networking/mqtt",slug:"/networking/mqtt/retained-messages",permalink:"/networking/mqtt/retained-messages",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/networking/mqtt/retained-messages.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"QoS Levels",permalink:"/networking/mqtt/qos-levels"},next:{title:"Scaling",permalink:"/networking/mqtt/scaling"}},h={},d=[{value:"Send a retained message",id:"send-a-retained-message",level:2},{value:"Delete a retained message",id:"delete-a-retained-message",level:2},{value:"Why and when should you use Retained Messages?",id:"why-and-when-should-you-use-retained-messages",level:2},{value:"References",id:"references",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"retained-messages",children:"Retained Messages"}),"\n",(0,n.jsx)(t.p,{children:"In MQTT, the client that publishes a message has no guarantee that a subscribing client actually receives the message. The publishing client can only make sure that the message gets delivered safely to the broker. Basically, the same is true for a subscribing client. The client that connects and subscribes to topics has no guarantee on when the publishing client will publish a message in one of their topics of interest. It can take a few seconds, minutes, or hours for the publisher to send a new message in one of the subscribed topics. Until the next message is published, the subscribing client is totally in the dark about the current status of the topic. This situation is where retained messages come into play."}),"\n",(0,n.jsxs)(t.p,{children:["A retained message is a normal MQTT message with the retained flag set to true. The broker stores the last retained message and the corresponding QoS for that topic.",(0,n.jsx)(t.strong,{children:"Each client that"})," subscribes to a topic pattern that matches the topic of the retained message receives the retained message immediately after they subscribe. The broker stores only one retained message per topic"]}),"\n",(0,n.jsx)(t.p,{children:"Retained messages help newly-subscribed clients get a status update immediately after they subscribe to a topic. The retained message eliminates the wait for the publishing clients to send the next update"}),"\n",(0,n.jsx)(t.p,{children:"In other words, a retained message on a topic is the last known good value. The retained message doesn't have to be the last value, but it must be the last message with the retained flag set to true."}),"\n",(0,n.jsx)(t.p,{children:"It is important to understand that a retained message has nothing to do with persitant session. Once a retained message is stored by the broker, there's only one way to remove it."}),"\n",(0,n.jsx)(t.h2,{id:"send-a-retained-message",children:"Send a retained message"}),"\n",(0,n.jsxs)(t.p,{children:["From the perspective of a developer, sending a retained message is quite simple and straight-forward. You just set the retained flag of a ",(0,n.jsx)(t.a,{href:"https://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe/",children:"MQTT publish message"})," to true. Typically, your client library provides an easy way to set this flag."]}),"\n",(0,n.jsx)(t.h2,{id:"delete-a-retained-message",children:"Delete a retained message"}),"\n",(0,n.jsx)(t.p,{children:"There is also a very simple way to delete the retained message of a topic: send a retained message with a zero-byte payload on the topic where you want to delete the previous retained message. The broker deletes the retained message and new subscribers no longer get a retained message for that topic. Frequently, it is not even necessary to delete, because each new retained message overwrites the previous one."}),"\n",(0,n.jsx)(t.h2,{id:"why-and-when-should-you-use-retained-messages",children:"Why and when should you use Retained Messages?"}),"\n",(0,n.jsxs)(t.p,{children:["A retained message makes sense when you want newly-connected subscribers to receive messages immediately (without waiting until a publishing client sends the next message). This is extremely helpful for status updates of components or devices on individual topics. For example, the status of device1 is on the topic ",(0,n.jsx)(t.code,{children:"myhome/devices/device1/status"}),". When retained messages are used, new subscribers to the topic get the status (online/offline) of the device immediately after they subscribe. The same is true for clients that send data in intervals, temperature, GPS coordinates, and other data. ",(0,n.jsx)(t.strong,{children:"Without retained messages, new subscribers are kept in the dark between publish intervals."})," Using retained messages helps provide the last good value to a connecting client immediately."]}),"\n",(0,n.jsx)(t.h3,{id:"references",children:"References"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages",children:"https://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages"})})]})}function c(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},511151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>r});var n=s(667294);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);