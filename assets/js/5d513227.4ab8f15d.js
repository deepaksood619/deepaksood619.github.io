"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[65440],{744784:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"devops/servers/gunicorn","title":"Gunicorn","description":"Gunicorn was inspired by Ruby\'s Unicorn server (hence the name). It modestly claims that it is \\"simply implemented, light on server resources, and fairly speedy.\\" Unlike Bjoern and CerryPy, Gunicorn is a standalone server. \\"WORKER_COUNT\\" was set to be twice the number of available of processors, plus one. This was based on a recommendation from Gunicorn\'s documentation.","source":"@site/docs/devops/servers/gunicorn.md","sourceDirName":"devops/servers","slug":"/devops/servers/gunicorn","permalink":"/devops/servers/gunicorn","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/servers/gunicorn.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1719081324000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Apache Server","permalink":"/devops/servers/apache-server"},"next":{"title":"NGINX","permalink":"/devops/servers/nginx/"}}');var s=r(474848),o=r(28453);const i={},a="Gunicorn",l={},c=[{value:"Async Workers",id:"async-workers",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Commands",id:"commands",level:2},{value:"Enhancements",id:"enhancements",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Setting up workers",id:"setting-up-workers",level:2},{value:"Others",id:"others",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"gunicorn",children:"Gunicorn"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"http://gunicorn.org/",children:"Gunicorn"}),' was inspired by Ruby\'s Unicorn server (hence the name). It modestly claims that it is "simply implemented, light on server resources, and fairly speedy." Unlike Bjoern and CerryPy, Gunicorn is a standalone server. "WORKER_COUNT" was set to be ',(0,s.jsx)(n.strong,{children:"twice the number of available of processors, plus one"}),". This was based on a recommendation from Gunicorn's documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"async-workers",children:"Async Workers"}),"\n",(0,s.jsxs)(n.p,{children:["You may also want to install ",(0,s.jsx)(n.a,{href:"http://eventlet.net/",children:"Eventlet"})," or ",(0,s.jsx)(n.a,{href:"http://www.gevent.org/",children:"Gevent"})," if you expect that your application code may need to pause for extended periods of time during request processing. Check out the ",(0,s.jsx)(n.a,{href:"http://docs.gunicorn.org/en/stable/design.html",children:"design docs"})," for more information on when you'll want to consider one of the alternate worker types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install greenlet # Required for both\npip install eventlet # For eventlet workers\npip install gunicorn [eventlet] # Or, using extra\npip install gevent # For gevent workers\npip install gunicorn [gevent] # Or, using extra\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://medium.com/@genchilu/brief-introduction-about-the-types-of-worker-in-gunicorn-and-respective-suitable-scenario-67b0c0e7bd62",children:"https://medium.com/@genchilu/brief-introduction-about-the-types-of-worker-in-gunicorn-and-respective-suitable-scenario-67b0c0e7bd62"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://docs.gunicorn.org/en/stable/design.html",children:"http://docs.gunicorn.org/en/stable/design.html"})}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.p,{children:"in order of least to most authoritative:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Framework Settings"}),"\n",(0,s.jsx)(n.li,{children:"Configuration File"}),"\n",(0,s.jsx)(n.li,{children:"Command Line"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"commands",children:"Commands"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install gunicorn [gevent]\n\ngunicorn <app_file>:app -b 0.0.0.0:5000 --workers 3 -k gevent --timeout 300 --worker-connections 1000 --max-requests 1000000 --limit-request-line 8190 --access-logfile /var/log/gunicorn/access.log\n\ngunicorn app:app -b 0.0.0.0:5000 --workers 3 -k gevent --timeout 300 --worker-connections 1000 --max-requests 1000000 --limit-request-line 8190 --access-logfile '-'\n\ngunicorn app:app -b 0.0.0.0:5000 --workers 16 -k gevent --timeout 300 --worker-connections 1000 --graceful-timeout 30 --keep-alive 2 --max-requests 1000000 --max-requests-jitter 100 --limit-request-line 0 --access-logfile '-' --error-logfile '-' --log-level 'info' --access-logformat '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.gunicorn.org/en/stable/settings.html",children:"https://docs.gunicorn.org/en/stable/settings.html"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/benoitc/gunicorn/blob/master/examples/example_config.py",children:"https://github.com/benoitc/gunicorn/blob/master/examples/example_config.py"})}),"\n",(0,s.jsx)(n.h2,{id:"enhancements",children:"Enhancements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"use/dev/shminstead of/tmp"}),"\n",(0,s.jsx)(n.li,{children:"start at least two workers, and probably also start a number of threads using"}),"\n",(0,s.jsx)(n.li,{children:"the gthread worker backend when running in a container"}),"\n",(0,s.jsx)(n.li,{children:"gunicorn --log-file=- ..."}),"\n",(0,s.jsx)(n.li,{children:"you don't always need nginx or another proxy in front Gunicorn"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Gunicorn should only need 4-12 worker processes to handle hundreds or thousands of requests per second."}),"\n",(0,s.jsx)(n.p,{children:"Gunicorn relies on the operating system to provide all of the load balancing when handling requests. Generally we recommend (2x$num_cores)+1 as the number of workers to start off with. While not overly scientific, the formula is based on the assumption that for a given core, one worker will be reading or writing from the socket while the other worker is processing a request."}),"\n",(0,s.jsx)(n.h2,{id:"timeout",children:"Timeout"}),"\n",(0,s.jsx)(n.p,{children:"The gunicorn documentation is not entirely clear to me on this point. For --timeout it says that Workers silent for more than this many seconds are killed and restarted. But it seems that workers are killed after 30sec even though they still produce data?"}),"\n",(0,s.jsx)(n.p,{children:"By silent, we mean silent from the perspective of the arbiter process, which communicates with the workers through a temporary file. If the worker is busy sending data, it does not update that file. From the perspective of the arbiter, the worker is missing heartbeats."}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Gunicorn's main process starts one or more worker processes, and restarts them if they die. To ensure the workers are still alive, Gunicorn has a heartbeat system - which works by using a file on the filesystem. Gunicorn therefore recommends that this file be stored in a memory-only part of the filesystem."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gunicorn starts a single master process that gets forked, and the resulting child processes are the workers."}),"\n",(0,s.jsx)(n.li,{children:"The role of the master process is to make sure that the number of workers is the same as the ones defined in the settings. So if any of the workers die, the master process starts another one, by forking itself again."}),"\n",(0,s.jsx)(n.li,{children:"The role of the workers is to handle HTTP requests."}),"\n",(0,s.jsx)(n.li,{children:"The pre in pre-forked means that the master process creates the workers before handling any HTTP request."}),"\n",(0,s.jsx)(n.li,{children:"The OS kernel handles load balancing between worker processes."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://pythonspeed.com/articles/gunicorn-in-docker",children:"https://pythonspeed.com/articles/gunicorn-in-docker"})}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-workers",children:"Setting up workers"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the application is ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/I/O_bound",children:"I/O bounded"}),', the best performance usually comes from using "pseudo-threads" (gevent or asyncio). As we have seen, Gunicorn supports this programming paradigm by setting the appropriate worker class and adjusting the value of workers to ',(0,s.jsx)(n.code,{children:"(2*CPU)+1"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the application is ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/CPU-bound",children:"CPU bounded"}),", it doesn't matter how many concurrent requests are handled by the application. The only thing that matters is the number of parallel requests. Due to ",(0,s.jsx)(n.a,{href:"https://wiki.python.org/moin/GlobalInterpreterLock",children:"Python's GIL"}),', threads and "pseudo-threads" cannot run in parallel. The only way to achieve parallelism is to increase workers to the suggested ',(0,s.jsx)(n.code,{children:"(2*CPU)+1"}),", understanding that the maximum number of parallel requests is the number of cores."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If there is a concern about the application ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memory_footprint",children:"memory footprint"}),", using threads and its corresponding gthread worker class in favor of workers yields better performance because the application is loaded once per worker and every thread running on the worker shares some memory, this comes to the expense of some additional CPU consumption."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If you don't know you are doing, start with the simplest configuration, which is only setting workers to ",(0,s.jsx)(n.code,{children:"(2*CPU)+1"})," and don't worry about threads. From that point, it's all trial and error with benchmarking. If the bottleneck is memory, start introducing threads. If the bottleneck is I/O, consider a different python programming paradigm. If the bottleneck is CPU, consider using more cores and adjusting the workers value."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://medium.com/building-the-system/gunicorn-3-means-of-concurrency-efbb547674b7",children:"https://medium.com/building-the-system/gunicorn-3-means-of-concurrency-efbb547674b7"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://opstree.com/blog/2024/05/28/solving-timeout-issues-in-python-django-on-kubernetes/",children:"Solving Timeout Issues in Python Django on Kubernetes - DEVOPS DONE RIGHT"})}),"\n",(0,s.jsx)(n.h2,{id:"others",children:"Others"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/blueswen/gunicorn-monitoring/tree/main",children:"GitHub - blueswen/gunicorn-monitoring: Monitor Gunicorn application (e.g. Flask) through build-in instrumentation feature using the statsD protocol over UDP with Prometheus and Grafana."})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(296540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);