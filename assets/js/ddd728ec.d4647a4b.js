"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[69066],{747574:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"computer-science/programming-concepts/type-introspection-and-reflection","title":"Type Introspection and Reflection","description":"Type Introspection","source":"@site/docs/computer-science/programming-concepts/type-introspection-and-reflection.md","sourceDirName":"computer-science/programming-concepts","slug":"/computer-science/programming-concepts/type-introspection-and-reflection","permalink":"/computer-science/programming-concepts/type-introspection-and-reflection","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-concepts/type-introspection-and-reflection.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Programming Styles","permalink":"/computer-science/programming-concepts/programming-styles"},"next":{"title":"Type Systems","permalink":"/computer-science/programming-concepts/type-systems"}}');var i=n(474848),r=n(28453);const c={},a="Type Introspection and Reflection",s={},p=[{value:"Type Introspection",id:"type-introspection",level:2},{value:"Reflection",id:"reflection",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"type-introspection-and-reflection",children:"Type Introspection and Reflection"})}),"\n",(0,i.jsx)(t.h2,{id:"type-introspection",children:"Type Introspection"}),"\n",(0,i.jsx)(t.p,{children:"The ability of a program to examine the type or properties of an object at runtime."}),"\n",(0,i.jsx)(t.p,{children:"Some languages even allow us to traverse the inheritance hierarchy to see if our object is derived from an inherited base class."}),"\n",(0,i.jsx)(t.p,{children:"Ex - Java"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"if(obj instanceof Person){\nPerson p = (Person)obj;\np.walk();\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"reflection",children:"Reflection"}),"\n",(0,i.jsx)(t.p,{children:"The ability to modify object attributes at runtime."}),"\n",(0,i.jsx)(t.p,{children:"Reflection is the ability of a computer program to examine and modify the structure and behavior (specifically the values, meta-data, properties and functions) of a program at runtime."}),"\n",(0,i.jsx)(t.p,{children:"In layman'sterms, what this allows you to dois invoke a method on an object, instantiate a new object, or modify an attribute of an object -- all without knowing the names of the interfaces, fields, methods at compile time."}),"\n",(0,i.jsx)(t.p,{children:"Because of the runtime-specificnature of reflection, it's more difficult to implement reflection in a statically-typed language compared to a dynamically-typed language because type checking occurs at compile time in a statically-typed language instead of at runtime."}),"\n",(0,i.jsx)(t.p,{children:"However it is by no means impossible, as Java, C#, and other modern statically-typed languages allow for both type introspection and reflection (but not C++, which allows only type introspection and not reflection)."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var o=n(296540);const i={},r=o.createContext(i);function c(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);