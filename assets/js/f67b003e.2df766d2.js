"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[81885],{381203:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=r(785893),a=r(511151);const s={},i="2-3 Search Trees",o={id:"data-structures/hierarchical-data-structure/2-3-search-trees",title:"2-3 Search Trees",description:"Properties",source:"@site/docs/data-structures/hierarchical-data-structure/2-3-search-trees.md",sourceDirName:"data-structures/hierarchical-data-structure",slug:"/data-structures/hierarchical-data-structure/2-3-search-trees",permalink:"/data-structures/hierarchical-data-structure/2-3-search-trees",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hierarchical-data-structure/2-3-search-trees.md",tags:[],version:"current",lastUpdatedAt:1681237065,formattedLastUpdatedAt:"Apr 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hierarchical Data Structure",permalink:"/data-structures/hierarchical-data-structure/"},next:{title:"AVL Tree",permalink:"/data-structures/hierarchical-data-structure/avl-tree"}},c={},l=[{value:"Properties",id:"properties",level:2},{value:"Search",id:"search",level:2},{value:"Insertion into a 3-node at bottom",id:"insertion-into-a-3-node-at-bottom",level:2},{value:"Height of a 2-3 tree increases only when root node of the tree splits",id:"height-of-a-2-3-tree-increases-only-when-root-node-of-the-tree-splits",level:2},{value:"Tree height",id:"tree-height",level:2},{value:"Direct implementation is complicated, because",id:"direct-implementation-is-complicated-because",level:2}];function d(e){const t={em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"2-3-search-trees",children:"2-3 Search Trees"}),"\n",(0,n.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Every non-leaf is a 2-node or a 3-node. A 2-node contains one data item and has two children. A 3-node contains two data items and has 3 children."}),"\n",(0,n.jsx)(t.li,{children:"All leaves are at the same level (the bottom level)"}),"\n",(0,n.jsx)(t.li,{children:"All data is kept in sorted order"}),"\n",(0,n.jsxs)(t.li,{children:["Every non-leaf node will contain 1 or 2 fields.",(0,n.jsx)(t.strong,{children:"2-3 Tree"})]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Allow 1 or 2 keys per node -"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"2-node: one key, two children"}),"\n",(0,n.jsx)(t.li,{children:"3-node: two keys, three children"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Symmetric order: Inorder traversal yields keys in ascending order"}),"\n",(0,n.jsx)(t.p,{children:"Perfect balance: Every path from root to null links has same length"}),"\n",(0,n.jsx)(t.p,{children:"Each transformation maintains symmetric order and perfect balance"}),"\n",(0,n.jsx)(t.h2,{id:"search",children:"Search"}),"\n",(0,n.jsx)(t.p,{children:"\u30fbCompare search key against keys in node.\n\u30fbFind interval containing search key.\n\u30fbFollow associated link (recursively)."}),"\n",(0,n.jsx)(t.h2,{id:"insertion-into-a-3-node-at-bottom",children:"Insertion into a 3-node at bottom"}),"\n",(0,n.jsx)(t.p,{children:"\u30fbAdd new key to 3-node to create temporary 4-node.\n\u30fbMove middle key in 4-node into parent.\n\u30fbRepeat up the tree, as necessary.\n\u30fbIf you reach the root and it's a 4-node, split it into three 2-nodes."}),"\n",(0,n.jsx)(t.h2,{id:"height-of-a-2-3-tree-increases-only-when-root-node-of-the-tree-splits",children:"Height of a 2-3 tree increases only when root node of the tree splits"}),"\n",(0,n.jsx)(t.h2,{id:"tree-height",children:"Tree height"}),"\n",(0,n.jsxs)(t.p,{children:["\u30fbWorst case: lg ",(0,n.jsx)(t.em,{children:"N"}),". [all 2-nodes]\n\u30fbBest case: log3 ",(0,n.jsx)(t.em,{children:"N"})," \u2248 .631 lg ",(0,n.jsx)(t.em,{children:"N"}),". [all 3-nodes]\n\u30fbBetween 12 and 20 for a million nodes.\n\u30fbBetween 18 and 30 for a billion nodes."]}),"\n",(0,n.jsx)(t.p,{children:"Guaranteed logarithmic performance for search and insert"}),"\n",(0,n.jsx)(t.h2,{id:"direct-implementation-is-complicated-because",children:"Direct implementation is complicated, because"}),"\n",(0,n.jsx)(t.p,{children:"\u30fbMaintaining multiple node types is cumbersome\n\u30fbNeed multiple compares to move down tree\n\u30fbNeed to move back up the tree to split 4-nodes\n\u30fbLarge number of cases for splitting"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:r(414967).Z+"",width:"1032",height:"596"})})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},414967:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/2-3-Search-Trees-image1-7ce544feec84cd7cef159c4de8717a4e.jpg"},511151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>i});var n=r(667294);const a={},s=n.createContext(a);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);