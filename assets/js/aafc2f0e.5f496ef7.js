"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[55005],{250192:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"technologies/kafka/kafka-partitions","title":"Partitions","description":"In\xa0Apache Kafka\xae,\xa0**partitions**\xa0are the key to scalability and distributed processing. Kafka is\xa0designed as a\xa0**distributed system**, meaning it runs across multiple machines but appears as a single, unified service. If a\xa0topic\xa0were stored entirely on one machine, it would be limited by that machine\'s storage and processing power, capping its scalability.\xa0Partitioning\xa0solves this by splitting a topic\'s log into multiple, smaller logs called\xa0partitions. Each partition is stored separately across different nodes, allowing Kafka to handle far larger amounts of data.","source":"@site/docs/technologies/kafka/kafka-partitions.md","sourceDirName":"technologies/kafka","slug":"/technologies/kafka/kafka-partitions","permalink":"/technologies/kafka/kafka-partitions","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/kafka-partitions.md","tags":[],"version":"current","lastUpdatedBy":"Deeapak Sood","lastUpdatedAt":1765826756000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kafka Message Key","permalink":"/technologies/kafka/kafka-message-key"},"next":{"title":"Kafka Producers","permalink":"/technologies/kafka/kafka-producers"}}');var n=i(474848),s=i(28453);const o={},r="Partitions",l={},d=[{value:"Partition distribution",id:"partition-distribution",level:2},{value:"Some Major Points to Remember in Topics, Partitions, and Offsets",id:"some-major-points-to-remember-in-topics-partitions-and-offsets",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"partitions",children:"Partitions"})}),"\n",(0,n.jsxs)(t.p,{children:["In\xa0",(0,n.jsx)(t.a,{href:"https://www.confluent.io/what-is-apache-kafka/?session_ref=https%3A%2F%2Fdeveloper.confluent.io%2Fcertification%2F%3Futm_medium%3Dsem%26utm_source%3Dgoogle%26utm_campaign%3Dch.sem_br.nonbrand_tp.prs_tgt.dsa_mt.dsa_rgn.apac_sbrgn.india_lng.eng_dv.all_con.confluent-developer%26utm_term%3D%26creative%3D%26device%3Dc%26placement%3D%26gad_source%3D1%26gad_campaignid%3D19560855030%26gbraid%3D0AAAAADRv2c1DOIOBAozJI6eYpioovMyoo%26gclid%3DCj0KCQiA9OnJBhD-ARIsAPV51xMQxq7e-jC0tkvQIDYfH3lARfj6MxXPSd6vORc94KGXIYCsASdOvvcaApazEALw_wcB",children:"Apache Kafka\xae"}),",\xa0",(0,n.jsx)(t.strong,{children:"partitions"}),"\xa0are the key to scalability and distributed processing. Kafka is\xa0",(0,n.jsxs)(t.a,{href:"https://www.confluent.io/learn/distributed-systems/?session_ref=https%3A%2F%2Fdeveloper.confluent.io%2Fcertification%2F%3Futm_medium%3Dsem%26utm_source%3Dgoogle%26utm_campaign%3Dch.sem_br.nonbrand_tp.prs_tgt.dsa_mt.dsa_rgn.apac_sbrgn.india_lng.eng_dv.all_con.confluent-developer%26utm_term%3D%26creative%3D%26device%3Dc%26placement%3D%26gad_source%3D1%26gad_campaignid%3D19560855030%26gbraid%3D0AAAAADRv2c1DOIOBAozJI6eYpioovMyoo%26gclid%3DCj0KCQiA9OnJBhD-ARIsAPV51xMQxq7e-jC0tkvQIDYfH3lARfj6MxXPSd6vORc94KGXIYCsASdOvvcaApazEALw_wcB",children:["designed as a\xa0",(0,n.jsx)(t.strong,{children:"distributed system"})]}),", meaning it runs across multiple machines but appears as a single, unified service. If a\xa0",(0,n.jsx)(t.strong,{children:"topic"}),"\xa0were stored entirely on one machine, it would be limited by that machine's storage and processing power, capping its scalability.\xa0",(0,n.jsx)(t.strong,{children:"Partitioning"}),"\xa0solves this by splitting a topic's log into multiple, smaller logs called\xa0",(0,n.jsx)(t.strong,{children:"partitions"}),". Each partition is stored separately across different nodes, allowing Kafka to handle far larger amounts of data."]}),"\n",(0,n.jsxs)(t.p,{children:["This partitioning introduces some changes to\xa0",(0,n.jsx)(t.strong,{children:"message ordering"}),". Within a single partition, message order is strictly maintained\u2014messages are read in the exact sequence they were written. However,\xa0",(0,n.jsx)(t.strong,{children:"global ordering"}),"\xa0across all partitions is not guaranteed. Messages with the same\xa0",(0,n.jsx)(t.strong,{children:"key"}),"\xa0are always written to the same partition, ensuring order for that key. This is managed through a\xa0",(0,n.jsx)(t.strong,{children:"hashing function"}),": Kafka hashes the key, applies modulo with the number of partitions, and assigns it accordingly. For example, all events from a thermostat with ID\xa042\xa0would consistently go to the same partition, preserving their order."]}),"\n",(0,n.jsxs)(t.p,{children:["If a message has\xa0",(0,n.jsx)(t.strong,{children:"no key"}),", Kafka distributes it using a\xa0",(0,n.jsx)(t.strong,{children:"round-robin"}),"\xa0method, cycling through the partitions evenly. While this balances the load, it also means that messages from the same thermostat may end up in different partitions, losing any guarantee of order. This trade-off is important to understand when designing your data streams."]}),"\n",(0,n.jsxs)(t.p,{children:["Kafka's ability to support\xa0",(0,n.jsx)(t.strong,{children:"millions of partitions"}),"\xa0across a cluster, thanks to KRaft, makes it incredibly scalable. More partitions allow for greater concurrency and parallelism, optimizing throughput and resilience. Understanding how Kafka distributes messages to partitions is crucial for designing efficient, high-throughput applications that preserve order where it matters."]}),"\n",(0,n.jsxs)(t.p,{children:["In short,\xa0",(0,n.jsx)(t.strong,{children:"partitions"}),"\xa0are what enable Kafka to scale massively while maintaining efficient, reliable, and ordered message processing."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Topics are divided into partitions, which are the unit of parallelism in Kafka"}),"\n",(0,n.jsx)(t.li,{children:"Partitions allow messages in a topic to be distributed to multiple servers"}),"\n",(0,n.jsx)(t.li,{children:"A topic can have any number of partitions"}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:"Each partition should fit in a single Kafka server"})}),"\n",(0,n.jsx)(t.li,{children:"The number of partitions decide the parallelism of the topic"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://developer.confluent.io/courses/apache-kafka/partitions/",children:"Intro to Kafka Partitions | Apache Kafka\xae 101"})}),"\n",(0,n.jsx)(t.h2,{id:"partition-distribution",children:"Partition distribution"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Partitions can be distributed across the Kafka cluster"}),"\n",(0,n.jsx)(t.li,{children:"Each Kafka server may handle one or more partitions"}),"\n",(0,n.jsx)(t.li,{children:"A partition can be replicated across serveral servers for fault-tolerance"}),"\n",(0,n.jsx)(t.li,{children:"One server is marked as a leader for the partition and the others are marked as followers"}),"\n",(0,n.jsx)(t.li,{children:"The leader controls the read and write for the partition, whereas the followers replicate the data"}),"\n",(0,n.jsx)(t.li,{children:"If a leader fails, one of the followers automatically become the leader."}),"\n",(0,n.jsx)(t.li,{children:"Zookeeper is used for the leader selection"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"some-major-points-to-remember-in-topics-partitions-and-offsets",children:"Some Major Points to Remember in Topics, Partitions, and Offsets"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Offsets only have a meaning for a specific partition"}),". That means offset number 3 in Partition 0 does not represent the same data or the same message as offset number 3 in partition 1."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Order is going to be guaranteed"})," only from within a partition."]}),"\n",(0,n.jsxs)(t.li,{children:["But across partitions, we have no ordering guarantee. So this is a very important certainty of Kafka is that you\u2019re going to have ",(0,n.jsx)(t.strong,{children:"ordered at the partition level only"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data in Kafka by default is kept only for a limited amount of time"})," and the default is one week. That means that after one week the data is going to be erased from a partition and this allows Kafka to keep on renewing its disk and to make sure it does not run out of disk space."]}),"\n",(0,n.jsxs)(t.li,{children:["Kafka is ",(0,n.jsx)(t.strong,{children:"immutable"}),". That means once the data is written into a partition, it cannot be changed. So if you write the message number 3 in partition 0 you cannot overwrite. So as such, you want to be careful about the kind of data you send to a Kafka topic and your recovery mechanism instead of in case you send bad data."]}),"\n",(0,n.jsx)(t.li,{children:"Also if you don\u2019t provide a key to your message, then when you send a message to a Kafka topic the data is going to be assigned to a random partition."}),"\n",(0,n.jsx)(t.li,{children:"Finally, a topic can have as many partitions as you want but it is not common to have topics with say 10, 20, 30, or 1000 partitions unless you have a truly high throughput topic."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var a=i(296540);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);