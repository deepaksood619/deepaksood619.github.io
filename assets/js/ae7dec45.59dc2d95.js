"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[12422],{554562:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(785893),a=t(511151);const i={},o="Intro",r={id:"databases/concepts/intro",title:"Intro",description:"Choosing the Database",source:"@site/docs/databases/concepts/intro.md",sourceDirName:"databases/concepts",slug:"/databases/concepts/intro",permalink:"/databases/concepts/intro",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/concepts/intro.md",tags:[],version:"current",lastUpdatedAt:1726859634,formattedLastUpdatedAt:"Sep 20, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"History",permalink:"/databases/concepts/history"},next:{title:"Isolation Levels",permalink:"/databases/concepts/isolation-levels"}},c={},l=[{value:"Choosing the Database",id:"choosing-the-database",level:2},{value:"Transactions",id:"transactions",level:2},{value:"Transaction Models",id:"transaction-models",level:2},{value:"Flat Transactions",id:"flat-transactions",level:2},{value:"Transaction Savepoints",id:"transaction-savepoints",level:2},{value:"Nested Transactions",id:"nested-transactions",level:2},{value:"Chained Transactions",id:"chained-transactions",level:2},{value:"Compensating Transactions",id:"compensating-transactions",level:2},{value:"Saga Transactions",id:"saga-transactions",level:2},{value:"Schedule",id:"schedule",level:2},{value:"Serial Schedule",id:"serial-schedule",level:3},{value:"Concurrent Schedule",id:"concurrent-schedule",level:3},{value:"Conflict Serializability in DBMS",id:"conflict-serializability-in-dbms",level:2},{value:"Topics",id:"topics",level:2},{value:"Others",id:"others",level:2}];function h(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"intro",children:"Intro"}),"\n",(0,s.jsx)(n.h2,{id:"choosing-the-database",children:"Choosing the Database"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Instant performance (respond in less than 1ms)"}),"\n",(0,s.jsx)(n.li,{children:"Scalability (Linear and horizontal scaling)"}),"\n",(0,s.jsx)(n.li,{children:"High availability (quickly recover from database failure without loss of data, replication)"}),"\n",(0,s.jsx)(n.li,{children:"Tiered memory support (hottest data in DRAM and warm data in persistent memory)"}),"\n",(0,s.jsx)(n.li,{children:"Simplicity and extensibility"}),"\n",(0,s.jsx)(n.li,{children:"Developer tools"}),"\n",(0,s.jsx)(n.li,{children:"Cloud native"}),"\n",(0,s.jsx)(n.li,{children:"Open source"}),"\n",(0,s.jsx)(n.li,{children:"NoSQL for the future"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(n.p,{children:"A transaction is defined as a sequence of actionsthat are executed on a shared database to perform some higher-level function. It is a basic unit of change in the DBMS. No partial transactions are allowed.\nThere are three categories of actions that the DBMS can execute."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unprotected Actions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Low-level operations on physical resources (e.g., disk, memory). These lack all of the ACID properties except for consistency. Their effects cannot be depended upon."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Protected Actions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These are the high-level changes that the application wants to perform on the database. The DBMS does not externalize their results before they are completely done. Fully ACID."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real Actions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These affect the physical world in a way that is hard or impossible to reverse. For example, if the application sends out an email, then the DBMS cannot retract it."}),"\n",(0,s.jsx)(n.h2,{id:"transaction-models",children:"Transaction Models"}),"\n",(0,s.jsx)(n.p,{children:"A transaction model specifies the execution semantics of protected actions."}),"\n",(0,s.jsx)(n.h2,{id:"flat-transactions",children:"Flat Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Standard transaction model that starts with BEGIN, followed by one or more actions, and then completed with either COMMIT or ROLLBACK. This is what most people think of when discussing transaction support in a DBMS.\nThere are several limitations to flat transactions that motivate us to consider other models. Foremost is that the application can only rollback the entire transaction (i.e., no partial rollbacks). All of a transaction's work is lost if the DBMS fails before that transaction finishes. Each transaction takes place at a single point in time."}),"\n",(0,s.jsx)(n.h2,{id:"transaction-savepoints",children:"Transaction Savepoints"}),"\n",(0,s.jsx)(n.p,{children:"Save the current state of processing for the transaction and provide a handle for the application to refer to that savepoint.The application can control the state of the transaction through these savepoints. The application can create a handle with the SAVEPOINT command during a transaction. It can use ROLLBACK to revert all changes back to the state of the database at a given savepoint. It can also use RELEASE to destroy a savepoint previously defined in the transaction."}),"\n",(0,s.jsx)(n.h2,{id:"nested-transactions",children:"Nested Transactions"}),"\n",(0,s.jsx)(n.p,{children:"The invocation of a transaction during the execution of another transaction. The nested transactions form a hierarchy of work. The outcome of a child transaction depends on the outcome of its parent transaction."}),"\n",(0,s.jsx)(n.h2,{id:"chained-transactions",children:"Chained Transactions"}),"\n",(0,s.jsx)(n.p,{children:"The ability to link multiple transactions one after each other. The combined COMMIT and BEGIN operations between two transactions is atomic. This means that no other transaction can change the state of the databaseas seen by the second transaction from the time that the first transaction commits and the second transaction begins."}),"\n",(0,s.jsx)(n.h2,{id:"compensating-transactions",children:"Compensating Transactions"}),"\n",(0,s.jsx)(n.p,{children:"A special type of transaction that is designed to semantically reverse the effects of another already committed transaction. Such a reversal has to be logical instead of physical."}),"\n",(0,s.jsx)(n.h2,{id:"saga-transactions",children:"Saga Transactions"}),"\n",(0,s.jsx)(n.p,{children:"A sequence of chained transactions T1-Tn and compensating transactions C1-Cn\u22121 where one of the following is guaranteed: The transactions will commit in the order T1,. . .Tj, Cj. . .C1 (where j < n)."}),"\n",(0,s.jsx)(n.h2,{id:"schedule",children:"Schedule"}),"\n",(0,s.jsx)(n.p,{children:"A schedule is a series of operations from one or more transactions. A schedule can be of two types:"}),"\n",(0,s.jsx)(n.h3,{id:"serial-schedule",children:"Serial Schedule"}),"\n",(0,s.jsx)(n.p,{children:"When one transaction completely executes before starting another transaction, the schedule is called serial schedule. A serial schedule is always consistent. e.g.; If a schedule S has debit transaction T1 and credit transaction T2, possible serial schedules are T1 followed by T2 (T1->T2) or T2 followed by T1 ((T1->T2). A serial schedule has low throughput and less resource utilization."}),"\n",(0,s.jsx)(n.h3,{id:"concurrent-schedule",children:"Concurrent Schedule"}),"\n",(0,s.jsx)(n.p,{children:"When operations of a transaction are interleaved with operations of other transactions of a schedule, the schedule is called Concurrent schedule. But concurrency can lead to inconsistency in the database."}),"\n",(0,s.jsx)(n.h2,{id:"conflict-serializability-in-dbms",children:"Conflict Serializability in DBMS"}),"\n",(0,s.jsx)(n.p,{children:"Serial schedules have less resource utilization and low throughput. To improve it, two are more transactions are run concurrently. But concurrency of transactions may lead to inconsistency in database. To avoid this, we need to check whether these concurrent schedules are serializable or not."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Conflict Serializable:"})," A schedule is called conflict serializable if it can be transformed into a serial schedule by swapping non-conflicting operations"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Conflicting operations:"})," Two operations are said to be conflicting if all conditions satisfy"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"They belong to different transactions"}),"\n",(0,s.jsx)(n.li,{children:"They operate on the same data item"}),"\n",(0,s.jsx)(n.li,{children:"At Least one of them is a write operation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conflicting"})," operations pair (R1(A), W2(A)) because they belong to two different transactions on same data item A and one of them is write operation."]}),"\n",(0,s.jsxs)(n.li,{children:["Similarly, (W1(A), W2(A)) and (W1(A), R2(A)) pairs are also ",(0,s.jsx)(n.strong,{children:"conflicting"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["On the other hand, (R1(A), W2(B)) pair is",(0,s.jsx)(n.strong,{children:"non-conflicting"}),"because they operate on different data item."]}),"\n",(0,s.jsxs)(n.li,{children:["Similarly, ((W1(A), W2(B)) pair is",(0,s.jsx)(n.strong,{children:"non-conflicting"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"topics",children:"Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Concurrency Control"}),"\n",(0,s.jsx)(n.li,{children:"Indexing"}),"\n",(0,s.jsx)(n.li,{children:"Storage Models, Compression"}),"\n",(0,s.jsx)(n.li,{children:"Parallel Join Algorithms"}),"\n",(0,s.jsx)(n.li,{children:"Networking Protocols"}),"\n",(0,s.jsx)(n.li,{children:"Logging & Recovery Methods"}),"\n",(0,s.jsx)(n.li,{children:"Query Optimization, Execution, Compilation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"others",children:"Others"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.oracle.com/cd/B19306_01/server.102/b14220/toc.htm",children:"https://docs.oracle.com/cd/B19306_01/server.102/b14220/toc.htm"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78",children:"https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://littlekendra.com",children:"https://littlekendra.com"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.freecodecamp.org/news/watch-a-cornell-university-database-course-for-free/",children:(0,s.jsx)(n.strong,{children:"https://www.freecodecamp.org/news/watch-a-cornell-university-database-course-for-free/"})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=BQBGORBPytw",children:(0,s.jsx)(n.strong,{children:"https://www.youtube.com/watch?v=BQBGORBPytw"})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=ER8oKX5myE0",children:(0,s.jsx)(n.strong,{children:"https://www.youtube.com/watch?v=ER8oKX5myE0"})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Database modeling"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Isolation levels"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},511151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>o});var s=t(667294);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);