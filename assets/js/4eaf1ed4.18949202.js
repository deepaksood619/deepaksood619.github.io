"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[33145],{275187:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"technologies/brokers/vernemq/readme","title":"VerneMQ","description":"VerneMQ is first and foremost a MQTT publish/subscribe message broker which implements the OASIS industry standard MQTT protocol. But VerneMQ is also built to take messaging and IoT applications to the next level by providing a unique set of features related to scalability, reliability and high-performance as well as operational simplicity.","source":"@site/docs/technologies/brokers/vernemq/readme.md","sourceDirName":"technologies/brokers/vernemq","slug":"/technologies/brokers/vernemq/","permalink":"/technologies/brokers/vernemq/","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/brokers/vernemq/readme.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"sMAP","permalink":"/technologies/brokers/smap"},"next":{"title":"Commands","permalink":"/technologies/brokers/vernemq/commands"}}');var t=s(474848),r=s(28453);const o={},a="VerneMQ",l={},d=[{value:"Features",id:"features",level:2},{value:"Internals",id:"internals",level:2},{value:"Routing Score",id:"routing-score",level:2},{value:"Dashboards",id:"dashboards",level:2},{value:"References",id:"references",level:2}];function c(e){const n={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"vernemq",children:"VerneMQ"})}),"\n",(0,t.jsxs)(n.p,{children:["VerneMQ is first and foremost a MQTT publish/subscribe message broker which implements the OASIS industry standard ",(0,t.jsx)(n.a,{href:"https://vernemq.com/intro/mqtt-primer/",children:"MQTT protocol"}),". But VerneMQ is also built to take messaging and IoT applications to the next level by providing a unique set of features related to scalability, reliability and high-performance as well as operational simplicity."]}),"\n",(0,t.jsxs)(n.p,{children:["To achieve these goals VerneMQ is designed from the ground up to work as a distributed message broker, ensuring continued operation in the event of node or network failures and easy horizontal scalability. The underlying technology is a proven ",(0,t.jsx)(n.a,{href:"https://vernemq.com/intro/benefits/erlang.html",children:"telecom grade technology stack"})," providing a rock solid foundation for systems that must be in continuous operation around the clock. It's also able to make efficient use of all available resources as a basis for easy vertical scalability."]}),"\n",(0,t.jsx)(n.p,{children:"VerneMQ uses a master-less clustering technology. There are no special nodes like masters or slaves to consider when the inevitable infrastructure changes or maintenance windows require adding or removing nodes. This makes operating the cluster safe and simple."}),"\n",(0,t.jsx)(n.p,{children:"VerneMQ uses Google's LevelDB as a fast storage backend for messages and subscriber information. Each VerneMQ node runs its own embedded LevelDB store."}),"\n",(0,t.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,t.jsx)(n.p,{children:"VerneMQ implements the MQTT 3.1, 3.1.1 and 5.0 specifications. Currently the following features are implemented and delivered as part of VerneMQ:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"QoS 0, QoS 1, QoS 2"}),"\n",(0,t.jsx)(n.li,{children:"Basic Authentication and Authorization"}),"\n",(0,t.jsx)(n.li,{children:"Bridge Support"}),"\n",(0,t.jsx)(n.li,{children:"$SYS Tree for monitoring and reporting"}),"\n",(0,t.jsx)(n.li,{children:"TLS (SSL) Encryption"}),"\n",(0,t.jsx)(n.li,{children:"Websockets Support"}),"\n",(0,t.jsx)(n.li,{children:"Cluster Support"}),"\n",(0,t.jsx)(n.li,{children:"Logging (Console, Files, Syslog)"}),"\n",(0,t.jsx)(n.li,{children:"Reporting to Graphite"}),"\n",(0,t.jsx)(n.li,{children:"Extensible Plugin architecture"}),"\n",(0,t.jsx)(n.li,{children:"Multiple Sessions per ClientId"}),"\n",(0,t.jsx)(n.li,{children:"Session Balancing"}),"\n",(0,t.jsx)(n.li,{children:"Shared subscriptions"}),"\n",(0,t.jsx)(n.li,{children:"Message load regulation"}),"\n",(0,t.jsx)(n.li,{children:"Message load shedding (for system protection)"}),"\n",(0,t.jsx)(n.li,{children:"Offline Message Storage (based on LevelDB)"}),"\n",(0,t.jsx)(n.li,{children:"Queue can handle messages FIFO or LIFO style."}),"\n",(0,t.jsx)(n.li,{children:"MongoDB auth & integration"}),"\n",(0,t.jsx)(n.li,{children:"Redis auth & integration"}),"\n",(0,t.jsx)(n.li,{children:"MySQL auth & integration"}),"\n",(0,t.jsx)(n.li,{children:"PostgreSQL auth & integration"}),"\n",(0,t.jsx)(n.li,{children:"Memcached integration"}),"\n",(0,t.jsx)(n.li,{children:"HTTP integration"}),"\n",(0,t.jsx)(n.li,{children:"HTTP Webhooks"}),"\n",(0,t.jsx)(n.li,{children:"PROXY Protocol v2"}),"\n",(0,t.jsx)(n.li,{children:"Administration HTTP API (BETA)"}),"\n",(0,t.jsx)(n.li,{children:"Real-time MQTT session tracing"}),"\n",(0,t.jsx)(n.li,{children:"Full multitenancy"}),"\n",(0,t.jsx)(n.li,{children:"Cluster status web page"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The following features are also applies to MQTT 5.0 clients:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enhanced authentication schemes (AUTH)"}),"\n",(0,t.jsx)(n.li,{children:"Message expiration"}),"\n",(0,t.jsx)(n.li,{children:"Last Will and Testament delay"}),"\n",(0,t.jsx)(n.li,{children:"Shared subscriptions"}),"\n",(0,t.jsx)(n.li,{children:"Request/response flow"}),"\n",(0,t.jsx)(n.li,{children:"Topic aliases"}),"\n",(0,t.jsx)(n.li,{children:"Flow control"}),"\n",(0,t.jsx)(n.li,{children:"Subscription flags (Retain as Published, No Local, Retain Handling)"}),"\n",(0,t.jsx)(n.li,{children:"Subscriber identifiers"}),"\n",(0,t.jsx)(n.li,{children:"All property types are supported: user properties, reason strings, content types etc."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"internals",children:"Internals"}),"\n",(0,t.jsx)(n.p,{children:"VerneMQ uses Plumtree for optimistic replication of the metadata, namely subscriber data and retained messages. The Plumtree based metadata storage relies on Merkle trees for its anti-entropy mechanism, that is a background process that ensures the metadata gets synchronized even in the case an update operation was missed. The initialization as well as the ongoing maintenance of such Merkle trees are expensive, especially ifa lotof items are managed by the tree. Moreover, removing items from the tree isn't currently supported (distributed deletes). As a consequence one has to look out to not randomly generate data (e.g. by random MQTT client ids or random topics used in retained messages)."}),"\n",(0,t.jsx)(n.p,{children:"While some of those issues could be solved by improving the way VerneMQ uses Plumtree it would most probably break backward compatibility and would have to wait until 2.0. For this reason we decided to look at better alternatives, one that scales to millions of items, where we could get rid of the Merkle trees, and get a better way to deal with distributed deletes. One promising alternative isServer Wide Clocks (SWC). SWC is a novel distributed algorithm that provides multiple advantages. Namely a new efficient and lightweight anti-entropy mechanism, reduced per-key causality information, andrealdistributed deletes."}),"\n",(0,t.jsx)(n.h2,{id:"routing-score",children:"Routing Score"}),"\n",(0,t.jsx)(n.p,{children:"The routing score consists of two percentages similar to 75 / 25 indicating that 75% of the received MQTT publish frames were routed to local subscribers and 25% were forwarded to subscribers on different cluster nodes. The routing score can be used to detect imbalances in a VerneMQ cluster and optimize your traffic and client partition."}),"\n",(0,t.jsx)(n.h2,{id:"dashboards",children:"Dashboards"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"http://localhost:8888/status",children:"http://localhost:8888/status"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"http://localhost:8888/metrics",children:"http://localhost:8888/metrics"})}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://vernemq.com/intro",children:"https://vernemq.com/intro"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://docs.vernemq.com/configuring-vernemq/storage",children:"https://docs.vernemq.com/configuring-vernemq/storage"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/vernemq/vernemq",children:"https://github.com/vernemq/vernemq"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(296540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);