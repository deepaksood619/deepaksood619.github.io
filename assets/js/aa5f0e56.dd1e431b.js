"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[7880],{637524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=n(785893),s=n(511151);const r={},o="Disjoint-Set Data Structure",a={id:"data-structures/general/disjoint-set-data-structure",title:"Disjoint-Set Data Structure",description:"Also called as union-find data structure or merge-find set, is a DS that keeps track of set of elements partitioned into a number of disjoint (non-overlapping) subset. It provides near constant time operation (bounded by inverse- Ackermann function) to add new sets, to merge existing sets and to determine whether elements are in the same set.",source:"@site/docs/data-structures/general/disjoint-set-data-structure.md",sourceDirName:"data-structures/general",slug:"/data-structures/general/disjoint-set-data-structure",permalink:"/data-structures/general/disjoint-set-data-structure",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/general/disjoint-set-data-structure.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"General",permalink:"/data-structures/general/"},next:{title:"DS Intro",permalink:"/data-structures/general/ds-intro"}},d={},l=[{value:"Representation",id:"representation",level:2},{value:"Operations",id:"operations",level:2},{value:"function <em>MakeSet</em>(<em>x</em>)",id:"function-makesetx",level:2},{value:"function <em>Find</em>(x)",id:"function-findx",level:2},{value:"function <em>Union</em>(x, y)",id:"function-unionx-y",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Applications",id:"applications",level:2},{value:"References",id:"references",level:2}];function h(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"disjoint-set-data-structure",children:"Disjoint-Set Data Structure"}),"\n",(0,i.jsx)(t.p,{children:"Also called as union-find data structure or merge-find set, is a DS that keeps track of set of elements partitioned into a number of disjoint (non-overlapping) subset. It provides near constant time operation (bounded by inverse- Ackermann function) to add new sets, to merge existing sets and to determine whether elements are in the same set."}),"\n",(0,i.jsx)(t.h2,{id:"representation",children:"Representation"}),"\n",(0,i.jsxs)(t.p,{children:["A disjoint set forest consists of a number of elements each of which contains an id, a parent pointer and in efficient algorithms, a value called the rank.\nThe parent pointers of elements are arranged to form one or more ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tree_data_structure",children:"trees"}),", each representing a set. If an element's parent pointer points to no other element, then the element is the root of a tree and is the representative member of its set. A set may consist of only a single element. However, if the element has a parent, the element is part of whatever set is identified by following the chain of parents upwards until a representative element (one without a parent) is reached at the root of the tree.\nForests can be represented compactly in memory as arrays in which parents are indicated by their array index."]}),"\n",(0,i.jsx)(t.h2,{id:"operations",children:"Operations"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"MakeSet"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.em,{children:"MakeSet"}),"operation makes a new set by creating a new element with a unique id, a rank of 0, and a parent pointer to itself. The parent pointer to itself indicates that the element is the representative member of its own set."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.em,{children:"MakeSet"}),"operation hasO(1)time complexity."]}),"\n",(0,i.jsx)(t.p,{children:"Pseudocode:"}),"\n",(0,i.jsxs)(t.h2,{id:"function-makesetx",children:["function ",(0,i.jsx)(t.em,{children:"MakeSet"}),"(",(0,i.jsx)(t.em,{children:"x"}),")"]}),"\n",(0,i.jsxs)(t.p,{children:["if ",(0,i.jsx)(t.em,{children:"x"})," is not already present:\nadd ",(0,i.jsx)(t.em,{children:"x"})," to the disjoint-set tree\nx.parent := x\nx.rank := 0\n2. Find"]}),"\n",(0,i.jsxs)(t.p,{children:["*Find(x)*follows the chain of parent pointers from ",(0,i.jsx)(t.em,{children:"x"})," upwards through the tree until an element is reached whose parent is itself. This element is the root of the tree and is the representative member of the set to which ",(0,i.jsx)(t.em,{children:"x"})," belongs, and may be ",(0,i.jsx)(t.em,{children:"x"})," itself."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Path compression"}),", is a way of flattening the structure of the tree whenever ",(0,i.jsx)(t.em,{children:"Find"}),"is used on it. Since each element visited on the way to a root is part of the same set, all of these visited elements can be reattached directly to the root. The resulting tree is much flatter, speeding up future operations not only on these elements, but also on those referencing them."]}),"\n",(0,i.jsx)(t.p,{children:"Pseudocode:"}),"\n",(0,i.jsxs)(t.h2,{id:"function-findx",children:["function ",(0,i.jsx)(t.em,{children:"Find"}),"(x)"]}),"\n",(0,i.jsxs)(t.p,{children:["if x.parent != x\nx.parent := ",(0,i.jsx)(t.em,{children:"Find"}),"(x.parent)\nreturn x.parent\n3. Union"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.em,{children:["Union(x, y)",(0,i.jsxs)(t.em,{children:["uses ",(0,i.jsx)(t.em,{children:"Find"}),"to determine the roots of the trees ",(0,i.jsx)(t.em,{children:"x"})," and ",(0,i.jsx)(t.em,{children:"y"})," belong to. If the roots are distinct, the trees are combined by attaching the root of one to the root of the other. If this is done naively, such as by always making ",(0,i.jsx)(t.em,{children:"x"})," a child of"]}),"y"]}),", the height of the trees can grow as"]}),"\n",(0,i.jsxs)(t.p,{children:[". To prevent this",(0,i.jsx)(t.em,{children:"union by rank"}),"is used."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Union by rank"}),"always attaches the shorter tree to the root of the taller tree. Thus, the resulting tree is no taller than the originals unless they were of equal height, in which case the resulting tree is taller by one node."]}),"\n",(0,i.jsxs)(t.p,{children:["To implement",(0,i.jsx)(t.em,{children:"union by rank"}),", each element is associated with a rank. Initially a set has one element and a rank of zero. If two sets are unioned and have the same rank, the resulting set's rank is one larger; otherwise, if two sets are unioned and have different ranks, the resulting set's rank is the larger of the two. Ranks are used instead of height or depth because path compression will change the trees' heights over time."]}),"\n",(0,i.jsx)(t.p,{children:"Pseudocode:"}),"\n",(0,i.jsxs)(t.h2,{id:"function-unionx-y",children:["function ",(0,i.jsx)(t.em,{children:"Union"}),"(x, y)"]}),"\n",(0,i.jsxs)(t.p,{children:["xRoot := ",(0,i.jsx)(t.em,{children:"Find"}),"(x)\nyRoot := ",(0,i.jsx)(t.em,{children:"Find"}),"(y)"]}),"\n",(0,i.jsx)(t.p,{children:"// x and y are already in the same set\nif xRoot == yRoot\nreturn"}),"\n",(0,i.jsxs)(t.p,{children:["// x and y are not in same set, so we merge them\nif xRoot.rank < yRoot.rank\nxRoot.parent := yRoot\nelse if xRoot.rank > yRoot.rank\nyRoot.parent := xRoot\nelse\n//Arbitrarily make one root the new parent\nyRoot.parent := xRoot\nxRoot.rank := xRoot.rank + 1 ",(0,i.jsx)(t.strong,{children:"Optimizations"})]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Weighted Union (Union by rank)"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Path Compression during Find"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,i.jsx)(t.p,{children:"Without any optimizations, Union and Find will take O(n)"}),"\n",(0,i.jsx)(t.p,{children:"With both optimizations i.e. Union by Rank and Path Compression, the time complexity is O(x(n)) where x is inverse Ackermann function. This value is < 5 for any value of n that can be written in this physical universe, so disjoint set operations take place in essentially constant time"}),"\n",(0,i.jsx)(t.h2,{id:"applications",children:"Applications"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Crucial role in finding Minimum Spanning Tree of a graph in Kruskal's algorithm."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Keep track of connected components in an undirected graph"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure",children:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure"})})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},511151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>o});var i=n(667294);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);