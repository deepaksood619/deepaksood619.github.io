"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[94115],{181299:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"algorithms/general/union-find-algorithm","title":"Union-Find Algorithm","description":"A union-find algorithm is an algorithm that performs two operations on a disjoint-set data structure -","source":"@site/docs/algorithms/general/union-find-algorithm.md","sourceDirName":"algorithms/general","slug":"/algorithms/general/union-find-algorithm","permalink":"/algorithms/general/union-find-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/general/union-find-algorithm.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Types of algorithms","permalink":"/algorithms/general/types-of-algorithms"},"next":{"title":"Graph Theory","permalink":"/algorithms/graphtheory/"}}');var o=i(474848),s=i(28453);const r={},l="Union-Find Algorithm",a={},d=[{value:"Connected Components - Maximal set of objects that are mutually connected",id:"connected-components---maximal-set-of-objects-that-are-mutually-connected",level:3},{value:"Quick-find (Eager approach)",id:"quick-find-eager-approach",level:3},{value:"Quick-union (lazy approach)",id:"quick-union-lazy-approach",level:3},{value:"Optimizations",id:"optimizations",level:2},{value:"1. Weighted Quick Union (Union by rank / Union by height)",id:"1-weighted-quick-union-union-by-rank--union-by-height",level:3},{value:"2. Path Compression",id:"2-path-compression",level:3},{value:"Complexity",id:"complexity",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"1. Find",id:"1-find",level:3},{value:"2. Union",id:"2-union",level:3},{value:"Applications",id:"applications",level:2},{value:"Union-Find vs DFS",id:"union-find-vs-dfs",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"union-find-algorithm",children:"Union-Find Algorithm"})}),"\n",(0,o.jsx)(e.p,{children:"A union-find algorithm is an algorithm that performs two operations on a disjoint-set data structure -"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Find - Determine which subset a particular element is in."}),"\n",(0,o.jsx)(e.li,{children:"Union - Join two subsets into a single subset."}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["Used for ",(0,o.jsx)(e.strong,{children:"dynamic connectivity"})]}),"\n",(0,o.jsx)(e.p,{children:"Given a set on N objects -"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Union Command - connect two objects"}),"\n",(0,o.jsx)(e.li,{children:"Find/connected query command - is there a path connecting two objects"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:'We assume "is connected to" is an equivalence relation:'}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reflexive: p is connected to p (Connected to itself)"}),"\n",(0,o.jsx)(e.li,{children:"Symmetric: if p is connected to q, then q is connected to p"}),"\n",(0,o.jsx)(e.li,{children:"Transitive: if p is connected to q and q is connected to r, then p is connected to r."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"connected-components---maximal-set-of-objects-that-are-mutually-connected",children:"Connected Components - Maximal set of objects that are mutually connected"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Find query: Check if two objects are in the same component"}),"\n",(0,o.jsx)(e.li,{children:"Union Command: Replace components containing two objects with their union."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"quick-find-eager-approach",children:"Quick-find (Eager approach)"}),"\n",(0,o.jsx)(e.p,{children:"Setting all the id to parent in Union step"}),"\n",(0,o.jsx)(e.h3,{id:"quick-union-lazy-approach",children:"Quick-union (lazy approach)"}),"\n",(0,o.jsx)(e.p,{children:"Only setting the last component's id to parent, Creating a tree like DS whose root represents the parent. Int root(int i) is used for finding the parent and checking if two elements are connected"}),"\n",(0,o.jsx)(e.h2,{id:"optimizations",children:"Optimizations"}),"\n",(0,o.jsx)(e.h3,{id:"1-weighted-quick-union-union-by-rank--union-by-height",children:"1. Weighted Quick Union (Union by rank / Union by height)"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Modify quick-union to avoid tall trees"}),"\n",(0,o.jsx)(e.li,{children:"Keep track of size of each tree"}),"\n",(0,o.jsx)(e.li,{children:"Balance by joining root of smaller tree to root of larger tree"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-path-compression",children:"2. Path Compression"}),"\n",(0,o.jsx)(e.p,{children:"Just after computing the root of p, set the id of each examined node to point to that root."}),"\n",(0,o.jsx)(e.h2,{id:"complexity",children:"Complexity"}),"\n",(0,o.jsx)(e.p,{children:"Without any optimizations, Union and Find will take O(n)"}),"\n",(0,o.jsxs)(e.p,{children:["With both optimizations i.e. Union by Rank and Path Compression, the time complexity is ",(0,o.jsx)(e.code,{children:"O(\u03b1(V))"})," where \u03b1 is inverse Ackermann function. This value is ",(0,o.jsx)(e.code,{children:"< 5"})," for any value of n that can be written in this physical universe, so disjoint set operations take place in essentially constant time"]}),"\n",(0,o.jsxs)(e.p,{children:["Any sequence of M union-find ops on N objects makes ",(0,o.jsx)(e.code,{children:"<= c(N+M lg* N)"})," array acccesses."]}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"N"}),(0,o.jsx)(e.th,{children:"lg* N"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"1"}),(0,o.jsx)(e.td,{children:"0"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"2"}),(0,o.jsx)(e.td,{children:"1"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4"}),(0,o.jsx)(e.td,{children:"2"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"16"}),(0,o.jsx)(e.td,{children:"3"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"65536"}),(0,o.jsx)(e.td,{children:"4"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"2^65536"}),(0,o.jsx)(e.td,{children:"5"})]})]})]}),"\n",(0,o.jsxs)(e.p,{children:["Here ",(0,o.jsx)(e.code,{children:"lg* N"})," is called Iterate log function (It's the number of times you have to take the log event to get 1)."]}),"\n",(0,o.jsxs)(e.p,{children:["Analysis can be improved to ",(0,o.jsx)(e.code,{children:"N + M \u03b1 (M, N)"})]}),"\n",(0,o.jsx)(e.p,{children:"Here \u03b1 is called Ackermann function."}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Algorithm"}),(0,o.jsx)(e.th,{children:"worst-case time"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Quick-find"}),(0,o.jsx)(e.td,{children:"M N"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Weighted QU"}),(0,o.jsx)(e.td,{children:"N + M log N"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"QU + path compression"}),(0,o.jsx)(e.td,{children:"N + M log N"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Weighted QU + path compression"}),(0,o.jsx)(e.td,{children:"N + M lg* N"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:"M union-find operations on a set of N objects"}),"\n",(0,o.jsx)(e.h2,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,o.jsx)(e.h3,{id:"1-find",children:"1. Find"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"function *Find*(x):\n if x.parent != x\n x.parent := *Find*(x.parent)\n return x.parent\n"})}),"\n",(0,o.jsx)(e.h3,{id:"2-union",children:"2. Union"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"function *Union*(x, y):\n\n xRoot := *Find*(x)\n yRoot := *Find*(y)\n\n // x and y are already in the same set\n if xRoot == yRoot\n  return\n\n // x and y are not in same set, so we merge them\n if xRoot.rank < yRoot.rank\n  xRoot.parent := yRoot\n else if xRoot.rank > yRoot.rank\n  yRoot.parent := xRoot\n else\n  //Arbitrarily make one root the new parent\n  yRoot.parent := xRoot\n  xRoot.rank := xRoot.rank + 1\n"})}),"\n",(0,o.jsx)(e.h2,{id:"applications",children:"Applications"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Check whether a graph contains a cycle or not"}),"\n",(0,o.jsx)(e.li,{children:"Percolation"}),"\n",(0,o.jsx)(e.li,{children:"Dynamic Connectivity"}),"\n",(0,o.jsx)(e.li,{children:"Connected Components"}),"\n",(0,o.jsx)(e.li,{children:"Least common ancestor"}),"\n",(0,o.jsx)(e.li,{children:"Equivalence of finite state automata"}),"\n",(0,o.jsx)(e.li,{children:"Kruskal's minimum spanning tree"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"union-find-vs-dfs",children:"Union-Find vs DFS"}),"\n",(0,o.jsx)(e.p,{children:"The union-find algorithm is best suited for situations where the equivalence relationship is changing, i.e., there are \"Union\" operations which need to be performed on your set of partitions. Given a fixed undirected graph, you don't have the equivalence relationships changing at all - the edges are all fixed. OTOH, if you have a graph with new edges being added, DFS won't cut it. While DFS is asymptotically faster than union-find, in practice, the likely deciding factor would be the actual problem that you are trying to solve."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Static graph - DFS"}),"\n",(0,o.jsx)(e.li,{children:"Dynamic graph - Union-find"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var t=i(296540);const o={},s=t.createContext(o);function r(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);