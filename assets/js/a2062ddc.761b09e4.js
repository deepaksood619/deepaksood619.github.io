"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[20949],{591097:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"algorithms/algorithmic-complexity/analysis-of-algorithms","title":"Analysis of Algorithms","description":"Discrete Fourier Transform (FTT - Fast Fourier Transform)","source":"@site/docs/algorithms/algorithmic-complexity/analysis-of-algorithms.md","sourceDirName":"algorithms/algorithmic-complexity","slug":"/algorithms/algorithmic-complexity/analysis-of-algorithms","permalink":"/algorithms/algorithmic-complexity/analysis-of-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/algorithmic-complexity/analysis-of-algorithms.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Algorithmic Complexity","permalink":"/algorithms/algorithmic-complexity/"},"next":{"title":"Complexity Zoo","permalink":"/algorithms/algorithmic-complexity/complexity-zoo"}}');var a=r(474848),s=r(28453);const n={},o="Analysis of Algorithms",l={},d=[{value:"Scientific method",id:"scientific-method",level:2},{value:"Empirical Analysis",id:"empirical-analysis",level:2},{value:"Mathematical Model",id:"mathematical-model",level:2},{value:"Theory of algorithms",id:"theory-of-algorithms",level:2},{value:"Amortized Analysis",id:"amortized-analysis",level:2},{value:"Memory",id:"memory",level:2},{value:"Typical memory usage summary",id:"typical-memory-usage-summary",level:2},{value:"Shallow memory usage: Don&#39;t count referenced objects",id:"shallow-memory-usage-dont-count-referenced-objects",level:3},{value:"Deep memory usage: If array entry or instance variable is a reference, add memory (recursively) for referenced object",id:"deep-memory-usage-if-array-entry-or-instance-variable-is-a-reference-add-memory-recursively-for-referenced-object",level:3},{value:"Space--time or time-memory tradeoff (TMTO)",id:"space--time-or-time-memory-tradeoff-tmto",level:2},{value:"Types of tradeoff",id:"types-of-tradeoff",level:2},{value:"Lookup tables vs. recalculation",id:"lookup-tables-vs-recalculation",level:2},{value:"Compressed vs. uncompressed data",id:"compressed-vs-uncompressed-data",level:2},{value:"Re-rendering vs. stored images",id:"re-rendering-vs-stored-images",level:2},{value:"Smaller code vs. loop unrolling",id:"smaller-code-vs-loop-unrolling",level:2},{value:"Time/memory/data tradeoff attack",id:"timememorydata-tradeoff-attack",level:2}];function c(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"analysis-of-algorithms",children:"Analysis of Algorithms"})}),"\n",(0,a.jsx)(i.p,{children:"Discrete Fourier Transform (FTT - Fast Fourier Transform)"}),"\n",(0,a.jsx)(i.h2,{id:"scientific-method",children:"Scientific method"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Observe"}),"\n",(0,a.jsx)(i.li,{children:"Hypothesis"}),"\n",(0,a.jsx)(i.li,{children:"Predict"}),"\n",(0,a.jsx)(i.li,{children:"Verify"}),"\n",(0,a.jsx)(i.li,{children:"Validate"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"empirical-analysis",children:"Empirical Analysis"}),"\n",(0,a.jsx)(i.p,{children:"Run the program for various input sizes and measure running time"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"3-Sum Problem -"}),"\n",(0,a.jsx)(i.p,{children:"Given N distinct integers, how many triples sum to exactly zero"}),"\n",(0,a.jsx)(i.p,{children:"Brute-force uses n^3 time."}),"\n",(0,a.jsx)(i.p,{children:"Can be solved in n^2 log N"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Sort the N (distinct) numbers"}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"For each pair of numbers a[i] and a[j], binary search for -(a[i] + a[j])"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"1-Sum problem -"}),"\n",(0,a.jsx)(i.p,{children:"How many integers are 0 in an array"}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"2-Sum problem"}),"\n",(0,a.jsx)(i.p,{children:"How many pair integers sum to 0"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"mathematical-model",children:"Mathematical Model"}),"\n",(0,a.jsx)(i.p,{children:"Cost Model"}),"\n",(0,a.jsx)(i.p,{children:"Tilde notation"}),"\n",(0,a.jsx)(i.p,{children:"Estimating a discrete sum (replace sum with an integral, and use calculus)"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"3-Sum Problem can be improved -"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Sort the input array"}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"For each pair of number a[i] and a[j], binary search for -(a[i] + a[j])"}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Order of growth is N^2 log N"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"theory-of-algorithms",children:"Theory of algorithms"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Best Case"}),"\n",(0,a.jsx)(i.li,{children:"Worst Case"}),"\n",(0,a.jsx)(i.li,{children:"Average Case"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"amortized-analysis",children:"Amortized Analysis"}),"\n",(0,a.jsx)(i.p,{children:"Amortized analysisis a method of analyzing the costs associated with a data structure that averages the worst operations out over time. Often, a data structure has one particularly costly operation, but it doesn't get performed very often. That data structure shouldn't be labelled a costly structure just because that one operation, that is seldom performed, is costly."}),"\n",(0,a.jsx)(i.p,{children:"So, amortized analysis is used to average out the costly operations in the worst case. The worst case scenario for a data structure is the absolute worst ordering of operations from a cost perspective. Once that ordering is found, then the operations can be averaged."}),"\n",(0,a.jsxs)(i.p,{children:["There are three main types of amortized analysis",":aggregate"," analysis, theaccounting method, and thepotential method."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://brilliant.org/wiki/amortized-analysis",children:"https://brilliant.org/wiki/amortized-analysis"})}),"\n",(0,a.jsx)(i.h2,{id:"memory",children:"Memory"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"image",src:r(994279).A+"",width:"796",height:"649"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"image",src:r(731704).A+"",width:"793",height:"649"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"image",src:r(522613).A+"",width:"814",height:"650"})}),"\n",(0,a.jsx)(i.h2,{id:"typical-memory-usage-summary",children:"Typical memory usage summary"}),"\n",(0,a.jsx)(i.p,{children:"Total memory. usage for a data type value"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Primitive type: 4 bytes for int, 8 bytes for double, ..."}),"\n",(0,a.jsx)(i.li,{children:"Object reference: 8 bytes"}),"\n",(0,a.jsx)(i.li,{children:"Array: 24 bytes + memory for each array entry"}),"\n",(0,a.jsx)(i.li,{children:"Object: 16 bytes + memory for each instance variable + 8 bytes if inner class (for pointer to enclosing class)"}),"\n",(0,a.jsx)(i.li,{children:"Padding: round up to multiple of 8 bytes"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"shallow-memory-usage-dont-count-referenced-objects",children:"Shallow memory usage: Don't count referenced objects"}),"\n",(0,a.jsx)(i.h3,{id:"deep-memory-usage-if-array-entry-or-instance-variable-is-a-reference-add-memory-recursively-for-referenced-object",children:"Deep memory usage: If array entry or instance variable is a reference, add memory (recursively) for referenced object"}),"\n",(0,a.jsx)(i.h2,{id:"space--time-or-time-memory-tradeoff-tmto",children:"Space--time or time-memory tradeoff (TMTO)"}),"\n",(0,a.jsxs)(i.p,{children:["Aspace--timeortime--memory trade-offin ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"})," is a case where an ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Algorithm",children:"algorithm"})," or ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_program",children:"program"}),(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Trade-off",children:"trades"})," increased space usage with decreased time. Here, spacerefers to the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_storage",children:"data storage"})," consumed in performing a given task (",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Dynamic_random-access_memory",children:"RAM"}),", ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hard_disk_drive",children:"HDD"}),", etc), andtimerefers to the time consumed in performing a given task (",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Time_complexity",children:"computation"})," time or ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Response_time_(technology)",children:"response time"}),")."]}),"\n",(0,a.jsxs)(i.p,{children:["The utility of a given space--time tradeoff is affected by related ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Fixed_cost",children:"fixed"})," and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Variable_costs",children:"variable costs"}),"(of, e.g., ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/CPU",children:"CPU"})," speed, storage space), and is subject to ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Diminishing_returns",children:"diminishing returns"}),"."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff",children:"https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff"})}),"\n",(0,a.jsx)(i.h2,{id:"types-of-tradeoff",children:"Types of tradeoff"}),"\n",(0,a.jsx)(i.h2,{id:"lookup-tables-vs-recalculation",children:"Lookup tables vs. recalculation"}),"\n",(0,a.jsxs)(i.p,{children:["A common situation is an algorithm involving a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Lookup_table",children:"lookup table"}),": an implementation can include the entire table, which reduces computing time, but increases the amount of memory needed, or it can compute table entries as needed, increasing computing time, but reducing memory requirements."]}),"\n",(0,a.jsx)(i.h2,{id:"compressed-vs-uncompressed-data",children:"Compressed vs. uncompressed data"}),"\n",(0,a.jsxs)(i.p,{children:["A space--time tradeoff can be applied to the problem of data storage. If data is stored uncompressed, it takes more space but access takes less time than if the data were stored compressed (since compressing the data reduces the amount of space it takes, but it takes time to run the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_compression",children:"decompression algorithm"}),"). Depending on the particular instance of the problem, either way is practical. There are also rare instances where it is possible to directly work with compressed data, such as in the case of compressed ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bitmap_index",children:"bitmap indices"}),", where it is faster to work with compression than without compression."]}),"\n",(0,a.jsx)(i.h2,{id:"re-rendering-vs-stored-images",children:"Re-rendering vs. stored images"}),"\n",(0,a.jsxs)(i.p,{children:["Storing only the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Scalable_Vector_Graphics",children:"SVG"})," source of a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Vector_graphics",children:"vector image"})," and rendering it as a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bitmap",children:"bitmap image"})," every time the page is requested would be trading time for space; more time used, but less space. Rendering the image when the page is changed and storing the rendered images would be trading space for time; more space used, but less time. This technique is more generally known as ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cache_(computing)",children:"caching"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"smaller-code-vs-loop-unrolling",children:"Smaller code vs. loop unrolling"}),"\n",(0,a.jsxs)(i.p,{children:["Larger code size can be traded for higher program speed when applying ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Loop_unrolling",children:"loop unrolling"}),". This technique makes the code longer for each iteration of a loop, but saves the computation time required for jumping back to the beginning of the loop at the end of each iteration."]}),"\n",(0,a.jsx)(i.h2,{id:"timememorydata-tradeoff-attack",children:"Time/memory/data tradeoff attack"}),"\n",(0,a.jsxs)(i.p,{children:["Atime/memory/data tradeoff attackis a type of ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptanalysis",children:"cryptographic attack"})," where an attacker tries to achieve a situation similar to the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff",children:"space--time tradeoff"})," but with the additional parameter ofdata, representing the amount of data available to the attacker. An attacker balances or reduces one or two of those parameters in favor of the other one or two. This type of attack is very difficult, so most of the ciphers and encryption schemes in use were not designed to resist it."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Time/memory/data_tradeoff_attack",children:"https://en.wikipedia.org/wiki/Time/memory/data_tradeoff_attack"})})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},994279:(e,i,r)=>{r.d(i,{A:()=>t});const t=r.p+"assets/images/Analysis-of-Algorithms-image1-a501f748b0199e90709b4e7b53e3bae4.jpg"},731704:(e,i,r)=>{r.d(i,{A:()=>t});const t=r.p+"assets/images/Analysis-of-Algorithms-image2-73b819832afe0a9fb7a385f7f529f5cb.jpg"},522613:(e,i,r)=>{r.d(i,{A:()=>t});const t=r.p+"assets/images/Analysis-of-Algorithms-image3-e33fcf90ac30dd4b98956e39073ff1b8.jpg"},28453:(e,i,r)=>{r.d(i,{R:()=>n,x:()=>o});var t=r(296540);const a={},s=t.createContext(a);function n(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);