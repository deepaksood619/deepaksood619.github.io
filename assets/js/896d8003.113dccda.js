"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[63043],{245424:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"ai/llm/interview-questions","title":"Interview Questions","description":"Can you provide a high-level overview of Transformers\' architecture?","source":"@site/docs/ai/llm/interview-questions.md","sourceDirName":"ai/llm","slug":"/ai/llm/interview-questions","permalink":"/ai/llm/interview-questions","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/ai/llm/interview-questions.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1746292599000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Top 50 Large Language Model (LLM) Interview","permalink":"/ai/llm/interview-questions-top-50"},"next":{"title":"Intro","permalink":"/ai/llm/intro"}}');var i=t(474848),r=t(28453);const o={},a="Interview Questions",l={},d=[{value:"Can you provide a high-level overview of Transformers&#39; architecture?",id:"can-you-provide-a-high-level-overview-of-transformers-architecture",level:2},{value:"How <em>next sentence prediction (NSP)</em> is used in language modeling?",id:"how-next-sentence-prediction-nsp-is-used-in-language-modeling",level:2},{value:"How can you <em>evaluate the performance</em> of Language Models?",id:"how-can-you-evaluate-the-performance-of-language-models",level:2},{value:"How do <em>generative language models</em> work?",id:"how-do-generative-language-models-work",level:2},{value:"What is a <em>token</em> in the Large Language Models context?",id:"what-is-a-token-in-the-large-language-models-context",level:2},{value:"What&#39;s the advantage of using transformer-based vs LSTM-based architectures in NLP?",id:"whats-the-advantage-of-using-transformer-based-vs-lstm-based-architectures-in-nlp",level:2},{value:"Can you provide some examples of <em>alignment problems</em> in Large Language Models?",id:"can-you-provide-some-examples-of-alignment-problems-in-large-language-models",level:2},{value:"How <em>Adaptative Softmax</em> is useful in Large Language Models?",id:"how-adaptative-softmax-is-useful-in-large-language-models",level:2},{value:"How does BERT <em>training</em> work?",id:"how-does-bert-training-work",level:2},{value:"How is the <em>Transformer Network</em> better than <em>CNNs</em> and <em>RNNs</em>?",id:"how-is-the-transformer-network-better-than-cnns-and-rnns",level:2},{value:"Is there a way to train a Large Language Model (LLM) to store a specific context?",id:"is-there-a-way-to-train-a-large-language-model-llm-to-store-a-specific-context",level:2},{value:"What <em>Transfer learning Techniques</em> can you use in LLMs?",id:"what-transfer-learning-techniques-can-you-use-in-llms",level:2},{value:"What is <em>Transfer Learning</em> and why is it important?",id:"what-is-transfer-learning-and-why-is-it-important",level:2},{value:"What&#39;s the difference between <em>Encoder</em> vs <em>Decoder</em> models?",id:"whats-the-difference-between-encoder-vs-decoder-models",level:2},{value:"What&#39;s the difference between <em>Wordpiece</em> vs <em>BPE</em>?",id:"whats-the-difference-between-wordpiece-vs-bpe",level:2},{value:"What&#39;s the difference between <em>Global</em> and <em>Local Attention</em> in LLMs?",id:"whats-the-difference-between-global-and-local-attention-in-llms",level:2},{value:"What&#39;s the difference between <em>next-token-prediction</em> vs <em>masked-language-modeling</em> in LLM?",id:"whats-the-difference-between-next-token-prediction-vs-masked-language-modeling-in-llm",level:2},{value:"Why a <em>Multi-Head Attention</em> mechanism is needed in a <em>Transformer-based Architecture</em>?",id:"why-a-multi-head-attention-mechanism-is-needed-in-a-transformer-based-architecture",level:2},{value:"Why would you use <em>Encoder-Decoder RNNs</em> vs <em>plain sequence-to-sequence RNNs</em> for <em>automatic translation</em>?",id:"why-would-you-use-encoder-decoder-rnns-vs-plain-sequence-to-sequence-rnns-for-automatic-translation",level:2},{value:"Explain what is <em>Self-Attention</em> mechanism in the Transformer architecture?",id:"explain-what-is-self-attention-mechanism-in-the-transformer-architecture",level:2},{value:"How does <em>Transfer Learning</em> work in LLMs?",id:"how-does-transfer-learning-work-in-llms",level:2},{value:"How does an LLM <em>parameter</em> relate to a <em>weight</em> in a Neural Network?",id:"how-does-an-llm-parameter-relate-to-a-weight-in-a-neural-network",level:2},{value:"What are some downsides of <em>fine-tuning</em> LLMs?",id:"what-are-some-downsides-of-fine-tuning-llms",level:2},{value:"What is the difference between <em>Word Embedding</em>, <em>Position Embedding</em> and <em>Positional Encoding</em> in BERT?",id:"what-is-the-difference-between-word-embedding-position-embedding-and-positional-encoding-in-bert",level:2},{value:"What\u2019s the difference between <em>Feature-based Transfer Learning</em> vs. <em>Fine Tuning</em> in LLMs?",id:"whats-the-difference-between-feature-based-transfer-learning-vs-fine-tuning-in-llms",level:2},{value:"Why do transformers need <em>Positional Encodings</em>?",id:"why-do-transformers-need-positional-encodings",level:2},{value:"What&#39;s the difference between <em>Monotonic alignment</em> and <em>Predictive alignment</em> in transformers?",id:"whats-the-difference-between-monotonic-alignment-and-predictive-alignment-in-transformers",level:2},{value:"What is OpenAI GPT model temperature?",id:"what-is-openai-gpt-model-temperature",level:2},{value:"How exactly does the temperature work?",id:"how-exactly-does-the-temperature-work",level:3},{value:"Rules of thumb for temperature choice",id:"rules-of-thumb-for-temperature-choice",level:3},{value:"Topics",id:"topics",level:2},{value:"Links",id:"links",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"interview-questions",children:"Interview Questions"})}),"\n",(0,i.jsx)(n.h2,{id:"can-you-provide-a-high-level-overview-of-transformers-architecture",children:"Can you provide a high-level overview of Transformers' architecture?"}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s begin by looking at the model as a ",(0,i.jsx)(n.em,{children:"single black box"}),". In a machine translation application, it would take a sentence in one language, and output its translation in another, as illustrated below,"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://jalammar.github.io/images/t/the_transformer_3.png",alt:"image"})}),"\n",(0,i.jsx)(n.p,{children:"Getting closer into the black box, transformers have on the inside:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.strong,{children:"encoding component"}),": which is a stack of ",(0,i.jsx)(n.code,{children:"N"})," encoders."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"decoding component"}),": which is a stack of ",(0,i.jsx)(n.code,{children:"N"})," decoders,"]}),"\n",(0,i.jsxs)(n.li,{children:["and ",(0,i.jsx)(n.strong,{children:"connections between them"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://jalammar.github.io/images/t/The_transformer_encoder_decoder_stack.png",alt:"image"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, each ",(0,i.jsx)(n.strong,{children:"encoder"})," is broken down into two sub-layers: the ",(0,i.jsx)(n.strong,{children:"self-attention layer"})," and the ",(0,i.jsx)(n.strong,{children:"feed-forward neural network layer"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The inputs first flow through a ",(0,i.jsx)(n.strong,{children:"self-attention layer"}),", and the outputs of the ",(0,i.jsx)(n.strong,{children:"self-attention layer"})," are fed to a ",(0,i.jsx)(n.strong,{children:"feed-forward neural network"}),". And this sequence is repeated till reaches the last encoder."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, the ",(0,i.jsx)(n.strong,{children:"decoder"})," receives the output of the ",(0,i.jsx)(n.strong,{children:"encoder component"})," and also has both the ",(0,i.jsx)(n.strong,{children:"self-attention layer"})," and ",(0,i.jsx)(n.strong,{children:"feed-forward layer"}),", and the flow is similar to before, but between them there is an ",(0,i.jsx)(n.strong,{children:"attention layer"})," that helps the decoder focus on relevant parts of the input sentence."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://jalammar.github.io/images/t/Transformer_decoder.png",alt:"image"})}),"\n",(0,i.jsxs)(n.h2,{id:"how-next-sentence-prediction-nsp-is-used-in-language-modeling",children:["How ",(0,i.jsx)(n.em,{children:"next sentence prediction (NSP)"})," is used in language modeling?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next sentence prediction (NSP)"})," is used in language modeling as ",(0,i.jsx)(n.em,{children:"one-half"})," of the training process behind the ",(0,i.jsx)(n.strong,{children:"BERT"})," model (the other half is ",(0,i.jsx)(n.em,{children:"masked-language modeling (MLM)"}),"). The objective of next-sentence prediction training is to predict whether one sentence logically follows the other sentence presented to the model."]}),"\n",(0,i.jsxs)(n.p,{children:["During training, the model is presented with pairs of sentences, some of which are consecutive in the original text, and some of which are not. The model is then trained to predict whether a given pair of sentences are adjacent or not. This allows the model to ",(0,i.jsx)(n.strong,{children:"understand longer-term dependencies across sentences"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Researchers have found that without ",(0,i.jsx)(n.strong,{children:"NSP"}),", ",(0,i.jsx)(n.strong,{children:"BERT"})," performs worse on every single metric - so its use it\u2019s relevant to language modeling."]}),"\n",(0,i.jsxs)(n.h2,{id:"how-can-you-evaluate-the-performance-of-language-models",children:["How can you ",(0,i.jsx)(n.em,{children:"evaluate the performance"})," of Language Models?"]}),"\n",(0,i.jsxs)(n.p,{children:["There are two ways to evaluate language models in ",(0,i.jsx)(n.strong,{children:"NLP"}),": ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Extrinsic evaluation"})})," and ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Intrinsic evaluation"})}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Intrinsic evaluation"})," captures how well the model captures what it is supposed to capture, like probabilities."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extrinsic evaluation"})," (or task-based evaluation) captures how useful the model is in a particular task."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["A common ",(0,i.jsx)(n.strong,{children:"intrinsic evaluation"})," of ",(0,i.jsx)(n.strong,{children:"LM"})," is the ",(0,i.jsx)(n.strong,{children:"perplexity"}),". It's a geometric average of the inverse probability of words predicted by the model. Intuitively, perplexity means to be ",(0,i.jsx)(n.em,{children:"surprised"}),". We measure ",(0,i.jsx)(n.em,{children:"how much the model is surprised"})," by seeing new data. The lower the perplexity, the better the training is. Another common measure is the ",(0,i.jsx)(n.strong,{children:"cross-entropy"}),", which is the Logarithm (base ",(0,i.jsx)(n.code,{children:"2"}),") of ",(0,i.jsx)(n.em,{children:"perplexity"}),". As a thumb rule, a reduction of ",(0,i.jsx)(n.code,{children:"10-20%"})," in perplexity is noteworthy."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"extrinsic evaluation"})," will depend on the task. Example: For ",(0,i.jsx)(n.em,{children:"speech recognition"}),", we can compare the performance of two language models by running the speech recognizer twice, once with each language model, and seeing which gives the more accurate transcription."]}),"\n",(0,i.jsxs)(n.h2,{id:"how-do-generative-language-models-work",children:["How do ",(0,i.jsx)(n.em,{children:"generative language models"})," work?"]}),"\n",(0,i.jsxs)(n.p,{children:["The very basic idea is the following: they take ",(0,i.jsx)(n.code,{children:"n"})," tokens as input, and produce ",(0,i.jsx)(n.code,{children:"one"})," token as output."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:828/format:webp/1*zaRZlVk-dl0zVUOe0g_ufg.png",alt:"image"})}),"\n",(0,i.jsx)(n.p,{children:"A token is a chunk of text. In the context of OpenAI GPT models, common and short words typically correspond to a single token and long and less commonly used words are generally broken up into several tokens."}),"\n",(0,i.jsxs)(n.p,{children:["This basic idea is applied in an ",(0,i.jsx)(n.em,{children:"expanding-window pattern"}),". You give it ",(0,i.jsx)(n.code,{children:"n"})," tokens in, it produces ",(0,i.jsx)(n.code,{children:"one"})," token out, then it incorporates that output token as part of the input of the next iteration, produces a new token out, and so on. This pattern keeps repeating until a stopping condition is reached, indicating that it finished generating all the text you need."]}),"\n",(0,i.jsx)(n.p,{children:"Now, behind the output is a probability distribution over all the possible tokens. What the model does is return a vector in which each entry expresses the probability of a particular token being chosen."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:828/format:webp/1*UZ_hexQINPnJV14HWLorAg.png",alt:"image"})}),"\n",(0,i.jsx)(n.p,{children:"This probability distribution comes from the training phase. During training, the model is exposed to a lot of text, and its weights are tuned to predict good probability distributions, given a sequence of input tokens."}),"\n",(0,i.jsx)(n.p,{children:"GPT generative models are trained with a large portion of the internet, so their predictions reflect a mix of the information they\u2019ve seen."}),"\n",(0,i.jsxs)(n.h2,{id:"what-is-a-token-in-the-large-language-models-context",children:["What is a ",(0,i.jsx)(n.em,{children:"token"})," in the Large Language Models context?"]}),"\n",(0,i.jsxs)(n.p,{children:["ChatGPT and other LLMs rely on input text being broken into pieces. Each piece is about a word-sized sequence of characters or smaller. We call those sub-word tokens. That process is called ",(0,i.jsx)(n.em,{children:"tokenization"})," and is done using a ",(0,i.jsx)(n.em,{children:"tokenizer"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tokens"}),' can be words or just chunks of characters. For example, the word "hamburger" gets broken up into the tokens "ham", "bur" and "ger", while a short and common word like "pear" is a single token. Many tokens start with whitespace, for example, " hello" and " bye".']}),"\n",(0,i.jsx)(n.p,{children:"The models understand the statistical relationships between these tokens and excel at producing the next token in a sequence of tokens."}),"\n",(0,i.jsxs)(n.p,{children:["The number of tokens processed in a given API request depends on the length of both your inputs and outputs. As a rough rule of thumb, the ",(0,i.jsx)(n.code,{children:"1"})," token is approximately ",(0,i.jsx)(n.code,{children:"4"})," characters or ",(0,i.jsx)(n.code,{children:"0.75"})," words for English text."]}),"\n",(0,i.jsx)(n.p,{children:"Consider:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:1400/1*yM5gg3cPHDvo7AAqDZryZA.png",alt:"https://miro.medium.com/v2/resize:fit:1400/1*yM5gg3cPHDvo7AAqDZryZA.png"})}),"\n",(0,i.jsx)(n.h2,{id:"whats-the-advantage-of-using-transformer-based-vs-lstm-based-architectures-in-nlp",children:"What's the advantage of using transformer-based vs LSTM-based architectures in NLP?"}),"\n",(0,i.jsxs)(n.p,{children:["To create ",(0,i.jsx)(n.strong,{children:"sequence-to-sequence"})," models before the ",(0,i.jsx)(n.strong,{children:"Transformer"}),", we used the famous ",(0,i.jsx)(n.strong,{children:"LSTM"})," with its ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Encoder-Decoder architecture"})}),", where"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['The "',(0,i.jsx)(n.strong,{children:"Encoder"}),'" part that creates a ',(0,i.jsx)(n.em,{children:"vector representation"})," of a ",(0,i.jsx)(n.em,{children:"sequence of words"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:['The "',(0,i.jsx)(n.strong,{children:"Decoder"}),'" returns a ',(0,i.jsx)(n.em,{children:"sequence of words"})," from the ",(0,i.jsx)(n.em,{children:"vector representation"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"LSTM"})," model takes into account the ",(0,i.jsx)(n.strong,{children:"interdependence of words"}),", so we need inputs of the previous state to make any operations on the current state. This model has a limitation: it is relatively slow to train and the input sequence can't be passed in parallel."]}),"\n",(0,i.jsxs)(n.p,{children:["Now, the idea of the ",(0,i.jsx)(n.strong,{children:"Transformer"})," is to maintain the ",(0,i.jsx)(n.strong,{children:"interdependence of the words"})," in a sequence without using a recurrent network but only the ",(0,i.jsx)(n.strong,{children:"attention mechanism"})," that is at the center of its architecture. The ",(0,i.jsx)(n.strong,{children:"attention"})," measures ",(0,i.jsx)(n.strong,{children:"how closely two elements of two sequences are related"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In transformer-based architectures, the attention mechanism is applied to a ",(0,i.jsx)(n.em,{children:"single sequence"})," (also known as a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"self-attention layer"})}),"). The ",(0,i.jsx)(n.strong,{children:"self-attention layer"})," determines the ",(0,i.jsx)(n.strong,{children:"interdependence of different words"}),' in the same sequence, to associate a relevant representation with it. Take for example the sentence: "',(0,i.jsx)(n.em,{children:"The dog didn't cross the street because it was too tired"}),'". It is obvious to a human being that "',(0,i.jsx)(n.em,{children:"it"}),'" refers to the "',(0,i.jsx)(n.em,{children:"dog"}),'" and not to the "',(0,i.jsx)(n.em,{children:"street"}),'". The objective of the self-attention process will therefore be to detect the link between "',(0,i.jsx)(n.em,{children:"dog"}),'" and "',(0,i.jsx)(n.em,{children:"it"}),'". This feature makes transformers much faster to train compared to their predecessors, and they have been proven to be more robust against noisy and missing data.']}),"\n",(0,i.jsxs)(n.p,{children:["As a plus, in ",(0,i.jsx)(n.strong,{children:"contextual embeddings"}),", transformers can draw information from the context to correct missing or noisy data and that is something that other neural networks couldn\u2019t offer."]}),"\n",(0,i.jsxs)(n.h2,{id:"can-you-provide-some-examples-of-alignment-problems-in-large-language-models",children:["Can you provide some examples of ",(0,i.jsx)(n.em,{children:"alignment problems"})," in Large Language Models?"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"alignment problem"})," refers to the extent to which a model's goals and behavior align with human values and expectations."]}),"\n",(0,i.jsxs)(n.p,{children:["Large Language Models, such as ",(0,i.jsx)(n.code,{children:"GPT-3"}),", are trained on vast amounts of text data from the internet and are capable of generating human-like text, but they may not always produce output that is consistent with human expectations or desirable values."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"alignment problem"})," in Large Language Models typically manifests as:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lack of helpfulness"}),": when the model is not following the user's explicit instructions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hallucinations"}),": when the model is making up unexisting or wrong facts."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lack of interpretability"}),": when it is difficult for humans to understand how the model arrived at a particular decision or prediction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Generating biased or toxic output"}),": when a language model that is trained on biased/toxic data may reproduce that in its output, even if it was not explicitly instructed to do so."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"how-adaptative-softmax-is-useful-in-large-language-models",children:["How ",(0,i.jsx)(n.em,{children:"Adaptative Softmax"})," is useful in Large Language Models?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Adaptive softmax"})," is useful in large language models because it allows for efficient training and inference when dealing with ",(0,i.jsx)(n.em,{children:"large vocabularies"}),". ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Traditional softmax"})})," involves computing probabilities for ",(0,i.jsx)(n.em,{children:"each word"})," in the vocabulary, which can become computationally expensive as the vocabulary size grows."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Adaptive softmax"})," reduces the number of computations required by grouping words together into clusters based on ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"how common the words are"})}),". This reduces the number of computations required to compute the probability distribution over the vocabulary."]}),"\n",(0,i.jsx)(n.p,{children:"Therefore, by using adaptive softmax, large language models can be trained and run more efficiently, allowing for faster experimentation and development."}),"\n",(0,i.jsxs)(n.h2,{id:"how-does-bert-training-work",children:["How does BERT ",(0,i.jsx)(n.em,{children:"training"})," work?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"BERT"})," (",(0,i.jsx)(n.em,{children:"Bidirectional Encoder Representations from Transformers"}),") utilizes a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"transformer architecture"})})," that learns contextual relationships between words in a text and since BERT\u2019s goal is to generate a language representation model, it only needs the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"encoder"})})," part."]}),"\n",(0,i.jsxs)(n.p,{children:["The input to the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"encoder"})})," for ",(0,i.jsx)(n.strong,{children:"BERT"})," is a sequence of ",(0,i.jsx)(n.em,{children:"tokens"}),", which are first converted into ",(0,i.jsx)(n.em,{children:"vectors"})," and then processed in the neural network. Then, the ",(0,i.jsx)(n.strong,{children:"BERT"})," algorithm makes use of the following two training techniques:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Masked LM (MLM)"}),": Before feeding word sequences into ",(0,i.jsx)(n.strong,{children:"BERT"}),", a percentage of the words in each sequence are replaced with a ",(0,i.jsx)(n.code,{children:"[MASK]"})," token. The model then attempts to predict the original value of the masked words, based on the context provided by the other, non-masked, words in the sequence."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Next Sentence Prediction (NSP)"}),": the model concatenates two masked sentences as inputs during pretraining. Sometimes they correspond to sentences that were next to each other in the original text, and sometimes not. The model then has to predict if the two sentences were following each other or not."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Now, to help the model distinguish between the two sentences in training, the input is processed with some extra metadata such as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Token embeddings"})}),": A ",(0,i.jsx)(n.code,{children:"[CLS]"})," token is inserted at the beginning of the first sentence and a ",(0,i.jsx)(n.code,{children:"[SEP]"})," token is inserted at the end of each sentence."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Segment embeddings"})}),": these assign markers to identify each sentence and allows the encoder to distinguish between them."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Positional embeddings"})}),": to indicate the token position in the sentence."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Then, to predict if the second sentence is indeed connected to the first, the following steps are performed:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The entire input sequence goes through the ",(0,i.jsx)(n.em,{children:"Transformer model"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The output of the ",(0,i.jsx)(n.code,{children:"[CLS]"})," token is transformed into a ",(0,i.jsx)(n.code,{children:"2\xd71"})," shaped vector, using a simple ",(0,i.jsx)(n.em,{children:"classification layer"})," (learned matrices of weights and biases)."]}),"\n",(0,i.jsxs)(n.li,{children:["Calculating the probability of ",(0,i.jsx)(n.code,{children:"IsNextSequence"})," with ",(0,i.jsx)(n.em,{children:"softmax"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When training the ",(0,i.jsx)(n.strong,{children:"BERT"})," model, ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Masked LM"})})," and ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Next Sentence Prediction"})})," are trained together, with the goal of minimizing the combined loss function of the two strategies."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:780/1*vUuxeQKHA5RHaaZ8-oVQ_A.png",alt:"https://miro.medium.com/v2/resize:fit:780/1*vUuxeQKHA5RHaaZ8-oVQ_A.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"how-is-the-transformer-network-better-than-cnns-and-rnns",children:["How is the ",(0,i.jsx)(n.em,{children:"Transformer Network"})," better than ",(0,i.jsx)(n.em,{children:"CNNs"})," and ",(0,i.jsx)(n.em,{children:"RNNs"}),"?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["With ",(0,i.jsx)(n.strong,{children:"RNN"}),", you have to go ",(0,i.jsx)(n.em,{children:"word by word"})," to access to the cell of the last word. If the network is formed with a long reach, it may take several steps to remember, each masked state (output vector in a word) depends on the previous masked state. This becomes a major problem for GPUs. This sequentiality is an obstacle to the parallelization of the process. In addition, in cases where such sequences are too long, the model tends to forget the contents of the distant positions one after the other or to mix with the contents of the following positions. In general, whenever ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"long-term dependencies"})})," are involved, we know that ",(0,i.jsx)(n.strong,{children:"RNN"})," suffers from the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Vanishing Gradient Problem"})}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Early efforts were trying to solve the dependency problem with ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"sequential convolutions"})})," for a solution to the ",(0,i.jsx)(n.strong,{children:"RNN"}),". A long sequence is taken and the convolutions are applied. The disadvantage is that ",(0,i.jsx)(n.strong,{children:"CNN"})," approaches require many layers to capture long-term dependencies in the sequential data structure, without ever succeeding or making the network so large that it would eventually become impractical."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"Transformer"})," presents a new approach, it proposes to ",(0,i.jsx)(n.em,{children:"encode"})," each word and apply the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"mechanism of attention"})})," in order to connect two distant words, then the ",(0,i.jsx)(n.em,{children:"decoder"})," predicts the sentences according to all the words preceding the current word. This workflow can be parallelized, accelerating learning and solving the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"long-term dependencies"})})," problem."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"is-there-a-way-to-train-a-large-language-model-llm-to-store-a-specific-context",children:"Is there a way to train a Large Language Model (LLM) to store a specific context?"}),"\n",(0,i.jsxs)(n.p,{children:['The only way at the moment to "memorize" past conversations is to ',(0,i.jsx)(n.strong,{children:"include past conversations in the prompt"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Consider:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"\nYou are a friendly support person. The customer will ask you questions, and you will provide polite responses\n\nQ: My phone won't start. What do I do? &lt;-- This is a past question\n\nA: Try plugging your phone into the charger for an hour and then turn it on. The most common cause for a phone not starting is that the battery is dead.\n\nQ: I've tried that. What else can I try? &lt;-- This is a past question\n\nA: Hold the button for 15 seconds. It may need a reset.\n\nQ: I did that. It worked, but the screen is blank. &lt;-- This is a current question\n\nA:\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You will hit a token limit at some point (if you chat long enough). Each GPT-3 model has a ",(0,i.jsx)(n.a,{href:"https://platform.openai.com/docs/models/gpt-3",children:"maximum number of tokens"})," you can pass to it. In the case of ",(0,i.jsx)(n.code,{children:"text-davinci-003"}),", it is ",(0,i.jsx)(n.code,{children:"4096"})," tokens. When you hit this limit, the OpenAI API will throw an error."]}),"\n",(0,i.jsxs)(n.h2,{id:"what-transfer-learning-techniques-can-you-use-in-llms",children:["What ",(0,i.jsx)(n.em,{children:"Transfer learning Techniques"})," can you use in LLMs?"]}),"\n",(0,i.jsxs)(n.p,{children:["There are several ",(0,i.jsx)(n.strong,{children:"Transfer Learning"})," techniques that are commonly used in ",(0,i.jsx)(n.strong,{children:"LLMs"}),". Here are three of the most popular:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature-based transfer learning"}),": This technique involves using a pre-trained language model as a ",(0,i.jsx)(n.em,{children:"feature extractor"}),", and then training a separate model on top of the extracted features for the target task."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fine-tuning"}),": involves taking a pre-trained language model and training it on a ",(0,i.jsx)(n.em,{children:"specific task"}),". Sometimes when fine-tuning, you can keep the model weights fixed and just add a new layer that you will train. Other times you can slowly unfreeze the layers one at a time. You can also use unlabelled data when pre-training, by masking words and trying to predict which word was masked."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-task learning"}),": involves training a single model on multiple related tasks simultaneously. The idea is that the model will learn to share information across tasks and improve performance on each individual task as a result."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"what-is-transfer-learning-and-why-is-it-important",children:["What is ",(0,i.jsx)(n.em,{children:"Transfer Learning"})," and why is it important?"]}),"\n",(0,i.jsxs)(n.p,{children:["A pre-trained model, such as GPT-3, essentially takes care of massive amounts of hard work for the developers: It teaches the model to do a basic understanding of the problem and provides solutions in a ",(0,i.jsx)(n.em,{children:"generic"})," format."]}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.strong,{children:"transfer learning"}),", given that the pre-trained models can generate basic solutions, we can ",(0,i.jsx)(n.em,{children:"transfer the learning to another context"}),". As a result, we will be able to customize the model to our requirements using fine-tuning without the need to retrain the entire model."]}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-encoder-vs-decoder-models",children:["What's the difference between ",(0,i.jsx)(n.em,{children:"Encoder"})," vs ",(0,i.jsx)(n.em,{children:"Decoder"})," models?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Encoder models"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["They use only the ",(0,i.jsx)(n.em,{children:"encoder"})," of a ",(0,i.jsx)(n.strong,{children:"Transformer model"}),". At each stage, the attention layers can access ",(0,i.jsx)(n.strong,{children:"all the words"})," in the ",(0,i.jsx)(n.strong,{children:"initial sentence"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The pretraining of these models usually revolves around somehow ",(0,i.jsx)(n.em,{children:"corrupting"})," a given sentence (for instance, by ",(0,i.jsx)(n.em,{children:"masking"})," random words in it) and tasking the model with ",(0,i.jsx)(n.strong,{children:"finding or reconstructing"})," the initial sentence."]}),"\n",(0,i.jsxs)(n.li,{children:["They are best suited for tasks requiring an ",(0,i.jsx)(n.strong,{children:"understanding of the full sentence"}),", such as sentence classification, named entity recognition (and more general word classification), and extractive question answering."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decoder models"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["They use only the ",(0,i.jsx)(n.em,{children:"decoder"})," of a ",(0,i.jsx)(n.strong,{children:"Transformer model"}),". At each stage, for a given word the attention layers ",(0,i.jsx)(n.strong,{children:"can only access the words positioned before it in the sentence"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The pretraining of decoder models usually revolves around ",(0,i.jsx)(n.strong,{children:"predicting"})," the next word in the sentence."]}),"\n",(0,i.jsxs)(n.li,{children:["They are best suited for tasks involving ",(0,i.jsx)(n.strong,{children:"text generation"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:1400/1*cfNpm7aDO4lD3e-Wkwgc1g.png",alt:"https://miro.medium.com/v2/resize:fit:1400/1*cfNpm7aDO4lD3e-Wkwgc1g.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-wordpiece-vs-bpe",children:["What's the difference between ",(0,i.jsx)(n.em,{children:"Wordpiece"})," vs ",(0,i.jsx)(n.em,{children:"BPE"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"WordPiece"})," and ",(0,i.jsx)(n.strong,{children:"BPE"})," are both ",(0,i.jsx)(n.em,{children:"subword tokenization algorithms"}),". They work by breaking down words into smaller units, called subwords. We then define a desired ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"vocabulary size"})})," and keep adding subwords till the limit is reached."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BPE"})," starts with a vocabulary of all the characters in the training data. It then ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"iteratively merges"})})," the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"most frequent pairs"})})," of characters until the desired ",(0,i.jsx)(n.em,{children:"vocabulary size"})," is reached. The merging is done ",(0,i.jsx)(n.em,{children:"greedily"}),", meaning that the most frequent pair of characters is always merged first."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"WordPiece"})," also starts with a vocabulary of all the characters in the training data. It then uses a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"statistical model"})})," to choose the pair of characters that is most likely to improve the likelihood of the training data until the ",(0,i.jsx)(n.em,{children:"vocab size"})," is reached."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-global-and-local-attention-in-llms",children:["What's the difference between ",(0,i.jsx)(n.em,{children:"Global"})," and ",(0,i.jsx)(n.em,{children:"Local Attention"})," in LLMs?"]}),"\n",(0,i.jsxs)(n.p,{children:['Consider the example sentence "',(0,i.jsx)(n.em,{children:"Where is Wally"}),'" which should be translated to its Italian counterpart "',(0,i.jsx)(n.em,{children:"Dove \xe8 Wally"}),'". In the transformer architecture, the ',(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"encoder"})})," processes the input word by word, producing three different ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"hidden states"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Then, the ",(0,i.jsx)(n.strong,{children:"attention layer"})," produces a single fixed-size ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"context vector"})}),' from all the encoder hidden states (often with a weighted sum) and it represents the "',(0,i.jsx)(n.em,{children:"attention"}),'" that must be given to that context when processing such input word. Here is when ',(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"global"})})," and ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"local"})})," attention comes into play."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Global attention"})," considers ",(0,i.jsx)(n.em,{children:"all the hidden"})," states in creating the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"context vector"})}),". When is applied, a lot of computation occurs. This is because all the hidden states must be taken into consideration, concatenated into a matrix, and processed by a ",(0,i.jsx)(n.strong,{children:"NN"})," to compute their weights."]}),"\n",(0,i.jsxs)(n.p,{children:["On the other hand, ",(0,i.jsx)(n.strong,{children:"local attention"})," considers ",(0,i.jsx)(n.em,{children:"only a subset"})," of all the hidden states in creating the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"context vector"})}),". The subset can be obtained in many different ways, such as with ",(0,i.jsx)(n.strong,{children:"Monotonic Alignment"})," and ",(0,i.jsx)(n.strong,{children:"Predictive Alignment"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:1200/0*eOBSEK6zMxz-S5kK.jpeg",alt:"https://miro.medium.com/v2/resize:fit:1200/0*eOBSEK6zMxz-S5kK.jpeg"})}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-next-token-prediction-vs-masked-language-modeling-in-llm",children:["What's the difference between ",(0,i.jsx)(n.em,{children:"next-token-prediction"})," vs ",(0,i.jsx)(n.em,{children:"masked-language-modeling"})," in LLM?"]}),"\n",(0,i.jsx)(n.p,{children:"Both are techniques for training large language models and involve predicting a word in a sequence of words."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next token prediction"}),": the model is given a sequence of words with the goal of predicting the next word. For example, given the phrase ",(0,i.jsx)(n.em,{children:"Hannah is a ____"}),", the model would try to predict:"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Hannah is a sister"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Hannah is a friend"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Hannah is a marketer"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Hannah is a comedian"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Masked-language-modeling"}),": the model is given a sequence of words with the goal of predicting a ",(0,i.jsx)(n.em,{children:"masked"})," word in the middle. For example, given the phrase, ",(0,i.jsx)(n.em,{children:"Jako mask reading"}),", the model would try to fill the gap as,"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Jacob fears reading"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Jacob loves reading"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Jacob enjoys reading"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Jacon hates reading"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"why-a-multi-head-attention-mechanism-is-needed-in-a-transformer-based-architecture",children:["Why a ",(0,i.jsx)(n.em,{children:"Multi-Head Attention"})," mechanism is needed in a ",(0,i.jsx)(n.em,{children:"Transformer-based Architecture"}),"?"]}),"\n",(0,i.jsx)(n.p,{children:"Take for example the sentence:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Bark is very cute and he is a dog."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Here, if we take the word \u2018",(0,i.jsx)(n.code,{children:"dog"}),"\u2019, grammatically we understand that the words \u2018",(0,i.jsx)(n.code,{children:"Bark"}),"\u2019, \u2018",(0,i.jsx)(n.code,{children:"cute"}),"\u2019, and \u2018",(0,i.jsx)(n.code,{children:"he"}),"\u2019 should have some significance or relevance with the word \u2018",(0,i.jsx)(n.code,{children:"dog"}),"\u2019. These words say that the dog\u2019s name is Bark, it is a male dog, and that he is a cute dog."]}),"\n",(0,i.jsxs)(n.p,{children:["In simple terms, just one attention mechanism may not be able to correctly identify these three words as relevant to \u2018",(0,i.jsx)(n.code,{children:"dog"}),"\u2019, and we can sense that three attentions are better here to signify the three words with the word \u2018",(0,i.jsx)(n.code,{children:"dog"}),"\u2019."]}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, to overcome some of the pitfalls of using ",(0,i.jsx)(n.strong,{children:"single attention"}),", ",(0,i.jsx)(n.strong,{children:"multi-head attention"})," is used. This reduces the load on one attention to find all significant words and also increases the chances of finding more relevant words easily."]}),"\n",(0,i.jsxs)(n.h2,{id:"why-would-you-use-encoder-decoder-rnns-vs-plain-sequence-to-sequence-rnns-for-automatic-translation",children:["Why would you use ",(0,i.jsx)(n.em,{children:"Encoder-Decoder RNNs"})," vs ",(0,i.jsx)(n.em,{children:"plain sequence-to-sequence RNNs"})," for ",(0,i.jsx)(n.em,{children:"automatic translation"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"plain sequence-to-sequence RNN"})," would start translating a sentence ",(0,i.jsx)(n.em,{children:"immediately"})," after reading the first word of a sentence, while an ",(0,i.jsx)(n.strong,{children:"Encoder-Decoder RNN"})," will first ",(0,i.jsx)(n.em,{children:"read the whole sentence"})," and then translate it."]}),"\n",(0,i.jsxs)(n.p,{children:['In general, if you translate a sentence one word at a time, the result will be terrible. For example, the french sentence "',(0,i.jsx)(n.em,{children:"Je vous en prie"}),'" means "',(0,i.jsx)(n.em,{children:"You are welcome"}),'" but if you translate it one word at a time using ',(0,i.jsx)(n.em,{children:"plain sequence-to-sequence RNN"}),', you get "',(0,i.jsx)(n.em,{children:"I you in pray"}),'" which it does not have sense. So in automatic translation cases is much better to use ',(0,i.jsx)(n.em,{children:"Encoder-Decoder RNNs"})," to read the whole sentence first and then translate it."]}),"\n",(0,i.jsxs)(n.h2,{id:"explain-what-is-self-attention-mechanism-in-the-transformer-architecture",children:["Explain what is ",(0,i.jsx)(n.em,{children:"Self-Attention"})," mechanism in the Transformer architecture?"]}),"\n",(0,i.jsxs)(n.p,{children:["We can think of ",(0,i.jsx)(n.strong,{children:"self-attention"})," as a mechanism that enhances the information content of an input embedding by ",(0,i.jsx)(n.em,{children:"including information about the input\u2019s context"}),". In other words, the self-attention mechanism enables the model to weigh the importance of different elements in an input sequence and dynamically adjust their influence on the output."]}),"\n",(0,i.jsxs)(n.p,{children:["Imagine that we have a text ",(0,i.jsx)(n.em,{children:"x"}),", which we convert from raw text using an embedding algorithm. To then apply the attention, we map a query (",(0,i.jsx)(n.em,{children:"q"}),") as well as a set of key-value pairs (",(0,i.jsx)(n.em,{children:"k"}),", ",(0,i.jsx)(n.em,{children:"v"}),") to our output ",(0,i.jsx)(n.em,{children:"x"}),". Both ",(0,i.jsx)(n.em,{children:"q"}),", ",(0,i.jsx)(n.em,{children:"k"}),", as well as v, are vectors. The result ",(0,i.jsx)(n.em,{children:"z"})," is called the attention-head and is then sent along a simple feed-forward neural network."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://sebastianraschka.com/images/blog/2023/self-attention-from-scratch/transformer.png",alt:"https://sebastianraschka.com/images/blog/2023/self-attention-from-scratch/transformer.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"how-does-transfer-learning-work-in-llms",children:["How does ",(0,i.jsx)(n.em,{children:"Transfer Learning"})," work in LLMs?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transfer learning"})," in ",(0,i.jsx)(n.strong,{children:"LLMs"})," involves training a language model on a ",(0,i.jsx)(n.em,{children:"large corpus of text"}),", and then ",(0,i.jsx)(n.strong,{children:"fine-tuning"})," the model on a specific task. The process involves several steps:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pre-training"}),": In this step, the language model is trained on a large corpus of text to learn the patterns and relationships within the language. The goal of pre-training is to generate a set of ",(0,i.jsx)(n.strong,{children:"general-purpose"})," language representations that can be used for a wide range of NLP tasks."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Fine-tuning"}),": Once the language model is pre-trained, it can be fine-tuned on a ",(0,i.jsx)(n.strong,{children:"specific NLP task"}),", such as sentiment analysis or text classification. Fine-tuning involves taking the pre-trained model and training it on a smaller dataset specific to the target task. The goal of fine-tuning is to adapt the general-purpose language representations to the specific task at hand."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Inference"}),": Once the model is fine-tuned, it can be used to make predictions on new data. During inference, the model takes in the input text and generates an output that represents the model\u2019s prediction for the task at hand."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://www.researchgate.net/publication/342547232/figure/fig4/AS:907957101404162@1593485250772/The-concept-of-the-transfer-learning.png",alt:"https://www.researchgate.net/publication/342547232/figure/fig4/AS:907957101404162@1593485250772/The-concept-of-the-transfer-learning.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"how-does-an-llm-parameter-relate-to-a-weight-in-a-neural-network",children:["How does an LLM ",(0,i.jsx)(n.em,{children:"parameter"})," relate to a ",(0,i.jsx)(n.em,{children:"weight"})," in a Neural Network?"]}),"\n",(0,i.jsx)(n.p,{children:'Yes, the parameters in a large language model (LLM) are similar to the weights in a standard neural network. In both LLMs and neural networks, these parameters are numerical values that start as random coefficients and are adjusted during training to minimize loss. These parameters include not only the weights that determine the strength of connections between neurons but also the biases, which affect the output of neurons. In a large language model (LLM) like GPT-4 or other transformer-based models, the term "parameters" refers to the numerical values that determine the behavior of the model. These parameters include weights and biases, which together define the connections and activations of neurons within the model. Here\'s a more detailed explanation:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Weights"}),": Weights are numerical values that define the strength of connections between neurons across different layers in the model. In the context of LLMs, weights are primarily used in the attention mechanism and the feedforward neural networks that make up the model's architecture. They are adjusted during the training process to optimize the model's ability to generate relevant and coherent text."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Biases"}),": Biases are additional numerical values that are added to the weighted sum of inputs before being passed through an activation function. They help to control the output of neurons and provide flexibility in the model's learning process. Biases can be thought of as a way to shift the activation function to the left or right, allowing the model to learn more complex patterns and relationships in the input data."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The training process involves adjusting these parameters (weights and biases) iteratively to minimize the loss function. This is typically done using gradient descent or a variant thereof, such as stochastic gradient descent or Adam optimizer. The loss function measures the difference between the model's predictions and the true values (e.g., the correct next word in a sentence). By minimizing the loss, the model learns to generate text that closely resembles the patterns in its training data."}),"\n",(0,i.jsx)(n.p,{children:'Researchers often use the term "parameters" instead of "weights" to emphasize that both weights and biases play a crucial role in the model\'s learning process.'}),"\n",(0,i.jsxs)(n.h2,{id:"what-are-some-downsides-of-fine-tuning-llms",children:["What are some downsides of ",(0,i.jsx)(n.em,{children:"fine-tuning"})," LLMs?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fine-tuning"})," requires manually creating tons of data, and the model may memorize portions of the data you provide."]}),"\n",(0,i.jsx)(n.li,{children:"Every time you want to add a new capability, instead of adding a few lines to a prompt, you need to create a bunch of fake data and then run the finetune process and then use the newly fine-tuned model."}),"\n",(0,i.jsx)(n.li,{children:"It is more expensive."}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"what-is-the-difference-between-word-embedding-position-embedding-and-positional-encoding-in-bert",children:["What is the difference between ",(0,i.jsx)(n.em,{children:"Word Embedding"}),", ",(0,i.jsx)(n.em,{children:"Position Embedding"})," and ",(0,i.jsx)(n.em,{children:"Positional Encoding"})," in BERT?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Word embedding"})})," is a learned lookup map i.e. ",(0,i.jsx)(n.em,{children:"every word"})," is given a ",(0,i.jsx)(n.em,{children:"one hot encoding"})," which then functions as an ",(0,i.jsx)(n.em,{children:"index"}),", and the corresponding to this index is a ",(0,i.jsx)(n.code,{children:"n"})," ",(0,i.jsx)(n.em,{children:"dimensional vector"})," where the coefficients are learned when training the model."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"Positional embedding"})," is similar to a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"word embedding"})}),". Except it is the ",(0,i.jsx)(n.em,{children:"position"})," in the ",(0,i.jsx)(n.em,{children:"sentence"})," is used as the index, rather than the one hot encoding. Those positions then correspond to a ",(0,i.jsx)(n.code,{children:"n"}),"-vector whose coefficients come from the trained model."]}),"\n",(0,i.jsxs)(n.li,{children:["On the other hand, the ",(0,i.jsx)(n.strong,{children:"Positional encoding"})," is a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"static function"})})," that maps an integer input to real-valued vectors in a way that captures the inherent relationships among the positions. That is, it captures the fact that position ",(0,i.jsx)(n.code,{children:"4"})," in input is more closely related to position ",(0,i.jsx)(n.code,{children:"5"})," than it is to position ",(0,i.jsx)(n.code,{children:"17"}),". In other words, ",(0,i.jsx)(n.strong,{children:"positional encoding"})," is not learned but a chosen mathematical function, ",(0,i.jsx)(n.code,{children:"N -> R^n"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-feature-based-transfer-learning-vs-fine-tuning-in-llms",children:["What\u2019s the difference between ",(0,i.jsx)(n.em,{children:"Feature-based Transfer Learning"})," vs. ",(0,i.jsx)(n.em,{children:"Fine Tuning"})," in LLMs?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["In ",(0,i.jsx)(n.strong,{children:"Feature-based Transfer Learning"}),", you can train ",(0,i.jsx)(n.em,{children:"word embeddings"})," by running a ",(0,i.jsxs)(n.strong,{children:["model ",(0,i.jsx)(n.code,{children:"A"})]})," and then using those features from model ",(0,i.jsx)(n.code,{children:"A"})," (i.e. ",(0,i.jsx)(n.em,{children:"word vectors"}),") on a ",(0,i.jsx)(n.strong,{children:"different task"}),", or model ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["When ",(0,i.jsx)(n.strong,{children:"Fine Tuning"}),", you can use the exact ",(0,i.jsxs)(n.strong,{children:["same model ",(0,i.jsx)(n.code,{children:"A"})]})," and just run it on a ",(0,i.jsx)(n.strong,{children:"different task"}),". Sometimes when fine-tuning, you can keep the model weights fixed and just add a new layer that you will train. Other times you can slowly unfreeze the layers one at a time. You can also use unlabelled data when pre-training, by masking words and trying to predict which word was masked."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://miro.medium.com/v2/resize:fit:828/format:webp/0*n49fDyrzIEeiUXqG.jpeg",alt:"image"})}),"\n",(0,i.jsxs)(n.h2,{id:"why-do-transformers-need-positional-encodings",children:["Why do transformers need ",(0,i.jsx)(n.em,{children:"Positional Encodings"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:['Consider the input sentence - "',(0,i.jsx)(n.em,{children:"I am good"}),'".']}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.strong,{children:"RNNs"}),", we feed the sentence to the network ",(0,i.jsx)(n.em,{children:"word by word"}),'. That is, first the word "',(0,i.jsx)(n.code,{children:"I"}),'" is passed as input, next the word "',(0,i.jsx)(n.code,{children:"am"}),'" is passed, and so on. We feed the sentence word by word so that our network understands the sentence completely.']}),"\n",(0,i.jsxs)(n.p,{children:["But with the ",(0,i.jsx)(n.strong,{children:"transformer network"}),", we don't follow the recurrence mechanism. So, instead of feeding the sentence word by word, we feed all the words in the sentence ",(0,i.jsx)(n.strong,{children:"parallel"})," to the network. Feeding the words in parallel helps in decreasing the training time and also helps in learning the long-term dependency."]}),"\n",(0,i.jsx)(n.p,{children:"When we feed the words parallel to the transformer, the word order (position of the words in the sentence) is important. So, we should give some information about the word order to the transformer so that it can understand the sentence."}),"\n",(0,i.jsxs)(n.p,{children:["If we pass the input matrix directly to the transformer, it cannot understand the word order. So, instead of feeding the input matrix directly to the transformer, we need to add some information indicating the word order (position of the word) so that our network can understand the meaning of the sentence. To do this, we introduce a technique called ",(0,i.jsx)(n.strong,{children:"positional encoding"}),". Positional encoding, as the name suggests, is an ",(0,i.jsx)(n.strong,{children:"encoding"})," indicating the position of the word in a sentence (word order)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://machinelearningmastery.com/wp-content/uploads/2022/01/PE6.png",alt:"https://machinelearningmastery.com/wp-content/uploads/2022/01/PE6.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"whats-the-difference-between-monotonic-alignment-and-predictive-alignment-in-transformers",children:["What's the difference between ",(0,i.jsx)(n.em,{children:"Monotonic alignment"})," and ",(0,i.jsx)(n.em,{children:"Predictive alignment"})," in transformers?"]}),"\n",(0,i.jsx)(n.h2,{id:"what-is-openai-gpt-model-temperature",children:"What is OpenAI GPT model temperature?"}),"\n",(0,i.jsx)(n.p,{children:"Temperature is a parameter of OpenAI ChatGPT, GPT-3 and GPT-4 models that governs the randomness and thus the creativity of the responses."}),"\n",(0,i.jsx)(n.p,{children:"It is always a number between 0 and 1. A temperature of 0 means the responses will be very straightforward, almost deterministic (meaning you almost always get the same response to a given prompt) A temperature of 1 means the responses can vary wildly."}),"\n",(0,i.jsx)(n.h3,{id:"how-exactly-does-the-temperature-work",children:"How exactly does the temperature work?"}),"\n",(0,i.jsx)(n.p,{children:"Under the hood, large language models try to predict the next best word given a prompt. One word at a time. They assign a probability to each word in their vocabulary, and then picks a word among those."}),"\n",(0,i.jsx)(n.p,{children:'A temperature of 0 means roughly that the model will always select the highest probability word. A higher temperature means that the model might select a word with slightly lower probability, leading to more variation, randomness and creativity. A very high temperature therefore increases the risk of "hallucination", meaning that the AI starts selecting words that will make no sense or be offtopic.'}),"\n",(0,i.jsx)(n.p,{children:"Since all characters count, the ratio of words to tokens is language dependent."}),"\n",(0,i.jsx)(n.h3,{id:"rules-of-thumb-for-temperature-choice",children:"Rules of thumb for temperature choice"}),"\n",(0,i.jsx)(n.p,{children:"Your choice of temperature should depend on the task you are giving GPT."}),"\n",(0,i.jsx)(n.p,{children:"For transformation tasks (extraction, standardization, format conversion, grammar fixes) prefer a temperature of 0 or up to 0.3. For writing tasks, you should juice the temperature higher, closer to 0.5. If you want GPT to be highly creative (for marketing or advertising copy for instance), consider values between 0.7 and 1."}),"\n",(0,i.jsx)(n.p,{children:"If you want to experiment and create many variations quickly, a high temperature is better."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://gptforwork.com/guides/openai-gpt3-temperature",children:"How to use OpenAI GPT-3 temperature \u2022 Gptforwork.com"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://platform.openai.com/docs/guides/flex-processing",children:"Flex processing - OpenAI Platform"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Flex processing provides significantly lower costs for\xa0",(0,i.jsx)(n.a,{href:"https://platform.openai.com/docs/api-reference/chat",children:"Chat Completions"}),"\xa0or\xa0",(0,i.jsx)(n.a,{href:"https://platform.openai.com/docs/api-reference/responses",children:"Responses"}),"\xa0requests in exchange for slower response times and occasional resource unavailability. It is ideal for non-production or lower-priority tasks such as model evaluations, data enrichment, or asynchronous workloads."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"topics",children:"Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"token embeddings"}),"\n",(0,i.jsx)(n.li,{children:"positional embeddings"}),"\n",(0,i.jsx)(n.li,{children:"self-attention"}),"\n",(0,i.jsx)(n.li,{children:"transformers"}),"\n",(0,i.jsx)(n.li,{children:"intuitive understanding of Q, K, V"}),"\n",(0,i.jsx)(n.li,{children:"causal and multi-head attention"}),"\n",(0,i.jsx)(n.li,{children:"temperature, top-k, top-p"}),"\n",(0,i.jsx)(n.li,{children:"classification & instruction fine-tuning"}),"\n",(0,i.jsx)(n.li,{children:"rotary positional encoding (RoPE)"}),"\n",(0,i.jsx)(n.li,{children:"KV Cache"}),"\n",(0,i.jsx)(n.li,{children:"infini-attention (long context windows)"}),"\n",(0,i.jsxs)(n.li,{children:["mixture of experts (MoE)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://youtu.be/pctR3sdCJgQ",children:"Mixture of Memory Experts (MoME) | Data Brew | Episode 36"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"grouped query attention"}),"\n",(0,i.jsx)(n.li,{children:"basic understanding of llama-2 architecture and techniques which is actually a recap of all the previous subjects"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.mlstack.cafe/blog/large-language-models-llms-interview-questions",children:"MLStack.Cafe - Kill Your Next Machine Learning, Data Science & Python Interview. Find your next ML Job."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://medium.com/machine-learning-mindset/top-20-interview-questions-answers-on-llms-generative-ai-42a2e16cb276",children:"Top 20 Interview Questions & Answers on LLMs & Generative AI | by amirsina torfi | Machine Learning Mindset | Nov, 2023 | Medium"})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(296540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);