"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[49240],{934116:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>h,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=t(785893),r=t(511151);const s={},a="Cryptography Terms",o={id:"computer-science/security/cryptography/cryptography-terms",title:"Cryptography Terms",description:"Cryptographic Techniques",source:"@site/docs/computer-science/security/cryptography/cryptography-terms.md",sourceDirName:"computer-science/security/cryptography",slug:"/computer-science/security/cryptography/cryptography-terms",permalink:"/computer-science/security/cryptography/cryptography-terms",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/security/cryptography/cryptography-terms.md",tags:[],version:"current",lastUpdatedAt:1707138374,formattedLastUpdatedAt:"Feb 5, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cryptographic Hash Functions",permalink:"/computer-science/security/cryptography/cryptographic-hash-functions"},next:{title:"Diffie-Hellman Key Exchange",permalink:"/computer-science/security/cryptography/diffie-hellman-key-exchange"}},h={},c=[{value:"Cryptographic Techniques",id:"cryptographic-techniques",level:2},{value:"Semantic Security",id:"semantic-security",level:2},{value:"Forward Secrecy",id:"forward-secrecy",level:2},{value:"Envelope Encryption",id:"envelope-encryption",level:2},{value:"How does this work ?",id:"how-does-this-work-",level:2},{value:"Initialization vector",id:"initialization-vector",level:2},{value:"MAC (Message Authentication Code)",id:"mac-message-authentication-code",level:2},{value:"Message Integrity Codes (MIC) / MACs (Message Authentication Code)",id:"message-integrity-codes-mic--macs-message-authentication-code",level:2},{value:"HMAC (Hash MAC)",id:"hmac-hash-mac",level:2}];function d(e){const i={a:"a",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"cryptography-terms",children:"Cryptography Terms"}),"\n",(0,n.jsx)(i.h2,{id:"cryptographic-techniques",children:"Cryptographic Techniques"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Substitution - is one in which the letters of the plaintext are replace by other letters"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Mono Alphabetic Substitution"}),"\n",(0,n.jsx)(i.li,{children:"Poly Alphabetic Substitution"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Transposition (Permutation) - Method of disguising text or alphabet by shuffling or exchanging their position"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"CSPRNGs (Cryptographically Secure Pseudo-Random Number Generators), also known as Deterministic Random Bit Generators (DRBGs)"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"PRNG (Psuedo-random)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Generates a random number with an even distribution"}),"\n",(0,n.jsx)(i.li,{children:'Can be seeded to "re-roll" the same random values'}),"\n",(0,n.jsx)(i.li,{children:"Random.new and rand()"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Gaussian/Normal distribution"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:'Generates random numbers but distributes them closed to the "center" mark of zero'}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Perlin Noise"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Takes an (x), (x,y), (x,y,z) coordinate and returns a value from Float32",":Max"," to Float32",":Min"]}),"\n",(0,n.jsx)(i.li,{children:"Attempts to normally distribute, at least from my understanding of the rubygem I ported"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"semantic-security",children:"Semantic Security"}),"\n",(0,n.jsxs)(i.p,{children:["In ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptography",children:"cryptography"}),", asemantically secure ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptosystem",children:"cryptosystem"})," is one where only negligible information about the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Plaintext",children:"plaintext"})," can be feasibly extracted from the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Ciphertext",children:"ciphertext"}),". Specifically, any ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/PP_(complexity)",children:"probabilistic, polynomial-time algorithm"}),"(PPTA) that is given the ciphertext of a certain messagem (taken from any distribution of messages), and the message's length, cannot determine any partial information on the message with probability ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Negligible_function",children:"non-negligibly"})," higher than all other PPTA's that only have access to the message length (and not the ciphertext).This concept is the computational complexity analogue to ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Claude_Shannon",children:"Shannon's"})," concept of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Perfect_secrecy",children:"perfect secrecy"}),". Perfect secrecy means that the ciphertext reveals no information at all about the plaintext, whereas semantic security implies that any information revealed cannot be feasibly extracted."]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Semantic_security",children:"https://en.wikipedia.org/wiki/Semantic_security"})}),"\n",(0,n.jsx)(i.h2,{id:"forward-secrecy",children:"Forward Secrecy"}),"\n",(0,n.jsxs)(i.p,{children:["In cryptography, ",(0,n.jsx)(i.strong,{children:"forward secrecy(FS), also known as perfect forward secrecy(PFS)"}),", is a feature of specific key agreement protocols that gives assurances that session keys will not be compromised even if the private key of the server is compromised.Forward secrecy protects past sessions against future compromises of secret keys or passwords.By generating a unique session key for every session a user initiates, the compromise of a single session key will not affect any data other than that exchanged in the specific session protected by that particular key."]}),"\n",(0,n.jsxs)(i.p,{children:["Forward secrecy further protects data on the transport layer of a network that uses common SSL/TLS protocols, including ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/OpenSSL",children:"OpenSSL"}),", which had previously been affected by the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Heartbleed",children:"Heartbleed"})," security bug. If forward secrecy is used, encrypted communications and sessions recorded in the past cannot be retrieved and decrypted should long-term secret keys or passwords be compromised in the future, even if the adversary actively interfered, for example via a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Man-in-the-middle_attack",children:"man-in-the-middle attack"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"The value of forward secrecy depends on the assumed capabilities of an adversary. Forward secrecy has value if an adversary is assumed to be able to obtain secret keys from a device (READ access) but not modify the way keys are generated in a device (WRITE access). In some cases an adversary who can read keys from a device may also be able to modify the functioning of the session key generator. In these cases forward secrecy has no value."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Forward_secrecy",children:"https://en.wikipedia.org/wiki/Forward_secrecy"})}),"\n",(0,n.jsx)(i.h2,{id:"envelope-encryption",children:"Envelope Encryption"}),"\n",(0,n.jsx)(i.p,{children:"Envelope encryption is the practice of encrypting data with a data encryption key (DEK) and then encrypting the DEK with a root key that you can fully manage."}),"\n",(0,n.jsx)(i.p,{children:"Envelope Encryption is an approach/process used within many applications to encrypt data. Using this approach your data is protected two-fold."}),"\n",(0,n.jsx)(i.h2,{id:"how-does-this-work-",children:"How does this work ?"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Typically there are manylong term keys or master keysthat isheld in a key management system (KMS)."}),"\n",(0,n.jsxs)(i.li,{children:["When you need to encrypt some message :","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"A request is sent to the KMS to generate a data keybased on one of the master keys."}),"\n",(0,n.jsx)(i.li,{children:"KMS returns a data key, which usually contains both the plain text version and the encrypted version of the data key."}),"\n",(0,n.jsx)(i.li,{children:"The message is encrypted using the plain text key."}),"\n",(0,n.jsx)(i.li,{children:"Then both the encrypted message and the encrypted data key are packaged into a structure (sometimes called envelope) and written."}),"\n",(0,n.jsx)(i.li,{children:"The plain text key is immediately removed from memory."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["When it comes time to decrypt the message:","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"The encrypted data key is extracted from the envelope."}),"\n",(0,n.jsx)(i.li,{children:"KMS is requested to decrypt the data key using the same master key as that was used to generate it."}),"\n",(0,n.jsx)(i.li,{children:"Once the plain text version of the data key is obtained then the encrypted message itself is decrypted."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Using this approach if one wants to decrypt data, they need be authenticated with the KMS, since the master keys are only held there and never exported, and only the KMS can decrypt the data keys."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(315013).Z+"",width:"656",height:"507"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://devender.me/2016/07/13/envelope-encryption",children:"https://devender.me/2016/07/13/envelope-encryption"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(157027).Z+"",width:"1101",height:"778"})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://www.druva.com/blog/druva-tech-moments-digital-envelope-encryption",children:"https://www.druva.com/blog/druva-tech-moments-digital-envelope-encryption"})," ",(0,n.jsx)(i.a,{href:"https://crypto.stackexchange.com/questions/3965/what-is-the-main-difference-between-a-key-an-iv-and-a-nonce",children:"https://crypto.stackexchange.com/questions/3965/what-is-the-main-difference-between-a-key-an-iv-and-a-nonce"})]}),"\n",(0,n.jsxs)(i.p,{children:["A ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Key_(cryptography)",children:"key"}),", in the context of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Symmetric-key_algorithm",children:"symmetric cryptography"}),", is something you keep secret. Anyone who knows your key (or can guess it) can decrypt any data you've encrypted with it (or forge any authentication codes you've calculated with it, etc.)"]}),"\n",(0,n.jsxs)(i.p,{children:['(There\'s also "asymmetric" or ',(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Public-key_encryption",children:"public key cryptography"}),", where the key effectively has two parts: the private key, which allows decryption and/or signing, and a public key (derived from the corresponding private key) which allows encryption and/or signature verification.)"]}),"\n",(0,n.jsxs)(i.p,{children:["An ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Initialization_vector",children:"IV"})," or initialization vector is, in its broadest sense, just the initial value used to start some iterated process. The term is used in a couple of different contexts and implies different security requirements in each of them. For example, ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_hash_function",children:"cryptographic hash functions"})," typically have a fixed IV, which is just an arbitrary constant which is included in the hash function specification and is used as the initial hash value before any data is fed in"]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(377470).Z+"",width:"400",height:"187"})}),"\n",(0,n.jsxs)(i.p,{children:["Conversely, most ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation",children:"block cipher modes of operation"})," require an IV which is random and unpredictable, or at least unique for each message encrypted with a given key. (Of course,ifeach key is only ever used to encrypt a single message, one can get away with using a fixed IV.) This random IV ensures that each message encrypts differently, such that seeing multiple messages encrypted with the same key doesn't give the attacker any more information than just seeing a single long message. In particular, it ensures that encrypting thesamemessage twice yields two completely different ciphertexts, which is necessary in order for the encryption scheme to be ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Semantic_security",children:"semantically secure"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"In any case, the IV never needs to be kept secret - if it did, it would be a key, not an IV. Indeed, in most cases, keeping the IV secret would not be practical even if you wanted to since the recipient needs to know it in order to decrypt the data (or verify the hash, etc.)."}),"\n",(0,n.jsxs)(i.p,{children:["A ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_nonce",children:"nonce"}),', in the broad sense, is just "a number used only once". The only thing generally demanded of a nonce is that it should never be used twice (within the relevant scope, such as encryption with a particular key). The unique IVs used for block cipher encryption qualify as nonces, but various other cryptographic schemes make use of nonces as well']}),"\n",(0,n.jsx)(i.p,{children:'There\'s some variation about which of the terms "IV" and "nonce" is used for different block cipher modes of operation: some authors use exclusively one or the other, while some make a distinction between them. For CTR mode, in particular, some authors reserve the term "IV" for the full cipher input block formed by the concatenation of the nonce and the initial counter value (usually a block of all zero bits), while others prefer not to use the term "IV" for CTR mode at all. This is all complicated by the fact that there are several variations on how the nonce/IV sent with the message in CTR mode is actually mapped into the initial block cipher input.\nConversely, for modes other than CTR (or related modes such as EAX or GCM), the term "IV" is almost universally preferred over "nonce". This is particularly true for CBC mode since it has requirements on its IV (specifically, that they are unpredictable) which go beyond the usual requirement of uniqueness expected of nonces.'}),"\n",(0,n.jsx)(i.h2,{id:"initialization-vector",children:"Initialization vector"}),"\n",(0,n.jsxs)(i.p,{children:["In ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptography",children:"cryptography"}),", aninitialization vector(IV) orstarting variable(SV) is an input to a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_primitive",children:"cryptographic primitive"})," being used to provide the initial state. The IV is typically required to be ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Random",children:"random"})," or ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Pseudorandom",children:"pseudorandom"}),", but sometimes an IV only needs to be unpredictable or unique.",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Randomization",children:"Randomization"})," is crucial for some ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Encryption",children:"encryption"})," schemes to achieve ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Semantic_security",children:"semantic security"}),", a property whereby repeated usage of the scheme under the same ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_key",children:"key"})," does not allow an attacker to infer relationships between (potentially similar) segments of the encrypted message. For ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Block_cipher",children:"block ciphers"}),", the use of an IV is described by the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation",children:"modes of operation"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Some cryptographic primitives require the IV only to be non-repeating, and the required randomness is derived internally. In this case, the IV is commonly called a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_nonce",children:"nonce"}),"(number used once), and the primitives (e.g.",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC",children:"CBC"}),") are consideredstatefulrather thanrandomized. This is because an IV need not be explicitly forwarded to a recipient but may be derived from a common state updated at both sender and receiver side. (In practice, a short nonce is still transmitted along with the message to consider message loss.) An example of stateful encryption schemes is the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Counter_mode",children:"counter mode"})," of operation, which has a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Sequence_number",children:"sequence number"})," for a nonce."]}),"\n",(0,n.jsxs)(i.p,{children:["The IV size depends on the cryptographic primitive used; for block ciphers it is generally the cipher's block-size. In encryption schemes, the unpredictable part of the IV has at best the same size as the key to compensate for ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Time/memory/data_tradeoff_attack",children:"time/memory/data tradeoff attacks"}),". When the IV is chosen at random, the probability of collisions due to the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Birthday_problem",children:"birthday problem"})," must be taken into account. Traditional stream ciphers such as ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/RC4",children:"RC4"})," do not support an explicit IV as input, and a custom solution for incorporating an IV into the cipher's key or internal state is needed. Some designs realized in practice are known to be insecure; the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy",children:"WEP"})," protocol is a notable example, and is prone to related-IV attacks."]}),"\n",(0,n.jsx)(i.p,{children:"Two of the same messages encrypted with the same key, but different IVs, will result in different ciphertext. This makes an attacker's job more difficult"}),"\n",(0,n.jsx)(i.p,{children:"A random IV is not a secret. It is no more sensitive than the ciphertext itself. You can transmit it along with the ciphertext without concern"}),"\n",(0,n.jsx)(i.p,{children:"The only secret in a properly designed crypto system is the key (and obviously the plaintext). Everything else (IVs, salts, algorithms, padding, everything) is assumed be be known by attackers."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://stackoverflow.com/questions/38059749/handling-transfer-of-iv-initialization-vectors",children:"https://stackoverflow.com/questions/38059749/handling-transfer-of-iv-initialization-vectors"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Initialization_vector",children:"https://en.wikipedia.org/wiki/Initialization_vector"})}),"\n",(0,n.jsx)(i.h2,{id:"mac-message-authentication-code",children:"MAC (Message Authentication Code)"}),"\n",(0,n.jsxs)(i.p,{children:["In ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptography",children:"cryptography"}),", a",(0,n.jsx)(i.strong,{children:"message authentication code"}),"(",(0,n.jsx)(i.strong,{children:"MAC"}),"), sometimes known as a",(0,n.jsx)(i.em,{children:"tag"}),", is a short piece of information used to ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Message_authentication",children:"authenticate a message"})," - in other words, to confirm that the message came from the stated sender (its authenticity) and has not been changed. The MAC value protects both a message's ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_integrity",children:"data integrity"})," as well as its ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Message_authentication",children:"authenticity"}),", by allowing verifiers (who also possess the secret key) to detect any changes to the message content.\nInformally, a message authentication code consists of three algorithms:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"A key generation algorithm selects a key from the key space uniformly at random."}),"\n",(0,n.jsx)(i.li,{children:"A signing algorithm efficiently returns a tag given the key and the message."}),"\n",(0,n.jsxs)(i.li,{children:["A verifying algorithm efficiently verifies the authenticity of the message given the key and the tag. That is, return ",(0,n.jsx)(i.em,{children:"accepted"}),"when the message and tag are not tampered with or forged, and otherwise return ",(0,n.jsx)(i.em,{children:"rejected"}),"\n",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Message_authentication_code",children:"https://en.wikipedia.org/wiki/Message_authentication_code"})]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"message-integrity-codes-mic--macs-message-authentication-code",children:"Message Integrity Codes (MIC) / MACs (Message Authentication Code)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Attacks","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Existential Forgery"}),"\n",(0,n.jsx)(i.li,{children:"Selective Forgery"}),"\n",(0,n.jsx)(i.li,{children:"Key recovery"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.li,{children:"Merkle-Damgard Iterated Construction"}),"\n",(0,n.jsx)(i.li,{children:"HMAC (Hash-MAC)"}),"\n",(0,n.jsx)(i.li,{children:"Encrypted CBC-MAC (ECBC-MAC)s"}),"\n",(0,n.jsx)(i.li,{children:"NMAC (nested MAC)"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"hmac-hash-mac",children:"HMAC (Hash MAC)"}),"\n",(0,n.jsxs)(i.p,{children:["In ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptography",children:"cryptography"}),", anHMAC(sometimes expanded as eitherkeyed-hash message authentication codeorhash-based message authentication code) is a specific type of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Message_authentication_code",children:"message authentication code"}),"(MAC) involving a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_hash_function",children:"cryptographic hash function"})," and a secret ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_key",children:"cryptographic key"}),". It may be used to simultaneously verify both ",(0,n.jsxs)(i.strong,{children:["the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_integrity",children:"data integrity"})," and the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Authentication",children:"authentication"})," of a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cleartext",children:"message"}),","]})," as with any MAC. Any cryptographic hash function, such as ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/SHA-256",children:"SHA-256"})," or ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/SHA-3",children:"SHA-3"}),", may be used in the calculation of an HMAC; the resulting MAC algorithm is termed HMAC-X, where X is the hash function used (e.g. HMAC-SHA256 or HMAC-SHA3). The cryptographic strength of the HMAC depends upon the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_strength",children:"cryptographic strength"})," of the underlying hash function, the size of its hash output, and the size and quality of the key."]}),"\n",(0,n.jsxs)(i.p,{children:["HMAC uses two passes of hash computation. The secret key is first used to derive two keys -- inner and outer. The first pass of the algorithm produces an internal hash derived from the message and the inner key. The second pass produces the final HMAC code derived from the inner hash result and the outer key. Thus the algorithm provides better immunity against ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Length_extension_attack",children:"length extension attacks"}),"."]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/HMAC",children:"https://en.wikipedia.org/wiki/HMAC"})})]})}function l(e={}){const{wrapper:i}={...(0,r.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},315013:(e,i,t)=>{t.d(i,{Z:()=>n});const n=t.p+"assets/images/Cryptography-Intro_Cryptography-Terms-image1-77649ade5fc293edd144bf31c2d4eea4.jpg"},157027:(e,i,t)=>{t.d(i,{Z:()=>n});const n=t.p+"assets/images/Cryptography-Intro_Cryptography-Terms-image2-85e8e7da82f721d2793eb7187b936c5f.jpg"},377470:(e,i,t)=>{t.d(i,{Z:()=>n});const n=t.p+"assets/images/Cryptography-Intro_Cryptography-Terms-image3-96ae7ec8ac731541fd45d0f41d1002e1.jpg"},511151:(e,i,t)=>{t.d(i,{Z:()=>o,a:()=>a});var n=t(667294);const r={},s=n.createContext(r);function a(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);