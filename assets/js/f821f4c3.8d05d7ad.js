"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[83806],{393677:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=a(785893),s=a(511151);const r={},i="Analytical Queries",l={id:"languages/sql/dql-data-query-language/analytical-queries",title:"Analytical Queries",description:"Aggregate functions perform calculations based on sets of rows",source:"@site/docs/languages/sql/dql-data-query-language/analytical-queries.md",sourceDirName:"languages/sql/dql-data-query-language",slug:"/languages/sql/dql-data-query-language/analytical-queries",permalink:"/languages/sql/dql-data-query-language/analytical-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/sql/dql-data-query-language/analytical-queries.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Aggregation Queries",permalink:"/languages/sql/dql-data-query-language/aggregation-queries"},next:{title:"Window Functions",permalink:"/languages/sql/dql-data-query-language/window-functions"}},o={},c=[{value:"Examples",id:"examples",level:2},{value:"Links",id:"links",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"analytical-queries",children:"Analytical Queries"}),"\n",(0,t.jsx)(n.p,{children:"Aggregate functions perform calculations based on sets of rows"}),"\n",(0,t.jsxs)(n.p,{children:["Unlike aggregate functions, ",(0,t.jsx)(n.strong,{children:"analytic functions"})," return a (potentially different) value for each row in the original table."]}),"\n",(0,t.jsxs)(n.p,{children:["All analytic functions have an ",(0,t.jsx)(n.strong,{children:"OVER"})," clause, which defines the sets of rows used in each calculation."]}),"\n",(0,t.jsx)(n.p,{children:"The OVER clause has three (optional) parts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"PARTITION BY"})," clause divides the rows of the table into different groups"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"ORDER BY"})," clause defines an ordering within each partition."]}),"\n",(0,t.jsxs)(n.li,{children:["The final clause (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) is known as a",(0,t.jsx)(n.strong,{children:"window frame"})," clause. It identifies the set of rows used in each calculation. We can refer to this group of rows as a ",(0,t.jsx)(n.strong,{children:"window"}),". (Actually, analytic functions are sometimes referred to as ",(0,t.jsx)(n.strong,{children:"analytic window functions"})," or simply ",(0,t.jsx)(n.strong,{children:"window functions"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:a(783142).Z+"",width:"1420",height:"527"})}),"\n",(0,t.jsx)(n.p,{children:"There are many ways to write window frame clauses:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROWS BETWEEN 1 PRECEDING AND CURRENT ROW"})," - the previous row and the current row."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING"})," - the 3 previous rows, the current row, and the following row."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING"})," - all rows in the partition."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"})," - a window frame that spans from the start of the partition to the current row, inclusive."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The lowest possible bound  is UNBOUNDED PRECEDING (the first row), the current row is CURRENT ROW and the highest possible row is UNBOUNDED FOLLOWING (the last row)."}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT time, buy,\n  avg(buy) OVER (ORDER BY time rows between 1 preceding and current row) as average_2,\n  avg(buy) OVER (ORDER BY time rows between 2 preceding and current row) as average_3\nFROM my_table;\n\n-- https://stackoverflow.com/questions/56063397/how-to-understand-the-results-of-rows-between-2-preceding-and-current-row\n\nSELECT sale_day, sale_time, branch, article, quantity, revenue,\nSUM(quantity) OVER (PARTITION BY article) AS total_units_sold\nFROM sales;\n\nSELECT DISTINCT article,\n EXTRACT('month' FROM sale_day) AS month,\n SUM(quantity) OVER (PARTITION BY article, sale_month) AS units_sold_month,\n SUM(quantity) OVER (PARTITION BY article) AS units_sold_year,\n ((SUM(quantity) OVER (PARTITION BY article, sale_month)::decimal / SUM(quantity) OVER (PARTITION BY article)::decimal ) * 100) AS month_percentage\nFROM sales\nWHERE EXTRACT('YEAR' FROM sale_day) = 2021\nORDER BY article, month\n\nWITH branch_month_sales AS (\n SELECT DISTINCT\n branch,\n EXTRACT('MONTH' FROM sale_day) AS month,\n SUM(revenue) OVER (PARTITION BY branch, sale_month ) AS revenue\n FROM sales\n)\nSELECT branch,\n month,\n revenue AS revenue_current_month,\n LAG(revenue) OVER (PARTITION BY branch ORDER BY month) AS revenue_prev_month,\n revenue - LAG(revenue) OVER (PARTITION BY branch ORDER BY month) AS revenue_delta\nFROM branch_month_sales\nORDER BY branch, month\n\n-- using ANY_VALUE and IF to transpose rows in columns based on rank\nWITH ranked_transactions AS (\nSELECT\natr.userId,\natr.operation,\natr.confirmedAt,\nROW_NUMBER() OVER (PARTITION BY atr.userId\nORDER BY\natr.confirmedAt ASC) AS rn\nFROM\nall_transactions atr\n)\nSELECT\nrt.UserId,\nANY_VALUE(IF(rt.rn = 1, rt.operation, NULL), TRUE) AS firstEntryProduct,\nANY_VALUE(IF(rt.rn = 2, rt.operation, NULL), TRUE) AS secondEntryProduct,\nFROM ranked_transactions rt GROUP BY userId\n"})}),"\n",(0,t.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/languages/sql/dql-data-query-language/window-functions",children:"Window Functions"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/languages/sql/dql-data-query-language/aggregation-queries",children:"Aggregation Queries"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://learnsql.com/blog/sql-over-clause/",children:"What Is the OVER() Clause in SQL? | LearnSQL.com"})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stevestedman.com/2012/03/rows-preceding-and-following-in-tsql-2012/",children:"ROWS PRECEDING and FOLLOWING in TSQL 2012 - Steve Stedman"})})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},783142:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/DQL-Data-Query-Language_Aggregation-Analytical-Queries-SQL-Analytics-image1-c52ba2820a19c8b088a4aac2737ffabc.jpg"},511151:(e,n,a)=>{a.d(n,{Z:()=>l,a:()=>i});var t=a(667294);const s={},r=t.createContext(s);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);