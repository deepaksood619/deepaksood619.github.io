"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[57281],{799046:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var n=s(785893),i=s(511151);const r={},o="Blocks",c={id:"decentralized-applications/ethereum/07-blocks",title:"Blocks",description:"Blocks are batches of transactions with a hash of the previous block in the chain. This links blocks together (in a chain) because hashes are cryptographically derived from the block data. This prevents fraud, because one change in any block in history would invalidate all the following blocks as all subsequent hashes would change and everyone running the blockchain would notice.",source:"@site/docs/decentralized-applications/ethereum/07-blocks.md",sourceDirName:"decentralized-applications/ethereum",slug:"/decentralized-applications/ethereum/07-blocks",permalink:"/decentralized-applications/ethereum/07-blocks",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/decentralized-applications/ethereum/07-blocks.md",tags:[],version:"current",lastUpdatedAt:1687721346,formattedLastUpdatedAt:"Jun 25, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Transactions",permalink:"/decentralized-applications/ethereum/06-transactions"},next:{title:"EVM - Ethereum Virtual Machine",permalink:"/decentralized-applications/ethereum/08-evm"}},d={},l=[{value:"Why blocks?",id:"why-blocks",level:2},{value:"How blocks work",id:"how-blocks-work",level:2},{value:"Proof-of-stake protocol",id:"proof-of-stake-protocol",level:2},{value:"What&#39;s in a block?",id:"whats-in-a-block",level:2},{value:"Block time",id:"block-time",level:2},{value:"Block size",id:"block-size",level:2},{value:"Further reading",id:"further-reading",level:2}];function a(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"blocks",children:"Blocks"}),"\n",(0,n.jsx)(t.p,{children:"Blocks are batches of transactions with a hash of the previous block in the chain. This links blocks together (in a chain) because hashes are cryptographically derived from the block data. This prevents fraud, because one change in any block in history would invalidate all the following blocks as all subsequent hashes would change and everyone running the blockchain would notice."}),"\n",(0,n.jsx)(t.h2,{id:"why-blocks",children:"Why blocks?"}),"\n",(0,n.jsx)(t.p,{children:"To ensure that all participants on the Ethereum network maintain a synchronized state and agree on the precise history of transactions, we batch transactions into blocks. This means dozens (or hundreds) of transactions are committed, agreed on, and synchronized all at once."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"A diagram showing transaction in a block causing state changes",src:s(345746).Z+"",width:"1080",height:"607"})}),"\n",(0,n.jsxs)(t.p,{children:["By spacing out commits, we give all network participants enough time to come to consensus: even though transaction requests occur dozens of times per second, blocks are only created and committed on Ethereum once every ",(0,n.jsx)(t.strong,{children:"twelve seconds"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"how-blocks-work",children:"How blocks work"}),"\n",(0,n.jsx)(t.p,{children:"To preserve the transaction history, blocks are strictly ordered (every new block created contains a reference to its parent block), and transactions within blocks are strictly ordered as well. Except in rare cases, at any given time, all participants on the network are in agreement on the exact number and history of blocks, and are working to batch the current live transaction requests into the next block."}),"\n",(0,n.jsx)(t.p,{children:'Once a block is put together by a randomly selected validator on the network, it is propagated to the rest of the network; all nodes add this block to the end of their blockchain, and a new validator is selected to create the next block. The exact block-assembly process and commitment/consensus process is currently specified by Ethereum\u2019s "proof-of-stake" protocol.'}),"\n",(0,n.jsx)(t.h2,{id:"proof-of-stake-protocol",children:"Proof-of-stake protocol"}),"\n",(0,n.jsx)(t.p,{children:"Proof-of-stake means the following:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Validating nodes have to stake 32 ETH into a deposit contract as collateral against bad behavior. This helps protect the network because provably dishonest activity leads to some or all of that stake being destroyed."}),"\n",(0,n.jsx)(t.li,{children:"In every slot (spaced twelve seconds apart) a validator is randomly selected to be the block proposer. They bundle transactions together, execute them and determine a new 'state'. They wrap this information into a block and pass it around to other validators."}),"\n",(0,n.jsx)(t.li,{children:"Other validators who hear about the new block re-execute the transactions to ensure they agree with the proposed change to the global state. Assuming the block is valid, they add it to their own database."}),"\n",(0,n.jsx)(t.li,{children:"If a validator hears about two conflicting blocks for the same slot they use their fork-choice algorithm to pick the one supported by the most staked ETH."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/",children:"More on proof-of-stake"})}),"\n",(0,n.jsx)(t.h2,{id:"whats-in-a-block",children:"What's in a block?"}),"\n",(0,n.jsx)(t.p,{children:"There is a lot of information contained within a block. At the highest level a block contains the following fields:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Field"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Description"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"slot"})}),(0,n.jsx)(t.td,{children:"the slot the block belongs to"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"proposer_index"})}),(0,n.jsx)(t.td,{children:"the ID of the validator proposing the block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"parent_root"})}),(0,n.jsx)(t.td,{children:"the hash of the preceding block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"state_root"})}),(0,n.jsx)(t.td,{children:"the root hash of the state object"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"body"})}),(0,n.jsx)(t.td,{children:"an object containing several fields, as defined below"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The block ",(0,n.jsx)(t.code,{children:"body"})," contains several fields of its own:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Field"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Description"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"randao_reveal"})}),(0,n.jsx)(t.td,{children:"a value used to select the next block proposer"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"eth1_data"})}),(0,n.jsx)(t.td,{children:"information about the deposit contract"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"graffiti"})}),(0,n.jsx)(t.td,{children:"arbitrary data used to tag blocks"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"proposer_slashings"})}),(0,n.jsx)(t.td,{children:"list of validators to be slashed"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attester_slashings"})}),(0,n.jsx)(t.td,{children:"list of validators to be slashed"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attestations"})}),(0,n.jsx)(t.td,{children:"list of attestations in favor of the current block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"deposits"})}),(0,n.jsx)(t.td,{children:"list of new deposits to the deposit contract"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"voluntary_exits"})}),(0,n.jsx)(t.td,{children:"list of validators exiting the network"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"sync_aggregate"})}),(0,n.jsx)(t.td,{children:"subset of validators used to serve light clients"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"execution_payload"})}),(0,n.jsx)(t.td,{children:"transactions passed from the execution client"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"attestations"})," field contains a list of all the attestations in the block. Attestations have their own data type that contains several pieces of data. Each attestation contains:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"aggregation_bits"})}),(0,n.jsx)(t.td,{children:"a list of which validators participated in this attestation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"data"})}),(0,n.jsx)(t.td,{children:"a container with multiple subfields"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"signature"})}),(0,n.jsx)(t.td,{children:"aggregate signature of all attesting validators"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"data"})," field in the ",(0,n.jsx)(t.code,{children:"attestation"})," contains the following:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"slot"})}),(0,n.jsx)(t.td,{children:"the slot the attestation relates to"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"index"})}),(0,n.jsx)(t.td,{children:"indices for attesting validators"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"beacon_block_root"})}),(0,n.jsx)(t.td,{children:"the root hash of the Beacon block containing this object"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"source"})}),(0,n.jsx)(t.td,{children:"the last justified checkpoint"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"target"})}),(0,n.jsx)(t.td,{children:"the latest epoch boundary block"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Executing the transactions in the ",(0,n.jsx)(t.code,{children:"execution_payload"})," updates the global state. All clients re-execute the transactions in the ",(0,n.jsx)(t.code,{children:"execution_payload"})," to ensure the new state matches that in the new block ",(0,n.jsx)(t.code,{children:"state_root"})," field. This is how clients can tell that a new block is valid and safe to add to their blockchain. The ",(0,n.jsx)(t.code,{children:"execution payload"})," itself is an object with several fields. There is also an ",(0,n.jsx)(t.code,{children:"execution_payload_header"})," that contains important summary information about the execution data. These data structures are organized as follows:"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"execution_payload_header"})," contains the following fields:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"parent_hash"})}),(0,n.jsx)(t.td,{children:"hash of the parent block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"fee_recipient"})}),(0,n.jsx)(t.td,{children:"account address for paying transaction fees to"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"state_root"})}),(0,n.jsx)(t.td,{children:"root hash for the global state after applying changes in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"receipts_root"})}),(0,n.jsx)(t.td,{children:"hash of the transaction receipts trie"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"logs_bloom"})}),(0,n.jsx)(t.td,{children:"data structure containing event logs"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"prev_randao"})}),(0,n.jsx)(t.td,{children:"value used in random validator selection"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"block_number"})}),(0,n.jsx)(t.td,{children:"the number of the current block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"gas_limit"})}),(0,n.jsx)(t.td,{children:"maximum gas allowed in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"gas_used"})}),(0,n.jsx)(t.td,{children:"the actual amount of gas used in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"timestamp"})}),(0,n.jsx)(t.td,{children:"the block time"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"extra_data"})}),(0,n.jsx)(t.td,{children:"arbitrary additional data as raw bytes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"base_fee_per_gas"})}),(0,n.jsx)(t.td,{children:"the base fee value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"block_hash"})}),(0,n.jsx)(t.td,{children:"Hash of execution block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"transactions_root"})}),(0,n.jsx)(t.td,{children:"root hash of the transactions in the payload"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"execution_payload"})," itself contains the following (notice this is identical to the header except that instead of the root hash of the transactions it includes the actual list of transactions) :"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"parent_hash"})}),(0,n.jsx)(t.td,{children:"hash of the parent block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"fee_recipient"})}),(0,n.jsx)(t.td,{children:"account address for paying transaction fees to"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"state_root"})}),(0,n.jsx)(t.td,{children:"root hash for the global state after applying changes in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"receipts_root"})}),(0,n.jsx)(t.td,{children:"hash of the transaction receipts trie"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"logs_bloom"})}),(0,n.jsx)(t.td,{children:"data structure containing event logs"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"prev_randao"})}),(0,n.jsx)(t.td,{children:"value used in random validator selection"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"block_number"})}),(0,n.jsx)(t.td,{children:"the number of the current block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"gas_limit"})}),(0,n.jsx)(t.td,{children:"maximum gas allowed in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"gas_used"})}),(0,n.jsx)(t.td,{children:"the actual amount of gas used in this block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"timestamp"})}),(0,n.jsx)(t.td,{children:"the block time"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"extra_data"})}),(0,n.jsx)(t.td,{children:"arbitrary additional data as raw bytes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"base_fee_per_gas"})}),(0,n.jsx)(t.td,{children:"the base fee value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"block_hash"})}),(0,n.jsx)(t.td,{children:"Hash of execution block"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"transactions"})}),(0,n.jsx)(t.td,{children:"list of transactions to be executed"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"block-time",children:"Block time"}),"\n",(0,n.jsx)(t.p,{children:"Block time refers to the time separating blocks. In Ethereum, time is divided up into twelve second units called 'slots'. In each slot a single validator is selected to propose a block. Assuming all validators are online and fully functional there will be a block in every slot, meaning the block time is 12s. However, occasionally validators might be offline when called to propose a block, meaning slots can sometimes go empty."}),"\n",(0,n.jsxs)(t.p,{children:["This implementation differs from proof-of-work based systems where block times are probabilistic and tuned by the protocol's target mining difficulty. Ethereum's ",(0,n.jsx)(t.a,{href:"https://etherscan.io/chart/blocktime",children:"average block time"})," is a perfect example of this whereby the transition from proof-of-work to proof-of-stake can be clearly inferred based on the consistency of the new 12s block time."]}),"\n",(0,n.jsx)(t.h2,{id:"block-size",children:"Block size"}),"\n",(0,n.jsx)(t.p,{children:"A final important note is that blocks themselves are bounded in size. Each block has a target size of 15 million gas but the size of blocks will increase or decrease in accordance with network demands, up until the block limit of 30 million gas (2x target block size). The total amount of gas expended by all transactions in the block must be less than the block gas limit. This is important because it ensures that blocks can\u2019t be arbitrarily large. If blocks could be arbitrarily large, then less performant full nodes would gradually stop being able to keep up with the network due to space and speed requirements. The larger the block, the greater the computing power required to process them in time for the next slot. This is a centralizing force, which is resisted by capping block sizes."}),"\n",(0,n.jsx)(t.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/transactions/",children:"Transactions"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/gas/",children:"Gas"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/",children:"Proof-of-stake"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},345746:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/Pasted image 20230305103925-a47dbc6205b300532c87e1d615352c06.png"},511151:(e,t,s)=>{s.d(t,{Z:()=>c,a:()=>o});var n=s(667294);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);