"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[75813],{643492:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"databases-nosql/time-series-db/influxdb/concepts","title":"Concepts","description":"In-memory indexing and the Time-Structured Merge Tree (TSM)","source":"@site/docs/databases-nosql/time-series-db/influxdb/concepts.md","sourceDirName":"databases-nosql/time-series-db/influxdb","slug":"/databases-nosql/time-series-db/influxdb/concepts","permalink":"/databases-nosql/time-series-db/influxdb/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/time-series-db/influxdb/concepts.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749575438000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Commands / Influx Query Language (InfluxQL)","permalink":"/databases-nosql/time-series-db/influxdb/commands-influx-query-language-influxql"},"next":{"title":"Influx","permalink":"/databases-nosql/time-series-db/influxdb/influx"}}');var a=s(474848),i=s(28453);const o={},r="Concepts",l={},d=[{value:"In-memory indexing and the Time-Structured Merge Tree (TSM)",id:"in-memory-indexing-and-the-time-structured-merge-tree-tsm",level:2},{value:"Storage Engine",id:"storage-engine",level:2},{value:"Write Ahead Log (WAL)",id:"write-ahead-log-wal",level:3},{value:"TLV Standard",id:"tlv-standard",level:2},{value:"Type",id:"type",level:3},{value:"Length",id:"length",level:3},{value:"Value",id:"value",level:3},{value:"Internals",id:"internals",level:2},{value:"Cache",id:"cache",level:3},{value:"TSM files",id:"tsm-files",level:3},{value:"Compression",id:"compression",level:3},{value:"Compactions",id:"compactions",level:3},{value:"Writes",id:"writes",level:3},{value:"Updates",id:"updates",level:3},{value:"Deletes",id:"deletes",level:3},{value:"Queries",id:"queries",level:3},{value:"Properties of time series data",id:"properties-of-time-series-data",level:3},{value:"LevelDB and log structured merge trees",id:"leveldb-and-log-structured-merge-trees",level:3},{value:"BoltDB and mmap B+Trees",id:"boltdb-and-mmap-btrees",level:3}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,a.jsx)(t.h2,{id:"in-memory-indexing-and-the-time-structured-merge-tree-tsm",children:"In-memory indexing and the Time-Structured Merge Tree (TSM)"}),"\n",(0,a.jsx)(t.p,{children:"The InfluxDB storage engine looks very similar to a LSM Tree. It has a write ahead log and a collection of read-only data files which are similar in concept to SSTables in an LSM Tree. TSM files contain sorted, compressed series data."}),"\n",(0,a.jsxs)(t.p,{children:["InfluxDB will create a ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#shard",children:"shard"})," for each block of time. For example, if you have a ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#retention-policy-rp",children:"retention policy"})," with an unlimited duration, shards will be created for each 7 day block of time. Each of these shards maps to an underlying storage engine database. Each of these databases has its own ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#wal-write-ahead-log",children:"WAL"})," and TSM files."]}),"\n",(0,a.jsx)(t.h2,{id:"storage-engine",children:"Storage Engine"}),"\n",(0,a.jsx)(t.p,{children:"The storage engine ties a number of components together and provides the external interface for storing and querying series data. It is composed of a number of components that each serve a particular role:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"In-Memory Index -"})," The in-memory index is a shared index across shards that provides the quick access to ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#measurement",children:"measurements"}),", ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#tag",children:"tags"}),", and ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#series",children:"series"}),". The index is used by the engine, but is not specific to the storage engine itself."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"WAL -"})," The WAL is a write-optimized storage format that allows for writes to be durable, but not easily queryable. Writes to the WAL are appended to segments of a fixed size."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cache -"})," The Cache is an in-memory representation of the data stored in the WAL. It is queried at runtime and merged with the data stored in TSM files."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"TSM Files -"})," TSM files store compressed series data in a columnar format."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"FileStore -"})," The FileStore mediates access to all TSM files on disk. It ensures that TSM files are installed atomically when existing ones are replaced as well as removing TSM files that are no longer used."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Compactor -"})," The Compactor is responsible for converting less optimized Cache and TSM data into more read-optimized formats. It does this by compressing series, removing deleted data, optimizing indices and combining smaller files into larger ones."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Compaction Planner -"})," The Compaction Planner determines which TSM files are ready for a compaction and ensures that multiple concurrent compactions do not interfere with each other."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Compression -"})," Compression is handled by various Encoders and Decoders for specific data types. Some encoders are fairly static and always encode the same type the same way; others switch their compression strategy based on the shape of the data."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Writers/Readers -"})," Each file type (WAL segment, TSM files, tombstones, etc..) has Writers and Readers for working with the formats."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"write-ahead-log-wal",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#write-ahead-log-wal",children:"Write Ahead Log (WAL)"})}),"\n",(0,a.jsxs)(t.p,{children:["The WAL is organized as a bunch of files that look like ",(0,a.jsx)(t.code,{children:"_000001.wal"}),". The file numbers are monotonically increasing and referred to as WAL segments. When a segment reaches 10MB in size, it is closed and a new one is opened. Each WAL segment stores multiple compressed blocks of writes and deletes."]}),"\n",(0,a.jsx)(t.p,{children:"When a write comes in the new points are serialized, compressed using Snappy, and written to a WAL file. The file is fsync'd and the data is added to an in-memory index before a success is returned. This means that batching points together is required to achieve high throughput performance. (Optimal batch size seems to be 5,000-10,000 points per batch for many use cases.)"}),"\n",(0,a.jsxs)(t.p,{children:["Each entry in the WAL follows a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Type-length-value",children:"TLV standard"})," with a single byte representing the type of entry (write or delete), a 4 byte uint32 for the length of the compressed block, and then the compressed block."]}),"\n",(0,a.jsx)(t.h2,{id:"tlv-standard",children:"TLV Standard"}),"\n",(0,a.jsxs)(t.p,{children:["Within ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Data_communication_protocol",children:"data communication protocols"}),", TLV (type-length-value or tag-length-value) is an encoding scheme used for optional information element in a certain protocol."]}),"\n",(0,a.jsx)(t.p,{children:"The type and length are fixed in size (typically 1-4 bytes), and the value field is of variable size. These fields are used as follows:"}),"\n",(0,a.jsx)(t.h3,{id:"type",children:"Type"}),"\n",(0,a.jsx)(t.p,{children:"A binary code, often simply alphanumeric, which indicates the kind of field that this part of the message represents;"}),"\n",(0,a.jsx)(t.h3,{id:"length",children:"Length"}),"\n",(0,a.jsx)(t.p,{children:"The size of the value field (typically in bytes);"}),"\n",(0,a.jsx)(t.h3,{id:"value",children:"Value"}),"\n",(0,a.jsx)(t.p,{children:"Variable-sized series of bytes which contains data for this part of the message."}),"\n",(0,a.jsx)(t.p,{children:"Some advantages of using a TLV representation data system solution are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"TLV sequences are easily searched using generalized parsing functions;"}),"\n",(0,a.jsxs)(t.li,{children:["New message elements which are received at an older node can be safely skipped and the rest of the message can be parsed. This is similar to the way that unknown ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/XML",children:"XML"})," tags can be safely skipped;"]}),"\n",(0,a.jsx)(t.li,{children:"TLV elements can be placed in any order inside the message body;"}),"\n",(0,a.jsx)(t.li,{children:"TLV elements are typically used in a binary format which makes parsing faster and the data smaller than in comparable text based protocols."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Type-length-value",children:"https://en.wikipedia.org/wiki/Type-length-value"})}),"\n",(0,a.jsx)(t.h2,{id:"internals",children:"Internals"}),"\n",(0,a.jsx)(t.h3,{id:"cache",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#cache",children:"Cache"})}),"\n",(0,a.jsxs)(t.p,{children:["The Cache is an in-memory copy of all data points current stored in the WAL. The points are organized by the key, which is the measurement, ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#tag-set",children:"tag set"}),", and unique ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#field",children:"field"}),". Each field is kept as its own time-ordered range. The Cache data is not compressed while in memory."]}),"\n",(0,a.jsx)(t.p,{children:"Queries to the storage engine will merge data from the Cache with data from the TSM files. Queries execute on a copy of the data that is made from the cache at query processing time. This way writes that come in while a query is running won't affect the result."}),"\n",(0,a.jsx)(t.p,{children:"Deletes sent to the Cache will clear out the given key or the specific time range for the given key."}),"\n",(0,a.jsxs)(t.p,{children:["The Cache exposes a few controls for snapshotting behavior. The two most important controls are the memory limits. There is a lower bound, ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/administration/config#cache-snapshot-memory-size-25m",children:"cache-snapshot-memory-size"}),", which when exceeded will trigger a snapshot to TSM files and remove the corresponding WAL segments. There is also an upper bound, ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/administration/config#cache-max-memory-size-1g",children:"cache-max-memory-size"}),", which when exceeded will cause the Cache to reject new writes. These configurations are useful to prevent out of memory situations and to apply back pressure to clients writing data faster than the instance can persist it. The checks for memory thresholds occur on every write."]}),"\n",(0,a.jsxs)(t.p,{children:["The other snapshot controls are time based. The idle threshold, ",(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/administration/config#cache-snapshot-write-cold-duration-10m",children:"cache-snapshot-write-cold-duration"}),", forces the Cache to snapshot to TSM files if it hasn't received a write within the specified interval."]}),"\n",(0,a.jsx)(t.p,{children:"The in-memory Cache is recreated on restart by re-reading the WAL files on disk."}),"\n",(0,a.jsx)(t.h3,{id:"tsm-files",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#tsm-files",children:"TSM files"})}),"\n",(0,a.jsx)(t.p,{children:"TSM files are a collection of read-only files that are memory mapped. The structure of these files looks very similar to an SSTable in LevelDB or other LSM Tree variants."}),"\n",(0,a.jsx)(t.p,{children:"A TSM file is composed of four sections: header, blocks, index, and footer."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header \u2502 Blocks \u2502 Index \u2502 Footer \u2502\n\u25025 bytes \u2502 N bytes \u2502 N bytes \u2502 4 bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.p,{children:"The Header is a magic number to identify the file type and a version number."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Magic \u2502 Version \u2502\n\u2502 4 bytes \u2502 1 byte \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.p,{children:"Blocks are sequences of pairs of CRC32 checksums and data. The block data is opaque to the file. The CRC32 is used for block level error detection. The length of the blocks is stored in the index."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Blocks \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Block 1 \u2502 Block 2 \u2502 Block N \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 CRC \u2502 Data \u2502 CRC \u2502 Data \u2502 CRC \u2502 Data \u2502\n\u2502 4 bytes \u2502 N bytes \u2502 4 bytes \u2502 N bytes \u2502 4 bytes \u2502 N bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.p,{children:"Following the blocks is the index for the blocks in the file. The index is composed of a sequence of index entries ordered lexicographically by key and then by time. The key includes the measurement name, tag set, and one field. Multiple fields per point creates multiple index entries in the TSM file. Each index entry starts with a key length and the key, followed by the block type (float, int, bool, string) and a count of the number of index block entries that follow for that key. Each index block entry is composed of the min and max time for the block, the offset into the file where the block is located and the size of the block. There is one index block entry for each block in the TSM file that contains the key."}),"\n",(0,a.jsx)(t.p,{children:"The index structure can provide efficient access to all blocks as well as the ability to determine the cost associated with accessing a given key. Given a key and timestamp, we can determine whether a file contains the block for that timestamp. We can also determine where that block resides and how much data must be read to retrieve the block. Knowing the size of the block, we can efficiently provision our IO statements."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Index \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2524\n\u2502 Key Len \u2502 Key \u2502 Type \u2502 Count \u2502Min Time \u2502Max Time \u2502 Offset \u2502 Size \u2502...\u2502\n\u2502 2 bytes \u2502 N bytes \u25021 byte\u25022 bytes\u2502 8 bytes \u2502 8 bytes \u25028 bytes \u25024 bytes \u2502 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.p,{children:"The last section is the footer that stores the offset of the start of the index."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Footer \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502Index Ofs\u2502\n\u2502 8 bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.h3,{id:"compression",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#compression",children:"Compression"})}),"\n",(0,a.jsx)(t.p,{children:"Each block is compressed to reduce storage space and disk IO when querying. A block contains the timestamps and values for a given series and field. Each block has one byte header, followed by the compressed timestamps and then the compressed values."}),"\n",(0,a.jsx)(t.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Type \u2502 Len \u2502 Timestamps \u2502 Values \u2502\n\u25021 Byte \u2502VByte\u2502 N Bytes \u2502 N Bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(t.p,{children:"The timestamps and values are compressed and stored separately using encodings dependent on the data type and its shape. Storing them independently allows timestamp encoding to be used for all timestamps, while allowing different encodings for different field types. For example, some points may be able to use run-length encoding whereas other may not."}),"\n",(0,a.jsx)(t.p,{children:"Each value type also contains a 1 byte header indicating the type of compression for the remaining bytes. The four high bits store the compression type and the four low bits are used by the encoder if needed."}),"\n",(0,a.jsx)(t.h3,{id:"compactions",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#compactions",children:"Compactions"})}),"\n",(0,a.jsx)(t.p,{children:"Compactions are recurring processes that migrate data stored in a write-optimized format into a more read-optimized format. There are a number of stages of compaction that take place while a shard is hot for writes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Snapshots -"})," Values in the Cache and WAL must be converted to TSM files to free memory and disk space used by the WAL segments. These compactions occur based on the cache memory and time thresholds."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Level Compactions -"})," Level compactions (levels 1-4) occur as the TSM files grow. TSM files are compacted from snapshots to level 1 files. Multiple level 1 files are compacted to produce level 2 files. The process continues until files reach level 4 and the max size for a TSM file. They will not be compacted further unless deletes, index optimization compactions, or full compactions need to run. Lower level compactions use strategies that avoid CPU-intensive activities like decompressing and combining blocks. Higher level (and thus less frequent) compactions will re-combine blocks to fully compact them and increase the compression ratio."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Index Optimization -"})," When many level 4 TSM files accumulate, the internal indexes become larger and more costly to access. An index optimization compaction splits the series and indices across a new set of TSM files, sorting all points for a given series into one TSM file. Before an index optimization, each TSM file contained points for most or all series, and thus each contains the same series index. After an index optimization, each TSM file contains points from a minimum of series and there is little series overlap between files. Each TSM file thus has a smaller unique series index, instead of a duplicate of the full series list. In addition, all points from a particular series are contiguous in a TSM file rather than spread across multiple TSM files."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Full Compactions -"})," Full compactions run when a shard has become cold for writes for long time, or when deletes have occurred on the shard. Full compactions produce an optimal set of TSM files and include all optimizations from Level and Index Optimization compactions. Once a shard is fully compacted, no other compactions will run on it unless new writes or deletes are stored."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"writes",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#writes",children:"Writes"})}),"\n",(0,a.jsx)(t.p,{children:"Writes are appended to the current WAL segment and are also added to the Cache. Each WAL segment has a maximum size. Writes roll over to a new file once the current file fills up. The cache is also size bounded; snapshots are taken and WAL compactions are initiated when the cache becomes too full. If the inbound write rate exceeds the WAL compaction rate for a sustained period, the cache may become too full, in which case new writes will fail until the snapshot process catches up.\nWhen WAL segments fill up and are closed, the Compactor snapshots the Cache and writes the data to a new TSM file. When the TSM file is successfully written andfsync'd, it is loaded and referenced by the FileStore."}),"\n",(0,a.jsx)(t.h3,{id:"updates",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#updates",children:"Updates"})}),"\n",(0,a.jsx)(t.p,{children:"Updates (writing a newer value for a point that already exists) occur as normal writes. Since cached values overwrite existing values, newer writes take precedence. If a write would overwrite a point in a prior TSM file, the points are merged at query runtime and the newer write takes precedence."}),"\n",(0,a.jsx)(t.h3,{id:"deletes",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#deletes",children:"Deletes"})}),"\n",(0,a.jsx)(t.p,{children:"Deletes occur by writing a delete entry to the WAL for the measurement or series and then updating the Cache and FileStore. The Cache evicts all relevant entries. The FileStore writes a tombstone file for each TSM file that contains relevant data. These tombstone files are used at startup time to ignore blocks as well as during compactions to remove deleted entries.\nQueries against partially deleted series are handled at query time until a compaction removes the data fully from the TSM files."}),"\n",(0,a.jsx)(t.h3,{id:"queries",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#queries",children:"Queries"})}),"\n",(0,a.jsx)(t.p,{children:"When a query is executed by the storage engine, it is essentially a seek to a given time associated with a specific series key and field. First, we do a search on the data files to find the files that contain a time range matching the query as well containing matching series.\nOnce we have the data files selected, we next need to find the position in the file of the series key index entries. We run a binary search against each TSM index to find the location of its index blocks.\nIn common cases the blocks will not overlap across multiple TSM files and we can search the index entries linearly to find the start block from which to read. If there are overlapping blocks of time, the index entries are sorted to ensure newer writes will take precedence and that blocks can be processed in order during query execution.\nWhen iterating over the index entries the blocks are read sequentially from the blocks section. The block is decompressed and we seek to the specific point."}),"\n",(0,a.jsx)(t.h3,{id:"properties-of-time-series-data",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#properties-of-time-series-data",children:"Properties of time series data"})}),"\n",(0,a.jsx)(t.p,{children:"The workload of time series data is quite different from normal database workloads. There are a number of factors that conspire to make it very difficult to scale and remain performant:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Billions of individual data points"}),"\n",(0,a.jsx)(t.li,{children:"High write throughput"}),"\n",(0,a.jsx)(t.li,{children:"High read throughput"}),"\n",(0,a.jsx)(t.li,{children:"Large deletes (data expiration)"}),"\n",(0,a.jsx)(t.li,{children:"Mostly an insert/append workload, very few updates"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The first and most obvious problem is one of scale. In DevOps, IoT, or APM it is easy to collect hundreds of millions or billions of unique data points every day.\nFor example, let's say we have 200 VMs or servers running, with each server collecting an average of 100 measurements every 10 seconds. Given there are 86,400 seconds in a day, a single measurement will generate 8,640 points in a day per server. That gives us a total of 172,800,000 (200 ",(0,a.jsx)(t.em,{children:"100"})," 8,640) individual data points per day. We find similar or larger numbers in sensor data use cases."]}),"\n",(0,a.jsx)(t.p,{children:"The volume of data means that the write throughput can be very high. We regularly get requests for setups than can handle hundreds of thousands of writes per second. Some larger companies will only consider systems that can handle millions of writes per second."}),"\n",(0,a.jsx)(t.p,{children:"At the same time, time series data can be a high read throughput use case. It's true that if you're tracking 700,000 unique metrics or time series you can't hope to visualize all of them. That leads many people to think that you don't actually read most of the data that goes into the database. However, other than dashboards that people have up on their screens, there are automated systems for monitoring or combining the large volume of time series data with other types of data."}),"\n",(0,a.jsx)(t.p,{children:"Inside InfluxDB, aggregate functions calculated on the fly may combine tens of thousands of distinct time series into a single view. Each one of those queries must read each aggregated data point, so for InfluxDB the read throughput is often many times higher than the write throughput."}),"\n",(0,a.jsx)(t.p,{children:"Given that time series is mostly an append-only workload, you might think that it's possible to get great performance on a B+Tree. Appends in the keyspace are efficient and you can achieve greater than 100,000 per second. However, we have those appends happening in individual time series. So the inserts end up looking more like random inserts than append only inserts."}),"\n",(0,a.jsx)(t.p,{children:"One of the biggest problems we found with time series data is that it's very common to delete all data after it gets past a certain age. The common pattern here is that users have high precision data that is kept for a short period of time like a few days or months. Users then downsample and aggregate that data into lower precision rollups that are kept around much longer."}),"\n",(0,a.jsx)(t.p,{children:"The naive implementation would be to simply delete each record once it passes its expiration time. However, that means that once the first points written reach their expiration date, the system is processing just as many deletes as writes, which is something most storage engines aren't designed for."}),"\n",(0,a.jsx)(t.p,{children:"Let's dig into the details of the two types of storage engines we tried and how these properties had a significant impact on our performance."}),"\n",(0,a.jsx)(t.h3,{id:"leveldb-and-log-structured-merge-trees",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#leveldb-and-log-structured-merge-trees",children:"LevelDB and log structured merge trees"})}),"\n",(0,a.jsx)(t.p,{children:'When the InfluxDB project began, we picked LevelDB as the storage engine because we had used it for time series data storage in the product that was the precursor to InfluxDB. We knew that it had great properties for write throughput and everything seemed to "just work".'}),"\n",(0,a.jsx)(t.p,{children:"LevelDB is an implementation of a log structured merge tree (LSM tree) that was built as an open source project at Google. It exposes an API for a key-value store where the key space is sorted. This last part is important for time series data as it allowed us to quickly scan ranges of time as long as the timestamp was in the key.\nLSM Trees are based on a log that takes writes and two structures known as Mem Tables and SSTables. These tables represent the sorted keyspace. SSTables are read only files that are continuously replaced by other SSTables that merge inserts and updates into the keyspace."}),"\n",(0,a.jsx)(t.p,{children:"The two biggest advantages that LevelDB had for us were high write throughput and built in compression. However, as we learned more about what people needed with time series data, we encountered a few insurmountable challenges."}),"\n",(0,a.jsx)(t.p,{children:"The first problem we had was that LevelDB doesn't support hot backups. If you want to do a safe backup of the database, you have to close it and then copy it. The LevelDB variants RocksDB and HyperLevelDB fix this problem, but there was another more pressing problem that we didn't think they could solve."}),"\n",(0,a.jsx)(t.p,{children:"Our users needed a way to automatically manage data retention. That meant we needed deletes on a very large scale. In LSM Trees, a delete is as expensive, if not more so, than a write. A delete writes a new record known as a tombstone. After that queries merge the result set with any tombstones to purge the deleted data from the query return. Later, a compaction runs that removes the tombstone record and the underlying deleted record in the SSTable file."}),"\n",(0,a.jsx)(t.p,{children:"To get around doing deletes, we split data across what we call shards, which are contiguous blocks of time. Shards would typically hold either one day or seven days worth of data. Each shard mapped to an underlying LevelDB. This meant that we could drop an entire day of data by just closing out the database and removing the underlying files."}),"\n",(0,a.jsx)(t.p,{children:"Users of RocksDB may at this point bring up a feature called Column Families. When putting time series data into Rocks, it's common to split blocks of time into column families and then drop those when their time is up. It's the same general idea: create a separate area where you can just drop files instead of updating indexes when you delete a large block of data. Dropping a column family is a very efficient operation. However, column families are a fairly new feature and we had another use case for shards."}),"\n",(0,a.jsx)(t.p,{children:"Organizing data into shards meant that it could be moved within a cluster without having to examine billions of keys. At the time of this writing, it was not possible to move a column family in one RocksDB to another. Old shards are typically cold for writes so moving them around would be cheap and easy. We would have the added benefit of having a spot in the keyspace that is cold for writes so it would be easier to do consistency checks later."}),"\n",(0,a.jsx)(t.p,{children:"The organization of data into shards worked great for a while, until a large amount of data went into InfluxDB. LevelDB splits the data out over many small files. Having dozens or hundreds of these databases open in a single process ended up creating a big problem. Users that had six months or a year of data would run out of file handles. It's not something we found with the majority of users, but anyone pushing the database to its limits would hit this problem and we had no fix for it. There were simply too many file handles open."}),"\n",(0,a.jsx)(t.h3,{id:"boltdb-and-mmap-btrees",children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#boltdb-and-mmap-b-trees",children:"BoltDB and mmap B+Trees"})}),"\n",(0,a.jsx)(t.p,{children:"After struggling with LevelDB and its variants for a year we decided to move over to BoltDB, a pure Golang database heavily inspired by LMDB, a mmap B+Tree database written in C. It has the same API semantics as LevelDB: a key value store where the keyspace is ordered. Many of our users were surprised. Our own posted tests of the LevelDB variants vs. LMDB (a mmap B+Tree) showed RocksDB as the best performer.\nHowever, there were other considerations that went into this decision outside of the pure write performance. At this point our most important goal was to get to something stable that could be run in production and backed up. BoltDB also had the advantage of being written in pure Go, which simplified our build chain immensely and made it easy to build for other OSes and platforms."}),"\n",(0,a.jsx)(t.p,{children:"The biggest win for us was that BoltDB used a single file as the database. At this point our most common source of bug reports were from people running out of file handles. Bolt solved the hot backup problem and the file limit problems all at the same time.\nWe were willing to take a hit on write throughput if it meant that we'd have a system that was more reliable and stable that we could build on. Our reasoning was that for anyone pushing really big write loads, they'd be running a cluster anyway."}),"\n",(0,a.jsx)(t.p,{children:"We released versions 0.9.0 to 0.9.2 based on BoltDB. From a development perspective it was delightful. Clean API, fast and easy to build in our Go project, and reliable. However, after running for a while we found a big problem with write throughput. After the database got over a few GB, writes would start spiking IOPS."}),"\n",(0,a.jsx)(t.p,{children:"Some users were able to get past this by putting InfluxDB on big hardware with near unlimited IOPS. However, most users are on VMs with limited resources in the cloud. We had to figure out a way to reduce the impact of writing a bunch of points into hundreds of thousands of series at a time."}),"\n",(0,a.jsx)(t.p,{children:"With the 0.9.3 and 0.9.4 releases our plan was to put a write ahead log (WAL) in front of Bolt. That way we could reduce the number of random insertions into the keyspace. Instead, we'd buffer up multiple writes that were next to each other and then flush them at once. However, that only served to delay the problem. High IOPS still became an issue and it showed up very quickly for anyone operating at even moderate work loads."}),"\n",(0,a.jsx)(t.p,{children:"However, our experience building the first WAL implementation in front of Bolt gave us the confidence we needed that the write problem could be solved. The performance of the WAL itself was fantastic, the index simply could not keep up. At this point we started thinking again about how we could create something similar to an LSM Tree that could keep up with our write load."}),"\n",(0,a.jsxs)(t.p,{children:["Thus was born the ",(0,a.jsx)(t.strong,{children:"Time Structured Merge Tree."})]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#the-new-influxdb-storage-engine-and-lsm-refined",children:"https://docs.influxdata.com/influxdb/v1.7/concepts/storage_engine/#the-new-influxdb-storage-engine-and-lsm-refined"})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(296540);const a={},i=n.createContext(a);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);