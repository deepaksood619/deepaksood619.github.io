"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[76194],{258498:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"databases-nosql/aws-dynamodb/capacity-modes","title":"Capacity Modes","description":"DynamoDB has two capacity modes, Provisioned and On-Demand. You can switch between these modes once every 24 hours.","source":"@site/docs/databases-nosql/aws-dynamodb/capacity-modes.md","sourceDirName":"databases-nosql/aws-dynamodb","slug":"/databases-nosql/aws-dynamodb/capacity-modes","permalink":"/databases-nosql/aws-dynamodb/capacity-modes","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/aws-dynamodb/capacity-modes.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749575438000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"DynamoDB","permalink":"/databases-nosql/aws-dynamodb/"},"next":{"title":"Cheatsheet","permalink":"/databases-nosql/aws-dynamodb/cheatsheet"}}');var a=t(474848),s=t(28453);const o={},r="Capacity Modes",d={},l=[{value:"Provisioned",id:"provisioned",level:3},{value:"On-Demand",id:"on-demand",level:3},{value:"Calculating Reads and Writes",id:"calculating-reads-and-writes",level:2},{value:"Calculating Reads (RCU)",id:"calculating-reads-rcu",level:3},{value:"Calculating Writes (Writes)",id:"calculating-writes-writes",level:3},{value:"Target Utilization",id:"target-utilization",level:2},{value:"Links",id:"links",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"capacity-modes",children:"Capacity Modes"})}),"\n",(0,a.jsx)(n.p,{children:"DynamoDB has two capacity modes, Provisioned and On-Demand. You can switch between these modes once every 24 hours."}),"\n",(0,a.jsx)(n.h3,{id:"provisioned",children:"Provisioned"}),"\n",(0,a.jsx)(n.p,{children:"Provisioned Throughput Capacity is the maximum amount of capacity your application is allowed to read or write per second from a table or index"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Provisioned is suited for predictable or steady state workloads"}),"\n",(0,a.jsx)(n.li,{children:"RCUs is Read Capacity Unit"}),"\n",(0,a.jsx)(n.li,{children:"WCUsis Write Capacity Unit"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You should enable Auto Scaling with Provisioned capacity mode. In this mode, you set a floor and ceiling for the capacity you wish the table to support. DynamoDB will automatically add and remove capacity to between these values on your behalf and throttle calls that go above the ceiling for too long."}),"\n",(0,a.jsxs)(n.p,{children:["If you go beyond your provisioned capacity, you'll get an Exception: ",(0,a.jsx)(n.code,{children:"ProvisionedThroughputExceededException(throttling)"})]}),"\n",(0,a.jsx)(n.p,{children:"Throttling is when requests are blocked due to read or write frequency higher than set thresholds. E.g. exceeding set provisioned capacity, partitions splitting, table/index capacity mismatch."}),"\n",(0,a.jsx)(n.h3,{id:"on-demand",children:"On-Demand"}),"\n",(0,a.jsx)(n.p,{children:"On-Demand Capacity is pay per request. So you pay only for what you use."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"On-Demand is suited for new or unpredictable workloads"}),"\n",(0,a.jsx)(n.li,{children:"The throughput is only limited by the default upper limits for a table (40K RCUs and 40K WCUs)"}),"\n",(0,a.jsx)(n.li,{children:"Throttling can occurif you exceed double your previous peak capacity (high water mark) within 30 minutes. For example, if you previously peaked to a maximum of 30,000 ops/sec, you could not peak immediately to 90,000 ops/sec, but you could to 60,000 ops/sec."}),"\n",(0,a.jsx)(n.li,{children:"Since there is no hard limit,On-Demand could become very expensivebased on emerging scenarios"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"calculating-reads-and-writes",children:"Calculating Reads and Writes"}),"\n",(0,a.jsx)(n.h3,{id:"calculating-reads-rcu",children:"Calculating Reads (RCU)"}),"\n",(0,a.jsx)(n.p,{children:"A read capacity unitrepresents:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"one strongly consistent read per second,"}),"\n",(0,a.jsx)(n.li,{children:"or two eventually consistent reads per second,"}),"\n",(0,a.jsx)(n.li,{children:"for an item up to 4 KB in size."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"How to calculate RCUs for strong"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Round data up to nearest 4."}),"\n",(0,a.jsx)(n.li,{children:"Divide data by 4"}),"\n",(0,a.jsx)(n.li,{children:"Times by number of reads"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"50 reads at 40KB per item. (40/4) x 50 = 500 RCUs"}),"\n",(0,a.jsx)(n.li,{children:"10 reads at 6KB per item. (8/4) x 10 = 20 RCUs"}),"\n",(0,a.jsx)(n.li,{children:"33 reads at 17KB per item. (20/4) x 33 = 132 RCUs"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"How to calculate RCUs for eventual"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Round data up to nearest 4."}),"\n",(0,a.jsx)(n.li,{children:"Divide data by 4"}),"\n",(0,a.jsx)(n.li,{children:"Times by number of reads"}),"\n",(0,a.jsx)(n.li,{children:"Divide final number by 2"}),"\n",(0,a.jsx)(n.li,{children:"Round up to the nearest whole number"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"50 reads at 40KB per item. (40/4) x 50 / 2 = 250 RCUs"}),"\n",(0,a.jsx)(n.li,{children:"11 reads at 9KB per item. (12/4) x 11 / 2 = 17 RCUs"}),"\n",(0,a.jsx)(n.li,{children:"14 reads at 24KB per item. (24/4) x 14 / 2 = 35 RCUs"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"calculating-writes-writes",children:"Calculating Writes (Writes)"}),"\n",(0,a.jsx)(n.p,{children:"A write capacity unit represents:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"one write per second,"}),"\n",(0,a.jsx)(n.li,{children:"for an item up to 1 KB"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"How to calculate Writes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Round data up to nearest 1."}),"\n",(0,a.jsx)(n.li,{children:"Times by number of writes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"50 writes at 40KB per item. 40 x 50 = 2000 WCUs"}),"\n",(0,a.jsx)(n.li,{children:"11 writes at 1KB per item. 1 x 11 = 11 WCUs"}),"\n",(0,a.jsx)(n.li,{children:"18 writes at 500 BYTES per item. 1 x 18 = 18 WCUs"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"target-utilization",children:"Target Utilization"}),"\n",(0,a.jsx)(n.p,{children:"DynamoDB Autoscaling will then vary the provisioned throughput between the maximum and mimumum bounds set. It will aim to keep this throughput provision at the utilization capacity."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Target utilization is the ratio of consumed capacity units to provisioned capacity units, expressed as a percentage"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"A good starting point is to ask why not set target utilization to 100%? This sounds efficient, because you will only be paying for the throughput you use. But there is a problem to this:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"DynamoDB auto scaling modifies provisioned throughput settings only when the actual workload stays elevated (or depressed) for a sustained period of several minutes"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["So, imagine your target utilization is 100% and you have increased demand on your table for 15 minutes. For the first 5 minutes you might be saved by ",(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html#bp-partition-key-throughput-bursting",children:"burst capacity"}),", in the second lot of 5 minutes you are likely to see database read/write failures as your throughput is exceeded, and then after around 10 minutes Autoscaling should kick in and increase your throughput."]}),"\n",(0,a.jsx)(n.p,{children:"This is the problem you are trying to avoid by setting target utilization (i.e. an increase in demand causing throttling). You need to consider two things"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1) What is the biggest change in throughput capacity usage you see over a time period of 15 minutes expressed as a percentage? Leave this amount of room in your target utilization."})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"2) How much do you care if you have some database throttling? (i.e. some database read/writes fail?) Adjust your target utilization higher or lower depending on your appetite for cost saving versus throttling."})}),"\n",(0,a.jsx)(n.p,{children:"Lets say you look over one week of data, and find that in a 15 minute period, the largest increase in throughput you see is 20%. That gives you a target utilization of 80% (because then your increased demand is absorbed by autoscaling)*. However lets say you are cautious and you really aren't OK with database throttling, so to be on the safe side, you might go with 70%."}),"\n",(0,a.jsxs)(n.p,{children:["Hope that helps make some decisions. In summary, ",(0,a.jsx)(n.strong,{children:"your target utilization should be a function of how quickly your throughput capacity changes, and how averse you are to throttling."})]}),"\n",(0,a.jsx)(n.p,{children:"EDIT:*The maths isn't perfect here, but you get the idea I think. And its probably a close enough approximation."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://stackoverflow.com/questions/50014572/how-to-calculate-target-utilization-in-dynamodb-table",children:"amazon web services - How to calculate Target Utilization in DynamoDB table? - Stack Overflow"})}),"\n",(0,a.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/switching.capacitymode.html",children:"Considerations when changing read/write Capacity Mode - Amazon DynamoDB"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://aws.amazon.com/blogs/database/amazon-dynamodb-auto-scaling-performance-and-cost-optimization-at-any-scale/",children:"Amazon DynamoDB auto scaling: Performance and cost optimization at any scale | AWS Database Blog"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(296540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);