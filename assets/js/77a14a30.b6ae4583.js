"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[43783],{449698:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"algorithms/dynamic-programming/intro","title":"Intro","description":"Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems and stores the results of subproblems to avoid computing the same results again.","source":"@site/docs/algorithms/dynamic-programming/intro.md","sourceDirName":"algorithms/dynamic-programming","slug":"/algorithms/dynamic-programming/intro","permalink":"/algorithms/dynamic-programming/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/dynamic-programming/intro.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"How to find DP","permalink":"/algorithms/dynamic-programming/how-to-find-dp"},"next":{"title":"Knapsack Problem","permalink":"/algorithms/dynamic-programming/knapsack-problem"}}');var i=r(474848),n=r(28453);const s={},a="Intro",l={},d=[{value:"Overlapping Subproblem Property",id:"overlapping-subproblem-property",level:2},{value:"Memoization (Top Down approach)",id:"memoization-top-down-approach",level:3},{value:"Tabulation (Bottom up approach)",id:"tabulation-bottom-up-approach",level:3},{value:"Optimal Substructure Property",id:"optimal-substructure-property",level:2},{value:"Algorithms",id:"algorithms",level:2},{value:"References",id:"references",level:2}];function h(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"intro",children:"Intro"})}),"\n",(0,i.jsx)(t.p,{children:"Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems and stores the results of subproblems to avoid computing the same results again."}),"\n",(0,i.jsxs)(t.p,{children:["The idea is very simple, If you have solved a problem with the given input, then save the result for future reference, so as to avoid solving the same problem again. shortly ",(0,i.jsx)(t.strong,{children:"'Remember your Past'"})]}),"\n",(0,i.jsx)(t.p,{children:"Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial."}),"\n",(0,i.jsx)(t.h2,{id:"overlapping-subproblem-property",children:"Overlapping Subproblem Property"}),"\n",(0,i.jsx)(t.p,{children:"In dynamic programming, computed solutions to subproblems are stored in a table so that these don't have to be recomputed."}),"\n",(0,i.jsx)(t.p,{children:"There are following two different ways to store the values so that these values can be reused:"}),"\n",(0,i.jsx)(t.h3,{id:"memoization-top-down-approach",children:"Memoization (Top Down approach)"}),"\n",(0,i.jsx)(t.p,{children:"The memoized program for a problem is similar to the recursive version with a small modification that it looks into a lookup table before computing solutions. We initialize a lookup array with all initial values as NIL. Whenever we need solution to a subproblem, we first look into the lookup table. If the precomputed value is there then we return that value, otherwise we calculate the value and put the result in lookup table so that it can be reused later."}),"\n",(0,i.jsxs)(t.p,{children:["Start solving the given problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. If it has not been solved, solve it and save the answer. This is usually easy to think of and very intuitive. This is referred to as ",(0,i.jsx)(t.strong,{children:"Memoization"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"tabulation-bottom-up-approach",children:"Tabulation (Bottom up approach)"}),"\n",(0,i.jsx)(t.p,{children:"The tabulated program for a given problem builds a table in bottom up fashion and returns the last entry from table."}),"\n",(0,i.jsxs)(t.p,{children:["Analyze the problem and see the order in which the sub-problems are solved and start solving from the trivial subproblem, up towards the given problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This is referred to as ",(0,i.jsx)(t.strong,{children:"Dynamic Programming"}),"."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{}),(0,i.jsx)(t.th,{children:"Tabulation"}),(0,i.jsx)(t.th,{children:"Memoization"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"State"})}),(0,i.jsx)(t.td,{children:"State transition relation is difficult to think"}),(0,i.jsx)(t.td,{children:"State Transition relation is easy to think"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Code"})}),(0,i.jsx)(t.td,{children:"Code gets complicated when a lot of conditions are required"}),(0,i.jsx)(t.td,{children:"Code is easy and less complicated"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Speed"})}),(0,i.jsx)(t.td,{children:"Fast, as we directly access previous states from the table"}),(0,i.jsx)(t.td,{children:"Slow due to a lot of recursive calls and return statements"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Subproblem solving"})}),(0,i.jsx)(t.td,{children:"If all subproblems must be solved at least once, a bottom-up dynamic programming algorithm usually outperforms a top-down memoized algorithm by a constant factor"}),(0,i.jsx)(t.td,{children:"If some subproblems in the subproblem space need not be solved at all, the memoized solution has the advantage of solving only those subproblems that are definitely required"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Table entries"})}),(0,i.jsx)(t.td,{children:"In the Tabulated version, starting from the first entry, all entries are filled one by one"}),(0,i.jsx)(t.td,{children:"Unlike the Tabulated version, all entries of the lookup table are not necessarily filled in Memoized version. The table is filled on demand."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Approach"})}),(0,i.jsx)(t.td,{children:"Generally, tabulation (dynamic programming) is an iterative approach"}),(0,i.jsx)(t.td,{children:"On the other hand, memoization is a recursive approach."})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"optimal-substructure-property",children:"Optimal Substructure Property"}),"\n",(0,i.jsx)(t.p,{children:"A given problems has Optimal Substructure Property if optimal solution of the given problem can be obtained by using optimal solutions of its subproblems."}),"\n",(0,i.jsx)(t.p,{children:"Both Tabulated and Memoized store the solutions of subproblems. In Memoized version, table is filled on demand while in Tabulated version, starting from the first entry, all entries are filled one by one. Unlike the Tabulated version, all entries of the lookup table are not necessarily filled in Memoized version."}),"\n",(0,i.jsx)(t.p,{children:"Majority of the Dynamic Programming problems can be categorized into two types:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Optimization problems"}),"\n",(0,i.jsx)(t.li,{children:"Combinatorial problems"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"algorithms",children:"Algorithms"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Fibonacci Series"}),"\n",(0,i.jsx)(t.li,{children:"Edit Distance"}),"\n",(0,i.jsx)(t.li,{children:"Longest Common Subsequence"}),"\n",(0,i.jsx)(t.li,{children:"Bellman-Ford shortest path routing algorithm"}),"\n",(0,i.jsx)(t.li,{children:"Subset sum"}),"\n",(0,i.jsx)(t.li,{children:"Coin change"}),"\n",(0,i.jsx)(t.li,{children:"Seam Carving"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/dynamic-programming",children:"https://www.geeksforgeeks.org/dynamic-programming"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials",children:"https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/dynamic-programming-set-1",children:"https://www.geeksforgeeks.org/dynamic-programming-set-1"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property",children:"https://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges",children:"https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr",children:"Dynamic Programming"})})]})}function m(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>a});var o=r(296540);const i={},n=o.createContext(i);function s(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);