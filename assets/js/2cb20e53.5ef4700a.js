"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[44923],{580389:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"computer-science/security/cryptography/hash-function-design","title":"Hash Function Design","description":"Merkle--Damg\xe5rd construction","source":"@site/docs/computer-science/security/cryptography/hash-function-design.md","sourceDirName":"computer-science/security/cryptography","slug":"/computer-science/security/cryptography/hash-function-design","permalink":"/computer-science/security/cryptography/hash-function-design","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/security/cryptography/hash-function-design.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Diffie-Hellman Key Exchange","permalink":"/computer-science/security/cryptography/diffie-hellman-key-exchange"},"next":{"title":"Cryptography","permalink":"/computer-science/security/cryptography/intro"}}');var a=i(474848),n=i(28453);const o={},r="Hash Function Design",h={},c=[{value:"Merkle--Damg\xe5rd construction",id:"merkle--damg\xe5rd-construction",level:3},{value:"Wide pipe vs narrow pipe",id:"wide-pipe-vs-narrow-pipe",level:4},{value:"Salt",id:"salt",level:3},{value:"Why should you use a salt?",id:"why-should-you-use-a-salt",level:4},{value:"Key derivation function",id:"key-derivation-function",level:2},{value:"Cryptographic key derivation",id:"cryptographic-key-derivation",level:4},{value:"Password storage",id:"password-storage",level:4}];function d(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"hash-function-design",children:"Hash Function Design"})}),"\n",(0,a.jsx)(t.h3,{id:"merkle--damg\xe5rd-construction",children:"Merkle--Damg\xe5rd construction"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(12986).A+"",width:"450",height:"210"})}),"\n",(0,a.jsxs)(t.p,{children:["A hash function must be able to process an arbitrary-length message into a fixed-length output. This can be achieved by breaking the input up into a series of equal-sized blocks, and operating on them in sequence using a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/One-way_compression_function",children:"one-way compression function"}),". The compression function can either be specially designed for hashing or be built from a block cipher. A hash function built with the Merkle--Damg\xe5rd construction is as resistant to collisions as is its compression function; any collision for the full hash function can be traced back to a collision in the compression function.\nThe last block processed should also be unambiguously ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Padding_(cryptography)",children:"length padded"}),"; this is crucial to the security of this construction. This construction is called the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction",children:"Merkle--Damg\xe5rd construction"}),". Most common classical hash functions, including ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/SHA-1",children:"SHA-1"})," and ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/MD5",children:"MD5"}),", take this form."]}),"\n",(0,a.jsx)(t.h4,{id:"wide-pipe-vs-narrow-pipe",children:"Wide pipe vs narrow pipe"}),"\n",(0,a.jsxs)(t.p,{children:["A straightforward application of the Merkle--Damg\xe5rd construction, where the size of hash output is equal to the internal state size (between each compression step), results in anarrow-pipehash design. This design causes many inherent flaws, including ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Length_extension_attack",children:"length-extension"}),", multicollisions, long message attacks, generate-and-paste attacks, and also cannot be parallelized. As a result, modern hash functions are built on wide-pipe constructions that have a larger internal state size - which range from tweaks of the Merkle--Damg\xe5rd construction to new constructions such as the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Sponge_construction",children:"sponge construction"})," and ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/HAIFA_construction",children:"HAIFA construction"}),".None of the entrants in the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/NIST_hash_function_competition",children:"NIST hash function competition"})," use a classical Merkle--Damg\xe5rd construction.\nMeanwhile, truncating the output of a longer hash, such as used in SHA-512/256, also defeats many of these attacks."]}),"\n",(0,a.jsx)(t.h3,{id:"salt",children:"Salt"}),"\n",(0,a.jsx)(t.p,{children:'A "salt" is a random piece of data that is often added to the data you want to hash before you actually hash it. Adding a salt to your data before hashing it will make the output of the hash function different than it would be if you had only hashed the data.\nWhen a user sets their password (often on signing up), a random salt should be generated and used to compute the password hash. The salt should then be stored with the password hash. When the user tries to log in, combine the salt with the supplied password, hash the combination of the two, and compare it to the hash in the database.'}),"\n",(0,a.jsx)(t.h4,{id:"why-should-you-use-a-salt",children:"Why should you use a salt?"}),"\n",(0,a.jsxs)(t.p,{children:["Without going into too much detail, hackers commonly use ",(0,a.jsx)(t.a,{href:"https://www.geeksforgeeks.org/understanding-rainbow-table-attack/",children:"rainbow table attacks"}),", ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Dictionary_attack",children:"dictionary attacks"}),", and ",(0,a.jsx)(t.a,{href:"http://www.tenminutetutor.com/data-formats/cryptography/attacks-on-hash-algorithms/",children:"brute-force attacks"})," to try and crack password hashes. While hackers can't compute the original password given only a hash, they can take a long list of possible passwords and compute hashes for them to try and match them with the passwords in the database. This is effectively how these types of attacks work, although each of the above works somewhat differently."]}),"\n",(0,a.jsx)(t.p,{children:"A salt makes it much more difficult for hackers to perform these types of attacks. Depending on the hash function, salted hashes take nearly exponentially more time to crack than unsalted ones. They also make rainbow table attacks nearly impossible. It's therefore important to always use salts in your hashes."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://dev.to/kmistele/how-to-securely-hash-and-store-passwords-in-your-next-application-4e2f",children:"https://dev.to/kmistele/how-to-securely-hash-and-store-passwords-in-your-next-application-4e2f"})}),"\n",(0,a.jsx)(t.h2,{id:"key-derivation-function",children:"Key derivation function"}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cryptography",children:"cryptography"}),", a key derivation function (KDF) is a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_hash_function",children:"cryptographic hash function"})," that derives one or more ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Key_(cryptography)",children:"secret keys"})," from a secret value such as a main key, a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Password",children:"password"}),", or a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Passphrase",children:"passphrase"})," using a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Pseudorandom_function",children:"pseudorandom function"}),". KDFs can be used to stretch keys into longer keys or to obtain keys of a required format, such as converting a group element that is the result of a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange",children:"Diffie--Hellman key exchange"})," into a symmetric key for use with ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard",children:"AES"}),". ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/HMAC",children:"Keyed cryptographic hash functions"})," are popular examples of pseudorandom functions used for key derivation."]}),"\n",(0,a.jsx)(t.p,{children:"There are many forms of KDF's, and not all functions used as KDF are explicitly named as KDF's. For instance, the KDF of TLS is simply called \"the PRF\" for Pseudo-Random-Functions, which is a much more generic term."}),"\n",(0,a.jsx)(t.p,{children:"Key derivation functions derive bytes suitable for cryptographic operations from passwords or other data sources using a pseudo-random function (PRF). Different KDFs are suitable for different tasks such as:"}),"\n",(0,a.jsx)(t.h4,{id:"cryptographic-key-derivation",children:"Cryptographic key derivation"}),"\n",(0,a.jsxs)(t.p,{children:["Deriving a key suitable for use as input to an encryption algorithm. Typically this means taking a password and running it through an algorithm such as ",(0,a.jsx)(t.a,{href:"https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/#cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC",children:"PBKDF2HMAC"})," or ",(0,a.jsx)(t.a,{href:"https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/#cryptography.hazmat.primitives.kdf.hkdf.HKDF",children:"HKDF"}),". This process is typically known as ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Key_stretching",children:"key stretching"}),"."]}),"\n",(0,a.jsx)(t.h4,{id:"password-storage",children:"Password storage"}),"\n",(0,a.jsx)(t.p,{children:"When storing passwords you want to use an algorithm that is computationally intensive. Legitimate users will only need to compute it once (for example, taking the user's password, running it through the KDF, then comparing it to the stored value), while attackers will need to do it billions of times. Ideal password storage KDFs will be demanding on both computational and memory resources."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=gTfNtop9vzM",children:"What is a Cryptographic Hashing Function? (Example + Purpose) - YouTube"})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},12986:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Cryptography-Intro_Cryptographic-Hash-Functions-image1-152f65e76d5032f4f7b7c1df09ae9b61.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var s=i(296540);const a={},n=s.createContext(a);function o(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);