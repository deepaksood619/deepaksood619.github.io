"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[43894],{37046:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"databases/data-warehouses/clickhouse/mergetree-engine-family","title":"MergeTree Engine Family","description":"Table engines from the MergeTree family are the core of ClickHouse data storage capabilities. They provide most features for resilience and high-performance data retrieval: columnar storage, custom partitioning, sparse primary index, secondary data-skipping indexes, etc.","source":"@site/docs/databases/data-warehouses/clickhouse/mergetree-engine-family.md","sourceDirName":"databases/data-warehouses/clickhouse","slug":"/databases/data-warehouses/clickhouse/mergetree-engine-family","permalink":"/databases/data-warehouses/clickhouse/mergetree-engine-family","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/data-warehouses/clickhouse/mergetree-engine-family.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1747376238000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Memory Engine","permalink":"/databases/data-warehouses/clickhouse/memory-engine"},"next":{"title":"Queries","permalink":"/databases/data-warehouses/clickhouse/queries"}}');var i=r(474848),n=r(28453);const a={},c="MergeTree Engine Family",o={},l=[];function d(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"mergetree-engine-family",children:"MergeTree Engine Family"})}),"\n",(0,i.jsx)(t.p,{children:"Table engines from the MergeTree family are the core of ClickHouse data storage capabilities. They provide most features for resilience and high-performance data retrieval: columnar storage, custom partitioning, sparse primary index, secondary data-skipping indexes, etc."}),"\n",(0,i.jsxs)(t.p,{children:["Base\xa0",(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"MergeTree"}),"\xa0table engine can be considered the default table engine for single-node ClickHouse instances because it is versatile and practical for a wide range of use cases."]}),"\n",(0,i.jsxs)(t.p,{children:["For production usage\xa0",(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication",children:"ReplicatedMergeTree"}),"\xa0is the way to go, because it adds high-availability to all features of regular MergeTree engine. A bonus is automatic data deduplication on data ingestion, so the software can safely retry if there was some network issue during insert."]}),"\n",(0,i.jsx)(t.p,{children:"All other engines of MergeTree family add extra functionality for some specific use cases. Usually, it's implemented as additional data manipulation in background."}),"\n",(0,i.jsxs)(t.p,{children:["The main downside of MergeTree engines is that they are rather heavy-weight. So the typical pattern is to have not so many of them. If you need many small tables, for example for temporary data, consider\xa0",(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/log-family",children:"Log engine family"}),"."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Page"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/aggregatingmergetree",children:"AggregatingMergeTree"})}),(0,i.jsxs)(t.td,{children:["Replaces all rows with the same primary key (or more accurately, with the same\xa0",(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"sorting key"}),") with a single row (within a single data part) that stores a combination of states of aggregate functions."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/annindexes",children:"Exact and Approximate Nearest Neighbor Search"})}),(0,i.jsx)(t.td,{children:"Documentation for Exact and Approximate Nearest Neighbor Search"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/collapsingmergetree",children:"CollapsingMergeTree"})}),(0,i.jsx)(t.td,{children:"Inherits from MergeTree but adds logic for collapsing rows during the merge process."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/custom-partitioning-key",children:"Custom Partitioning Key"})}),(0,i.jsx)(t.td,{children:"Learn how to add a custom partitioning key to MergeTree tables."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/graphitemergetree",children:"GraphiteMergeTree"})}),(0,i.jsx)(t.td,{children:"Designed for thinning and aggregating/averaging (rollup) Graphite data."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/invertedindexes",children:"Full-text Search using Full-text Indexes"})}),(0,i.jsx)(t.td,{children:"Quickly find search terms in text."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree",children:"MergeTree"})}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"MergeTree"}),"-family table engines are designed for high data ingest rates and huge data volumes."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replacingmergetree",children:"ReplacingMergeTree"})}),(0,i.jsxs)(t.td,{children:["differs from MergeTree in that it removes duplicate entries with the same sorting key value (",(0,i.jsx)(t.code,{children:"ORDER BY"}),"\xa0table section, not\xa0",(0,i.jsx)(t.code,{children:"PRIMARY KEY"}),")."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication",children:"Data Replication"})}),(0,i.jsx)(t.td,{children:"Overview of Data Replication in ClickHouse"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/summingmergetree",children:"SummingMergeTree"})}),(0,i.jsx)(t.td,{children:"SummingMergeTree inherits from the MergeTree engine. Its key feature is the ability to automatically sum numeric data during part merges."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family/versionedcollapsingmergetree",children:"VersionedCollapsingMergeTree"})}),(0,i.jsx)(t.td,{children:"Allows for quick writing of object states that are continually changing, and deleting old object states in the background."})]})]})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/engines/table-engines/mergetree-family",children:"MergeTree Engine Family | ClickHouse Docs"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>c});var s=r(296540);const i={},n=s.createContext(i);function a(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);