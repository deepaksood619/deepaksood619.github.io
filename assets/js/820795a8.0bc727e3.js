"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[49011],{329185:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>d,contentTitle:()=>h,default:()=>a,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"algorithms/bit-manipulation/general","title":"General","description":"Bitwise Operators ( a = 60, b = 13)","source":"@site/docs/algorithms/bit-manipulation/general.md","sourceDirName":"algorithms/bit-manipulation","slug":"/algorithms/bit-manipulation/general","permalink":"/algorithms/bit-manipulation/general","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/bit-manipulation/general.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Examples","permalink":"/algorithms/bit-manipulation/examples"},"next":{"title":"Complex Systems","permalink":"/algorithms/complex-systems/"}}');var s=t(474848),r=t(28453);const l={},h="General",d={},o=[{value:"Tricks",id:"tricks",level:2},{value:"Bit Shift",id:"bit-shift",level:2},{value:"Arithmetic Shift",id:"arithmetic-shift",level:3},{value:"Logical Shift",id:"logical-shift",level:3},{value:"XOR",id:"xor",level:2},{value:"Method 2 (Efficient method)",id:"method-2-efficient-method",level:3},{value:"Caching or Indexing",id:"caching-or-indexing",level:2},{value:"1s 2s Complement",id:"1s-2s-complement",level:2}];function c(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"general",children:"General"})}),"\n",(0,s.jsx)(i.p,{children:"Bitwise Operators ( a = 60, b = 13)"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"a = 0011 1100"}),"\n",(0,s.jsx)(i.li,{children:"b = 0000 1101"}),"\n"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Operator"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Description"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Example"})})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"& Binary AND"})}),(0,s.jsx)(i.td,{children:"Operator copies a bit to the result if it exists in both operands"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"(a & b)"})," (means 0000 1100)"]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"| Binary OR"})}),(0,s.jsx)(i.td,{children:"It copies a bit if it exists in either operand."}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"(a | b) = 61"})," (means 0011 1101)"]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"^ Binary XOR"})}),(0,s.jsx)(i.td,{children:"It copies the bit if it is set in one operand but not both."}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"(a ^ b) = 49"})," (means 0011 0001)"]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"~ Binary Ones Complement"})}),(0,s.jsx)(i.td,{children:"It is unary and has the effect of 'flipping' bits."}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"(~a ) = -61"})," means 1100 0011 in 2's complement form due to a signed binary number."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"<< Binary Left Shift"})}),(0,s.jsx)(i.td,{children:"The left operands value is moved left by the number of bits specified by the right operand."}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"a << 2 = 240 (means 1111 0000)"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:">> Binary Right Shift"})}),(0,s.jsx)(i.td,{children:"The left operands value is moved right by the number of bits specified by the right operand."}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"a >> 2 = 15 (means 0000 1111)"})})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"tricks",children:"Tricks"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x & (x-1)will clear the lowest set bit of x"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"(x & (1 << i)) != 0, Get the i^th^ bit"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x & ~(x-1)extracts the lowest set bit of x (all others are clear). Pretty patterns when applied to a linear sequence."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x & (x + (1 << n))= x, with the run of set bits (possibly length 0) starting at bit n cleared."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x & ~(x + (1 << n))= the run of set bits (possibly length 0) in x, starting at bit n."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"(x & (~(1 << i))), clear i^th^ bit"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x | (x + 1)= x with the lowest cleared bit set."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"(x | (1 << i)), Set the i^th^ bit"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x | ~(x + 1)= extracts the lowest cleared bit of x (all others are set)."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x | (x - (1 << n))= x, with the run of cleared bits (possibly length 0) starting at bit n set."})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x | ~(x - (1 << n))= the lowest run of cleared bits (possibly length 0) in x, starting at bit n are the only clear bits."})}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"bit-shift",children:"Bit Shift"}),"\n",(0,s.jsx)(i.h3,{id:"arithmetic-shift",children:"Arithmetic Shift"}),"\n",(0,s.jsxs)(i.p,{children:["In an ",(0,s.jsx)(i.em,{children:"arithmetic shift"}),", the bits that are shifted out of either end are discarded. In a left arithmetic shift, zeros are shifted in on the right; in a right arithmetic shift, the ",(0,s.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Sign_bit",children:"sign bit"}),"(the MSB in two's complement) is shifted in on the left, thus preserving the sign of the operand."]}),"\n",(0,s.jsx)(i.h3,{id:"logical-shift",children:"Logical Shift"}),"\n",(0,s.jsxs)(i.p,{children:["In a ",(0,s.jsx)(i.em,{children:"logical shift"}),", zeros are shifted in to replace the discarded bits. Therefore, the logical and arithmetic left-shifts are exactly the same."]}),"\n",(0,s.jsxs)(i.p,{children:["However, as the logical right-shift inserts value 0 bits into the most significant bit, instead of copying the sign bit, it is ideal for unsigned binary numbers, while the arithmetic right-shift is ideal for signed ",(0,s.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Two%27s_complement",children:"two's complement"})," binary numbers."]}),"\n",(0,s.jsx)(i.h2,{id:"xor",children:"XOR"}),"\n",(0,s.jsx)(i.p,{children:"XOR by 1 can work like a toggle switch that turns 1 to 0 or 0 to 1."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"0 ^ 1 = 1"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"1 ^ 1 = 0"})}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Another interesting thing to note is"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x^0 = x"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"x^x = 0"})}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"XOR - Bitwise XOR of N numbers can be calculated as follows : For each bit position (lets say p), if the number of 1's in the binary representation of the involved numbers at position p is odd then the result is 1 else 0. For example, bitwise XOR of three numbers (3, 4, 5) is (011, 100, 101) => (010) = 2. The LSB and MSB has two 1's so result is 0 for those bits. In most languages, [^] operator can be used to find Xor"}),"\n",(0,s.jsx)(i.h3,{id:"method-2-efficient-method",children:"Method 2 (Efficient method)"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Find the remainder of n by moduling it with 4."}),"\n",(0,s.jsx)(i.li,{children:"If rem = 0, then xor will be same as n."}),"\n",(0,s.jsx)(i.li,{children:"If rem = 1, then xor will be 1."}),"\n",(0,s.jsx)(i.li,{children:"If rem = 2, then xor will be n+1."}),"\n",(0,s.jsx)(i.li,{children:"If rem = 3 , then xor will be 0."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.a,{href:"https://www.geeksforgeeks.org/calculate-xor-1-n",children:"https://www.geeksforgeeks.org/calculate-xor-1-n"})}),"\n",(0,s.jsx)(i.p,{children:"OR - Bitwise OR of N numbers can be calculated as follows : Unlike Xor, if any of the N Number has a 1 in that position (lets say p), then the result at p is 1 else 0. Bitwise OR of (3, 4, 5) is (011, 100, 101) => (111) = 7. All bit positions have atleast 1 number with a 1. In most programming languages [|] operator can be used to find Or"}),"\n",(0,s.jsx)(i.h2,{id:"caching-or-indexing",children:"Caching or Indexing"}),"\n",(0,s.jsx)(i.p,{children:"Caching or Indexing is a technique used to store counts of values which lie in a small range."}),"\n",(0,s.jsx)(i.h2,{id:"1s-2s-complement",children:"1s 2s Complement"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=lKTsv6iVxV4",children:"Binary: Plusses & Minuses (Why We Use Two's Complement) - Computerphile"})})]})}function a(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>l,x:()=>h});var n=t(296540);const s={},r=n.createContext(s);function l(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function h(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);