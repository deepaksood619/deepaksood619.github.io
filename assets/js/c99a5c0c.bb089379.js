"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[19362],{780559:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"algorithms/advanced-algorithms/disk-scheduling-algorithms","title":"Disk Scheduling Algorithms","description":"Elevator algorithm / SCAN","source":"@site/docs/algorithms/advanced-algorithms/disk-scheduling-algorithms.md","sourceDirName":"algorithms/advanced-algorithms","slug":"/algorithms/advanced-algorithms/disk-scheduling-algorithms","permalink":"/algorithms/advanced-algorithms/disk-scheduling-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/advanced-algorithms/disk-scheduling-algorithms.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Automated Planning and Scheduling","permalink":"/algorithms/advanced-algorithms/automated-planning-and-scheduling"},"next":{"title":"Informed Search Algorithms","permalink":"/algorithms/advanced-algorithms/informed-search-algorithms"}}');var r=t(474848),n=t(28453);const a={},o="Disk Scheduling Algorithms",h={},d=[{value:"Elevator algorithm / SCAN",id:"elevator-algorithm--scan",level:2},{value:"Variations",id:"variations",level:4},{value:"FSCAN",id:"fscan",level:3},{value:"Analysis",id:"analysis",level:4},{value:"LOOK",id:"look",level:3},{value:"Variants",id:"variants",level:2},{value:"C-LOOK(Circular LOOK)",id:"c-lookcircular-look",level:3},{value:"N-LOOK and F-LOOK",id:"n-look-and-f-look",level:3},{value:"S-LOOK",id:"s-look",level:3},{value:"Performance",id:"performance",level:2},{value:"Shortest seek first",id:"shortest-seek-first",level:3}];function l(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"disk-scheduling-algorithms",children:"Disk Scheduling Algorithms"})}),"\n",(0,r.jsx)(i.h2,{id:"elevator-algorithm--scan",children:"Elevator algorithm / SCAN"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.strong,{children:"elevator algorithm"})," (also ",(0,r.jsx)(i.strong,{children:"SCAN"}),") is a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hard_disk",children:"disk"}),"-",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/I/O_scheduling",children:"scheduling"})," algorithm to determine the motion of the disk's arm and head in servicing read and write requests."]}),"\n",(0,r.jsxs)(i.p,{children:["This algorithm is named after the behavior of a building ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Elevator",children:"elevator"}),", where the elevator continues to travel in its current direction (up or down) until empty, stopping only to let individuals off or to pick up new individuals heading in the same direction."]}),"\n",(0,r.jsxs)(i.p,{children:["From an implementation perspective, the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Disk_drive",children:"drive"})," maintains a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_buffer",children:"buffer"})," of pending read/write requests, along with the associated ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cylinder_(disk_drive)",children:"cylinder"})," number of the request. (Lower cylinder numbers generally indicate that the cylinder is closer to the spindle, and higher numbers indicate the cylinder is farther away.)"]}),"\n",(0,r.jsx)(i.p,{children:"When a new request arrives while the drive is idle, the initial arm/head movement will be in the direction of the cylinder where the data is stored, eitherinorout. As additional requests arrive, requests are serviced only in the current direction of arm movement until the arm reaches the edge of the disk. When this happens, the direction of the arm reverses, and the requests that were remaining in the opposite direction are serviced, and so on."}),"\n",(0,r.jsx)(i.h4,{id:"variations",children:"Variations"}),"\n",(0,r.jsx)(i.p,{children:'One variation of this method ensures all requests are serviced in only one direction, that is, once the head has arrived at the outer edge of the disk, it returns to the beginning and services the new requests in this one direction only (or vice versa). This is known as the "Circular Elevator Algorithm" or C-SCAN. Although the time of the return seek is wasted, this results in more equal performance for all head positions, as the expected distance from the head is always half the maximum distance, unlike in the standard elevator algorithm where cylinders in the middle will be serviced as much as twice as often as the innermost or outermost cylinders.'}),"\n",(0,r.jsx)(i.p,{children:"Other variations include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/FSCAN",children:"FSCAN"})}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/LOOK_algorithm",children:"LOOK"}),"(andC-LOOK)"]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/N-Step-SCAN",children:"N-Step-SCAN"})}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Elevator_algorithm",children:"https://en.wikipedia.org/wiki/Elevator_algorithm"})}),"\n",(0,r.jsx)(i.h3,{id:"fscan",children:"FSCAN"}),"\n",(0,r.jsxs)(i.p,{children:["FScan is a disk ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/I/O_scheduling",children:"scheduling"})," algorithm to determine the motion of the disk's arm and head in servicing read and write requests. It uses two sub-queues. During the scan, all of the requests are in the first queue and all new requests are put into the second ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Queue_(data_structure)",children:"queue"}),". Thus, service of new requests is deferred until all of the old requests have been processed. When the scan ends, the arm is taken to the first queue entries and is started all over again"]}),"\n",(0,r.jsx)(i.h4,{id:"analysis",children:"Analysis"}),"\n",(0,r.jsxs)(i.p,{children:["FSCAN along with ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/N-Step-SCAN",children:"N-Step-SCAN"}),' prevents "arm stickiness" unlike ',(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Shortest_seek_first",children:"SSTF"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Elevator_algorithm",children:"SCAN"}),", and ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/C-SCAN",children:"C-SCAN"}),'. Arm stickiness in those other algorithms occurs when a stream of requests for the same track causes the disk arm to stop progressing at that track, preferring to satisfy the no-seek requests for the track it is on. Because FSCAN separates requests into two queues, with new requests going into a waiting queue, the arm continues its sweep to the outer track and is therefore not "sticky." There is an obvious trade-off in that the requests in the waiting queue must wait longer to be fulfilled, but in exchange FSCAN is more fair to all requests.']}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/FSCAN",children:"https://en.wikipedia.org/wiki/FSCAN"})}),"\n",(0,r.jsx)(i.h3,{id:"look",children:"LOOK"}),"\n",(0,r.jsxs)(i.p,{children:["LOOK is a disk ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/I/O_scheduling",children:"scheduling"})," algorithm used to determine the order in which new disk read and write requests are processed."]}),"\n",(0,r.jsx)(i.p,{children:'The LOOK algorithm is the same as the SCAN algorithm in that it also honors requests on both sweep direction of the disk head, however, this algorithm "Looks" ahead to see if there are any requests pending in the direction of head movement. If no requests are pending in the direction of head movement, then the disk head traversal will be reversed to the opposite direction and requests on the other direction can be served. In LOOK scheduling, the arm goes only as far as final requests in each direction and then reverses direction without going all the way to the end. Consider an example, Given a disk with 200 cylinders (0-199), suppose we have 8 pending requests: 98, 183, 37, 122, 14, 124, 65, 67 and that the read/write head is currently at cylinder 53. In order to complete these requests, the arm will move in the increasing order first and then will move in decreasing order after reaching the end. So, the order in which it will execute is 65, 67, 98, 122, 124, 183, 37, 14.'}),"\n",(0,r.jsxs)(i.p,{children:["LOOK behaves almost identically to ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Shortest_seek_time_first",children:"Shortest seek time first"}),"(SSTF), but avoids the starvation problem of SSTF. This is because LOOK is biased against the area recently traversed, and heavily favors tracks clustered at the outermost and innermost edges of the platter. LOOK is also biased towards more recently arriving jobs (on average)."]}),"\n",(0,r.jsx)(i.h2,{id:"variants",children:"Variants"}),"\n",(0,r.jsx)(i.h3,{id:"c-lookcircular-look",children:"C-LOOK(Circular LOOK)"}),"\n",(0,r.jsx)(i.p,{children:"One variant of LOOK is C-LOOK. It is an effort to remove the bias in LOOK for track clusters at the edges of the platter. C-LOOK basically only scans in one direction. Either you sweep from the inside out, or the outside in. When you reach the end, you just swing the head all the way back to the beginning. This actually takes advantage of the fact that many drives can move the read/write head at high speeds if it's moving across a large number of tracks (e.g. the seek time from the last track to track 0 is smaller than one would expect and usually considerably less than the time it would take to seek there one track at a time).The huge jump from one end request to the other is not considered as a head movement as the cylinders are treated as a circular list."}),"\n",(0,r.jsx)(i.h3,{id:"n-look-and-f-look",children:"N-LOOK and F-LOOK"}),"\n",(0,r.jsx)(i.p,{children:"N and F LOOK were designed to offset LOOK's bias towards recent jobs. Both algorithms partition the request queue into smaller sub queues and process the sub queues in order (oldest first). N-LOOK is so-called because the request queue is divided intoNsub queues. F-LOOK is a simplification where there are only 2 queues, but they are used in a double-buffered fashion. While F-LOOK is processing one queue, all new requests go into the other one. To explain these algorithms we're going to use the example of a disk with 200 tracks, and the read/write head starts at track 100. The request queue, in order, contains requests for tracks: 55, 58, 18, 90, 160, 38, we assume that the request queue is split into two, with the oldest one containing the requests for tracks: 55, 58, 18, 90. In this instance, N-LOOK and F-LOOK behave the same. Also notice, that in this configuration, it doesn't matter which direction the head was moving in, all requested tracks are less than 100 so it will only move in the direction of decreasing tracks."}),"\n",(0,r.jsx)(i.p,{children:"Even through the average number of tracks traversed is the same as LOOK in the worst case, N and F LOOK are in some sense, more fair than plain old LOOK. The sub queue system caps the maximum latency a process can expect between a request and it being serviced (unlike SSTF that can starve processes for arbitrary lengths of time)."}),"\n",(0,r.jsx)(i.h3,{id:"s-look",children:"S-LOOK"}),"\n",(0,r.jsx)(i.p,{children:"The Shortest LOOK (S-LOOK) algorithm is an extension of the LOOK algorithm to handle the cases where the disk head is located between the far-end requests. The algorithm is designed to make a decision of which direction should be served first instead of only continuing to seek in the same direction before the new requests have arrived. Since the seek time is directly proportional to the seek distance, our goal is to minimize the seek distance, and hence, reduce the seek time."}),"\n",(0,r.jsx)(i.h2,{id:"performance",children:"Performance"}),"\n",(0,r.jsx)(i.p,{children:"LOOK has slightly better average seek times than SCAN. C-LOOK has a slightly lower variance in seek time than LOOK since the worst case seek time is nearly cut in half."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/LOOK_algorithm",children:"https://en.wikipedia.org/wiki/LOOK_algorithm"})}),"\n",(0,r.jsx)(i.h3,{id:"shortest-seek-first",children:"Shortest seek first"}),"\n",(0,r.jsx)(i.p,{children:"Disk scheduling algorithm to reduce seek time"})]})}function c(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var s=t(296540);const r={},n=s.createContext(r);function a(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);