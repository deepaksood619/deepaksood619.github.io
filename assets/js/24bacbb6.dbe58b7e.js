"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[36705],{88994:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"technologies/apache-spark/02-spark-modules","title":"Spark Modules","description":"Apache Spark (Core)","source":"@site/docs/technologies/apache-spark/02-spark-modules.md","sourceDirName":"technologies/apache-spark","slug":"/technologies/apache-spark/02-spark-modules","permalink":"/technologies/apache-spark/02-spark-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache-spark/02-spark-modules.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1734022610000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Terms","permalink":"/technologies/apache-spark/01-terms"},"next":{"title":"Processing Model","permalink":"/technologies/apache-spark/03-processing-model"}}');var r=a(474848),i=a(28453);const t={},l="Spark Modules",d={},o=[{value:"Apache Spark (Core)",id:"apache-spark-core",level:2},{value:"Spark SQL",id:"spark-sql",level:2},{value:"GraphX",id:"graphx",level:2},{value:"Spark Streaming",id:"spark-streaming",level:2},{value:"Spark Streaming vs Kafka Streams vs Flink",id:"spark-streaming-vs-kafka-streams-vs-flink",level:2},{value:"Spark MLlib",id:"spark-mllib",level:2},{value:"Spark MLlib Component",id:"spark-mllib-component",level:2},{value:"Spark GraphX",id:"spark-graphx",level:2},{value:"pyspark",id:"pyspark",level:2},{value:"Spark UI",id:"spark-ui",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"spark-modules",children:"Spark Modules"})}),"\n",(0,r.jsx)(n.h2,{id:"apache-spark-core",children:"Apache Spark (Core)"}),"\n",(0,r.jsx)(n.p,{children:"Spark consists of a core framework that manages the internal representation of data, including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"serialization"}),"\n",(0,r.jsx)(n.li,{children:"memory allocation"}),"\n",(0,r.jsx)(n.li,{children:"caching"}),"\n",(0,r.jsx)(n.li,{children:"increasing resilience by storing intermediate snapshots on disk"}),"\n",(0,r.jsx)(n.li,{children:"automatic retries"}),"\n",(0,r.jsx)(n.li,{children:"data exchange (shuffling) between worker nodes"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["It also provides a bunch of methods to transform data (likemapandreduce). All of these methods work on ",(0,r.jsx)(n.strong,{children:"resilient distributed datasets (RDD)."})]}),"\n",(0,r.jsx)(n.p,{children:"Spark automatically recognizes dependencies between single steps and thereby knows which of them can be executed in parallel."}),"\n",(0,r.jsx)(n.p,{children:"This is accomplished by building a directed acyclic graph (DAG), which also implies that transformations are not executed right away, but when action functions are called."}),"\n",(0,r.jsx)(n.p,{children:"So basically, the methods can be divided into two types: RDD transformations and actions."}),"\n",(0,r.jsx)(n.p,{children:"These are RDD transformations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"map(func)"}),"\n",(0,r.jsx)(n.li,{children:"flatMap()"}),"\n",(0,r.jsx)(n.li,{children:"filter(func)"}),"\n",(0,r.jsx)(n.li,{children:"mapPartitions(func)"}),"\n",(0,r.jsx)(n.li,{children:"mapPartitionWithIndex()"}),"\n",(0,r.jsx)(n.li,{children:"union(dataset)"}),"\n",(0,r.jsx)(n.li,{children:"intersection(dataset)"}),"\n",(0,r.jsx)(n.li,{children:"distinct()"}),"\n",(0,r.jsx)(n.li,{children:"groupByKey()"}),"\n",(0,r.jsx)(n.li,{children:"reduceByKey(func, [numTasks])"}),"\n",(0,r.jsx)(n.li,{children:"sortByKey()"}),"\n",(0,r.jsx)(n.li,{children:"join()"}),"\n",(0,r.jsx)(n.li,{children:"coalesce()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"And these are RDD actions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"count()"}),"\n",(0,r.jsx)(n.li,{children:"collect()"}),"\n",(0,r.jsx)(n.li,{children:"take(n)"}),"\n",(0,r.jsx)(n.li,{children:"top()"}),"\n",(0,r.jsx)(n.li,{children:"countByValue()"}),"\n",(0,r.jsx)(n.li,{children:"reduce()"}),"\n",(0,r.jsx)(n.li,{children:"fold()"}),"\n",(0,r.jsx)(n.li,{children:"aggregate()"}),"\n",(0,r.jsx)(n.li,{children:"foreach()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The DAG of a running job can be viewed in the Spark UI web interface. It also shows the pending jobs, the lists of tasks, and current resource usage and configuration."}),"\n",(0,r.jsx)(n.p,{children:"Most of the information can also be reviewed for finished (or failed) jobs if the history server is configured."}),"\n",(0,r.jsx)(n.h2,{id:"spark-sql",children:"Spark SQL"}),"\n",(0,r.jsx)(n.p,{children:"This is an abstraction of Spark's core API. Whereas the core API works with RDD, and all transformations are defined by the developer explicitly, Spark SQL represents the RDD as so-called DataFrames. The DataFrame API is more like a DSL that looks like SQL."}),"\n",(0,r.jsx)(n.p,{children:"The developer can even more abstract the RDD by registering a DataFrame as a named in-memory table. This table can then be queried as one would query a table in a relational database using SQL."}),"\n",(0,r.jsx)(n.h2,{id:"graphx",children:"GraphX"}),"\n",(0,r.jsx)(n.p,{children:"This lets you represent RDD as a graph (nodes are connected via edges) and perform some basic graph operations on it. Currently (only) three more advanced algorithms are provided: PageRank, ConnectedComponents, andTriangleCounting."}),"\n",(0,r.jsx)(n.h2,{id:"spark-streaming",children:"Spark Streaming"}),"\n",(0,r.jsx)(n.p,{children:"This can poll distributed logs like Apache Kafka or Amazon Kinesis (and some other messaging systems, like ActiveMQ) to process the messages in micro-batches. (Nearly) all functionality available for Spark batch jobs can also be applied on the RDD provided by Spark Streaming."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spark Streaming is an extension of the core Spark API that enables scalable, high-throughput, fault-tolerant stream processing of live data streams."}),"\n",(0,r.jsx)(n.li,{children:"Streaming data inputs from HDFS, Kafka, Flume, TCP sockets, kinesis, etc"}),"\n",(0,r.jsx)(n.li,{children:"Spark ML (Machine Learning) functions and GraphX graph processing algorithms are fully applicable to streaming data"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image",src:a(201244).A+"",width:"862",height:"638"})}),"\n",(0,r.jsx)(n.h2,{id:"spark-streaming-vs-kafka-streams-vs-flink",children:"Spark Streaming vs Kafka Streams vs Flink"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka Streams is just a library (no additional infrastructure component, but it has the responsibility to deploy and scale the streaming application)."}),"\n",(0,r.jsx)(n.li,{children:"Flink is currently the most superior/feature-rich framework when it comes to low-latency stream processing (which is important when streams are used as the core communication between services in real-time)."}),"\n",(0,r.jsx)(n.li,{children:"Spark's main benefit is the whole existing eco-system including the MLlib/GraphX abstractions and that parts of the code can be reused for both batch- and stream-processing functionality."}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Flink"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Kafka Streams"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Spark Streaming"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Deployment"})}),(0,r.jsx)(n.td,{children:"A framework that also takes care of deployment in a cluster"}),(0,r.jsx)(n.td,{children:"A library that can be included in any Java program. Deployment depends how the Java application is deployed."}),(0,r.jsx)(n.td,{children:"A framework that also takes care of deployment in a cluster"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Life cycle"})}),(0,r.jsx)(n.td,{children:"Stream processing logic is run as a job in the Flink cluster"}),(0,r.jsx)(n.td,{children:'Stream processing logic is run as part of a "standard" Java application'}),(0,r.jsx)(n.td,{children:"Stream processing logic is run as a job in the Spark cluster"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Responsibility"})}),(0,r.jsx)(n.td,{children:"Dedicated infrastructure team"}),(0,r.jsx)(n.td,{children:"Application developer"}),(0,r.jsx)(n.td,{children:"Dedicated infrastructure team"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Coordination"})}),(0,r.jsx)(n.td,{children:"Flink master (JobManager), part of the streaming program"}),(0,r.jsx)(n.td,{children:"Leverages the Kafka cluster for coordination, load balancing, and fault-tolerance"}),(0,r.jsx)(n.td,{children:"Spark Master"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Source of continuous data"})}),(0,r.jsx)(n.td,{children:"Kafka, File Systems, other message queues"}),(0,r.jsx)(n.td,{children:"Kafka only"}),(0,r.jsx)(n.td,{children:"Common streaming platforms like Kafka, Flume, Kinesis, etc."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Sink for results"})}),(0,r.jsx)(n.td,{children:"Any storage where an implementation using the Flink Sink API is available"}),(0,r.jsx)(n.td,{children:"Kafka or any other storage where a Kafka Sink is implemented using the Kafka Connect API"}),(0,r.jsx)(n.td,{children:"File and Kafka as a predefined sink, any other destination using the forEach-sink (manual implementation)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bounded and unbounded data streams"})}),(0,r.jsx)(n.td,{children:"Unbounded and bounded"}),(0,r.jsx)(n.td,{children:"Unbounded"}),(0,r.jsx)(n.td,{children:"Unbounded (bounded using Spark Batch jobs)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Semantical guarantees"})}),(0,r.jsx)(n.td,{children:"Exactly once for internal Flink state; end-to-end exactly once with selected sources and sinks (e.g., Kafka to Flink to HDFS); at least once when Kafka is used as a sink"}),(0,r.jsx)(n.td,{children:"Exactly once, end-to-end with Kafka"}),(0,r.jsx)(n.td,{children:"Exactly once"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stream processing approach"})}),(0,r.jsx)(n.td,{children:"Single record"}),(0,r.jsx)(n.td,{children:"Single record"}),(0,r.jsx)(n.td,{children:"Micro-batches"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"State management"})}),(0,r.jsx)(n.td,{children:"Key-value storage, transparent to the developer"}),(0,r.jsx)(n.td,{children:"No, must be implemented manually"}),(0,r.jsx)(n.td,{children:"No, stateless by nature"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Feature set"})}),(0,r.jsx)(n.td,{children:"Rich feature set, including event time (opposed to processing time), sliding windows, and watermarks"}),(0,r.jsx)(n.td,{children:"Simple features set to aggregate in tumbling windows"}),(0,r.jsx)(n.td,{children:"Wide feature set but lacking some of the more advanced features that Flink offers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Low latency"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Example of when to choose as stream processor"})}),(0,r.jsx)(n.td,{children:"Setup of a new event-driven architecture that needs advanced stream-processing features and has low-latency requirements"}),(0,r.jsx)(n.td,{children:"JVM application that should consume an existing Kafka event stream"}),(0,r.jsx)(n.td,{children:"Add stream processing when Spark is already used for batch processing and low latency is not mandatory"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"spark-mllib",children:"Spark MLlib"}),"\n",(0,r.jsx)(n.p,{children:"MLlib provides high-level algorithms that are commonly used in general data analysis (like clustering and regression) and in machine learning. It provides the functionality to define pipelines, train models and persist them, and read trained models to apply them to live data."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spark MLlib is a distributed machine-learning framework on top of Spark. Core"}),"\n",(0,r.jsx)(n.li,{children:"MLlib is Spark's scalable machine learning library consisting of common learning algorithms and utilities, including classfication, regression, clustering, collaborative filtering, dimensionality reduction"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"spark-mllib-component",children:"Spark MLlib Component"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image",src:a(55655).A+"",width:"844",height:"614"})}),"\n",(0,r.jsx)(n.h2,{id:"spark-graphx",children:"Spark GraphX"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"GraphX is a new component in Spark for graphs and graph-parallel computation. At a high level, GraphX extends the Spark RDD by introducing a new graph abstraction"}),"\n",(0,r.jsx)(n.li,{children:"GraphX reuses Spark RDD concept, simplifies graph analytics tasks, provides the ability to make operations on a directed multigraph with properties attached to each vertex and edge"}),"\n",(0,r.jsx)(n.li,{children:"GraphX is a thin layer on top of the Spark general-purpose dataflow framework"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image",src:a(559850).A+"",width:"936",height:"448"})}),"\n",(0,r.jsx)(n.h2,{id:"pyspark",children:"pyspark"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"docker run -p 8888:8888 jupyter/pyspark-notebook"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://realpython.com/pyspark-intro",children:"https://realpython.com/pyspark-intro"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.datacamp.com/community/blog/big-data-with-pyspark",children:"https://www.datacamp.com/community/blog/big-data-with-pyspark"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"http://spark.apache.org/docs/2.1.0/api/python/pyspark.sql.html",children:"http://spark.apache.org/docs/2.1.0/api/python/pyspark.sql.html"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://towardsdatascience.com/natural-language-processing-with-spark-9efef3564270",children:"https://towardsdatascience.com/natural-language-processing-with-spark-9efef3564270"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://koalas.readthedocs.io/en/latest/",children:"Koalas: pandas API on Apache Spark - Koalas 1.8.2 documentation"})}),"\n",(0,r.jsx)(n.h2,{id:"spark-ui",children:"Spark UI"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://spark.apache.org/docs/3.0.0-preview/web-ui.html",children:"https://spark.apache.org/docs/3.0.0-preview/web-ui.html"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},201244:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Technologies-Apache-Apache-Spark-image3-488ffd86947c34a4377e0d7a525ab417.jpg"},55655:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Technologies-Apache-Apache-Spark-image4-2c7203d906c06515299b67fb2bf85d11.jpg"},559850:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Technologies-Apache-Apache-Spark-image5-5ec351c785809f744aa8daccaad3f3e3.jpg"},28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>l});var s=a(296540);const r={},i=s.createContext(r);function t(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);