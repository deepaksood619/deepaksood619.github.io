"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[89483],{445389:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"technologies/apache/apache-storm","title":"Apache Storm","description":"Apache Storm","source":"@site/docs/technologies/apache/apache-storm.md","sourceDirName":"technologies/apache","slug":"/technologies/apache/apache-storm","permalink":"/technologies/apache/apache-storm","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/apache/apache-storm.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1678191863000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Apache Samza","permalink":"/technologies/apache/apache-samza"},"next":{"title":"Apache Zookeeper","permalink":"/technologies/apache/apache-zookeeper"}}');var a=s(474848),n=s(28453);const r={},i="Apache Storm",c={},h=[];function l(e){const t={h1:"h1",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"apache-storm",children:"Apache Storm"})}),"\n",(0,a.jsx)(t.p,{children:"Apache Storm"}),"\n",(0,a.jsx)(t.p,{children:"Apache Storm is a stream processing framework that focuses on extremely low latency and is perhaps the best option for workloads that require near real-time processing. It can handle very large quantities of data with and deliver results with less latency than other solutions."}),"\n",(0,a.jsx)(t.p,{children:"Stream Processing Model"}),"\n",(0,a.jsxs)(t.p,{children:["Storm stream processing works by orchestrating DAGs (Directed Acyclic Graphs) in a framework it calls ",(0,a.jsx)(t.strong,{children:"topologies"}),". These topologies describe the various transformations or steps that will be taken on each incoming piece of data as it enters the system."]}),"\n",(0,a.jsx)(t.p,{children:"The topologies are composed of:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Streams"}),": Conventional data streams. This is unbounded data that is continuously arriving at the system."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Spouts"}),": Sources of data streams at the edge of the topology. These can be APIs, queues, etc. that produce data to be operated on."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Bolts"}),": Bolts represent a processing step that consumes streams, applies an operation to them, and outputs the result as a stream. Bolts are connected to each of the spouts, and then connect to each other to arrange all of the necessary processing. At the end of the topology, final bolt output may be used as an input for a connected system."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The idea behind Storm is to define small, discrete operations using the above components and then compose them into a topology. By default, Storm offers at-least-once processing guarantees, meaning that it can guarantee that each message is processed at least once, but there may be duplicates in some failure scenarios. Storm does not guarantee that messages will be processed in order."}),"\n",(0,a.jsxs)(t.p,{children:["In order to achieve exactly-once, stateful processing, an abstraction called ",(0,a.jsx)(t.strong,{children:"Trident"})," is also available. To be explicit, Storm without Trident is often referred to as ",(0,a.jsx)(t.strong,{children:"Core Storm"}),". Trident significantly alters the processing dynamics of Storm, increasing latency, adding state to the processing, and implementing a micro-batching model instead of an item-by-item pure streaming system."]}),"\n",(0,a.jsx)(t.p,{children:"Storm users typically recommend using Core Storm whenever possible to avoid those penalties. With that in mind, Trident's guarantee to processes items exactly once is useful in cases where the system cannot intelligently handle duplicate messages. Trident is also the only choice within Storm when you need to maintain state between items, like when counting how many users click a link within an hour. Trident gives Storm flexibility, even though it does not play to the framework's natural strengths."}),"\n",(0,a.jsx)(t.p,{children:"Trident topologies are composed of:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Stream batches"}),": These are micro-batches of stream data that are chunked in order to provide batch processing semantics."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Operations"}),": These are batch procedures that can be performed on the data."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Advantages and Limitations"}),"\n",(0,a.jsx)(t.p,{children:"Storm is probably the best solution currently available for near real-time processing. It is able to handle data with extremely low latency for workloads that must be processed with minimal delay. Storm is often a good choice when processing time directly affects user experience, for example when feedback from the processing is fed directly back to a visitor's page on a website."}),"\n",(0,a.jsx)(t.p,{children:"Storm with Trident gives you the option to use micro-batches instead of pure stream processing. While this gives users greater flexibility to shape the tool to an intended use, it also tends to negate some of the software's biggest advantages over other solutions. That being said, having a choice for the stream processing style is still helpful."}),"\n",(0,a.jsx)(t.p,{children:"Core Storm does not offer ordering guarantees of messages. Core Storm offers at-least-once processing guarantees, meaning that processing of each message can be guaranteed but duplicates may occur. Trident offers exactly-once guarantees and can offer ordering between batches, but not within."}),"\n",(0,a.jsx)(t.p,{children:"In terms of interoperability, Storm can integrate with Hadoop's YARN resource negotiator, making it easy to hook up to an existing Hadoop deployment. More than most processing frameworks, Storm has very wide language support, giving users many options for defining topologies."}),"\n",(0,a.jsx)(t.p,{children:"Summary"}),"\n",(0,a.jsx)(t.p,{children:"For pure stream processing workloads with very strict latency requirements, Storm is probably the best mature option. It can guarantee message processing and can be used with a large number of programming languages. Because Storm does not do batch processing, you will have to use additional software if you require those capabilities. If you have a strong need for exactly-once processing guarantees, Trident can provide that. However, other stream processing frameworks might also be a better fit at that point."})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>i});var o=s(296540);const a={},n=o.createContext(a);function r(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);