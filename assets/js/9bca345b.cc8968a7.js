"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[29411],{810282:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=o(785893),a=o(511151);const i={},s="Travelling Salesman Problem",l={id:"algorithms/advanced-algorithms/travelling-salesman-problem",title:"Travelling Salesman Problem",description:"The Traveling Salesman Problem is a well known challenge in Computer Science: it consists on finding the shortest route possible that traverses all cities in a given map only once. Although its simple explanation, this problem is, indeed, NP-Complete. This implies that the difficulty to solve it increases rapidly with the number of cities, and we do not know in fact a general solution that solves the problem. For that reason, we currently consider that any method able to find a sub-optimal solution is generally good enough (we cannot verify if the solution returned is the optimal one most of the times).",source:"@site/docs/algorithms/advanced-algorithms/travelling-salesman-problem.md",sourceDirName:"algorithms/advanced-algorithms",slug:"/algorithms/advanced-algorithms/travelling-salesman-problem",permalink:"/algorithms/advanced-algorithms/travelling-salesman-problem",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/advanced-algorithms/travelling-salesman-problem.md",tags:[],version:"current",lastUpdatedAt:1701846168,formattedLastUpdatedAt:"Dec 6, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Regular Expressions",permalink:"/algorithms/advanced-algorithms/regular-expressions"},next:{title:"Algorithmic Complexity",permalink:"/algorithms/algorithmic-complexity/"}},r={},c=[{value:"Arora PTAS for Euclidean TSP",id:"arora-ptas-for-euclidean-tsp",level:2},{value:"References",id:"references",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"travelling-salesman-problem",children:"Travelling Salesman Problem"}),"\n",(0,n.jsx)(t.p,{children:"The Traveling Salesman Problem is a well known challenge in Computer Science: it consists on finding the shortest route possible that traverses all cities in a given map only once. Although its simple explanation, this problem is, indeed, NP-Complete. This implies that the difficulty to solve it increases rapidly with the number of cities, and we do not know in fact a general solution that solves the problem. For that reason, we currently consider that any method able to find a sub-optimal solution is generally good enough (we cannot verify if the solution returned is the optimal one most of the times)."}),"\n",(0,n.jsx)(t.p,{children:"To solve it, we can try to apply a modification of the Self-Organizing Map (SOM) technique."}),"\n",(0,n.jsx)(t.h2,{id:"arora-ptas-for-euclidean-tsp",children:"Arora PTAS for Euclidean TSP"}),"\n",(0,n.jsxs)(t.p,{children:["The Travelling Salesman Problem (TSP) is one of the most famous problems in Computer Science, but it turns out to be NP-Hard. It's even NP-hard to approximate it to any polynomial factor in the general case! Thankfully we can do a constant (around 1.5) approximation when the distances for which we are solving the problem come from a metric. While exactly what this constant is remains open, we know we cannot have a PTAS in the general case. What's a PTAS? It's a Polynomial Time Approximation Scheme. The idea is that you give me an epsilon, I will give you a (1+epsilon) approximation algorithm whose runtime depends on epsilon but is polynomial in n. So we have runtimes like poly(n) ",(0,n.jsx)(t.code,{children:"2^{1/epsilon}"})," and others."]}),"\n",(0,n.jsx)(t.p,{children:"Sanjeev Arora discovered a PTAS for TSP when the distances come from a Euclidean space a couple of decades ago. This is very good news for Uber and the like, since their distances usually come from the plane! The idea is not hard to understand, and I plan to make the talk accessible to anyone who is comfortable with Dynamic Programming."}),"\n",(0,n.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://diego.codes/post/som-tsp",children:"https://diego.codes/post/som-tsp"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/DiegoVicen/som-tsp",children:"https://github.com/DiegoVicen/som-tsp"})})]})}function m(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},511151:(e,t,o)=>{o.d(t,{Z:()=>l,a:()=>s});var n=o(667294);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);