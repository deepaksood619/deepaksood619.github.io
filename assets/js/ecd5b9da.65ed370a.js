"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[37488],{352899:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"technologies/kafka/security/09-securing-zookeeper","title":"Securing ZooKeeper","description":"If you\'ve chosen to run Kafka with ZooKeeper, you will also need to consider how to secure ZooKeeper, as it stores a lot of important cluster configuration and security information, such as ACLs, the list of a cluster\'s broker members, and partition metadata, and if you are using Kafka\'s SASL/SCRAM provider for authorization\u2014encrypted versions of user passwords. (Note that if you are using KRaft, you can skip this module entirely.)","source":"@site/docs/technologies/kafka/security/09-securing-zookeeper.md","sourceDirName":"technologies/kafka/security","slug":"/technologies/kafka/security/09-securing-zookeeper","permalink":"/technologies/kafka/security/09-securing-zookeeper","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/security/09-securing-zookeeper.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1769433622000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Hands On: Requiring Encryption for Broker Traffic","permalink":"/technologies/kafka/security/08-hands-on-requiring-encryption-for-broker-traffic"},"next":{"title":"Audit Logs","permalink":"/technologies/kafka/security/10-audit-logs"}}');var s=o(474848),n=o(28453);const r={},a="Securing ZooKeeper",c={},h=[{value:"SSL",id:"ssl",level:2},{value:"SASL (Simple Authentication and Security Layer)",id:"sasl-simple-authentication-and-security-layer",level:2},{value:"SSL vs. SASL",id:"ssl-vs-sasl",level:2},{value:"Network Segmentation",id:"network-segmentation",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"securing-zookeeper",children:"Securing ZooKeeper"})}),"\n",(0,s.jsx)(t.p,{children:"If you've chosen to run Kafka with ZooKeeper, you will also need to consider how to secure ZooKeeper, as it stores a lot of important cluster configuration and security information, such as ACLs, the list of a cluster's broker members, and partition metadata, and if you are using Kafka's SASL/SCRAM provider for authorization\u2014encrypted versions of user passwords. (Note that if you are using KRaft, you can skip this module entirely.)"}),"\n",(0,s.jsxs)(t.p,{children:["Similar to Kafka, there are two ways to secure ZooKeeper: SSL and SASL. No matter which one you use, you\u2019ll need to update your broker configuration with\xa0",(0,s.jsx)(t.code,{children:"zookeeper.set.acl=true"}),", which makes sure that secure ACLs in ZooKeeper are associated with the metadata in ZooKeeper. These ACLs specify that the metadata can be read by everyone but only changed by the brokers. Sensitive metadata, such as SCRAM credentials, is an exception: it can only be read by the brokers by default."]}),"\n",(0,s.jsx)(t.h2,{id:"ssl",children:"SSL"}),"\n",(0,s.jsx)(t.p,{children:"SSL client authentication in ZooKeeper uses certificates to authenticate ZooKeeper to brokers and vice versa. There is one difference, however, between the usual Kafka SSL authentication and the SSL here: each broker (as well as CLI tool) accessing ZooKeeper must use the same certificate \u201cDistinguished Name\u201d when accessing it. A certificate\u2019s Distinguished Name is part of the identifying information used to create a certificate. Essentially, the ZooKeeper ACL includes its Distinguished Name and will only authorize brokers with the same one (it will authenticate brokers with other Distinguished Names but will only authorize brokers with the correct one)."}),"\n",(0,s.jsx)(t.p,{children:"A Distinguished Name usually includes the hostname of the entity to which it has been issued, so as to allow the server (ZooKeeper in this case) to verify the hostname. So if you have multiple brokers on multiple machines (i.e., with different hostnames), you may find that they are unable to access ZooKeeper."}),"\n",(0,s.jsx)(t.p,{children:"The solution to this problem is either to use a wildcard certificate (which includes a wildcard in the hostname), or to use a certificate with a single hostname plus a subject alternative name (SAN), which includes a list of all of the hostnames of the brokers in the cluster. The single hostname will be used in the ACL, while the SAN allows ZooKeeper to verify the actual hostname of the broker."}),"\n",(0,s.jsx)(t.h2,{id:"sasl-simple-authentication-and-security-layer",children:"SASL (Simple Authentication and Security Layer)"}),"\n",(0,s.jsxs)(t.p,{children:["Similar to Kafka, ZooKeeper supports SASL, which you are most likely to use if you need to integrate with an existing Kerberos server, such as Active Directory. For SASL, you should ensure that connections from Kafka brokers to ZooKeeper are encrypted with TLS but not authenticated by setting\xa0",(0,s.jsx)(t.code,{children:"ssl.clientAuth=none"}),"\xa0in your ZooKeeper configuration. This lets clients connect to ZooKeeper using a TLS-encrypted connection but without a certificate. With SASL for Kerberos, the problem of using the same identity for all brokers for ACL and authorization purposes is easily solved, you just have to make sure that the ZooKeeper client file on each broker is configured with the same principal."]}),"\n",(0,s.jsx)(t.h2,{id:"ssl-vs-sasl",children:"SSL vs. SASL"}),"\n",(0,s.jsx)(t.p,{children:"SSL has some administrative overhead but is the most popular and is probably the easiest option to use. You also have to periodically update this information before the certificates expire to prevent TLS handshake failures. SASL of course makes sense if you need to integrate with an existing Kerberos server."}),"\n",(0,s.jsx)(t.p,{children:"You can actually use both, however, use SSL for authentication and use SASL to determine access and grant authorization. This has the benefit of clients not needing to use the same Distinguished Name and thus you won't have to set a unique subject alternative name (SAN)."}),"\n",(0,s.jsx)(t.p,{children:"SSL + SASL"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Able to use either identity"}),"\n",(0,s.jsx)(t.li,{children:"No need to use same distinguished name"}),"\n",(0,s.jsx)(t.li,{children:"Ability to use hostnames in the distinguished name"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"network-segmentation",children:"Network Segmentation"}),"\n",(0,s.jsxs)(t.p,{children:["Although the measures we've discussed in this module will help secure ZooKeeper, a final recommendation is to use ",(0,s.jsx)(t.strong,{children:"network segmentation"}),". This way only your brokers and administrative tools will have access to ZooKeeper."]})]})}function l(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var i=o(296540);const s={},n=i.createContext(s);function r(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);