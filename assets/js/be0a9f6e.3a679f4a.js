"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[58711],{127751:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"computer-science/programming-concepts/others","title":"Others","description":"Relationships","source":"@site/docs/computer-science/programming-concepts/others.md","sourceDirName":"computer-science/programming-concepts","slug":"/computer-science/programming-concepts/others","permalink":"/computer-science/programming-concepts/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-concepts/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1768583708000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Metaprogramming","permalink":"/computer-science/programming-concepts/metaprogramming"},"next":{"title":"Programming Styles","permalink":"/computer-science/programming-concepts/programming-styles"}}');var a=n(474848),r=n(28453);const s={},o="Others",c={},h=[{value:"Relationships",id:"relationships",level:2},{value:"Loitering",id:"loitering",level:2},{value:"Reentrency",id:"reentrency",level:2},{value:"Fuzzing",id:"fuzzing",level:2},{value:"Conway&#39;s Law",id:"conways-law",level:2},{value:"Semantic Versioning (SemVer)",id:"semantic-versioning-semver",level:2},{value:"Releases",id:"releases",level:2},{value:"Calendar Versioning (CalVer)",id:"calendar-versioning-calver",level:2},{value:"YYYY.MINOR.MICRO - 2020.1.1",id:"yyyyminormicro---202011",level:2},{value:"What is Dynamic Binding (late binding)?",id:"what-is-dynamic-binding-late-binding",level:2},{value:"Virtual Method Table",id:"virtual-method-table",level:2},{value:"Dynamic Dispatch",id:"dynamic-dispatch",level:2},{value:"Guard Clauses Technique",id:"guard-clauses-technique",level:2}];function l(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"others",children:"Others"})}),"\n",(0,a.jsx)(i.h2,{id:"relationships",children:"Relationships"}),"\n",(0,a.jsx)(i.p,{children:"inheritance (is-a relationship)"}),"\n",(0,a.jsx)(i.p,{children:"aggregation (has-a relationship)"}),"\n",(0,a.jsx)(i.h2,{id:"loitering",children:"Loitering"}),"\n",(0,a.jsx)(i.p,{children:"Holding the reference to an object, when it is no longer needed."}),"\n",(0,a.jsx)(i.h2,{id:"reentrency",children:"Reentrency"}),"\n",(0,a.jsx)(i.p,{children:"In computing, a computer program or subroutine is called reentrant if it can be interrupted in the middle of its execution and then safely be called again before its previous invocations complete execution. The interruption could be caused by an internal action such as a jump or call, or by an external action such as an interrupt or signal. Once the reentered invocation completes, the previous invocations will resume correct execution."}),"\n",(0,a.jsx)(i.h2,{id:"fuzzing",children:"Fuzzing"}),"\n",(0,a.jsx)(i.p,{children:"Fuzzing is a technique for amplifying race conditions."}),"\n",(0,a.jsx)(i.p,{children:"In this technique Thread.sleep is added before and after every statement."}),"\n",(0,a.jsx)(i.h2,{id:"conways-law",children:"Conway's Law"}),"\n",(0,a.jsx)(i.p,{children:"Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure."}),"\n",(0,a.jsx)(i.p,{children:"Any piece of software reflects the organizational structure that produced it."}),"\n",(0,a.jsx)(i.p,{children:"If you have four teams working on a compiler you will end up with a four pass compiler"}),"\n",(0,a.jsx)(i.h2,{id:"semantic-versioning-semver",children:"Semantic Versioning (SemVer)"}),"\n",(0,a.jsx)(i.p,{children:"Given a version number MAJOR.MINOR.PATCH, increment the:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"MAJOR version when you make incompatible API changes,"}),"\n",(0,a.jsx)(i.li,{children:"MINOR version when you add functionality in a backwards-compatible manner, and"}),"\n",(0,a.jsx)(i.li,{children:"PATCH version when you make backwards-compatible bug fixes."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://semver.org",children:"https://semver.org"})}),"\n",(0,a.jsx)(i.h2,{id:"releases",children:"Releases"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Releases","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"GA - Generally Available"}),"\n",(0,a.jsx)(i.li,{children:"EA - Early Access"}),"\n",(0,a.jsx)(i.li,{children:"Public Preview - Beta (available for all the customers, not supported for production)"}),"\n",(0,a.jsx)(i.li,{children:"Private Preview - Selected customers using Feature flags"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.li,{children:"Nightly Releases / Insiders"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"calendar-versioning-calver",children:"Calendar Versioning (CalVer)"}),"\n",(0,a.jsx)(i.p,{children:"CalVer is a versioning convention based on your project's release calendar, instead of arbitrary numbers."}),"\n",(0,a.jsx)(i.h2,{id:"yyyyminormicro---202011",children:"YYYY.MINOR.MICRO - 2020.1.1"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://calver.org",children:"https://calver.org"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Software_versioning",children:"https://en.wikipedia.org/wiki/Software_versioning"})}),"\n",(0,a.jsx)(i.h2,{id:"what-is-dynamic-binding-late-binding",children:"What is Dynamic Binding (late binding)?"}),"\n",(0,a.jsxs)(i.p,{children:["Binding refers to the linking of a procedure call to the code to be executed in response to the call. Dynamic binding means that the code associated with a given procedure call is not known until the time of the call at run-time.\nLate binding, dynamic binding, ordynamic linkageis a computer programming mechanism in which the method being called upon an object or the function being called with arguments is looked up by name at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)",children:"runtime"}),".\nWith ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Early_binding",children:"early binding"}),", or ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Static_binding",children:"static binding"}),", in an ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Object-oriented_programming",children:"object-oriented language"}),", the compilation phase fixes all types of variables and expressions. This is usually stored in the compiled program as an offset in a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Virtual_method_table",children:"virtual method table"}),'("v-table") and is very efficient. With late binding the compiler does not read enough information to verify the method exists or bind its slot on the v-table. Instead the method is looked up by name at runtime.\nThe primary advantage of using late binding in ',(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Component_Object_Model",children:"Component Object Model"}),"(COM) programming is that it does not require the compiler to reference the libraries that contain the object at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Compile_time",children:"compile time"}),". This makes the compilation process more resistant to version conflicts, in which the class's v-table may be accidentally modified. (This is not a concern in ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Just-in-time_compilation",children:"JIT"}),"-compiled platforms such as .NET or Java, because the v-table is created at runtime by the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Virtual_machine",children:"virtual machine"})," against the libraries as they are being loaded into the running application.)\n",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Late_binding",children:"https://en.wikipedia.org/wiki/Late_binding"})]}),"\n",(0,a.jsx)(i.h2,{id:"virtual-method-table",children:"Virtual Method Table"}),"\n",(0,a.jsxs)(i.p,{children:["Avirtual method table(VMT), virtual function table, virtual call table, ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Dispatch_table",children:"dispatch table"}),", vtable, orvftableis a mechanism used in a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Programming_language",children:"programming language"})," to support ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Dynamic_dispatch",children:"dynamic dispatch"}),"(or ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)",children:"run-time"}),(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Method_(computer_programming)",children:"method"}),(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Name_binding",children:"binding"}),").\nWhenever a class defines a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Virtual_function",children:"virtual function"}),"(or method), most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the virtual method table. These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class.\nThere are many different ways to implement such dynamic dispatch, but use of virtual method tables is especially common among ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/C%2B%2B",children:"C++"})," and related languages (such as ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/D_(programming_language)",children:"D"})," and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/C_Sharp_(programming_language)",children:"C#"}),"). Languages that separate the programmatic interface of objects from the implementation, like ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Visual_Basic",children:"Visual Basic"})," and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Object_Pascal",children:"Delphi"}),", also tend to use this approach, because it allows objects to use a different implementation simply by using a different set of method pointers.\nSuppose a program contains three ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Class_(computer_programming)",children:"classes"})," in an ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)",children:"inheritance"})," hierarchy: a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Superclass_(computer_science)",children:"superclass"}),", Cat, and two ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Subclass_(computer_science)",children:"subclasses"}),", HouseCatandLion. ClassCatdefines a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Virtual_function",children:"virtual function"})," namedspeak, so its subclasses may provide an appropriate implementation (e.g. eithermeoworroar). When the program calls thespeakfunction on aCatreference (which can refer to an instance ofCat, or an instance ofHouseCatorLion), the code must be able to determine which implementation of the function the call should bedispatchedto. This depends on the actual class of the object, not the class of the reference to it (Cat). The class cannot generally be determinedstatically(that is, at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Compile_time",children:"compile time"}),"), so neither can the compiler decide which function to call at that time. The call must be dispatched to the right functiondynamically(that is, at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)",children:"run time"}),") instead."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Virtual_method_table",children:"https://en.wikipedia.org/wiki/Virtual_method_table"})}),"\n",(0,a.jsx)(i.h2,{id:"dynamic-dispatch",children:"Dynamic Dispatch"}),"\n",(0,a.jsxs)(i.p,{children:["In ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_science",children:"computer science"}),", dynamic dispatchis the process of selecting which implementation of a ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)",children:"polymorphic"})," operation (",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Method_(computer_programming)",children:"method"})," or function) to call at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)",children:"run time"}),". It is commonly employed in, and considered a prime characteristic of, ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Object-oriented_programming",children:"object-oriented programming"}),"(OOP) languages and systems.\nObject-oriented systems model a problem as a set of interacting objects that enact operations referred to by name. Polymorphism is the phenomenon wherein somewhat interchangeable objects each expose an operation of the same name but possibly differing in behavior. As an example, aFileobject and aDatabaseobject both have aStoreRecordmethod that can be used to write a personnel record to storage. Their implementations differ. A program holds a reference to an object which may be either aFileobject or aDatabaseobject. Which it is may have been determined by a run-time setting, and at this stage, the program may not know or care which. When the program callsStoreRecordon the object, something needs to choose which behavior gets enacted. If one thinks of OOP as ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Message_passing",children:"sending messages"})," to objects, then in this example the program sends aStoreRecordmessage to an object of unknown type, leaving it to the run-time support system to dispatch the message to the right object. The object enacts whichever behavior it implements.\nDynamic dispatch contrasts withstatic dispatch, in which the implementation of a polymorphic operation is selected at ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Compile_time",children:"compile time"}),". The purpose of dynamic dispatch is to defer the selection of an appropriate implementation until the run time type of a parameter (or multiple parameters) is known.\nDynamic dispatch is different from ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Late_binding",children:"late binding"}),"(also known as dynamic binding).",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Name_binding",children:"Name binding"})," associates a name with an operation. A polymorphic operation has several implementations, all associated with the same name. Bindings can be made at compile time or (with late binding) at run time. With dynamic dispatch, one particular implementation of an operation is chosen at run time. While dynamic dispatch does not imply late binding, late binding does imply dynamic dispatch, since the implementation of a late-bound operation is not known until run time."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Dynamic_dispatch",children:"https://en.wikipedia.org/wiki/Dynamic_dispatch"})}),"\n",(0,a.jsx)(i.h2,{id:"guard-clauses-technique",children:"Guard Clauses Technique"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.youtube.com/shorts/Zmx0Ou5TNJs",children:'Nesting "If Statements" Is Bad. Do This Instead.'})})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>o});var t=n(296540);const a={},r=t.createContext(a);function s(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);