"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[20125],{184396:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"decentralized-applications/ethereum/42-block-proposals","title":"Block Proposals","description":"WHO PRODUCES BLOCKS?","source":"@site/docs/decentralized-applications/ethereum/42-block-proposals.md","sourceDirName":"decentralized-applications/ethereum","slug":"/decentralized-applications/ethereum/42-block-proposals","permalink":"/decentralized-applications/ethereum/42-block-proposals","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/decentralized-applications/ethereum/42-block-proposals.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1739572825000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Rewards and Penalties","permalink":"/decentralized-applications/ethereum/41-rewards-and-penalties"},"next":{"title":"Arbitrum","permalink":"/decentralized-applications/ethereum/arbitrum"}}');var s=o(474848),r=o(28453);const n={},i="Block Proposals",c={},l=[{value:"WHO PRODUCES BLOCKS?",id:"who-produces-blocks",level:2},{value:"Random selection",id:"random-selection",level:3},{value:"HOW IS THE BLOCK CREATED?",id:"how-is-the-block-created",level:2},{value:"WHAT HAPPENS TO THE BLOCK?",id:"what-happens-to-the-block",level:2},{value:"BLOCK REWARDS",id:"block-rewards",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"block-proposals",children:"Block Proposals"})}),"\n",(0,s.jsx)(t.h2,{id:"who-produces-blocks",children:"WHO PRODUCES BLOCKS?"}),"\n",(0,s.jsx)(t.p,{children:"Validator accounts propose blocks. Validator accounts are managed by node operators who run validator software as part of their execution and consensus clients and have deposited at least 32 ETH into the deposit contract. However, each validator is only occasionally responsible for proposing a block. Ethereum measures time in slots and epochs. Each slot is twelve seconds, and 32 slots (6.4 minutes) make up an epoch. Every slot is an opportunity to add a new block on Ethereum."}),"\n",(0,s.jsx)(t.h3,{id:"random-selection",children:"Random selection"}),"\n",(0,s.jsx)(t.p,{children:"A single validator is pseudo-randomly chosen to propose a block in each slot. There is no such thing as true randomness in a blockchain because if each node generated genuinely random numbers, they couldn't come to consensus. Instead, the aim is to make the validator selection process unpredictable. The randomness is achieved on Ethereum using an algorithm called RANDAO that mixes a hash from the block proposer with a seed that gets updated every block. This value is used to select a specific validator from the total validator set. The validator selection is fixed two epochs in advance as a way to protect against certain kinds of seed manipulation."}),"\n",(0,s.jsx)(t.h2,{id:"how-is-the-block-created",children:"HOW IS THE BLOCK CREATED?"}),"\n",(0,s.jsx)(t.p,{children:"The block proposer is expected to broadcast a signed beacon block that builds on top of the most recent head of the chain according to the view of their own locally-run fork choice algorithm. The fork choice algorithm applies any queued attestations left over from the previous slot, then finds the block with the greatest accumulated weight of attestations in its history. That block is the parent of the new block created by the proposer."}),"\n",(0,s.jsx)(t.h2,{id:"what-happens-to-the-block",children:"WHAT HAPPENS TO THE BLOCK?"}),"\n",(0,s.jsxs)(t.p,{children:["The block is added to the block proposer's local database and broadcast to peers over the consensus layer gossip network. When a validator receives the block, it verifies the data inside it, including checking that the block has the correct parent, corresponds to the correct slot, that the proposer index is the expected one, that the RANDAO reveal is valid and that the proposer is not slashed. The ",(0,s.jsx)(t.code,{children:"execution_payload"})," is unbundled, and the validator's execution client re-executes the transactions in the list to check the proposed state change. Assuming the block passes all these checks, each validator adds the block to its own canonical chain. The process then starts again in the next slot."]}),"\n",(0,s.jsx)(t.h2,{id:"block-rewards",children:"BLOCK REWARDS"}),"\n",(0,s.jsxs)(t.p,{children:["The block proposer receives payment for their work. There is a ",(0,s.jsx)(t.code,{children:"base_reward"})," calculated as a function of the number of active validators and their effective balances. The block proposer then receives a fraction of ",(0,s.jsx)(t.code,{children:"base_reward"})," for every valid attestation included in the block; the more validators attest to the block, the greater the block proposer's reward. There is also a reward for reporting validators that should be slashed, equal to ",(0,s.jsx)(t.code,{children:"1/512 * effective balance"})," for each slashed validator."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/block-proposal/",children:"Block proposal | ethereum.org"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>n,x:()=>i});var a=o(296540);const s={},r=a.createContext(s);function n(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);