"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[55905],{413195:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"databases/concepts/mvcc-multiversion-concurrency-control","title":"MVCC, MultiVersion Concurrency Control","description":"The DBMS maintans physical versions of a single logical object in the database:","source":"@site/docs/databases/concepts/mvcc-multiversion-concurrency-control.md","sourceDirName":"databases/concepts","slug":"/databases/concepts/mvcc-multiversion-concurrency-control","permalink":"/databases/concepts/mvcc-multiversion-concurrency-control","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/concepts/mvcc-multiversion-concurrency-control.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Isolation Levels","permalink":"/databases/concepts/isolation-levels"},"next":{"title":"Others","permalink":"/databases/concepts/others"}}');var o=n(474848),s=n(28453);const i={},r="MVCC, MultiVersion Concurrency Control",c={},l=[{value:"Lock Contention",id:"lock-contention",level:2},{value:"Long Term Blocking",id:"long-term-blocking",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"mvcc-multiversion-concurrency-control",children:"MVCC, MultiVersion Concurrency Control"})}),"\n",(0,o.jsx)(t.p,{children:"The DBMS maintans physical versions of a single logical object in the database:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"When a txn writes to an object, the DBMS creates a new version of that object"}),"\n",(0,o.jsx)(t.li,{children:"When a txn reads an object, it reads the newest version that existed when the txn started."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"MVCC means that while querying a database each transaction sees a snapshot of data (adatabase version) as it was some time ago, regardless of the current state of the underlying data. This protects the transaction from viewing inconsistent data that could be caused by (other) concurrent transaction updates on the same data rows, providingtransaction isolationfor each database session."}),"\n",(0,o.jsx)(t.p,{children:"The main difference between multiversion and lock models is that in MVCC locks acquired for querying (reading) data don't conflict with locks acquired for writing data and so reading never blocks writing and writing never blocks reading."}),"\n",(0,o.jsxs)(t.p,{children:["Multiversion concurrency control(MCCorMVCC), is a ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Concurrency_control",children:"concurrency control"})," method commonly used by ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Database_management_system",children:"database management systems"})," to provide concurrent access to the database and in programming languages to implement ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Transactional_memory",children:"transactional memory"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Without concurrency control, if someone is reading from a database at the same time as someone else is writing to it, it is possible that the reader will see a half-written or ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Consistency_(database_systems)",children:"inconsistent"})," piece of data. For instance, when making a wire transfer between two bank accounts if a reader reads the balance at the bank when the money has been withdrawn from the original account and before it has deposited in the destination account, it would seem that money has disappeared from the bank.",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/ACID#Isolation",children:"Isolation"})," is the property that provides guarantees in the concurrent accesses to data. Isolation is implemented by means of a ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Concurrency_control",children:"concurrency control"})," protocol. The simplest way is to make all readers wait until the writer is done, which is known as a ",(0,o.jsxs)(t.strong,{children:["read-write ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Lock_(database)",children:"lock"}),"."]})," Locks are known to create contention especially between long read transactions and update transactions. MVCC aims at solving the problem by keeping ",(0,o.jsx)(t.strong,{children:"multiple copies of each data item."})," In this way, each user connected to the database sees asnapshotof the database at a particular instant in time. Any changes made by a writer will not be seen by other users of the database until the changes have been completed (or, in database terms: until the ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Database_transaction",children:"transaction"})," has been committed.)"]}),"\n",(0,o.jsxs)(t.p,{children:["When an MVCC database needs to update a piece of data, it will not overwrite the original data item with new data, but instead creates a newer version of the data item. Thus there are multiple versions stored. The version that each transaction sees depends on the isolation level implemented. The most common isolation level implemented with MVCC is ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Snapshot_isolation",children:"snapshot isolation"}),". With snapshot isolation, a transaction observes a state of the data as when the transaction started. MVCC introduces the challenge of how to remove versions that become obsolete and will never be read. In some cases, a process to periodically sweep through and delete the obsolete versions is implemented. This is often a stop-the-world process that traverses a whole table and rewrites it with the last version of each data item.",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/PostgreSQL",children:"PostgreSQL"})," adopts this approach with its VACUUM process. Other databases split the storage blocks into two parts: the data part and an undo log. The data part always keeps the last committed version. The undo log enables recreation of older versions of data. The main inherent limitation of this latter approach is that when there are update-intensive workloads, the undo log part runs out of space and then transactions are aborted as they cannot be given their snapshot. For a ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Document-oriented_database",children:"document-oriented database"})," it also allows the system to optimize documents by writing entire documents onto contiguous sections of disk - when updated, the entire document can be re-written rather than bits and pieces cut out or maintained in a linked, non-contiguous database structure"]}),"\n",(0,o.jsxs)(t.p,{children:["MVCC provides ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Data_consistency#Point-in-time_consistency",children:"point-in-time consistent"})," views. Read transactions under MVCC typically use a timestamp or transaction ID to determine what state of the DB to read, and read these versions of the data. Read and write transactions are thus ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Isolation_(database_systems)",children:"isolated"})," from each other without any need for locking. However, despite locks being unnecessary, they are used by some MVCC databases such as Oracle. Writes create a newer version, while concurrent reads access an older version."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multiversion_concurrency_control",children:"https://en.wikipedia.org/wiki/Multiversion_concurrency_control"})}),"\n",(0,o.jsx)(t.h2,{id:"lock-contention",children:"Lock Contention"}),"\n",(0,o.jsxs)(t.p,{children:["Lock contention occurs ",(0,o.jsx)(t.strong,{children:"when many database sessions all require frequent access to the same lock."}),' This is also often called a "hot lock". The locks in question are only held for a short time by each accessing session, then released. This creates a "single lane bridge" situation. Problems are not noticeable when traffic is low (i.e. non-concurrent or low-concurrency situations). However, as traffic (i.e. concurrency) increases, a bottleneck is created.']}),"\n",(0,o.jsx)(t.p,{children:"Overall, Lock Contention problems have a relatively low impact. They manifest themselves by impacting and limiting scalability. As concurrency increases, system throughput does not increase and may even degrade (as shown in Figure 1 below). Lock contention may also lead to high CPU usage on the database server."}),"\n",(0,o.jsx)(t.p,{children:"The best way to identify a lock contention problem is through analysis of statistical information on locks provided by the DBMS"}),"\n",(0,o.jsx)(t.h2,{id:"long-term-blocking",children:"Long Term Blocking"}),"\n",(0,o.jsxs)(t.p,{children:["Long Term Blocking is similar to Lock Contention in that ",(0,o.jsx)(t.strong,{children:"it involves an object or lock that is frequently accessed by a large number of database sessions"}),". Where it differs is that in this case, one session does not release the lock immediately. Instead, the lock is held for a long period of time and while that lock is held, all dependent sessions will be blocked."]}),"\n",(0,o.jsx)(t.p,{children:'Long Term Blocking tends to be a much bigger problem than Lock Contention. It can bring an entire area of functionality or even a whole system to a stand still. The locks involved in these scenarios may not be "hot" enough to lead to Lock Contention problems under normal circumstances. As such, these problems may be intermittent and very dependent on certain coincidental activity. These are the most likely to lead to "disasters" in production due to the combination of devastating impact and difficulty to reproduce.'}),"\n",(0,o.jsx)(t.p,{children:"The consequences of long term blocking problems may be abandonment. However, these problems can also often lead to further problems as frustrated users re-submit their requests. This can compound and exacerbate the problem by leading to a larger queue and consuming additional resource. In this way, the impact can expand to consume an entire system."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(296540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);