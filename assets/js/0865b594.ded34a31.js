"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[34320],{212350:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"languages/sql/concepts","title":"Concepts","description":"Predicate","source":"@site/docs/languages/sql/concepts.md","sourceDirName":"languages/sql","slug":"/languages/sql/concepts","permalink":"/languages/sql/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/sql/concepts.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1739572825000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SQL","permalink":"/languages/sql/"},"next":{"title":"CTE / Subquery","permalink":"/languages/sql/cte-subquery"}}');var i=n(474848),o=n(28453);const r={},a="Concepts",l={},c=[{value:"Predicate",id:"predicate",level:2},{value:"Comparisons",id:"comparisons",level:2},{value:"EXISTS vs IN vs JOIN",id:"exists-vs-in-vs-join",level:3},{value:"Others",id:"others",level:2},{value:"NULL",id:"null",level:3}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,i.jsx)(s.h2,{id:"predicate",children:"Predicate"}),"\n",(0,i.jsx)(s.p,{children:"A WHERE clause is a predicate. Retrieving records from a database using a projection statement like SELECT and combining it with any other clause that limits or filters your result set is considered to be a predicate. A predicate is an assertion which returns true or false. Only the true path affects the result set"}),"\n",(0,i.jsxs)(s.p,{children:["A predicate defines a logical condition being applied to rows in a table. SQL Predicates are found on the tail end of clauses, functions, and SQL expressions in existing query statements. It is an expression that evaluates to ",(0,i.jsx)(s.strong,{children:"TRUE"}),", ",(0,i.jsx)(s.strong,{children:"FALSE"}),", or ",(0,i.jsx)(s.strong,{children:"UNKNOWN"}),". Predicates are used in the search condition of ",(0,i.jsx)(s.strong,{children:"WHERE"})," clauses and ",(0,i.jsx)(s.strong,{children:"HAVING"})," clauses, the join conditions of ",(0,i.jsx)(s.strong,{children:"FROM"})," clauses, and other constructs where a Boolean value is required."]}),"\n",(0,i.jsx)(s.p,{children:"In the line:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"JOIN Country ON Customer.countryCode = Country.countryCode"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"Customer.countryCode = Country.countryCode"})," part is called a Predicate."]}),"\n",(0,i.jsx)(s.p,{children:"And in the line:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"WHERE Country.nickName IN ('USA', 'UK', 'Japan')"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"Country.nickName IN ('USA', 'UK', 'Japan')"})," part is also called a Predicate."]}),"\n",(0,i.jsx)(s.p,{children:"A predicate is simply the formal name for when an expression is used to evaluate a TRUE or FALSE condition (or sometimes UNKNOWN if a TRUE/FALSE value can't be determined)"}),"\n",(0,i.jsx)(s.p,{children:"The Transact-SQL language supports the following predicates:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"In Operator"}),"\n",(0,i.jsx)(s.li,{children:"Exists function"}),"\n",(0,i.jsx)(s.li,{children:"Between Operator"}),"\n",(0,i.jsx)(s.li,{children:"Like Operator"}),"\n",(0,i.jsx)(s.li,{children:"All and any Operator"}),"\n",(0,i.jsx)(s.li,{children:"Like"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://www.quora.com/What-is-a-predicate-in-SQL",children:"https://www.quora.com/What-is-a-predicate-in-SQL"})}),"\n",(0,i.jsx)(s.h2,{id:"comparisons",children:"Comparisons"}),"\n",(0,i.jsx)(s.h3,{id:"exists-vs-in-vs-join",children:"EXISTS vs IN vs JOIN"}),"\n",(0,i.jsx)(s.p,{children:"Surprisingly doing a join is usually faster then a large IN statement, this is because the values in the IN are not indexed, so MySQL can not do an index join on them. But this only applies with lots of values - for small number of them using IN could be faster."}),"\n",(0,i.jsx)(s.p,{children:"Personally, I would use the JOIN method until the point that you see this query becoming a problem. (Which would only happen if you had some very complex conditionals to check, that could get slow to do twice). The join is simpler code, and most likely will be super fast - so don't make things more complicated without a specific reason."}),"\n",(0,i.jsx)(s.p,{children:"A regular JOIN can be used to find matching values in a subquery. Like EXISTS, JOIN allows one or more columns to be used to find matches. Unlike EXISTS, JOIN isn't as confusing to implement. The downside to JOIN is that if the subquery has any identical rows based on the JOIN predicate, then the main query will repeat rows which could lead to invalid query outputs. Both IN and EXISTS will ignore duplicate values in a subquery. Take extra precaution when joining to a table in this fashion."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://www.mssqltips.com/sqlservertip/6659/sql-exists-vs-in-vs-join-performance-comparison/",children:"SQL EXISTS vs IN vs JOIN Performance Comparison"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://learnsql.com/blog/subquery-vs-join/",children:"Subquery vs. JOIN | LearnSQL.com"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://dev.mysql.com/doc/refman/8.0/en/semijoins.html",children:"MySQL :: MySQL 8.0 Reference Manual :: 8.2.2.1 Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://www.sqlshack.com/t-sql-commands-performance-comparison-not-vs-not-exists-vs-left-join-vs-except/",children:"T-SQL commands performance comparison - NOT IN vs NOT EXISTS vs LEFT JOIN vs EXCEPT"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"methods that use the SQL NOT EXISTS and the LEFT JOIN commands has the least execution costs, and the method that uses the NOT IN command has the heaviest query cost"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"others",children:"Others"}),"\n",(0,i.jsx)(s.h3,{id:"null",children:"NULL"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"http://www-cs-students.stanford.edu/~wlam/compsci/sqlnulls",children:"http://www-cs-students.stanford.edu/~wlam/compsci/sqlnulls"})})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var t=n(296540);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);