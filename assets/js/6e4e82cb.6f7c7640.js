"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[49408],{515056:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"databases-nosql/druid/architecture","title":"Architecture","description":"Druid has a multi-process, distributed architecture that is designed to be cloud-friendly and easy to operate. Each Druid process type can be configured and scaled independently, giving you maximum flexibility over your cluster. This design also provides enhanced fault tolerance: an outage of one component will not immediately affect other components.","source":"@site/docs/databases-nosql/druid/architecture.md","sourceDirName":"databases-nosql/druid","slug":"/databases-nosql/druid/architecture","permalink":"/databases-nosql/druid/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/druid/architecture.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749576162000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Druid","permalink":"/databases-nosql/druid/"},"next":{"title":"Cheatsheet","permalink":"/databases-nosql/druid/cheatsheet"}}');var i=r(474848),n=r(28453);const a={},o="Architecture",d={},l=[{value:"Historical",id:"historical",level:3},{value:"MiddleManager",id:"middlemanager",level:3},{value:"Broker",id:"broker",level:3},{value:"Coordinator",id:"coordinator",level:3},{value:"Overlord",id:"overlord",level:3},{value:"Router",id:"router",level:3}];function c(e){const s={a:"a",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,i.jsx)(s.p,{children:"Druid has a multi-process, distributed architecture that is designed to be cloud-friendly and easy to operate. Each Druid process type can be configured and scaled independently, giving you maximum flexibility over your cluster. This design also provides enhanced fault tolerance: an outage of one component will not immediately affect other components."}),"\n",(0,i.jsx)(s.p,{children:"Druid's process types are:"}),"\n",(0,i.jsx)(s.h3,{id:"historical",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/historical.html",children:"Historical"})}),"\n",(0,i.jsx)(s.p,{children:'Historical processes are the workhorses that handle storage and querying on "historical" data (including any streaming data that has been in the system long enough to be committed). Historical processes download segments from deep storage and respond to queries about these segments. They don\'t accept writes.'}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Each Historical process serves up data that has been partitioned into segments. These segments are assigned to Historical by the Coordinator via ZooKeeper"}),"\n",(0,i.jsx)(s.li,{children:"When a Historical process is assigned a segment, it will copy the file from deep storage to its local storage"}),"\n",(0,i.jsx)(s.li,{children:"When a query is received from the Broker process, the Historical process returns the results"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"middlemanager",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/middlemanager.html",children:"MiddleManager"})}),"\n",(0,i.jsx)(s.p,{children:"MiddleManager processes handle ingestion of new data into the cluster. They are responsible for reading from external data sources and publishing new Druid segments."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The MiddleManager process is a worker process that executes submitted tasks. Middle Managers forward tasks to Peons that run in separate JVMs. The reason we have separate JVMs for tasks is for resource and log isolation. Each ",(0,i.jsx)(s.a,{href:"https://druid.apache.org/docs/latest/design/peons.html",children:"Peon"})," is capable of running only one task at a time, however, a MiddleManager may have multiple Peons."]}),"\n",(0,i.jsx)(s.li,{children:"During real-time ingestion, the MiddleManager also serves queries on real-time data before it has been pushed to deep storage."}),"\n",(0,i.jsx)(s.li,{children:"When a query is received from the Broker process, the MiddleManager process executes that query on real-time data and returns results."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"broker",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/broker.html",children:"Broker"})}),"\n",(0,i.jsx)(s.p,{children:"Broker processes receive queries from external clients and forward those queries to Historicals and MiddleManagers. When Brokers receive results from those subqueries, they merge those results and return them to the caller. End users typically query Brokers rather than querying Historicals or MiddleManagers directly."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Broker process is responsible for knowing the internal state of the cluster (from the ZooKeeper)"}),"\n",(0,i.jsxs)(s.li,{children:["The broker finds out information from ZooKeeper about the Druid cluster","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Which Historical processes are serving which segments"}),"\n",(0,i.jsx)(s.li,{children:"Which MiddleManager processes are serving which tasks' data"}),"\n",(0,i.jsx)(s.li,{children:"When a query is run, the Broker will figure out which process to contact"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"coordinator",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/coordinator.html",children:"Coordinator"})}),"\n",(0,i.jsx)(s.p,{children:"Coordinator processes watch over the Historical processes. They are responsible for assigning segments to specific servers, and for ensuring segments are well-balanced across Historicals."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Segment management and distribution"}),"\n",(0,i.jsxs)(s.li,{children:["It communicates with the Historical nodes to:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Load -"})," Copy a segment from deep storage and start serving it"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Drop -"})," Delete a segment from its local copy and stop serving it"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"overlord",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/overlord.html",children:"Overlord"})}),"\n",(0,i.jsx)(s.p,{children:"Overlord processes watch over the MiddleManager processes and are the controllers of data ingestion into Druid. They are responsible for assigning ingestion tasks to MiddleManagers and for coordinating segment publishing."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Accepting ingestion supervisors and tasks"}),"\n",(0,i.jsx)(s.li,{children:"Coordinating which servers run which tasks"}),"\n",(0,i.jsx)(s.li,{children:"Managing locks so tasks don't conflict with each other"}),"\n",(0,i.jsx)(s.li,{children:"Returning supervisor and task status to callers"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"router",children:(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/development/router.html",children:"Router"})}),"\n",(0,i.jsx)(s.p,{children:"Router processes are optional processes that provide a unified API gateway in front of Druid Brokers, Overlords, and Coordinators. They are optional since you can also simply contact the Druid Brokers, Overlords, and Coordinators directly."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"image",src:r(549812).A+"",width:"999",height:"405"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://docs.imply.io/cloud/design",children:"https://docs.imply.io/cloud/design"})}),"\n",(0,i.jsx)(s.p,{children:"Druid processes can be deployed individually (one per physical server, virtual server, or container) or can be colocated on shared servers. One common colocation plan is a three-type plan:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:'"Data"'})," servers run Historical and MiddleManager processes."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:'"Query"'})," servers run Broker and (optionally) Router processes."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:'"Master"'})," servers run Coordinator and Overlord processes. They may run ZooKeeper as well."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"In addition to these process types, Druid also has three external dependencies. These are intended to be able to leverage existing infrastructure, where present."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/index.html#deep-storage",children:"Deep storage"}),","]})," shared file storage accessible by every Druid server. This is typically going to be a distributed object store like S3 or HDFS, cassandra, Google Cloud Storage or a network mounted filesystem. Druid uses this to store any data that has been ingested into the system."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/index.html#metadata-storage",children:(0,i.jsx)(s.strong,{children:"Metadata store"})}),", shared metadata storage. This is typically going to be a traditional RDBMS like PostgreSQL or MySQL."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"http://druid.io/docs/latest/design/index.html#zookeeper",children:(0,i.jsx)(s.strong,{children:"ZooKeeper"})})," is used for internal service discovery, coordination, and leader election."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The idea behind this architecture is to make a Druid cluster simple to operate in production at scale. For example, the separation of deep storage and the metadata store from the rest of the cluster means that Druid processes are radically fault tolerant: even if every single Druid server fails, you can still relaunch your cluster from data stored in deep storage and the metadata store."}),"\n",(0,i.jsx)(s.p,{children:"The following diagram shows how queries and data flow through this architecture:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"image",src:r(444291).A+"",width:"999",height:"562"})})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},549812:(e,s,r)=>{r.d(s,{A:()=>t});const t=r.p+"assets/images/Druid_Architecture-image1-94a812c2f4d015cb33c68164d4491ada.jpg"},444291:(e,s,r)=>{r.d(s,{A:()=>t});const t=r.p+"assets/images/Druid_Architecture-image2-01db52d5ab42bd00a07b1225a63b668c.jpg"},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>o});var t=r(296540);const i={},n=t.createContext(i);function a(e){const s=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);