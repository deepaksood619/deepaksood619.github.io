"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[53786],{889362:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"algorithms/general/recursion","title":"Recursion","description":"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-recursion-part-2","source":"@site/docs/algorithms/general/recursion.md","sourceDirName":"algorithms/general","slug":"/algorithms/general/recursion","permalink":"/algorithms/general/recursion","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/general/recursion.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Quick Select","permalink":"/algorithms/general/quick-select"},"next":{"title":"Reverse Polish Notation / Postfix Notation","permalink":"/algorithms/general/reverse-polish-notation-postfix-notation"}}');var r=n(474848),s=n(28453);const a={},o="Recursion",c={},l=[{value:"Always think of base case and recursive case",id:"always-think-of-base-case-and-recursive-case",level:2},{value:"Two instances",id:"two-instances",level:2},{value:"Tail Recursion",id:"tail-recursion",level:2},{value:"Example",id:"example",level:2},{value:"Here is a simple JavaScript implementation that uses recursion",id:"here-is-a-simple-javascript-implementation-that-uses-recursion",level:2},{value:"Here&#39;s a tail-recursive version of the same function",id:"heres-a-tail-recursive-version-of-the-same-function",level:2},{value:"Recursion Limit",id:"recursion-limit",level:2},{value:"TRE - Tail Recursion Elimination",id:"tre---tail-recursion-elimination",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"recursion",children:"Recursion"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-recursion-part-2",children:"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-recursion-part-2"})}),"\n",(0,r.jsx)(t.p,{children:"Starter Function -"}),"\n",(0,r.jsx)(t.p,{children:'Starter Function will initialize any data and get the parameters in a form that will be easy to work with. Once things are ready, the "starter" function calls the recursive function that will do the rest of the work.'}),"\n",(0,r.jsx)(t.p,{children:'"multiple related decision" pattern - if we have a lot of decisions to make in a recursive call'}),"\n",(0,r.jsx)(t.h2,{id:"always-think-of-base-case-and-recursive-case",children:"Always think of base case and recursive case"}),"\n",(0,r.jsx)(t.h2,{id:"two-instances",children:"Two instances"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The first is when recursion is used as a technique in which a function makes one or more calls to itself."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The second is when a data structure uses smaller instances of the exact same type of data structure when it represents itself."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Recursion provides a powerful alternative for performing repetitions of tasks in which a loop is not ideal. Most modern programming languages support recursion and recursion serves as a great tool for building out particular data structures."}),"\n",(0,r.jsx)(t.h2,{id:"tail-recursion",children:"Tail Recursion"}),"\n",(0,r.jsx)(t.p,{children:"A recursive function is tail recursive when recursive call is the last thing executed by the function."}),"\n",(0,r.jsx)(t.p,{children:"The tail recursive functions considered better than non tail recursive functions as tail-recursion can be optimized by compiler. The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current function's stack frame is of no use."}),"\n",(0,r.jsxs)(t.p,{children:["In",(0,r.jsx)(t.strong,{children:"traditional recursion"}),", the typical model is that you perform your recursive calls first, and then you take the return value of the recursive call and calculate the result. In this manner, you don't get the result of your calculation until you have returned from every recursive call."]}),"\n",(0,r.jsxs)(t.p,{children:["In ",(0,r.jsx)(t.strong,{children:"tail recursion"}),', you perform your calculations first, and then you execute the recursive call, passing the results of your current step to the next recursive step. This results in the last statement being in the form of "(return (recursive-function params))" (I think that\'s the syntax for Lisp).Basically, the ',(0,r.jsx)(t.strong,{children:"return value of any given recursive step is the same as the return value of the next recursive call."})]}),"\n",(0,r.jsx)(t.p,{children:"The consequence of this is that once you are ready to perform your next recursive step, you don't need the current stack frame any more. This allows for some optimization. In fact, with an appropriately written compiler, you should never have a stack overflowsnickerwith a tail recursive call. Simply reuse the current stack frame for the next recursive step. I'm pretty sure Lisp does this."}),"\n",(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(t.p,{children:"Consider a simple function that adds the first N integers. (e.g.sum(5) = 1 + 2 + 3 + 4 + 5 = 15)."}),"\n",(0,r.jsx)(t.h2,{id:"here-is-a-simple-javascript-implementation-that-uses-recursion",children:"Here is a simple JavaScript implementation that uses recursion"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"function recsum(x) {\nif (x===1) {\nreturn x;\n} else {\nreturn x + recsum(x-1);\n}\n}\n\nIf you calledrecsum(5), this is what the JavaScript interpreter would evaluate:\n\nrecsum(5)\n5 + recsum(4)\n5 + (4 + recsum(3))\n5 + (4 + (3 + recsum(2)))\n5 + (4 + (3 + (2 + recsum(1))))\n5 + (4 + (3 + (2 + 1)))\n15\n"})}),"\n",(0,r.jsx)(t.p,{children:"Note how every recursive call has to complete before the JavaScript interpreter begins to actually do the work of calculating the sum."}),"\n",(0,r.jsx)(t.h2,{id:"heres-a-tail-recursive-version-of-the-same-function",children:"Here's a tail-recursive version of the same function"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"function tailrecsum(x, running_total=0) {\nif (x===0) {\nreturn running_total;\n} else {\nreturn tailrecsum(x-1, running_total+x);\n}\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Here's the sequence of events that would occur if you calledtailrecsum(5), (which would effectively betailrecsum(5, 0), because of the default second argument)."}),"\n",(0,r.jsx)(t.p,{children:"tailrecsum(5, 0)\ntailrecsum(4, 5)\ntailrecsum(3, 9)\ntailrecsum(2, 12)\ntailrecsum(1, 14)\ntailrecsum(0, 15)\n15"}),"\n",(0,r.jsx)(t.p,{children:"In the tail-recursive case, with each evaluation of the recursive call, therunning_totalis updated."}),"\n",(0,r.jsx)(t.h2,{id:"recursion-limit",children:"Recursion Limit"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"import sys\n\nsys.getrecursionlimit() #default 3000 for python\n\nsys.setrecursionlimit(86400)\n"})}),"\n",(0,r.jsx)(t.p,{children:"TCO - Tail Call Optimization"}),"\n",(0,r.jsx)(t.h2,{id:"tre---tail-recursion-elimination",children:"TRE - Tail Recursion Elimination"}),"\n",(0,r.jsx)(t.p,{children:"It is a guard against a stack overflow."}),"\n",(0,r.jsx)(t.p,{children:"Python (or rather, the CPython implementation) doesn't optimize tail recursion, and unbridled recursion causes stack overflows."}),"\n",(0,r.jsx)(t.p,{children:"Changing the recursion limit is dangerous, the standard limit for python is a little conservative, but Python stackframes can be quite big."}),"\n",(0,r.jsx)(t.p,{children:"Python isn't a functional language and tail recursion is not a particularly efficient technique. Rewriting the algorithm iteratively, if possible, is generally a better idea. Since Guido prefers to be able to have proper tracebacks Python will never optimize tail recursions"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tail_call",children:"https://en.wikipedia.org/wiki/Tail_call"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://towardsdatascience.com/advanced-concepts-in-recursion-every-effective-programmer-should-know-de233a092dbf",children:"https://towardsdatascience.com/advanced-concepts-in-recursion-every-effective-programmer-should-know-de233a092dbf"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://blog.moertel.com/posts/2013-06-12-recursion-to-iteration-4-trampolines.html",children:"https://blog.moertel.com/posts/2013-06-12-recursion-to-iteration-4-trampolines.html"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(296540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);