"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[22093],{996182:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"algorithms/graphtheory/shortest-path-algorithms","title":"Shortest Path Algorithms","description":"Shortest path variants","source":"@site/docs/algorithms/graphtheory/shortest-path-algorithms.md","sourceDirName":"algorithms/graphtheory","slug":"/algorithms/graphtheory/shortest-path-algorithms","permalink":"/algorithms/graphtheory/shortest-path-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/graphtheory/shortest-path-algorithms.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1692586856000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Seam Carving","permalink":"/algorithms/graphtheory/seam-carving"},"next":{"title":"Strong Components","permalink":"/algorithms/graphtheory/strong-components"}}');var n=i(474848),r=i(28453);const a={},o="Shortest Path Algorithms",h={},l=[{value:"Shortest path variants",id:"shortest-path-variants",level:2},{value:"Which vertices?",id:"which-vertices",level:3},{value:"Restrictions on edge weights?",id:"restrictions-on-edge-weights",level:3},{value:"Cycles?",id:"cycles",level:3},{value:"Concept",id:"concept",level:2},{value:"Edge Relaxation",id:"edge-relaxation",level:3},{value:"Efficient implementations. How to choose which edge to relax?",id:"efficient-implementations-how-to-choose-which-edge-to-relax",level:2},{value:"Applications",id:"applications",level:2},{value:"Advanced - Used in maps (precomputed)",id:"advanced---used-in-maps-precomputed",level:2},{value:"Applications - Arbitrage Detection",id:"applications---arbitrage-detection",level:2}];function c(e){const t={h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"shortest-path-algorithms",children:"Shortest Path Algorithms"})}),"\n",(0,n.jsx)(t.h2,{id:"shortest-path-variants",children:"Shortest path variants"}),"\n",(0,n.jsx)(t.h3,{id:"which-vertices",children:"Which vertices?"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Single Source : from one vertex s to every other vertex."}),"\n",(0,n.jsx)(t.li,{children:"Source-sink : from one vertex s to another vertex t"}),"\n",(0,n.jsx)(t.li,{children:"All pairs : between all pairs of vertices"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"restrictions-on-edge-weights",children:"Restrictions on edge weights?"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Non negative weights"}),"\n",(0,n.jsx)(t.li,{children:"Euclidean weights"}),"\n",(0,n.jsx)(t.li,{children:"Arbitrary weighs"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"cycles",children:"Cycles?"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"No directed cycles"}),"\n",(0,n.jsx)(t.li,{children:'No "negative cycles"'}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"concept",children:"Concept"}),"\n",(0,n.jsx)(t.h3,{id:"edge-relaxation",children:"Edge Relaxation"}),"\n",(0,n.jsx)(t.p,{children:"Create SPT (Shortest Path Tree)"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(440409).A+"",width:"999",height:"840"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(241742).A+"",width:"732",height:"356"})}),"\n",(0,n.jsx)(t.p,{children:"Optimality Condition (there is no edge we missed)"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(537579).A+"",width:"1000",height:"763"})}),"\n",(0,n.jsx)(t.h2,{id:"efficient-implementations-how-to-choose-which-edge-to-relax",children:"Efficient implementations. How to choose which edge to relax?"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Topological sort algorithm (no directed cycles)"}),"\n",(0,n.jsx)(t.li,{children:"Dijkstra's algorithm (non-negative weights)"}),"\n",(0,n.jsx)(t.li,{children:"Bellman-Ford algorithm (no negative cycles)"}),"\n",(0,n.jsx)(t.li,{children:"Ford - Fulkerson Algorithm (for maximum flow in a graph)"}),"\n",(0,n.jsx)(t.li,{children:"Floyd-Warshall Algorithm (All pairs shortest path algorithm)"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(833976).A+"",width:"999",height:"734"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(895157).A+"",width:"1000",height:"834"})}),"\n",(0,n.jsx)(t.h2,{id:"applications",children:"Applications"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"PERT / CPM (Program Evaluation and Review Technique / Critical Path Method)"}),"\n",(0,n.jsx)(t.li,{children:"Map routing"}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:"Seam carving"})}),"\n",(0,n.jsx)(t.li,{children:"Robot navigation"}),"\n",(0,n.jsx)(t.li,{children:"Texture mapping"}),"\n",(0,n.jsx)(t.li,{children:"Typesetting in TeX"}),"\n",(0,n.jsx)(t.li,{children:"Urban traffic planning"}),"\n",(0,n.jsx)(t.li,{children:"Optimal pipelining of VLSI chip"}),"\n",(0,n.jsx)(t.li,{children:"Telemarketer operator scheduling"}),"\n",(0,n.jsx)(t.li,{children:"Routing of telecommunication messages"}),"\n",(0,n.jsx)(t.li,{children:"Network routing protocol (OSPF, BGP, RIP)"}),"\n",(0,n.jsx)(t.li,{children:"Exploiting arbitrage opportunities in currency exchange."}),"\n",(0,n.jsx)(t.li,{children:"Optimal truck routing through given traffic congestion pattern."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"advanced---used-in-maps-precomputed",children:"Advanced - Used in maps (precomputed)"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Highway-node routing"}),"\n",(0,n.jsx)(t.li,{children:"Contraction hierarchies"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"applications---arbitrage-detection",children:"Applications - Arbitrage Detection"}),"\n",(0,n.jsx)(t.p,{children:"Arbitrage - the simultaneous buying and selling of securities, currency, or commodities in different markets or in derivative forms in order to take advantage of differing prices for the same asset. (Making money of the System)"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(354666).A+"",width:"999",height:"760"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(366823).A+"",width:"778",height:"649"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(519348).A+"",width:"999",height:"701"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},440409:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image1-352b9668c43fbacc68e309085c332686.jpg"},241742:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image2-e2dcc5dc6429b335f35c0fd5ea112f12.jpg"},537579:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image3-28ea6eea039247bcce6cbd6ecd905ae7.jpg"},833976:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image4-dc967b801a55b48818fd8065f987c481.jpg"},895157:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image5-5528c959599cbbb1fee6d2a1806f70a9.jpg"},354666:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image6-9d1ee46d341d461decc55ccec242f173.jpg"},366823:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image7-c270a065b5bc3ec8ccb61b67ec9ea8fe.jpg"},519348:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Shortest-Path-Algorithms-image8-4b73d56acbaa6d79a18dc1cac1f91c6a.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var s=i(296540);const n={},r=s.createContext(n);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);