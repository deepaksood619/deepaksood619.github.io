"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[72107],{331454:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"computer-science/operating-system/memory-allocation","title":"Memory Allocation","description":"Dynamic memory allocation","source":"@site/docs/computer-science/operating-system/memory-allocation.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/memory-allocation","permalink":"/computer-science/operating-system/memory-allocation","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/memory-allocation.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Journaling File System","permalink":"/computer-science/operating-system/journaling-file-system"},"next":{"title":"Memory Layout","permalink":"/computer-science/operating-system/memory-layout"}}');var o=i(474848),n=i(28453);const r={},s="Memory Allocation",l={},c=[{value:"Dynamic memory allocation",id:"dynamic-memory-allocation",level:2},{value:"Automatic memory allocation",id:"automatic-memory-allocation",level:2},{value:"Static memory allocation",id:"static-memory-allocation",level:2},{value:"*Notes on static memory allocation",id:"notes-on-static-memory-allocation",level:2},{value:"Register Memory",id:"register-memory",level:2},{value:"References",id:"references",level:2}];function m(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"memory-allocation",children:"Memory Allocation"})}),"\n",(0,o.jsx)(t.h2,{id:"dynamic-memory-allocation",children:"Dynamic memory allocation"}),"\n",(0,o.jsxs)(t.p,{children:["Is memory allocated at runtime usingcalloc(), malloc()and friends. It is sometimes also referred to as 'heap' memory, although it has nothing to do with the heap data-structure ",(0,o.jsx)(t.a,{href:"http://www.quora.com/Why-is-dynamic-memory-allocation-called-heap-memory-allocation",children:"ref"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"int * a = malloc(sizeof(int));\nHeap memory is persistent untilfree()is called. In other words, you control the lifetime of the variable."}),"\n",(0,o.jsx)(t.h2,{id:"automatic-memory-allocation",children:"Automatic memory allocation"}),"\n",(0,o.jsxs)(t.p,{children:["This is what is commonly known as 'stack' memory, and is allocated when you enter a new scope (usually when a new function is pushed on the call stack). Once you move out of the scope, the values of automatic memory addresses are undefined, and it is an ",(0,o.jsx)(t.a,{href:"https://stackoverflow.com/a/6445794/140264",children:"error to access them"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"int a = 43;\nNote that scope does not necessarily mean function. Scopes can nest within a function, and the variable will be in-scope only within the block in which it was declared. Note also that where this memory is allocated is not specified. (On asanesystem it will be on the stack, or registers for optimisation)"}),"\n",(0,o.jsx)(t.h2,{id:"static-memory-allocation",children:"Static memory allocation"}),"\n",(0,o.jsxs)(t.p,{children:["Is allocated at compile time*, and the lifetime of a variable in static memory is the ",(0,o.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Static_variable",children:"lifetime of the program"}),".\nIn C, static memory can be allocated using thestatickeyword. The scope is the compilation unit only.\nThings get more interesting ",(0,o.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Extern_variable",children:"when theexternkeyword is considered"}),". When anexternvariable isdefinedthe compiler allocates memory for it. When anexternvariable isdeclared, the compiler requires that the variable bedefinedelsewhere. Failure to declare/defineexternvariables will cause linking problems, while failure to declare/definestaticvariables will cause compilation problems."]}),"\n",(0,o.jsx)(t.p,{children:"in file scope, the static keyword is optional (outside of a function):"}),"\n",(0,o.jsx)(t.p,{children:"int a = 32;\nBut not in function scope (inside of a function):"}),"\n",(0,o.jsx)(t.p,{children:"static int a = 32;\nTechnically, externandstaticare two separate classes of variables in C."}),"\n",(0,o.jsxs)(t.p,{children:["extern int a; /",(0,o.jsx)(t.em,{children:"Declaration"}),"/\nint a; /",(0,o.jsx)(t.em,{children:"Definition"}),"/"]}),"\n",(0,o.jsx)(t.h2,{id:"notes-on-static-memory-allocation",children:"*Notes on static memory allocation"}),"\n",(0,o.jsx)(t.p,{children:"It's somewhat confusing to say that static memory is allocated at compile time, especially if we start considering that the compilation machine and the host machine might not be the same or might not even be on the same architecture."}),"\n",(0,o.jsx)(t.p,{children:"It may be better to thinkthat the allocation of static memory is handled by the compilerrather thanallocated at compile time."}),"\n",(0,o.jsx)(t.p,{children:"For example the compiler may create a largedatasection in the compiled binary and when the program is loaded in memory, the address within thedatasegment of the program will be used as the location of the allocated memory. This has the marked disadvantage of making the compiled binary very large if uses a lot of static memory. It's possible to write a multi-gigabytes binary generated from less than half a dozen lines of code. Another option is for the compiler to inject initialisation code that will allocate memory in some other way before the program is executed. This code will vary according to the target platform and OS. In practice, modern compilers use heuristics to decide which of these options to use. You can try this out yourself by writing a small C program that allocates a large static array of either 10k, 1m, 10m, 100m, 1G or 10G items. For many compilers, the binary size will keep growing linearly with the size of the array, and past a certain point, it will shrink again as the compiler uses another allocation strategy."}),"\n",(0,o.jsx)(t.h2,{id:"register-memory",children:"Register Memory"}),"\n",(0,o.jsxs)(t.p,{children:["The last memory class are 'register' variables. As expected, register variables should be allocated on a CPU's register, but the decision is actually left to the compiler. You may not turn a register variable into a reference by using address-of.\nregister int meaning = 42;\nprintf(\"%pn\",&meaning); /",(0,o.jsx)(t.em,{children:"this is wrong and will fail at compile time."}),"/\nMost modern compilers are smarter than you at picking which variables should be put in registers."]}),"\n",(0,o.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation",children:"https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://www.memorymanagement.org/index.html",children:"https://www.memorymanagement.org/index.html"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var a=i(296540);const o={},n=a.createContext(o);function r(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);