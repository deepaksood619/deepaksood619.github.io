"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[82642],{347152:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"computer-science/operating-system/caches-caching","title":"Caches / Caching","description":"Points to remeber about cache","source":"@site/docs/computer-science/operating-system/caches-caching.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/caches-caching","permalink":"/computer-science/operating-system/caches-caching","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/caches-caching.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Cache Coherence","permalink":"/computer-science/operating-system/cache-coherence-invalidation"},"next":{"title":"Caching Strategies","permalink":"/computer-science/operating-system/caching-strategies-topologies"}}');var r=t(474848),n=t(28453);const o={},s="Caches / Caching",c={},h=[{value:"Points to remeber about cache",id:"points-to-remeber-about-cache",level:2},{value:"Benefits of caching",id:"benefits-of-caching",level:2},{value:"WHAT TO CACHE?",id:"what-to-cache",level:2},{value:"WHAT NOT TO CACHE?",id:"what-not-to-cache",level:2},{value:"Cache Types",id:"cache-types",level:2},{value:"HTTP Cache",id:"http-cache",level:3},{value:"Fragment Cache",id:"fragment-cache",level:3},{value:"Object Cache",id:"object-cache",level:3},{value:"BFCache | others",id:"bfcache--others",level:3},{value:"Locality of reference / Cache locality / Principle of locality",id:"locality-of-reference--cache-locality--principle-of-locality",level:2},{value:"Types of locality",id:"types-of-locality",level:3},{value:"Temporal locality",id:"temporal-locality",level:4},{value:"Spatial locality",id:"spatial-locality",level:4},{value:"Memory locality",id:"memory-locality",level:4},{value:"Branch locality",id:"branch-locality",level:4},{value:"Equidistant locality",id:"equidistant-locality",level:4},{value:"Cache-oblivious algorithm",id:"cache-oblivious-algorithm",level:2},{value:"HTTP ETag (Entity tag)",id:"http-etag-entity-tag",level:2},{value:"Others",id:"others",level:2},{value:"References",id:"references",level:2}];function l(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"caches--caching",children:"Caches / Caching"})}),"\n",(0,r.jsx)(i.h2,{id:"points-to-remeber-about-cache",children:"Points to remeber about cache"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Cache data cannot be the source of truth"}),"\n",(0,r.jsx)(i.li,{children:"Cache data has to be pretty small because cache tends to keep all the data in-memory"}),"\n",(0,r.jsx)(i.li,{children:"Consider Eviction policies (Page replacement policies)"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["In ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computing",children:"computing"}),", acacheis a hardware or software component that stores data so that future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation or a copy of data stored elsewhere. Acache hitoccurs when the requested data can be found in a cache, while acache missoccurs when it cannot. Cache hits are served by reading data from the cache, which is faster than recomputing a result or reading from a slower data store; thus, the more requests that can be served from the cache, the faster the system performs."]}),"\n",(0,r.jsxs)(i.p,{children:["To be cost-effective and to enable efficient use of data, caches must be relatively small. Nevertheless, caches have proven themselves in many areas of computing, because typical ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Application_software",children:"computer applications"})," access data with a high degree of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Locality_of_reference",children:"locality of reference"}),". Such access patterns exhibit temporal locality, where data is requested that has been recently requested already, and ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Memory_address",children:"spatial"})," locality, where data is requested that is stored physically close to data that has already been requested."]}),"\n",(0,r.jsx)(i.p,{children:"A cache hit happens whenever data is already available in the cache and can be returned without any other operation, otherwise the cache responds with a cache miss or, if available, can transparently retrieve the value from another underlying backend system and cache it before returning it to the requestor."}),"\n",(0,r.jsx)(i.p,{children:"Caches are designed to respond to cache requests in near real-time and therefore are implemented as simple key-value stores. The underlying data structure, however, can still be different and depends on the storage backend. In addition, caches can most often be used by multiple front end consumers such as web applications."}),"\n",(0,r.jsx)(i.p,{children:"Caches can have multiple levels, so-called tiered storages, which are ordered by their speed factor. Frequently or recently used data are typically held in memory, whereas other data (depending on the tiered storage implementations) can be written to SSD, slower spinning disk systems and later on other even slower systems, or can be evicted completely - if reproducible.\nTypical use cases are in-memory caches for database, slowly retrievable disk-based data, data stored remotely behind slow network connections or results of previous calculations."}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Caching first approach"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"benefits-of-caching",children:"Benefits of caching"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Improved responsiveness"}),"\n",(0,r.jsx)(i.li,{children:"Decreased network costs"}),"\n",(0,r.jsx)(i.li,{children:"Improved performance with same hardware"}),"\n",(0,r.jsx)(i.li,{children:"Availability of content with interruption on network or backend resources"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"what-to-cache",children:"WHAT TO CACHE?"}),"\n",(0,r.jsx)(i.p,{children:"A good starting point to find out what to cache in your application is to imagine everything where multiple executions of some request result in the same outcome. This can be database queries, HTML fragments, complete web pages or an output of a heavy computation."}),"\n",(0,r.jsx)(i.p,{children:"It also makes sense to store any kind of language related data geographically local to the content consumer. Common elements of this type of data is translations, user data for people living in a given region. Only one rule applies: data should not change too often or fast but should be read very frequently."}),"\n",(0,r.jsx)(i.h2,{id:"what-not-to-cache",children:"WHAT NOT TO CACHE?"}),"\n",(0,r.jsx)(i.p,{children:"A common misconception is if you cache everything, you'll automatically benefit from it. What often works in the first place delivers another problem during high data peaks.\nData that changes often is generally not very good for caches. Whenever data changes, the cache must be invalidated and, depending on the chosen caching strategy, this can be a costly operation. Imagine a caching system that is located around the world and your data change with a rate of more than 100 changes per second. The benefit of having those data cached will be nullified by the fact that all caches need to invalidate and maybe re-retrieve that changed data record for every single change."}),"\n",(0,r.jsx)(i.p,{children:"Another point to think about is to not cache data that is fast to retrieve anyways. Caching those elements will introduce an additional round-trip while filling the cache, requiring additional memory. The benefit might not show the expected results or be worth the overhead of bringing in another layer into the architecture."}),"\n",(0,r.jsx)(i.h2,{id:"cache-types",children:"Cache Types"}),"\n",(0,r.jsx)(i.h3,{id:"http-cache",children:"HTTP Cache"}),"\n",(0,r.jsx)(i.p,{children:"A HTTP Cache is mostly used in browsers. This kind of cache keeps information about the last modification date of a resource or a content hash to identify changes to its content. Web servers are expected to deliver useful information about the state of an element to prevent retrieval of an already cached element from the server."}),"\n",(0,r.jsx)(i.p,{children:"This kind of cache is used to reduce network traffic, minimize cost and offer the user an instant experience for multiple visits."}),"\n",(0,r.jsx)(i.h3,{id:"fragment-cache",children:"Fragment Cache"}),"\n",(0,r.jsx)(i.p,{children:"A Fragment Cache caches parts of a response or result. This could be a database query outcome or a part of an HTML page. Whatever it is, it should not change often."}),"\n",(0,r.jsxs)(i.p,{children:["A common use case for a Fragment Cache is a web page known to contain user specific and user unspecific content. The user-independent content can be cached as a fragment and augmented with user specific content on retrieval. This process is called ",(0,r.jsx)(i.strong,{children:"Content Enrichment."})]}),"\n",(0,r.jsx)(i.p,{children:"This caching type is used to reduce operation cost and hardware by providing the same throughput with less computational overhead."}),"\n",(0,r.jsx)(i.h3,{id:"object-cache",children:"Object Cache"}),"\n",(0,r.jsx)(i.p,{children:"An Object Cache stores any sort of objects that otherwise need to be read from other data representations. A cache of this type can be used in front of a database to speed up queries and store the resulting objects (e.g. Object Relational Mapping, ORM), or store un-marshalled results of XML, JSON or other general data representations transformed into objects."}),"\n",(0,r.jsx)(i.p,{children:"These caches often act as a proxy between some external resource, like a database or webservice, and they speed up transformation processes or prevent additional network round-trips between the consumer and producer systems."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"cache-access-patterns",children:"Cache Access Patterns"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"caching-strategies-topologies",children:"Caching Strategies / Topologies"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"cache-coherence-invalidation",children:"Cache Coherence / Invalidation"})}),"\n",(0,r.jsx)(i.h3,{id:"bfcache--others",children:(0,r.jsx)(i.a,{href:"/frontend/frontend-intro/others",children:"BFCache | others"})}),"\n",(0,r.jsx)(i.h2,{id:"locality-of-reference--cache-locality--principle-of-locality",children:"Locality of reference / Cache locality / Principle of locality"}),"\n",(0,r.jsx)(i.p,{children:"It is the tendency of a processor to access the same set of memory locations repetitively over a short period of time."}),"\n",(0,r.jsxs)(i.p,{children:["Locality is a type of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Predictability",children:"predictable"})," behavior that occurs in computer systems. Systems that exhibit stronglocality of referenceare great candidates for performance optimization through the use of techniques such as the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/CPU_cache",children:"caching"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Prefetch_instruction",children:"prefetching"})," for memory and advanced ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Branch_predictor",children:"branch predictors"})," at the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Pipeline_(computing)",children:"pipelining"})," stage of a processor core."]}),"\n",(0,r.jsx)(i.h3,{id:"types-of-locality",children:"Types of locality"}),"\n",(0,r.jsx)(i.h4,{id:"temporal-locality",children:"Temporal locality"}),"\n",(0,r.jsx)(i.p,{children:"If at one point a particular memory location is referenced, then it is likely that the same location will be referenced again in the near future. There is a temporal proximity between the adjacent references to the same memory location. In this case it is common to make efforts to store a copy of the referenced data in faster memory storage, to reduce the latency of subsequent references. Temporal locality is a special case of spatial locality (see below), namely when the prospective location is identical to the present location."}),"\n",(0,r.jsx)(i.h4,{id:"spatial-locality",children:"Spatial locality"}),"\n",(0,r.jsx)(i.p,{children:"If a particular storage location is referenced at a particular time, then it is likely that nearby memory locations will be referenced in the near future. In this case it is common to attempt to guess the size and shape of the area around the current reference for which it is worthwhile to prepare faster access for subsequent reference."}),"\n",(0,r.jsx)(i.h4,{id:"memory-locality",children:"Memory locality"}),"\n",(0,r.jsxs)(i.p,{children:["Spatial locality explicitly relating to ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_memory",children:"memory"}),"."]}),"\n",(0,r.jsxs)(i.h4,{id:"branch-locality",children:[(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Branch_(computer_science)",children:"Branch"})," locality"]}),"\n",(0,r.jsx)(i.p,{children:"If there are only a few possible alternatives for the prospective part of the path in the spatial-temporal coordinate space. This is the case when an instruction loop has a simple structure, or the possible outcome of a small system of conditional branching instructions is restricted to a small set of possibilities. Branch locality is typically not a spatial locality since the few possibilities can be located far away from each other."}),"\n",(0,r.jsx)(i.h4,{id:"equidistant-locality",children:"Equidistant locality"}),"\n",(0,r.jsx)(i.p,{children:"It is halfway between the spatial locality and the branch locality. Consider a loop accessing locations in an equidistant pattern, i.e., the path in the spatial-temporal coordinate space is a dotted line. In this case, a simple linear function can predict which location will be accessed in the near future."}),"\n",(0,r.jsxs)(i.p,{children:["In order to benefit from the very frequently occurring temporal and spatial locality, most of the information storage systems are ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computer_data_storage#Hierarchy_of_storage",children:"hierarchical"}),". The equidistant locality is usually supported by the diverse nontrivial increment instructions of the processors. For branch locality, the contemporary processors have sophisticated branch predictors, and on the basis of this prediction the memory manager of the processor tries to collect and preprocess the data of the plausible alternatives."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Locality_of_reference",children:"https://en.wikipedia.org/wiki/Locality_of_reference"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://www.geeksforgeeks.org/locality-of-reference-and-cache-operation-in-cache-memory",children:"https://www.geeksforgeeks.org/locality-of-reference-and-cache-operation-in-cache-memory"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://www.geeksforgeeks.org/computer-organization-locality-and-cache-friendly-code",children:"https://www.geeksforgeeks.org/computer-organization-locality-and-cache-friendly-code"})}),"\n",(0,r.jsx)(i.h2,{id:"cache-oblivious-algorithm",children:"Cache-oblivious algorithm"}),"\n",(0,r.jsxs)(i.p,{children:["In ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Computing",children:"computing"}),", a cache-oblivious algorithm (or cache-transcendent algorithm) is an ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Algorithm",children:"algorithm"})," designed to take advantage of a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/CPU_cache",children:"CPU cache"})," without having the size of the cache (or the length of the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cache_line",children:"cache lines"}),", etc.) as an explicit parameter. An",(0,r.jsx)(i.strong,{children:"optimal cache-oblivious algorithm"}),"is a cache-oblivious algorithm that uses the cache optimally (in an ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Asymptotic_notation",children:"asymptotic"})," sense, ignoring constant factors). Thus, a cache-oblivious algorithm is designed to perform well, without modification, on multiple machines with different cache sizes, or for a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Memory_hierarchy",children:"memory hierarchy"})," with different levels of cache having different sizes. Cache-oblivious algorithms are contrasted with explicit ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Loop_tiling",children:"blocking"}),", as in ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Loop_nest_optimization",children:"loop nest optimization"}),", which explicitly breaks a problem into blocks that are optimally sized for a given cache."]}),"\n",(0,r.jsxs)(i.p,{children:["Optimal cache-oblivious algorithms are known for ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cache-oblivious_matrix_multiplication",children:"matrix multiplication"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Matrix_transposition",children:"matrix transposition"}),", ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Funnelsort",children:"sorting"}),", and several other problems. Some more general algorithms, such as ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm",children:"Cooley--Tukey FFT"}),", are optimally cache-oblivious under certain choices of parameters. Because these algorithms are only optimal in an asymptotic sense (ignoring constant factors), further machine-specific tuning may be required to obtain nearly optimal performance in an absolute sense. The goal of cache-oblivious algorithms is to reduce the amount of such tuning that is required."]}),"\n",(0,r.jsxs)(i.p,{children:["Typically, a cache-oblivious algorithm works by a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Recursion",children:"recursive"}),(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm",children:"divide and conquer algorithm"}),", where the problem is divided into smaller and smaller subproblems. Eventually, one reaches a subproblem size that fits into cache, regardless of the cache size. For example, an optimal cache-oblivious matrix multiplication is obtained by recursively dividing each matrix into four sub-matrices to be multiplied, multiplying the submatrices in a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Depth-first",children:"depth-first"})," fashion. In tuning for a specific machine, one may use a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hybrid_algorithm",children:"hybrid algorithm"})," which uses blocking tuned for the specific cache sizes at the bottom level, but otherwise uses the cache-oblivious algorithm."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cache-oblivious_algorithm",children:"https://en.wikipedia.org/wiki/Cache-oblivious_algorithm"})}),"\n",(0,r.jsx)(i.h2,{id:"http-etag-entity-tag",children:"HTTP ETag (Entity tag)"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.strong,{children:"ETag"})," or ",(0,r.jsx)(i.strong,{children:"entity tag"})," is part of ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol",children:"HTTP"}),", the protocol for the ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/World_Wide_Web",children:"World Wide Web"}),". It is one of several mechanisms that HTTP provides for ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Web_cache",children:"Web cache"})," validation, which allows a client to make conditional requests. This allows caches to be more efficient and saves bandwidth, as a Web server does not need to send a full response if the content has not changed. ETags can also be used for ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Optimistic_concurrency_control",children:"optimistic concurrency control"}),", as a way to help prevent simultaneous updates of a resource from overwriting each other."]}),"\n",(0,r.jsxs)(i.p,{children:["An ETag is an opaque identifier assigned by a Web server to a specific version of a resource found at a ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Uniform_Resource_Locator",children:"URL"}),". If the resource representation at that URL ever changes, a new and different ETag is assigned. Used in this manner, ETags are similar to ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Fingerprint_(computing)",children:"fingerprints"})," and can quickly be compared to determine whether two representations of a resource are the same."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/HTTP_ETag",children:"https://en.wikipedia.org/wiki/HTTP_ETag"})}),"\n",(0,r.jsx)(i.h2,{id:"others",children:"Others"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"set-associative (SA) caches"}),"\n",(0,r.jsx)(i.li,{children:"log-structured (LS) caches"}),"\n",(0,r.jsxs)(i.li,{children:["Kangaroo - ",(0,r.jsx)(i.a,{href:"https://engineering.fb.com/2021/10/26/core-data/kangaroo",children:"https://engineering.fb.com/2021/10/26/core-data/kangaroo"})]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cache_(computing)#WRITE-BACK",children:"https://en.wikipedia.org/wiki/Cache_(computing)"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://www.freecodecamp.org/news/what-is-cached-data",children:"https://www.freecodecamp.org/news/what-is-cached-data"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.a,{href:"https://engineering.fb.com/2021/09/02/open-source/cachelib",children:"https://engineering.fb.com/2021/09/02/open-source/cachelib"})})]})}function d(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>s});var a=t(296540);const r={},n=a.createContext(r);function o(e){const i=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(n.Provider,{value:i},e.children)}}}]);