"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[38564],{637954:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"devops/kubernetes/services-loadbalancing-and-networking/services","title":"Services","description":"A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a microservice.","source":"@site/docs/devops/kubernetes/services-loadbalancing-and-networking/services.md","sourceDirName":"devops/kubernetes/services-loadbalancing-and-networking","slug":"/devops/kubernetes/services-loadbalancing-and-networking/services","permalink":"/devops/kubernetes/services-loadbalancing-and-networking/services","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/kubernetes/services-loadbalancing-and-networking/services.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1717094338000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Others","permalink":"/devops/kubernetes/services-loadbalancing-and-networking/others"},"next":{"title":"Storage","permalink":"/devops/kubernetes/storage"}}');var r=n(474848),i=n(28453);const o={},a="Services",c={},l=[{value:"Headless services",id:"headless-services",level:2},{value:"With selectors",id:"with-selectors",level:2},{value:"Without selectors",id:"without-selectors",level:2},{value:"Anatomy of a Kubernetes Service",id:"anatomy-of-a-kubernetes-service",level:2}];function d(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"services",children:"Services"})}),"\n",(0,r.jsxs)(s.p,{children:["A Kubernetes ",(0,r.jsx)(s.strong,{children:"Service"})," is an abstraction which defines a logical set of ",(0,r.jsx)(s.strong,{children:"Pods"})," and a policy by which to access them - sometimes called a microservice."]}),"\n",(0,r.jsx)(s.p,{children:"Remember that Pods are not durable. When a Pod dies, the ReplicaSet creates a new Pod instance. The new Pod's IP address differs from the old Pod's IP address. Therefore services are used. A service gets its own stable IP address, a stable DNS name and a stable port. Services provide service discovery, load-balancing, and features to support zero-downtime deployments."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"An abstraction to define a logical set of Pods bound by a policy by to access them"}),"\n",(0,r.jsx)(s.li,{children:"Services are exposed through intenal and external endpoints"}),"\n",(0,r.jsx)(s.li,{children:"Services can also point to non-Kubenetes endpoints through a Virtual-IP-Bridge"}),"\n",(0,r.jsx)(s.li,{children:"Supports TCP and UDP"}),"\n",(0,r.jsx)(s.li,{children:"Interfaces with kube-proxy to manipulate iptables"}),"\n",(0,r.jsx)(s.li,{children:"Service can be exposed internal or external to the cluster"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes provides two types of Services."}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.strong,{children:"ClusterIP service"})," gives you a service inside your cluster. Your apps inside your cluster can access that service via a stable IP address, DNS name and port. A ClusterIP service does not provide access from outside the cluster."]}),"\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.strong,{children:"NodePort service"})," provides access to a Pod from outside the cluster. And everything a ClusterIP service provides."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/services-networking/#loadbalancer",children:"LoadBalancer"}),": Exposes the service externally using a cloud provider's load balancer.NodePort and ClusterIP services, to which the external load balancer will route, are automatically created."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:[(0,r.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/services-networking/#externalname",children:"ExternalName"}),":"]})," Maps the service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of kube-dns.","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"An ExternalName Service is a special case of Service that does not have selectors and uses DNS names instead."}),"\n",(0,r.jsxs)(s.li,{children:["When looking up the host my-service.prod.svc.cluster.local, the cluster DNS Service returns a CNAME record with the value my.database.example.com. Accessing my-service works in the same way as other Services but with the crucial difference that redirection happens at the DNS level rather than via proxying or forwarding. Should you later decide to ",(0,r.jsx)(s.strong,{children:"move your database into your cluster"}),", you can start its Pods, add appropriate selectors or endpoints, and change the Service's type."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["For Kubernetes-native applications, Kubernetes offers a simple ",(0,r.jsx)(s.strong,{children:"Endpoints"})," API that is updated whenever the set of ",(0,r.jsx)(s.strong,{children:"Pods"})," in a ",(0,r.jsx)(s.strong,{children:"Service"})," changes. For non-native applications, Kubernetes offers a virtual-IP-based bridge to Services which redirects to the backend ",(0,r.jsx)(s.strong,{children:"Pods"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"headless-services",children:"Headless services"}),"\n",(0,r.jsx)(s.p,{children:'Sometimes you don\'t need or want load-balancing and a single service IP. In this case, you can create "headless" services by specifying"None"for the cluster IP (.spec.clusterIP).'}),"\n",(0,r.jsx)(s.p,{children:"This option allows developers to reduce coupling to the Kubernetes system by allowing them freedom to do discovery their own way. Applications can still use a self-registration pattern and adapters for other discovery systems could easily be built upon this API."}),"\n",(0,r.jsx)(s.p,{children:"For suchServices, a cluster IP is not allocated, kube-proxy does not handle these services, and there is no load balancing or proxying done by the platform for them. How DNS is automatically configured depends on whether the service has selectors defined."}),"\n",(0,r.jsx)(s.h2,{id:"with-selectors",children:"With selectors"}),"\n",(0,r.jsx)(s.p,{children:"For headless services that define selectors, the endpoints controller creates Endpoints records in the API, and modifies the DNS configuration to return A records (addresses) that point directly to the Pods backing the Service."}),"\n",(0,r.jsx)(s.h2,{id:"without-selectors",children:"Without selectors"}),"\n",(0,r.jsx)(s.p,{children:"For headless services that do not define selectors, the endpoints controller does not create Endpoints records. However, the DNS system looks for and configures either:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["CNAME records for ",(0,r.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName"})," - type services."]}),"\n",(0,r.jsx)(s.li,{children:"A records for any Endpoints that share a name with the service, for all other types."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service",children:"https://kubernetes.io/docs/concepts/services-networking/service"})}),"\n",(0,r.jsx)(s.h2,{id:"anatomy-of-a-kubernetes-service",children:"Anatomy of a Kubernetes Service"}),"\n",(0,r.jsx)(s.p,{children:"It's useful to think of a Kubernetes Service as having a front-end and a back-end:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Front-end: name, IP, port that never change"}),"\n",(0,r.jsx)(s.li,{children:"Back-end: Pods that match a label selector"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"The front-end is stable and reliable. This means the name, IP and port number are guaranteed to never change for the entire life of the Service. The stable nature of the Service front-end also means that you do not need to worry about stale entries on clients that cache DNS results for longer than the standards recommend."}),"\n",(0,r.jsx)(s.p,{children:"The back-end is highly dynamic and will load-balance traffic to all Pods in the cluster that match the set of labels the Service is configured to look for."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"image",src:n(736461).A+"",width:"997",height:"200"})}),"\n",(0,r.jsx)(s.p,{children:'Load-balancing in this situation is simple L4 round-robin load-balancing. This works at the "connection" level where all requests over the same connection go to the same Pod. This means two things:'}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Multiple requests from the same browser will always hit the samePod. This is because browsers send all requests over a single connection that is kept open using keep alives. Requests via tools like curl open a new connection for each request and will therefore hit different Pods."}),"\n",(0,r.jsx)(s.li,{children:"Load-balancing is not aware of application layer(L7) concepts such as HTTP headers and cookie-based session affinity."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery",children:"https://nigelpoulton.com/blog/f/demystifying-kubernetes-service-discovery"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},736461:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/DevOps-Kubernetes-Services-image1-a2b47a27f3d6fcac780cd714ab340389.jpg"},28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(296540);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);