"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[81771],{79982:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"ai/computer-vision-cv/image-formats","title":"Image Formats","description":"Exchangeable image file format (EXIF)","source":"@site/docs/ai/computer-vision-cv/image-formats.md","sourceDirName":"ai/computer-vision-cv","slug":"/ai/computer-vision-cv/image-formats","permalink":"/ai/computer-vision-cv/image-formats","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/ai/computer-vision-cv/image-formats.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1707413368000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Image / Data Labeling Tools","permalink":"/ai/computer-vision-cv/image-data-labeling-tools"},"next":{"title":"ImageMagick","permalink":"/ai/computer-vision-cv/imagemagick"}}');var a=s(474848),r=s(28453);const t={},o="Image Formats",l={},c=[{value:"Exchangeable image file format (EXIF)",id:"exchangeable-image-file-format-exif",level:2},{value:"JPG",id:"jpg",level:2},{value:"JPEG-XL",id:"jpeg-xl",level:2},{value:"PNG",id:"png",level:2},{value:"AVIF",id:"avif",level:2},{value:"WebP-v2",id:"webp-v2",level:2},{value:"WebP",id:"webp",level:2},{value:"How WebP Works",id:"how-webp-works",level:3},{value:"Image Recognition",id:"image-recognition",level:2},{value:"Tools",id:"tools",level:2},{value:"pngcheck",id:"pngcheck",level:3},{value:"Image processing",id:"image-processing",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"image-formats",children:"Image Formats"})}),"\n",(0,a.jsx)(i.h2,{id:"exchangeable-image-file-format-exif",children:"Exchangeable image file format (EXIF)"}),"\n",(0,a.jsxs)(i.p,{children:["Exchangeable image file format(officiallyExif, according to JEIDA/JEITA/CIPA specifications) is a standard that specifies the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/File_format",children:"formats"})," for ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Image",children:"images"}),", ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Sound",children:"sound"}),", and ancillary tags used by ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Digital_camera",children:"digital cameras"})," (including ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Smartphone",children:"smartphones"}),"), ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Image_scanner",children:"scanners"})," and other systems handling image and sound files recorded by digital cameras."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Exif",children:"https://en.wikipedia.org/wiki/Exif"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.exifdata.com",children:"https://www.exifdata.com"})}),"\n",(0,a.jsx)(i.h2,{id:"jpg",children:"JPG"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Progressive rendering"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"jpeg-xl",children:"JPEG-XL"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Progressive rendering"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"png",children:"PNG"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Progressive rendering"}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"JPEGcompression"})," reduces the image size by finding areas of a similar color; the higher the compression level, the more aggressively it looks for such areas leading to a loss of visual information and the generation of artefacts at the edges of the compressed areas. This compression is effective for photos, drawings, gradients, most illustrations and other colorful, rich images. JPEG doesn't work as well for screenshots, simple UI elements, flat icons, schematics, and it is especially bad for text."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"PNGcompression"})," works by reducing the number of used colors. Depending on the level of compression this could lead to slight loss of color shades. PNG is great for logos, icons, signs, images containing text, for simple illustrations, UI elements and screenshots. Unlike JPEG, it also allows images to have transparent areas. PNG files are usually larger than JPEGs and don't provide good compression for photos and complex, colorful images and gradients."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"avif",children:"AVIF"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"AV1 Image File Format"}),"\xa0(",(0,a.jsx)(i.strong,{children:"AVIF"}),") is an\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Open_format",title:"Open format",children:"open"}),",\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Royalty-free",title:"Royalty-free",children:"royalty-free"}),"\xa0image file format specification for storing images or image sequences compressed with\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/AV1",title:"AV1",children:"AV1"}),"\xa0in the\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format",title:"High Efficiency Image File Format",children:"HEIF"}),"\xa0container format.\xa0It competes with\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format",title:"High Efficiency Image File Format",children:"HEIC"}),", which uses the same container format built upon\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/ISOBMFF",title:"ISOBMFF",children:"ISOBMFF"}),", but\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/HEVC",title:"HEVC",children:"HEVC"}),"\xa0for compression. Version 1.0.0 of the AVIF specification was finalized in February 2019."]}),"\n",(0,a.jsxs)(i.p,{children:["In a number of tests by\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Netflix",title:"Netflix",children:"Netflix"}),"\xa0in 2020, AVIF showed better compression efficiency than\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/JPEG",title:"JPEG",children:"JPEG"}),"\xa0as well as better detail preservation, fewer blocking artifacts and less\xa0",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Color_bleeding_(printing)",title:"Color bleeding (printing)",children:"color bleeding"}),"\xa0around hard edges in composites of natural images, text, and graphics."]}),"\n",(0,a.jsxs)(i.p,{children:["AV1 Image File Format (AVIF) is an encoding based on the open source AV1 video codec. AVIF is\xa0",(0,a.jsx)(i.a,{href:"https://caniuse.com/avif",children:"even newer"}),"-than WebP, only supported in Chrome and Opera since 2020, Firefox in 2021, and Safari in 2022. As with WebP, AVIF aims to address every conceivable use case for raster images on the web: GIF-like animation, PNG-like transparency, and improved perceptual quality at file sizes smaller than JPEG or WebP."]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"No progressive rendering"}),"\n",(0,a.jsx)(i.li,{children:"AVIF + Blur is good"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/AVIF",children:"AVIF - Wikipedia"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://web.dev/learn/images/avif",children:"Image formats: AVIF \xa0|\xa0 web.dev"})}),"\n",(0,a.jsx)(i.h2,{id:"webp-v2",children:"WebP-v2"}),"\n",(0,a.jsx)(i.h2,{id:"webp",children:"WebP"}),"\n",(0,a.jsx)(i.p,{children:"WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster."}),"\n",(0,a.jsxs)(i.p,{children:["WebP lossless images are ",(0,a.jsx)(i.a,{href:"https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study#results",children:"26% smaller"})," in size compared to PNGs. WebP lossy images are ",(0,a.jsx)(i.a,{href:"https://developers.google.com/speed/webp/docs/webp_study",children:"25-34% smaller"})," than comparable JPEG images at equivalent ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Structural_similarity",children:"SSIM"})," quality index."]}),"\n",(0,a.jsxs)(i.p,{children:["Lossless WebP supports transparency(also known as alpha channel) at a cost of just ",(0,a.jsx)(i.a,{href:"https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study#results",children:"22% additional bytes"}),". For cases when lossy RGB compression is acceptable, lossy WebP also supports transparency, typically providing 3\xd7 smaller file sizes compared to PNG."]}),"\n",(0,a.jsx)(i.h3,{id:"how-webp-works",children:"How WebP Works"}),"\n",(0,a.jsx)(i.p,{children:"Lossy WebP compression uses predictive coding to encode an image, the same method used by the VP8 video codec to compress keyframes in videos. Predictive coding uses the values in neighboring blocks of pixels to predict the values in a block, and then encodes only the difference."}),"\n",(0,a.jsx)(i.p,{children:"Lossless WebP compression uses already seen image fragments in order to exactly reconstruct new pixels. It can also use a local palette if no interesting match is found."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"brew install webp"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://developers.google.com/speed/webp",children:"https://developers.google.com/speed/webp"})}),"\n",(0,a.jsx)(i.h2,{id:"image-recognition",children:"Image Recognition"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Categorization"}),"\n",(0,a.jsx)(i.li,{children:"Segmentation Problems"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"tools",children:"Tools"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"http://www.libpng.org/pub/png/apps/pngcheck.html",children:"http://www.libpng.org/pub/png/apps/pngcheck.html"})}),"\n",(0,a.jsx)(i.h3,{id:"pngcheck",children:"pngcheck"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.code,{children:"pngcheck"})," verifies the integrity of PNG, JNG and MNG files (by checking the internal 32-bit CRCs, a.k.a. checksums, and decompressing the image data); it can optionally dump almost all of the chunk-level information in the image in human-readable form. For example, it can be used to print the basic statistics about an image (dimensions, bit depth, etc.); to list the color and transparency info in its palette (assuming it has one); or to extract the embedded text annotations. This is a command-line program with batch capabilities"]}),"\n",(0,a.jsx)(i.h2,{id:"image-processing",children:"Image processing"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://sharp.pixelplumbing.com/",children:"sharp - High performance Node.js image processing"})}),"\n",(0,a.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.youtube.com/watch?v=-7k3H2GxE5E",children:"Progressively loading images - HTTP 203 - YouTube"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.youtube.com/watch?v=B7Dopv6kzJA",children:"How does a camera work? - YouTube"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://www.youtube.com/watch?v=Kv1Hiv3ox8I",children:"How are Images Compressed? [46MB \u2198\u2198 4.07MB] JPEG In Depth - YouTube"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://blog.imagekit.io/jpeg-vs-png-vs-gif-which-image-format-to-use-and-when-c8913ae3e01d",children:"JPEG vs PNG vs GIF - which image format to use and when? | by Rahul Nanwani | Blog | ImageKit.io"})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,i,s)=>{s.d(i,{R:()=>t,x:()=>o});var n=s(296540);const a={},r=n.createContext(a);function t(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);