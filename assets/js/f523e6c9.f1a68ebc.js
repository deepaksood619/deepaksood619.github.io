"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[11892],{227829:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"data-warehouses/databricks/20-delta-live-tables","title":"Delta Live Tables","description":"Delta Live Tables is a declarative framework for building reliable, maintainable, and testable data processing pipelines. You define the transformations to perform on your data and Delta Live Tables manages task orchestration, cluster management, monitoring, data quality, and error handling.","source":"@site/docs/data-warehouses/databricks/20-delta-live-tables.md","sourceDirName":"data-warehouses/databricks","slug":"/data-warehouses/databricks/20-delta-live-tables","permalink":"/data-warehouses/databricks/20-delta-live-tables","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-warehouses/databricks/20-delta-live-tables.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749575438000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Medallion Architecture","permalink":"/data-warehouses/databricks/10-medallion-architecture"},"next":{"title":"Unity Catalog","permalink":"/data-warehouses/databricks/30-unity-catalog"}}');var s=t(474848),n=t(28453);const r={},l="Delta Live Tables",d={},o=[{value:"What are Delta Live Tables datasets?",id:"what-are-delta-live-tables-datasets",level:2},{value:"Streaming table",id:"streaming-table",level:3},{value:"Materialized view",id:"materialized-view",level:3},{value:"Views",id:"views",level:3},{value:"What is a Delta Live Tables pipeline?",id:"what-is-a-delta-live-tables-pipeline",level:2},{value:"When to use views, materialized views, and streaming tables",id:"when-to-use-views-materialized-views-and-streaming-tables",level:2},{value:"Consider using a view when",id:"consider-using-a-view-when",level:4},{value:"Consider using a materialized view when",id:"consider-using-a-materialized-view-when",level:4},{value:"Consider using a streaming table when",id:"consider-using-a-streaming-table-when",level:4},{value:"Some general rules",id:"some-general-rules",level:4}];function c(e){const a={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"delta-live-tables",children:"Delta Live Tables"})}),"\n",(0,s.jsx)(a.p,{children:"Delta Live Tables is a declarative framework for building reliable, maintainable, and testable data processing pipelines. You define the transformations to perform on your data and Delta Live Tables manages task orchestration, cluster management, monitoring, data quality, and error handling."}),"\n",(0,s.jsxs)(a.p,{children:["Instead of defining your data pipelines using a series of separate Apache Spark tasks, you define streaming tables and materialized views that the system should create and keep up to date. Delta Live Tables manages how your data is transformed based on queries you define for each processing step. You can also enforce data quality with Delta Live Tables ",(0,s.jsx)(a.em,{children:"expectations"}),", which allow you to define expected data quality and specify how to handle records that fail those expectations."]}),"\n",(0,s.jsx)(a.h2,{id:"what-are-delta-live-tables-datasets",children:"What are Delta Live Tables datasets?"}),"\n",(0,s.jsx)(a.p,{children:"Delta Live Tables datasets are the streaming tables, materialized views, and views maintained as the results of declarative queries. The following table describes how each dataset is processed:"}),"\n",(0,s.jsxs)(a.table,{children:[(0,s.jsx)(a.thead,{children:(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.th,{children:"Dataset type"}),(0,s.jsx)(a.th,{children:"How are records processed through defined queries?"})]})}),(0,s.jsxs)(a.tbody,{children:[(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"Streaming table"}),(0,s.jsx)(a.td,{children:"Each record is processed exactly once. This assumes an append-only source."})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"Materialized views"}),(0,s.jsx)(a.td,{children:"Records are processed as required to return accurate results for the current data state. Materialized views should be used for data sources with updates, deletions, or aggregations, and for change data capture processing (CDC)."})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"Views"}),(0,s.jsx)(a.td,{children:"Records are processed each time the view is queried. Use views for intermediate transformations and data quality checks that should not be published to public datasets."})]})]})]}),"\n",(0,s.jsx)(a.h3,{id:"streaming-table",children:"Streaming table"}),"\n",(0,s.jsxs)(a.p,{children:["A ",(0,s.jsx)(a.em,{children:"streaming table"})," is a Delta table with extra support for streaming or incremental data processing. Streaming tables allow you to process a growing dataset, handling each row only once. Because most datasets grow continuously over time, streaming tables are good for most ingestion workloads. Streaming tables are optimal for pipelines that require data freshness and low latency. Streaming tables can also be useful for massive scale transformations, as results can be incrementally calculated as new data arrives, keeping results up to date without needing to fully recompute all source data with each update. Streaming tables are designed for data sources that are append-only."]}),"\n",(0,s.jsx)(a.h3,{id:"materialized-view",children:"Materialized view"}),"\n",(0,s.jsxs)(a.p,{children:["A ",(0,s.jsx)(a.em,{children:"materialized view"})," (or ",(0,s.jsx)(a.em,{children:"live table"}),") is a view where the results have been precomputed. Materialized views are refreshed according to the update schedule of the pipeline in which they\u2019re contained. Materialized views are powerful because they can handle any changes in the input. Each time the pipeline updates, query results are recalculated to reflect changes in upstream datasets that might have occurred because of compliance, corrections, aggregations, or general CDC. Delta Live Tables implements materialized views as Delta tables, but abstracts away complexities associated with efficient application of updates, allowing users to focus on writing queries."]}),"\n",(0,s.jsx)(a.h3,{id:"views",children:"Views"}),"\n",(0,s.jsxs)(a.p,{children:["All ",(0,s.jsx)(a.em,{children:"views"})," in Databricks compute results from source datasets as they are queried, leveraging caching optimizations when available. Delta Live Tables does not publish views to the catalog, so views can be referenced only within the pipeline in which they are defined. Views are useful as intermediate queries that should not be exposed to end users or systems. Databricks recommends using views to enforce data quality constraints or transform and enrich datasets that drive multiple downstream queries."]}),"\n",(0,s.jsx)(a.h2,{id:"what-is-a-delta-live-tables-pipeline",children:"What is a Delta Live Tables pipeline?"}),"\n",(0,s.jsxs)(a.p,{children:["A ",(0,s.jsx)(a.em,{children:"pipeline"})," is the main unit used to configure and run data processing workflows with Delta Live Tables."]}),"\n",(0,s.jsx)(a.p,{children:"A pipeline contains materialized views and streaming tables declared in Python or SQL source files. Delta Live Tables infers the dependencies between these tables, ensuring updates occur in the right order. For each dataset, Delta Live Tables compares the current state with the desired state and proceeds to create or update datasets using efficient processing methods."}),"\n",(0,s.jsx)(a.h2,{id:"when-to-use-views-materialized-views-and-streaming-tables",children:"When to use views, materialized views, and streaming tables"}),"\n",(0,s.jsx)(a.p,{children:"To ensure your pipelines are efficient and maintainable, choose the best dataset type when you implement your pipeline queries."}),"\n",(0,s.jsx)(a.h4,{id:"consider-using-a-view-when",children:"Consider using a view when"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"You have a large or complex query that you want to break into easier-to-manage queries."}),"\n",(0,s.jsx)(a.li,{children:"You want to validate intermediate results using expectations."}),"\n",(0,s.jsx)(a.li,{children:"You want to reduce storage and compute costs and do not require the materialization of query results. Because tables are materialized, they require additional computation and storage resources."}),"\n"]}),"\n",(0,s.jsx)(a.h4,{id:"consider-using-a-materialized-view-when",children:"Consider using a materialized view when"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Multiple downstream queries consume the table. Because views are computed on demand, the view is re-computed every time the view is queried."}),"\n",(0,s.jsx)(a.li,{children:"The table is consumed by other pipelines, jobs, or queries. Because views are not materialized, you can only use them in the same pipeline."}),"\n",(0,s.jsx)(a.li,{children:"You want to view the results of a query during development. Because tables are materialized and can be viewed and queried outside of the pipeline, using tables during development can help validate the correctness of computations. After validating, convert queries that do not require materialization into views."}),"\n"]}),"\n",(0,s.jsx)(a.h4,{id:"consider-using-a-streaming-table-when",children:"Consider using a streaming table when"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"A query is defined against a data source that is continuously or incrementally growing."}),"\n",(0,s.jsx)(a.li,{children:"Query results should be computed incrementally."}),"\n",(0,s.jsx)(a.li,{children:"High throughput and low latency is desired for the pipeline."}),"\n"]}),"\n",(0,s.jsx)(a.h4,{id:"some-general-rules",children:"Some general rules"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"The less frequently your underlying data sources update (i.e. your data freshness requirement is constrained upstream), the more rationale there is to convert expensive joins and queries into materialized views."}),"\n",(0,s.jsx)(a.li,{children:"Similarly, the less actual data that comes in as part of changes, the more rationale there is to use materialized views and DLT because those incremental data points can be (sanely!) maintained."}),"\n",(0,s.jsx)(a.li,{children:'And again, if it\'s okay for your data to be "directionally correct" or have some imprecision, then again the performance benefits of a materialized view are greater.'}),"\n",(0,s.jsx)(a.li,{children:"And finally, if a particular set of query patterns dominate your overall usage (think 80/20 rule), there's more rationale to provide materialized views of those results to users."}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.a,{href:"https://community.databricks.com/s/question/0D53f00001GHVMlCAP/views-vs-materialized-delta-tables",children:"Views vs Materialized Delta Tables"})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.a,{href:"https://www.databricks.com/discover/pages/getting-started-with-delta-live-tables",children:"Getting Started with Delta Live Tables - Databricks"})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.a,{href:"https://docs.databricks.com/delta-live-tables/index.html",children:"What is Delta Live Tables? | Databricks on AWS"})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.a,{href:"https://docs.databricks.com/delta-live-tables/sql-ref.html",children:"Delta Live Tables SQL language reference | Databricks on AWS"})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.a,{href:"https://docs.databricks.com/delta-live-tables/tutorial-pipelines.html",children:"Tutorial: Run your first Delta Live Tables pipeline | Databricks on AWS"})})]})}function h(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>r,x:()=>l});var i=t(296540);const s={},n=i.createContext(s);function r(e){const a=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(n.Provider,{value:a},e.children)}}}]);