"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[77927],{55009:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var i=n(785893),a=n(511151);const s={},r="A* Search Algorithm",o={id:"algorithms/advanced-algorithms/a-search-algorithm",title:"A* Search Algorithm",description:"The process of plotting an efficiently directed path between multiple points, called nodes.",source:"@site/docs/algorithms/advanced-algorithms/a-search-algorithm.md",sourceDirName:"algorithms/advanced-algorithms",slug:"/algorithms/advanced-algorithms/a-search-algorithm",permalink:"/algorithms/advanced-algorithms/a-search-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/advanced-algorithms/a-search-algorithm.md",tags:[],version:"current",lastUpdatedAt:1707138374,formattedLastUpdatedAt:"Feb 5, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Advanced Algorithms",permalink:"/algorithms/advanced-algorithms/"},next:{title:"Automated Planning and Scheduling",permalink:"/algorithms/advanced-algorithms/automated-planning-and-scheduling"}},l={},h=[{value:"Used in",id:"used-in",level:2},{value:"Application",id:"application",level:2},{value:"Optimizations",id:"optimizations",level:3},{value:"Heuristic Search",id:"heuristic-search",level:2},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"a-search-algorithm",children:"A* Search Algorithm"}),"\n",(0,i.jsx)(t.p,{children:"The process of plotting an efficiently directed path between multiple points, called nodes."}),"\n",(0,i.jsx)(t.h2,{id:"used-in",children:"Used in"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.strong,{children:"Path Finding"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.strong,{children:"Graph Traversals"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"application",children:"Application"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.strong,{children:"8 puzzle problem"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"There are lots of algorithms that run on graphs. (Path Finding Algorithms)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Breadth First Search"})," explores equally in all directions. This is an incredibly useful algorithm, not only for regular path finding, but also for procedural map generation, flow field pathfinding, distance maps, and other types of map analysis."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dijkstra's Algorithm"})," (also called Uniform Cost Search) lets us prioritize which paths to explore. Instead of exploring all possible paths equally, it favors lower cost paths. We can assign lower costs to encourage moving on roads, higher costs to avoid forests, higher costs to discourage going near enemies, and more. When movement costs vary, we use this instead of Breadth First Search."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"A"}),(0,i.jsx)(t.em,{children:"is a modification of Dijkstra's Algorithm that is optimized for a single destination. Dijkstra's Algorithm can find paths to all locations; A"})," finds paths to one location. It prioritizes paths that seem to be leading closer to the goal."]}),"\n",(0,i.jsx)(t.h3,{id:"optimizations",children:"Optimizations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Early Exit"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"heuristic-search",children:"Heuristic Search"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Hamming priority function."})," The number of blocks in the wrong position, plus the number of moves made so far to get to the search node. Intuitively, a search node with a small number of blocks in the wrong position is close to the goal, and we prefer a search node that have been reached using a small number of moves."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Manhattan priority function."})," The sum of the Manhattan distances (sum of the vertical and horizontal distance) from the blocks to their goal positions, plus the number of moves made so far to get to the search node."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The standard heuristic for a square grid is the ",(0,i.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Taxicab_geometry",children:"Manhattan distance"}),". Look at your cost function and find the minimum cost D for moving from one space to an adjacent space. ",(0,i.jsx)(t.em,{children:"In the simple case, you can set D to be 1."})," The heuristic on a square grid where you can move in 4 directions should be D times the Manhattan distance:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function heuristic(node) =\ndx = abs(node.x - goal.x)\ndy = abs(node.y - goal.y)\nreturn D * (dx + dy)\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Diagonal Distance"}),"\n",(0,i.jsx)(t.li,{children:"Euclidean Distance"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/A*_search_algorithm",children:"https://en.wikipedia.org/wiki/A*_search_algorithm"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html",children:"http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.redblobgames.com/pathfinding/a-star/introduction.html",children:"https://www.redblobgames.com/pathfinding/a-star/introduction.html"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.redblobgames.com/pathfinding/a-star/implementation.html",children:"https://www.redblobgames.com/pathfinding/a-star/implementation.html"})})]})}function c(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},511151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var i=n(667294);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);