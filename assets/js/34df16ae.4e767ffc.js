"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[12923],{29727:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"databases-nosql/redis/redis-eviction-policies","title":"Redis Eviction Policies","description":"Cache Eviction Policies","source":"@site/docs/databases-nosql/redis/redis-eviction-policies.md","sourceDirName":"databases-nosql/redis","slug":"/databases-nosql/redis/redis-eviction-policies","permalink":"/databases-nosql/redis/redis-eviction-policies","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/redis/redis-eviction-policies.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749576162000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Redis Data Types","permalink":"/databases-nosql/redis/redis-data-types"},"next":{"title":"redis-py","permalink":"/databases-nosql/redis/redis-py"}}');var n=i(474848),a=i(28453);const o={},r="Redis Eviction Policies",c={},l=[{value:"How the eviction process works",id:"how-the-eviction-process-works",level:2},{value:"Approximated LRU algorithm",id:"approximated-lru-algorithm",level:2},{value:"LFU Mode (Least Frequently Used)",id:"lfu-mode-least-frequently-used",level:2},{value:"Important Points",id:"important-points",level:2},{value:"1. Cache density is more impactful than eviction policy",id:"1-cache-density-is-more-impactful-than-eviction-policy",level:3},{value:"2. Object sizes change in the course of time",id:"2-object-sizes-change-in-the-course-of-time",level:3},{value:"3. Object TTL (TIME TO LIVE) can be more important than its eviction policy",id:"3-object-ttl-time-to-live-can-be-more-important-than-its-eviction-policy",level:3},{value:"4. Not all workloads are read-heavy",id:"4-not-all-workloads-are-read-heavy",level:3},{value:"Top 8 Cache Eviction Strategies",id:"top-8-cache-eviction-strategies",level:2},{value:"LRU (Least Recently Used)",id:"lru-least-recently-used",level:3},{value:"MRU (Most Recently Used)",id:"mru-most-recently-used",level:3},{value:"SLRU (Segmented LRU)",id:"slru-segmented-lru",level:3},{value:"LFU (Least Frequently Used)",id:"lfu-least-frequently-used",level:3},{value:"FIFO (First In First Out)",id:"fifo-first-in-first-out",level:3},{value:"TTL (Time-to-Live)",id:"ttl-time-to-live",level:3},{value:"Two-Tiered Caching",id:"two-tiered-caching",level:3},{value:"RR (Random Replacement)",id:"rr-random-replacement",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"redis-eviction-policies",children:"Redis Eviction Policies"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Cache Eviction Policies"})}),"\n",(0,n.jsx)(t.p,{children:"The exact behavior Redis follows when the maxmemory limit is reached is configured using the maxmemory-policy configuration directive."}),"\n",(0,n.jsx)(t.p,{children:"The following policies are available:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"noeviction:"})," return errors when the memory limit was reached and the client is trying to execute commands that could result in more memory to be used (most write commands, but ",(0,n.jsx)(t.a,{href:"https://redis.io/commands/del",children:"DEL"})," and a few more exceptions)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"allkeys-lru:"})," evict keys by trying to remove the less recently used (LRU) keys first, in order to make space for the new data added."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"volatile-lru:"})," evict keys by trying to remove the less recently used (LRU) keys first, but only among keys that have anexpire set, in order to make space for the new data added."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"allkeys-random:"})," evict keys randomly in order to make space for the new data added."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"volatile-random:"})," evict keys randomly in order to make space for the new data added, but only evict keys with anexpire set."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"volatile-ttl:"})," evict keys with anexpire set, and try to evict keys with a shorter time to live (TTL) first, in order to make space for the new data added."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The policies ",(0,n.jsx)(t.strong,{children:"volatile-lru, volatile-random"})," and ",(0,n.jsx)(t.strong,{children:"volatile-ttl"})," behave like ",(0,n.jsx)(t.strong,{children:"noeviction"})," if there are no keys to evict matching the prerequisites."]}),"\n",(0,n.jsxs)(t.p,{children:["Picking the right eviction policy is important depending on the access pattern of your application, however you can reconfigure the policy at runtime while the application is running, and monitor the number of cache misses and hits using the Redis ",(0,n.jsx)(t.a,{href:"https://redis.io/commands/info",children:"INFO"})," output in order to tune your setup."]}),"\n",(0,n.jsx)(t.p,{children:"In general as a rule of thumb:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Use the ",(0,n.jsx)(t.strong,{children:"allkeys-lru"})," policy when you expect a power-law distribution in the popularity of your requests, that is, you expect that a subset of elements will be accessed far more often than the rest. ",(0,n.jsx)(t.strong,{children:"This is a good pick if you are unsure."})]}),"\n",(0,n.jsxs)(t.li,{children:["Use the ",(0,n.jsx)(t.strong,{children:"allkeys-random"})," if you have a cyclic access where all the keys are scanned continuously, or when you expect the distribution to be uniform (all elements likely accessed with the same probability)."]}),"\n",(0,n.jsxs)(t.li,{children:["Use the ",(0,n.jsx)(t.strong,{children:"volatile-ttl"})," if you want to be able to provide hints to Redis about what are good candidate for expiration by using different TTL values when you create your cache objects."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.strong,{children:"volatile-lru and volatile-random"})," policies are mainly useful when you want to use a single instance for both caching and to have a set of persistent keys. However it is usually a better idea to run two Redis instances to solve such a problem."]}),"\n",(0,n.jsxs)(t.p,{children:["It is also worth noting that setting an expire to a key costs memory, so using a policy like ",(0,n.jsx)(t.strong,{children:"allkeys-lru"})," is more memory efficient since there is no need to set an expire for the key to be evicted under memory pressure."]}),"\n",(0,n.jsx)(t.h2,{id:"how-the-eviction-process-works",children:"How the eviction process works"}),"\n",(0,n.jsx)(t.p,{children:"It is important to understand that the eviction process works like this:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"A client runs a new command, resulting in more data added."}),"\n",(0,n.jsx)(t.li,{children:"Redis checks the memory usage, and if it is greater than themaxmemorylimit , it evicts keys according to the policy."}),"\n",(0,n.jsx)(t.li,{children:"A new command is executed, and so forth."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"So we continuously cross the boundaries of the memory limit, by going over it, and then by evicting keys to return back under the limits.\nIf a command results in a lot of memory being used (like a big set intersection stored into a new key) for some time the memory limit can be surpassed by a noticeable amount."}),"\n",(0,n.jsx)(t.h2,{id:"approximated-lru-algorithm",children:"Approximated LRU algorithm"}),"\n",(0,n.jsx)(t.p,{children:"Redis LRU algorithm is not an exact implementation. This means that Redis is not able to pick thebest candidatefor eviction, that is, the access that was accessed the most in the past. Instead it will try to run an approximation of the LRU algorithm, by sampling a small number of keys, and evicting the one that is the best (with the oldest access time) among the sampled keys."}),"\n",(0,n.jsx)(t.p,{children:"However since Redis 3.0 the algorithm was improved to also take a pool of good candidates for eviction. This improved the performance of the algorithm, making it able to approximate more closely the behavior of a real LRU algorithm."}),"\n",(0,n.jsx)(t.p,{children:"What is important about the Redis LRU algorithm is that youare able to tunethe precision of the algorithm by changing the number of samples to check for every eviction. This parameter is controlled by the following configuration directive:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"maxmemory-samples 5"})}),"\n",(0,n.jsx)(t.h2,{id:"lfu-mode-least-frequently-used",children:"LFU Mode (Least Frequently Used)"}),"\n",(0,n.jsx)(t.p,{children:"If you think at LRU, an item that was recently accessed but is actually almost never requested, will not get expired, so the risk is to evict a key that has an higher chance to be requested in the future. LFU does not have this problem, and in general should adapt better to different access patterns."}),"\n",(0,n.jsx)(t.p,{children:"To configure the LFU mode, the following policies are available:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"volatile-lfu"})," Evict using approximated LFU among the keys with an expire set."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"allkeys-lfu"})," Evict any key using approximated LFU."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["LFU is approximated like LRU: it uses a probabilistic counter, called a ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Approximate_counting_algorithm",children:"Morris counter"})," in order to estimate the object access frequency using just a few bits per object, combined with a decay period so that the counter is reduced over time: at some point we no longer want to consider keys as frequently accessed, even if they were in the past, so that the algorithm can adapt to a shift in the access pattern."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://redis.io/topics/lru-cache",children:"https://redis.io/topics/lru-cache"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://tokers.github.io/posts/lru-and-lfu-in-redis-memory-eviction",children:"https://tokers.github.io/posts/lru-and-lfu-in-redis-memory-eviction"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"cache-problems",src:i(158297).A+"",width:"1000",height:"1300"})}),"\n",(0,n.jsx)(t.h2,{id:"important-points",children:"Important Points"}),"\n",(0,n.jsx)(t.h3,{id:"1-cache-density-is-more-impactful-than-eviction-policy",children:"1. Cache density is more impactful than eviction policy"}),"\n",(0,n.jsx)(t.p,{children:"That means data compression and reducing cache metadata is more important than the choice made between LRU and FIFO algorithms."}),"\n",(0,n.jsx)(t.p,{children:"The more objects you can stuff in a cache, the more performant it is."}),"\n",(0,n.jsx)(t.h3,{id:"2-object-sizes-change-in-the-course-of-time",children:"2. Object sizes change in the course of time"}),"\n",(0,n.jsx)(t.p,{children:"This significantly impacts cache performance, since memory either fragments or calcifies (new objects can't be added because other size slabs have taken up space)."}),"\n",(0,n.jsx)(t.p,{children:"There are no efficient proven algorithms to deal with this problem!"}),"\n",(0,n.jsx)(t.h3,{id:"3-object-ttl-time-to-live-can-be-more-important-than-its-eviction-policy",children:"3. Object TTL (TIME TO LIVE) can be more important than its eviction policy"}),"\n",(0,n.jsx)(t.p,{children:"Despite it's importance, there are no good proven algorithms for evicting expired objects."}),"\n",(0,n.jsx)(t.p,{children:"A full scan is inefficient, and algorithms like the timer wheel (explained at InterviewReady) don't work on all objects."}),"\n",(0,n.jsx)(t.p,{children:"Again, we notice that some principles of Java's garbage collection can be applied here (especially the generational hypothesis). Do check out the videos mentioned above."}),"\n",(0,n.jsx)(t.h3,{id:"4-not-all-workloads-are-read-heavy",children:"4. Not all workloads are read-heavy"}),"\n",(0,n.jsx)(t.p,{children:"Facebook has very read heavy workloads, and Memcached is accordingly optimised for reads."}),"\n",(0,n.jsx)(t.p,{children:"Twemcache has some write heavy workloads too (about 35-40% of the queries result in write operations)."}),"\n",(0,n.jsx)(t.p,{children:"The result is a break of many expectations, like behavior changes in TTL of objects and the number of times these objects are accessed."}),"\n",(0,n.jsx)(t.p,{children:"Understandably, with these expectations breaking, cache performance of write heavy clusters isn't great."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Using production log traces from Twitter to evaluate different caching strategies."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"top-8-cache-eviction-strategies",children:"Top 8 Cache Eviction Strategies"}),"\n",(0,n.jsx)(t.h3,{id:"lru-least-recently-used",children:"LRU (Least Recently Used)"}),"\n",(0,n.jsx)(t.p,{children:"LRU eviction strategy removes the least recently accessed items first. This approach is based on the principle that items accessed recently are more likely to be accessed again in the near future."}),"\n",(0,n.jsx)(t.h3,{id:"mru-most-recently-used",children:"MRU (Most Recently Used)"}),"\n",(0,n.jsx)(t.p,{children:"Contrary to LRU, the MRU algorithm removes the most recently used items first. This strategy can be useful in scenarios where the most recently accessed items are less likely to be accessed again soon."}),"\n",(0,n.jsx)(t.h3,{id:"slru-segmented-lru",children:"SLRU (Segmented LRU)"}),"\n",(0,n.jsx)(t.p,{children:"SLRU divides the cache into two segments: a probationary segment and a protected segment. New items are initially placed into the probationary segment. If an item in the probationary segment is accessed again, it is promoted to the protected segment."}),"\n",(0,n.jsx)(t.h3,{id:"lfu-least-frequently-used",children:"LFU (Least Frequently Used)"}),"\n",(0,n.jsx)(t.p,{children:"LFU algorithm evicts the items with the lowest access frequency."}),"\n",(0,n.jsx)(t.h3,{id:"fifo-first-in-first-out",children:"FIFO (First In First Out)"}),"\n",(0,n.jsx)(t.p,{children:"FIFO is one of the simplest caching strategies, where the cache behaves in a queue-like manner, evicting the oldest items first, regardless of their access patterns or frequency."}),"\n",(0,n.jsx)(t.h3,{id:"ttl-time-to-live",children:"TTL (Time-to-Live)"}),"\n",(0,n.jsx)(t.p,{children:"While not strictly an eviction algorithm, TTL is a strategy where each cache item is given a specific lifespan."}),"\n",(0,n.jsx)(t.h3,{id:"two-tiered-caching",children:"Two-Tiered Caching"}),"\n",(0,n.jsx)(t.p,{children:"In Two-Tiered Caching strategy, we use an in-memory cache for the first layer and a distributed cache for the second layer."}),"\n",(0,n.jsx)(t.h3,{id:"rr-random-replacement",children:"RR (Random Replacement)"}),"\n",(0,n.jsx)(t.p,{children:"Random Replacement algorithm randomly selects a cache item and evicts it to make space for new items. This method is also simple to implement and does not require tracking access patterns or frequencies."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Top 8 Cache Eviction Strategies",src:i(488708).A+"",width:"1000",height:"1300"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},158297:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Pasted image 20240105232856-aeefe2016c894fb958800587ed7d6089.jpg"},488708:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Pasted image 20240429231428-b6b222bffc4bae2bed5cf193075c7a1b.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var s=i(296540);const n={},a=s.createContext(n);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);