"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[43541],{970073:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"computer-science/system-design/microservice-architecture/example","title":"Example","description":"https://thenewstack.io/how-redis-simplifies-microservices-design-patterns","source":"@site/docs/computer-science/system-design/microservice-architecture/example.md","sourceDirName":"computer-science/system-design/microservice-architecture","slug":"/computer-science/system-design/microservice-architecture/example","permalink":"/computer-science/system-design/microservice-architecture/example","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/system-design/microservice-architecture/example.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1726859634000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Domain Driven Design","permalink":"/computer-science/system-design/microservice-architecture/domain-driven-design"},"next":{"title":"Microservice Architecture","permalink":"/computer-science/system-design/microservice-architecture/intro"}}');var a=i(474848),n=i(28453);const r={},o="Example",c={},d=[{value:"Financial System",id:"financial-system",level:2},{value:"Design Pattern: Bounded Context -&gt; Domain-Driven Design",id:"design-pattern-bounded-context---domain-driven-design",level:2},{value:"Design Pattern: Asynchronous Messaging -&gt; Interservice Communication",id:"design-pattern-asynchronous-messaging---interservice-communication",level:2},{value:"Design Pattern: Choreography-Based Saga -&gt; Distributed Transactions",id:"design-pattern-choreography-based-saga---distributed-transactions",level:2},{value:"Design Pattern: Transactional Outbox and Message Relay -&gt; Consistency",id:"design-pattern-transactional-outbox-and-message-relay---consistency",level:2},{value:"Design Pattern: Command Query Responsibility Segregation (CQRS) -&gt; Performance",id:"design-pattern-command-query-responsibility-segregation-cqrs---performance",level:2},{value:"Design Pattern: Shared Data -&gt; Reusability",id:"design-pattern-shared-data---reusability",level:2}];function h(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"example",children:"Example"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://thenewstack.io/how-redis-simplifies-microservices-design-patterns",children:"https://thenewstack.io/how-redis-simplifies-microservices-design-patterns"})}),"\n",(0,a.jsx)(t.h2,{id:"financial-system",children:"Financial System"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(85182).A+"",width:"955",height:"468"})}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-bounded-context---domain-driven-design",children:"Design Pattern: Bounded Context -> Domain-Driven Design"}),"\n",(0,a.jsx)(t.p,{children:"Our first challenge is to logically segment the business into micro-subdomains, so that each can be supported by a small empowered autonomous team. Each subdomain's scope should be bound by its team's capacity to manage the lifecycle of its supporting microservice(s) - from inception to post-production. This shift from working on transient-projects to autonomous domain-ownership incentivizes accountability for all aspects of microservice design and empowers agile decision-making - which results in improved time-to-market."}),"\n",(0,a.jsx)(t.p,{children:"Think of the prefix \"micro\" alluding to the size of the team needed to support the entire lifecycle of the microservice(s) within its bounded business subdomain.\nWithin the context of our mockup architecture, let's begin the organizational design process by starting with the payment-processing domain - which includes fraud detection, payments, settlement, and more. Since this scope is likely too complicated for a small team to manage, let's choose to narrow their ownership boundary down to just the fraud-detection subdomain."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(128265).A+"",width:"794",height:"208"})}),"\n",(0,a.jsx)(t.p,{children:"The diagram above shows that fraud-detection is composed of the workflow's first three microservices - which include digital identities, statistical analysis, and AI-based transaction risk-scoring. Since their scope is likely still too broad for a small team to manage, let's split fraud detection further down into two subdomains - which finally seems more manageable."}),"\n",(0,a.jsxs)(t.p,{children:["At a very high level, the process we just followed is called ",(0,a.jsx)(t.a,{href:"https://dddcommunity.org/learning-ddd/what_is_ddd/",children:"Domain-Driven Design (DDD)"}),", which is supported by the recommended pattern to bind each microservice's scope and ownership claim to a business subdomain called ",(0,a.jsx)(t.a,{href:"https://martinfowler.com/bliki/BoundedContext.html",children:"bounded context"}),".\nNotice that each microservice has its own dedicated database for ",(0,a.jsx)(t.strong,{children:"isolation"}),". The",(0,a.jsx)(t.strong,{children:"empowered autonomous team"}),"that owns the blue bounded context chose ",(0,a.jsx)(t.a,{href:"https://redislabs.com/modules/redis-search/",children:"RediSearch"}),' to support their "Authenticate Digital Identity" microservice, and ',(0,a.jsx)(t.a,{href:"https://redislabs.com/modules/redis-bloom/",children:"RedisBloom"}),' to support their "Probabilistic Fraud Detection Checkpoint" microservice. Meanwhile, a separate team that owns the purple bounded context chose ',(0,a.jsx)(t.a,{href:"https://redislabs.com/modules/redis-ai/",children:"RedisAI"}),' to support "Transaction Risk Scoring" in real-time.']}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-asynchronous-messaging---interservice-communication",children:"Design Pattern: Asynchronous Messaging -> Interservice Communication"}),"\n",(0,a.jsxs)(t.p,{children:["Now that we've identified a bounded context and optimal data model for each microservice, our next challenge is to enable communication between them without breaking compliance to ",(0,a.jsx)(t.strong,{children:"isolation"}),". This can be solved byembracing",(0,a.jsx)(t.strong,{children:"eventual consistency"}),", which presumes the microservice on the receiving end of interservice communication will not be available during outbound transmission, however, can consume the message as soon as availability is restored."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(190220).A+"",width:"403",height:"306"})}),"\n",(0,a.jsxs)(t.p,{children:["The recommended pattern for interservice communication is ",(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/communication-style/messaging.html",children:"asynchronous messaging"})," using a publish-subscribe message broker as its event distribution hub. In this pattern, a producer can publish an event without requisite awareness of whether or not any consumer is listening, and - in the same way - consumers of that event can react to it at their convenience or ignore it altogether. This is typically the foundation of an event-driven architecture."]}),"\n",(0,a.jsxs)(t.p,{children:["Since we have already chosen Redis as the primary database for multiple microservices, we can simplify our architecture by also using it to implement this pattern with ",(0,a.jsx)(t.a,{href:"https://university.redislabs.com/courses/ru202/",children:"Redis Streams"}),". Redis Streams is an immutable time-ordered log data structure that allows a producer to publish asynchronous messages to multiple subscribed consumers. This ensures the microservice that is publishing events will remain decoupled from the microservice(s) consuming them - so there are no cross-dependencies on availability and release cycles. In addition, Redis Streams can be configured to handle different delivery guarantees, support consumer groups, and other nuances that are similar in nature to ",(0,a.jsx)(t.a,{href:"https://kafka.apache.org/",children:"Kafka"})," - also a staple across microservice architectures."]}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-choreography-based-saga---distributed-transactions",children:"Design Pattern: Choreography-Based Saga -> Distributed Transactions"}),"\n",(0,a.jsx)(t.p,{children:"Now that we've enabled interservice communication, our next challenge is to handle transactions that span across multiple bounded contexts without breaking compliance to isolation. In the past, this was trivial to implement, since all operations within the transactional scope were executed against a single RDBMS that provided row-locking, deadlock-detection, and roll-back features. Once data became distributed across multiple databases, the Two-Phase Commit protocol (2PC) became a standard for distributed transactions. However, while both approaches worked, they were not designed with eventual consistency in mind."}),"\n",(0,a.jsx)(t.p,{children:"If we presume a dependency will be unavailable during a distributed transaction, then we should also presume frequent rollbacks will cause sporadic unavailability across the system - which is neither cloud native nor improves time-to-market.\nThis can be solved by relaxing strict requirements for ACID guarantees, which have propped up relational databases across most traditional architectures for decades. While relational databases have their place within microservice architectures, their relevance becomes much more situational. For example, if referential integrity is not a requirement then why wouldn't an empowered autonomous team choose to optimize their microservice with a NoSQL database that is purpose-built to handle their specific data access patterns and SLAs."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(371415).A+"",width:"523",height:"240"})}),"\n",(0,a.jsxs)(t.p,{children:["Recall that our payment-processing workflow is composed of multiple microservices that are organized into separate bounded contexts and supported by Redis - a NoSQL database. Within this context, the recommended pattern to handle distributed transactions is a ",(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/saga.html",children:"choreography-based saga"}),", which performs a sequence of isolated local transactions with published events facilitating the transition between workflow stages."]}),"\n",(0,a.jsx)(t.p,{children:"Each microservice participating in the saga will listen only for its own workflow-related event, which will notify it to perform a local database transaction and subsequently publish its own event to the message broker. This event-driven choreography can include compensating microservices for rollback purposes and decision services for complex business processes."}),"\n",(0,a.jsx)(t.p,{children:"It's worth noting that in a choreography-based saga there is no central orchestrator, which avoids coupling the release cycles of participating microservices. However, it is not always the right solution. There can be cases where strong consistency is an absolute requirement - such as account transfers. Within that context, either an orchestration-based saga might be better suited, or relying on a 2PC between microservices within the same bounded context."}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-transactional-outbox-and-message-relay---consistency",children:"Design Pattern: Transactional Outbox and Message Relay -> Consistency"}),"\n",(0,a.jsxs)(t.p,{children:["Now that we've choreographed transactions that span multiple bounded contexts, our next challenge is to mitigate the risks of inconsistency between a microservice's database and the message broker - even if Redis is used for both. Recall that in the previous two design patterns, each microservice committed locally to its database and subsequently published an event. If this is implemented using some variation of the ",(0,a.jsx)(t.a,{href:"https://thorben-janssen.com/dual-writes/",children:"dual writes"})," pattern, communication could become lost and distributed transactions could become orphaned - especially in a cloud environment.\nCode-complexity can be added to each microservice to handle various failure and inconsistency scenarios, however consider this effort multiplied across 100s of teams and the risks of incorrect implementations - all adding no business value."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(807578).A+"",width:"316",height:"289"})}),"\n",(0,a.jsxs)(t.p,{children:["To avoid the risks and costs of various application-level implementations, the recommended patterns are ",(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/transactional-outbox.html",children:"transactional outbox and message replay"}),". Redis simplifies and supports the combined implementation of both patterns, known as ",(0,a.jsx)(t.a,{href:"https://github.com/RedisGears/rgsync",children:"write-behind"}),", by using ",(0,a.jsx)(t.a,{href:"https://university.redislabs.com/courses/ru202/",children:"Redis Streams"})," as the transactional outbox and ",(0,a.jsx)(t.a,{href:"https://redislabs.com/modules/redis-gears/",children:"RedisGears"})," as the message relay. Within Redis a secondary thread can listen for changed-data events, durably store them in time order, and publish them to the message broker - whenever it's available. This can be uniformly enabled or upgraded on each Redis database at the same time withinfrastructure automation."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/transactional-outbox.html",children:"https://microservices.io/patterns/data/transactional-outbox.html"})}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-command-query-responsibility-segregation-cqrs---performance",children:"Design Pattern: Command Query Responsibility Segregation (CQRS) -> Performance"}),"\n",(0,a.jsx)(t.p,{children:"Notice that when we defined our fraud-related bounded contexts, we left out the final stage of the payment-processing workflow. This was because itsempowered autonomous teamchose a non-Redis database to support its microservice."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(128265).A+"",width:"794",height:"208"})}),"\n",(0,a.jsx)(t.p,{children:"So, let's now assume that the \"Approve | Decline Payment\" microservice is supported by a disk-based database which is not optimized for query-performance. Since it presumably has strong durability guarantees, it's a logical choice for record-keeping - however, what if its bounded context also includes a microservice that requires this data for query. This means our next challenge is to optimize query-performance when Redis is not the system-of-record."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(430181).A+"",width:"383",height:"300"})}),"\n",(0,a.jsxs)(t.p,{children:["The recommended pattern is ",(0,a.jsx)(t.a,{href:"https://martinfowler.com/bliki/CQRS.html",children:"CQRS"}),", which segregates the responsibility for a dataset's writes - Command - and reads - Query. Implementing CQRS by using separate databases optimizes the data structure, or data model, to the data access pattern on both sides of the segregation and their individual SLAs. Since our goal is to optimize performance, the direction of data replication will typically flow into Redis from a disk-based database - i.e. MongoDB, Cassandra, RDBMS, etc. Easy, right?\nHere's the catch - to implement this pattern we will need to solve for near-real-time continuous data replication, maintaineventual consistencybetween heterogeneous databases, and transform the data to avoid an impedance mismatch between Command and Query data-structures. This should sound familiar, since we did this when Redis was the source database - recall the transactional outbox and message relay patterns. However, since in this case Redis is the target and most other databases don't support ",(0,a.jsx)(t.a,{href:"https://github.com/RedisGears/rgsync",children:"write-behind"}),", we'll need an external implementation to replicate changed-data events."]}),"\n",(0,a.jsxs)(t.p,{children:["Within this context, we can simplify the implementation of CQRS by using a Change Data Capture (CDC) framework that can integrate with both Command and Query databases. CDC frameworks typically use ",(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/transaction-log-tailing.html",children:"transaction-log tailing"})," or ",(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/polling-publisher.html",children:"polling-publisher"})," patterns to scan for changed-data events on the Command database and replicate them as a transformed payload to the Query database. Notice how this is different than using Redis in a ",(0,a.jsx)(t.a,{href:"https://redislabs.com/solutions/use-cases/caching/",children:"cache-aside"})," pattern, since it does not couple the databases at the microservice level - maintainingisolation."]}),"\n",(0,a.jsx)(t.h2,{id:"design-pattern-shared-data---reusability",children:"Design Pattern: Shared Data -> Reusability"}),"\n",(0,a.jsxs)(t.p,{children:["Now that we've addressed optimizing performance when Redis is not the system-of-record, our next challenge is to handle shared data between microservices that are separated by different bounded contexts or a database outside of the microservice architecture.\nA real-world example of the latter, is a ",(0,a.jsx)(t.a,{href:"https://martinfowler.com/bliki/StranglerFigApplication.html",children:"strangler application"})," migration from a monolithic to microservice architecture. In this case, a microservice's database could be reliant on an external system-of-record for multiple years, or even indefinitely, as part of a Hybrid Cloud deployment. We actually solved this when we introduced the CQRS pattern, however let's extend the problem statement to include microservices that share the same data and data-access pattern.\nIn this case, here are some applicable patterns where Redis simplifies the implementation:"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://docs.redislabs.com/5.2/rs/administering/intercluster-replication/replica-of/",children:"Read Replicas"})," - replicate source data to multiple destinations"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://microservices.io/patterns/data/shared-database.html",children:"Shared Database"})," - allow cross-dependencies between separate bounded contexts"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://dddcommunity.org/learning-ddd/what_is_ddd/",children:"Domain-Driven Design"})," - include all microservices sharing data within a single bounded context"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(986664).A+"",width:"585",height:"301"})}),"\n",(0,a.jsx)(t.p,{children:"Here's the catch - while these patterns address shared data between a few bounded contexts, none of them would scale at a global level."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:i(191155).A+"",width:"626",height:"401"})}),"\n",(0,a.jsx)(t.p,{children:"For global data, the recommended pattern is anisolateddatabase for the API Gateway. Since this database could potentially be accessed by every transaction that flows through the architecture, we must consider business continuity, scalability, and performance as critical success criteria for its selection."})]})}function l(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},85182:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image1-a50fb049012203ce0de6659c572564b8.jpg"},128265:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image2-d28287fbeb19cddd79b1a4a78a347d7e.jpg"},190220:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image3-e3cf720b04e59dcaefca7b40f5cbbfe3.jpg"},371415:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image4-f44ed2cf946dfc7fb1c43e77d81c8a16.jpg"},807578:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image5-c2a2e6d66a7c055d1d79a40dd75c3810.jpg"},430181:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image6-72dbe9efd7b15dc832a4494821ddc9ef.jpg"},986664:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image7-a3a4f6fc1f7d623340320852a0410868.jpg"},191155:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/Microservice-Architecture_Example-image8-ec4ccb48d687c6145f94d7d177cede6f.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var s=i(296540);const a={},n=s.createContext(a);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);