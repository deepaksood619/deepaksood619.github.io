"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[33524],{157434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"data-structures/linear-data-structure/problems","title":"Problems","description":"Anagrams (ABC, CBA are anagrams of each other)","source":"@site/docs/data-structures/linear-data-structure/problems.md","sourceDirName":"data-structures/linear-data-structure","slug":"/data-structures/linear-data-structure/problems","permalink":"/data-structures/linear-data-structure/problems","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/linear-data-structure/problems.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1678191863000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Priority Queue","permalink":"/data-structures/linear-data-structure/priority-queue"},"next":{"title":"Queue FIFO","permalink":"/data-structures/linear-data-structure/queue-fifo"}}');var s=t(474848),i=t(28453);const a={},l="Problems",o={},d=[{value:"Anagrams (ABC, CBA are anagrams of each other)",id:"anagrams-abc-cba-are-anagrams-of-each-other",level:2},{value:"Array Pair Sum",id:"array-pair-sum",level:2},{value:"Find the Missing Element",id:"find-the-missing-element",level:2},{value:"Largest Continuous Sum",id:"largest-continuous-sum",level:2},{value:"Sentence Reversal",id:"sentence-reversal",level:2},{value:"String Compression",id:"string-compression",level:2},{value:"Unique Characters in a String",id:"unique-characters-in-a-string",level:2},{value:"Interview Problems (Array)",id:"interview-problems-array",level:2},{value:"Interview Problems (Linked List)",id:"interview-problems-linked-list",level:2},{value:"Single Linked List Cycle Check",id:"single-linked-list-cycle-check",level:3},{value:"Linked List Reversal in-place",id:"linked-list-reversal-in-place",level:3},{value:"Nth to last node",id:"nth-to-last-node",level:3},{value:"Interview Problems (Stacks and Queues)",id:"interview-problems-stacks-and-queues",level:2}];function c(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"problems",children:"Problems"})}),"\n",(0,s.jsx)(n.h2,{id:"anagrams-abc-cba-are-anagrams-of-each-other",children:"Anagrams (ABC, CBA are anagrams of each other)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can sort both array and compare both"}),"\n",(0,s.jsx)(n.li,{children:"Can count all characters of string1 and decrement count by second string2. Check if all values are 0. Use dictionary, defaultdict."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"array-pair-sum",children:"Array Pair Sum"}),"\n",(0,s.jsxs)(n.p,{children:["Problem - Given an integer array, output all the ",(0,s.jsx)(n.em,{children:"unique"})," pairs that sum up to a specific value k"]}),"\n",(0,s.jsx)(n.p,{children:"Solution - The O(N) algorithm uses the set data structure. We perform a linear pass from the beginning and for each element we check whether k-element is in the set of seen numbers. If it is, then we found a pair of sum k and add it to the output. If not, this element doesn't belong to a pair yet, and we add it to the set of seen elements"}),"\n",(0,s.jsx)(n.h2,{id:"find-the-missing-element",children:"Find the Missing Element"}),"\n",(0,s.jsx)(n.p,{children:"Problem - Consider an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array"}),"\n",(0,s.jsx)(n.p,{children:"Solution - O(N) - We can use a hashtable and store the number of times each element appears in the second array. Then for each element in the first array we decrement its counter. Once hit an element with zero count that's the missing element"}),"\n",(0,s.jsx)(n.p,{children:"we can achieve linear time and constant space complexity without any problems. Here it is: initialize a variable to 0, thenXOR every element in the first and second arrays with that variable. In the end, the value of the variable is the result, missing element in array2."}),"\n",(0,s.jsx)(n.h2,{id:"largest-continuous-sum",children:"Largest Continuous Sum"}),"\n",(0,s.jsx)(n.p,{children:"Problem - Given an array of integers (positive and negative) find the largest continuous sum"}),"\n",(0,s.jsx)(n.p,{children:"Solution - O(N) - Use current_sum and max_sum to track the values and update the values using current_sum = max(current_sum + num, num) and max_sum(current_sum, max_sum)"}),"\n",(0,s.jsx)(n.h2,{id:"sentence-reversal",children:"Sentence Reversal"}),"\n",(0,s.jsx)(n.p,{children:"Problem - Given a string of words, reverse all the words"}),"\n",(0,s.jsx)(n.p,{children:"Solution - Use stack to push the words and then print the stack"}),"\n",(0,s.jsx)(n.h2,{id:"string-compression",children:"String Compression"}),"\n",(0,s.jsx)(n.p,{children:"Problem - Implement Run Length Encoding"}),"\n",(0,s.jsx)(n.p,{children:"Solution - Use while loop to check if current value is equal to previous value"}),"\n",(0,s.jsx)(n.h2,{id:"unique-characters-in-a-string",children:"Unique Characters in a String"}),"\n",(0,s.jsx)(n.p,{children:"Solution - Use dictionary to store seen values"}),"\n",(0,s.jsx)(n.p,{children:"Can also use set"}),"\n",(0,s.jsx)(n.h2,{id:"interview-problems-array",children:"Interview Problems (Array)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Find the second minimum element of an array"}),"\n",(0,s.jsx)(n.li,{children:"First non-repeating integers in an array"}),"\n",(0,s.jsx)(n.li,{children:"Merge two sorted arrays"}),"\n",(0,s.jsx)(n.li,{children:"Rearrange positive and negative values in an array"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"interview-problems-linked-list",children:"Interview Problems (Linked List)"}),"\n",(0,s.jsx)(n.h3,{id:"single-linked-list-cycle-check",children:"Single Linked List Cycle Check"}),"\n",(0,s.jsx)(n.p,{children:"Solution - using two markers, in which marker2 will move two nodes ahead for every one node that marker1 moves, if both markers are equal means there is a cycle"}),"\n",(0,s.jsx)(n.p,{children:"Mysolution - add visited as a variable to node, use set to store seen nodes (not efficient)"}),"\n",(0,s.jsx)(n.h3,{id:"linked-list-reversal-in-place",children:"Linked List Reversal in-place"}),"\n",(0,s.jsx)(n.p,{children:"Solution - Use previous, current, next pointers (remember to save nextnode before updating the current.nextnode)"}),"\n",(0,s.jsx)(n.h3,{id:"nth-to-last-node",children:"Nth to last node"}),"\n",(0,s.jsx)(n.p,{children:"Solution - Use two pointers - last and nth_last, move last to given n steps away. Move both pointers one step until last becomes last node."}),"\n",(0,s.jsx)(n.p,{children:"return nth_last"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Walk one pointer ",(0,s.jsx)(n.strong,{children:"n"})," nodes from the head, this will be the right_point"]}),"\n",(0,s.jsx)(n.li,{children:"Put the other pointer at the head, this will be the left_point"}),"\n",(0,s.jsxs)(n.li,{children:["Walk/traverse the block (both pointers) towards the tail, one node at a time, keeping a distance ",(0,s.jsx)(n.strong,{children:"n"})," between them."]}),"\n",(0,s.jsx)(n.li,{children:"Once the right_point has hit the tail, we know that the left point is at the target."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"interview-problems-stacks-and-queues",children:"Interview Problems (Stacks and Queues)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Implement a stack"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Implement a queue"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Implement a deque"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Balanced paranthesis"}),"\n",(0,s.jsx)(n.p,{children:"Use stack to store the opening paranthesis. Pop when closing paranthesis found while checking for set. If equal than continue otherwise return False (since not balanced)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Implement a queue using two stacks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"costly enqueue"}),"\n",(0,s.jsx)(n.li,{children:"costly dequeue"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"whenever dequeue is called pop element from second stack, if second stack is empty then push elements from second stack by popping from it. (transfer elements from first stack to second in reverse order)"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(296540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);