"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[93758],{84422:(e,i,a)=>{a.r(i),a.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"databases-nosql/vector-databases/indexing","title":"Indexing","description":"HNSW, IVF, and PQ are all\xa0Indexing techniques used in approximate nearest neighbor (ANN) search, often within vector databases like Milvus.\xa0HNSW (Hierarchical Navigable Small World graph) excels at speed and recall but uses more memory.\xa0IVF (Inverted File) is efficient for clustered data and faster queries but can be less precise.\xa0PQ (Product Quantization) is memory-efficient and fast but may reduce accuracy due to compression.\xa0Combining these techniques, like IVF-PQ and HNSW-PQ, is common to balance speed, memory, and accuracy.","source":"@site/docs/databases-nosql/vector-databases/indexing.md","sourceDirName":"databases-nosql/vector-databases","slug":"/databases-nosql/vector-databases/indexing","permalink":"/databases-nosql/vector-databases/indexing","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-nosql/vector-databases/indexing.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1750704279000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Comparison","permalink":"/databases-nosql/vector-databases/comparison"},"next":{"title":"Intro","permalink":"/databases-nosql/vector-databases/intro"}}');var n=a(474848),r=a(28453);const t={},l="Indexing",c={},o=[{value:"HNSW (Hierarchical Navigable Small World graph)",id:"hnsw-hierarchical-navigable-small-world-graph",level:3},{value:"IVF (Inverted File)",id:"ivf-inverted-file",level:3},{value:"PQ (Product Quantization)",id:"pq-product-quantization",level:3},{value:"Hybrid Approaches",id:"hybrid-approaches",level:3},{value:"HSNW (Hierarchical Navigable Small Worlds)",id:"hsnw-hierarchical-navigable-small-worlds",level:2},{value:"FAISS (Facebook AI Similarity Search)",id:"faiss-facebook-ai-similarity-search",level:2},{value:"Links",id:"links",level:2}];function d(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"indexing",children:"Indexing"})}),"\n",(0,n.jsxs)(i.p,{children:["HNSW, IVF, and PQ are all\xa0Indexing techniques used in approximate nearest neighbor (ANN) search, often within vector databases like Milvus.\xa0HNSW (Hierarchical Navigable Small World graph) excels at speed and recall but uses more memory.\xa0",(0,n.jsx)(i.strong,{children:"IVF (Inverted File)"})," is efficient for clustered data and faster queries but can be less precise.\xa0",(0,n.jsx)(i.strong,{children:"PQ (Product Quantization)"})," is memory-efficient and fast but may reduce accuracy due to compression.\xa0Combining these techniques, like IVF-PQ and HNSW-PQ, is common to balance speed, memory, and accuracy."]}),"\n",(0,n.jsx)(i.h3,{id:"hnsw-hierarchical-navigable-small-world-graph",children:"HNSW (Hierarchical Navigable Small World graph)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Uses a multi-layered graph structure for efficient traversal and search."}),"\n",(0,n.jsx)(i.li,{children:"Each layer is a graph, with the top layer being sparse and the bottom layer dense."}),"\n",(0,n.jsx)(i.li,{children:"Offers high recall and speed but requires more memory to store the graph structure."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"ivf-inverted-file",children:"IVF (Inverted File)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:'Partitions the dataset into "buckets" or "lists".'}),"\n",(0,n.jsx)(i.li,{children:"During a query, only a subset of these lists are searched."}),"\n",(0,n.jsx)(i.li,{children:"Efficient for clustered data and faster than brute-force search."}),"\n",(0,n.jsx)(i.li,{children:"Can be less accurate than HNSW."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"pq-product-quantization",children:"PQ (Product Quantization)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Compresses vectors by dividing them into subvectors and quantizing each subvector."}),"\n",(0,n.jsx)(i.li,{children:"Reduces memory usage and speeds up distance calculations."}),"\n",(0,n.jsx)(i.li,{children:"Reduces recall due to compression."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"hybrid-approaches",children:"Hybrid Approaches"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"IVF-PQ:"}),"\xa0Combines IVF for efficient search space reduction and PQ for memory efficiency."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"HNSW-PQ:"}),"\xa0Combines HNSW for speed and recall with PQ for memory optimization."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Choosing the right index depends on your priorities:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"High accuracy and recall:"}),"\xa0HNSW or HNSW-PQ."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Memory efficiency:"}),"\xa0PQ or IVF-PQ."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Speed and clustered data:"}),"\xa0IVF."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"hsnw-hierarchical-navigable-small-worlds",children:"HSNW (Hierarchical Navigable Small Worlds)"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://www.youtube.com/watch?v=H9Qdm8_JBAs",children:"System Design of ChatGPT | Mock interview @gkcs - YouTube"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://www.pinecone.io/learn/series/faiss/hnsw/",children:"Hierarchical Navigable Small Worlds (HNSW) | Pinecone"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://towardsdatascience.com/similarity-search-part-4-hierarchical-navigable-small-world-hnsw-2aad4fe87d37",children:"Similarity Search, Part 4: Hierarchical Navigable Small World (HNSW) | by Vyacheslav Efimov | Towards Data Science"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://medium.com/@vanshkharidia7/hsnw-intuitively-explained-the-best-algorithm-for-billion-scale-vector-search-540527e5278e",children:"HSNW Intuitively Explained: The Best Algorithm for Billion Scale Vector Search | by Vansh Kharidia | Medium"})}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"faiss-facebook-ai-similarity-search",children:"FAISS (Facebook AI Similarity Search)"}),"\n",(0,n.jsxs)(i.p,{children:["Faiss is a library for efficient similarity search and clustering of dense vectors. It contains algorithms that search in sets of vectors of any size, up to ones that possibly do not fit in RAM. It also contains supporting code for evaluation and parameter tuning. Faiss is written in C++ with complete wrappers for Python/numpy. Some of the most useful algorithms are implemented on the GPU. It is developed primarily at Meta's ",(0,n.jsx)(i.a,{href:"https://ai.facebook.com/",children:"Fundamental AI Research"})," group."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://github.com/facebookresearch/faiss",children:"GitHub - facebookresearch/faiss: A library for efficient similarity search and clustering of dense vectors."})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://www.datacamp.com/blog/faiss-facebook-ai-similarity-search",children:"What Is Faiss (Facebook AI Similarity Search)?"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://ai.meta.com/tools/faiss/",children:"FAISS"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://engineering.fb.com/2017/03/29/data-infrastructure/faiss-a-library-for-efficient-similarity-search/",children:"Faiss: A library for efficient similarity search - Engineering at Meta"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://faiss.ai/index.html",children:"Welcome to Faiss Documentation \u2014 Faiss documentation"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://python.langchain.com/docs/integrations/vectorstores/faiss/",children:"Faiss | \ud83e\udd9c\ufe0f\ud83d\udd17 LangChain"})}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://myscale.com/blog/hnsw-vs-ivf-explained-powerful-comparison/",children:"Powerful Comparison: HNSW vs IVF Indexing Methods"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,i,a)=>{a.d(i,{R:()=>t,x:()=>l});var s=a(296540);const n={},r=s.createContext(n);function t(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:t(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);