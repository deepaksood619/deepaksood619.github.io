"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[82495],{486584:(e,i,a)=>{a.r(i),a.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"computer-science/operating-system/caching-strategies-topologies","title":"Caching Strategies","description":"1. Cooperative/Distributed caching","source":"@site/docs/computer-science/operating-system/caching-strategies-topologies.md","sourceDirName":"computer-science/operating-system","slug":"/computer-science/operating-system/caching-strategies-topologies","permalink":"/computer-science/operating-system/caching-strategies-topologies","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/operating-system/caching-strategies-topologies.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1729323453000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Caches / Caching","permalink":"/computer-science/operating-system/caches-caching"},"next":{"title":"Compilers","permalink":"/computer-science/operating-system/compilers"}}');var n=a(474848),s=a(28453);const r={},c="Caching Strategies",l={},o=[{value:"1. Cooperative/Distributed caching",id:"1-cooperativedistributed-caching",level:3},{value:"2. Partial caching",id:"2-partial-caching",level:3},{value:"3. Geographical caching",id:"3-geographical-caching",level:3},{value:"4. Preemptive caching",id:"4-preemptive-caching",level:3},{value:"5. Latency SLA caching",id:"5-latency-sla-caching",level:3},{value:"Caching Topologies",id:"caching-topologies",level:2},{value:"IN-PROCESS CACHES",id:"in-process-caches",level:3},{value:"EMBEDDED NODE CACHES",id:"embedded-node-caches",level:3},{value:"CLIENT-SERVER CACHES",id:"client-server-caches",level:3},{value:"Caching places",id:"caching-places",level:2},{value:"Caching Layers",id:"caching-layers",level:2},{value:"Integrated Redis Cache",id:"integrated-redis-cache",level:2},{value:"1. CacheFront Read and Writes with CDC",id:"1-cachefront-read-and-writes-with-cdc",level:3},{value:"2. Multi-Region Cache Warming with Redis Streaming",id:"2-multi-region-cache-warming-with-redis-streaming",level:3},{value:"3. Redis and Docstore Sharding",id:"3-redis-and-docstore-sharding",level:3}];function h(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"caching-strategies",children:"Caching Strategies"})}),"\n",(0,n.jsx)(i.h3,{id:"1-cooperativedistributed-caching",children:"1. Cooperative/Distributed caching"}),"\n",(0,n.jsx)(i.p,{children:"Cache data is distributed between nodes"}),"\n",(0,n.jsx)(i.p,{children:"In Cooperative Caching, also known as Distributed Caching, multiple distinct systems (normally referred to as cluster-nodes) work together to build a huge, shared cache."}),"\n",(0,n.jsx)(i.h3,{id:"2-partial-caching",children:"2. Partial caching"}),"\n",(0,n.jsx)(i.p,{children:"Partial Caching describes a type of caching where not all data is stored inside the cache. Depending on certain criteria, responses might not be cacheable or are not expected to be cached (like temporary failures)."}),"\n",(0,n.jsx)(i.p,{children:'A typical example for data where not everything is cacheable is websites. Some pages are "static" and'}),"\n",(0,n.jsx)(i.p,{children:"only change if some manual or regular action happens. Those pages can easily be cached and invalidated whenever this particular action happened. Apart from that, other pages consist of mostly dynamic content or frequently updated content (like stock market tickers) and shouldn't be cached at all."}),"\n",(0,n.jsx)(i.h3,{id:"3-geographical-caching",children:"3. Geographical caching"}),"\n",(0,n.jsx)(i.p,{children:"Geographical Caches are located in strategically chosen locations to optimize latency on requests, therefore this kind of cache will mostly be used for website content. It is also known as CDN (Content Delivery Network)."}),"\n",(0,n.jsx)(i.h3,{id:"4-preemptive-caching",children:"4. Preemptive caching"}),"\n",(0,n.jsx)(i.p,{children:"A Preemptive Cache itself is not a caching type like the others above but is mostly used in conjunction with a Geographical Cache."}),"\n",(0,n.jsx)(i.p,{children:"Using a warm-up engine a Preemptive Cache is populated on startup and tries to update itself based on rules or events. The idea behind this cache addition is to reload data from any backend service or central cluster even before a requestor wants to retrieve the element. This keeps access time to the cached elements constant and prevents accesses to single elements from becoming unexpectedly long."}),"\n",(0,n.jsx)(i.p,{children:"Building a Preemptive Cache is not easy and requires a lot of knowledge of the cached domain and the update workflows."}),"\n",(0,n.jsx)(i.h3,{id:"5-latency-sla-caching",children:"5. Latency SLA caching"}),"\n",(0,n.jsx)(i.p,{children:"A Latency SLA Cache is able to maintain latency SLAs even if the cache is slow or overloaded. This type of cache can be build in two different ways."}),"\n",(0,n.jsx)(i.p,{children:"The first option is to have a timeout to exceed before the system either requests the potentially cached element from the original source (in parallel to the already running cache request) or provides a simple default answer, and uses whatever returns first."}),"\n",(0,n.jsx)(i.p,{children:"The other option is to always fire both requests in parallel and take whatever returns first. This option is not the preferred way of implementation since it mostly works against the idea of caching and won't reduce load on the backend system. This option might still make sense if multiple caching layers are available, like always try the first and second nearest caches in parallel."}),"\n",(0,n.jsx)(i.h2,{id:"caching-topologies",children:"Caching Topologies"}),"\n",(0,n.jsx)(i.h3,{id:"in-process-caches",children:"IN-PROCESS CACHES"}),"\n",(0,n.jsx)(i.p,{children:"The In-Process Cache is most oftenly used in non-distributed systems. The cache is kept inside the application's memory space itself and offers the fastest possible access speed."}),"\n",(0,n.jsx)(i.p,{children:"This type of cache is used for caching database entities but can also be used as some kind of an object pool, for instance pooling most recently used network connections to be reused at a later point."}),"\n",(0,n.jsx)(i.p,{children:"Advantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Highest access speed"}),"\n",(0,n.jsx)(i.li,{children:"Data available locally"}),"\n",(0,n.jsx)(i.li,{children:"Easy to maintain"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Disadvantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Data duplication if multiple applications"}),"\n",(0,n.jsx)(i.li,{children:"High memory consumption on a single node"}),"\n",(0,n.jsx)(i.li,{children:"Data cached inside the applications memory"}),"\n",(0,n.jsx)(i.li,{children:"Seems easy to build but has a lot of hidden challenges"}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"embedded-node-caches",children:"EMBEDDED NODE CACHES"}),"\n",(0,n.jsx)(i.p,{children:"Using an Embedded Node Cache the application itself will be part of the cluster. This caching topology is a kind of combination between an In-Process Cache and the Cooperative Caching and it can either use partitioning or full dataset replication."}),"\n",(0,n.jsx)(i.p,{children:"Using full replication the application will get all the benefits of an In-Process Cache since all data is available locally (highest access speed) but for the sake of memory consumption and heap size."}),"\n",(0,n.jsx)(i.p,{children:"By using data partitioning the application knows about the owner of a requested record and will ask directly using an existing data stream. Speed is lower than locally available data but still accessible quickly."}),"\n",(0,n.jsx)(i.p,{children:"Advantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Data can be replicated for highest access speed"}),"\n",(0,n.jsx)(i.li,{children:"Data can be partitioned to create bigger datasets"}),"\n",(0,n.jsx)(i.li,{children:"Cached data might be used a shared state lookup between applications U Possible to scale out the application itself"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Disadvantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"High duplication rate on replication"}),"\n",(0,n.jsx)(i.li,{children:"Application and cache cannot be scaled independently U Data cached inside the applications memory"}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"client-server-caches",children:"CLIENT-SERVER CACHES"}),"\n",(0,n.jsx)(i.p,{children:"A Client-Server Cache is one of the most typical setups these days (next to a pure In-Process Cache). In general these systems tend to be Cooperative Caches by having a multi-server architecture to scale out and have the same feature set as the Embedded Node Caches but with the client layer on top."}),"\n",(0,n.jsx)(i.p,{children:"This architecture keeps separate clusters of the applications using the cached data and the data itself, offering the possibility to scale the application cluster and the caching cluster independently. Instead of a caching cluster it is also possible to have a single caching server however this situation slowly losing traction."}),"\n",(0,n.jsx)(i.p,{children:"Having a Client-Server Cache architecture is quite similar to the common usage patterns of an external relational database or other network-connected backend resources."}),"\n",(0,n.jsx)(i.p,{children:"Advantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Data can be replicated for highest access speed"}),"\n",(0,n.jsx)(i.li,{children:"Data can be partitioned to create bigger datasets"}),"\n",(0,n.jsx)(i.li,{children:"Cached data might be used a shared state lookup between applications U Applications and cache can be scaled out independently"}),"\n",(0,n.jsx)(i.li,{children:"Applications can be restarted without losing data"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Disadvantages:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"High duplication rate on replication"}),"\n",(0,n.jsx)(i.li,{children:"Always an additional network round trip (fast network)"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"caching-places",children:"Caching places"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Client Side Caching"}),"\n",(0,n.jsx)(i.li,{children:"Server Side Caching"}),"\n",(0,n.jsx)(i.li,{children:"Network Caching"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"caching-layers",children:"Caching Layers"}),"\n",(0,n.jsx)(i.p,{children:"Data is cached everywhere, from the front end to the back end!"}),"\n",(0,n.jsx)(i.p,{children:"There are multiple layers along the flow."}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Client apps: HTTP responses can be cached by the browser. We request data over HTTP for the first time, and it is returned with an expiry policy in the HTTP header; we request data again, and the client app tries to retrieve the data from the browser cache first."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"CDN: CDN caches static web resources. The clients can retrieve data from a CDN node nearby."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Load Balancer: The load Balancer can cache resources as well."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Messaging infra: Message brokers store messages on disk first, and then consumers retrieve them at their own pace. Depending on the retention policy, the data is cached in Kafka clusters for a period of time."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Services: There are multiple layers of cache in a service. If the data is not cached in the CPU cache, the service will try to retrieve the data from memory. Sometimes the service has a second-level cache to store data on disk."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Distributed Cache: Distributed cache like Redis hold key-value pairs for multiple services in memory. It provides much better read/write performance than the database."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Full-text Search: we sometimes need to use full-text searches like Elastic Search for document search or log search. A copy of data is indexed in the search engine as well."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Database: Even in the database, we have different levels of caches:"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"WAL(Write-ahead Log): data is written to WAL first before building the B tree index"}),"\n",(0,n.jsx)(i.li,{children:"Bufferpool: A memory area allocated to cache query results"}),"\n",(0,n.jsx)(i.li,{children:"Materialized View: Pre-compute query results and store them in the database tables for better query performance"}),"\n",(0,n.jsx)(i.li,{children:"Transaction log: record all the transactions and database updates"}),"\n",(0,n.jsx)(i.li,{children:"Replication Log: used to record the replication state in a database cluster"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"where do we cache data",src:a(248881).A+"",width:"1000",height:"1458"})}),"\n",(0,n.jsx)(i.h2,{id:"integrated-redis-cache",children:"Integrated Redis Cache"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Integrated redis cache",src:a(206043).A+"",width:"999",height:"1242"})}),"\n",(0,n.jsx)(i.h3,{id:"1-cachefront-read-and-writes-with-cdc",children:"1. CacheFront Read and Writes with CDC"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Uber built CacheFront - an integrated caching solution with Redis, Docstore, and MySQL."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Rather than the microservice, Docstore\u2019s query engine communicates with Redis for read requests."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"For cache hits, the query engine fetches data from Redis. For cache misses, the request goes to the storage engine and the database."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"In the case of writes, Docstore\u2019s CDC service (Flux) invalidates the records in Redis. It tails MySQL binlog events to trigger the invalidation."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"2-multi-region-cache-warming-with-redis-streaming",children:"2. Multi-Region Cache Warming with Redis Streaming"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"A region fail-over can result in cache misses and overload the database."}),"\n",(0,n.jsx)(i.li,{children:"To handle this, Uber\u2019s engineering team uses cross-region Redis replication. This is done by tailing the Redis write stream to replicate keys to the remote region."}),"\n",(0,n.jsx)(i.li,{children:"In the remote region, the stream consumer issues read requests to the query engine that reads the database and updates the cache."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"3-redis-and-docstore-sharding",children:"3. Redis and Docstore Sharding"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"All teams in Uber use Docstore and some generate a huge number of requests."}),"\n",(0,n.jsx)(i.li,{children:"Both Redis and Docstore instances are sharded or partitioned to handle the load. But a single Redis cluster going down may create a hot DB shard."}),"\n",(0,n.jsx)(i.li,{children:"To prevent this, they partitioned the Redis cluster using a scheme that was different from the DB sharding. This ensures that the load is evenly distributed."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://blog.bytebytego.com/p/ep131-how-uber-served-40-million",children:"EP131: How Uber Served 40 Million Reads with Integrated Redis Cache?"})})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},206043:(e,i,a)=>{a.d(i,{A:()=>t});const t=a.p+"assets/images/Pasted image 20241006232918-97c7a18fd6e5522e118918bee6ba9ef7.jpg"},248881:(e,i,a)=>{a.d(i,{A:()=>t});const t=a.p+"assets/images/cache-layers-data-9e3d568cc3ced250974eea54bbb7c90f.jpg"},28453:(e,i,a)=>{a.d(i,{R:()=>r,x:()=>c});var t=a(296540);const n={},s=t.createContext(n);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);