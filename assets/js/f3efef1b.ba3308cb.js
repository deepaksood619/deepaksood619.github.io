"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[28419],{54146:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>n,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"data-structures/others/bitmap","title":"Bitmap","description":"Bitmap / Bit Array / Bit Vector / Bitmap index / Bit set / Bit string","source":"@site/docs/data-structures/others/bitmap.md","sourceDirName":"data-structures/others","slug":"/data-structures/others/bitmap","permalink":"/data-structures/others/bitmap","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/others/bitmap.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Others","permalink":"/data-structures/others/"},"next":{"title":"Large Objects","permalink":"/data-structures/others/large-objects"}}');var a=i(474848),r=i(28453);const n={},o="Bitmap",p={},h=[{value:"Bitmap / Bit Array / Bit Vector / Bitmap index / Bit set / Bit string",id:"bitmap--bit-array--bit-vector--bitmap-index--bit-set--bit-string",level:2},{value:"When should you use a bitmap?",id:"when-should-you-use-a-bitmap",level:2},{value:"When should you use compressed bitmaps?",id:"when-should-you-use-compressed-bitmaps",level:2},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"bitmap",children:"Bitmap"})}),"\n",(0,a.jsx)(t.h2,{id:"bitmap--bit-array--bit-vector--bitmap-index--bit-set--bit-string",children:"Bitmap / Bit Array / Bit Vector / Bitmap index / Bit set / Bit string"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.strong,{children:"bit array"})," (also known as ",(0,a.jsx)(t.strong,{children:"bit map"}),", ",(0,a.jsx)(t.strong,{children:"bit set"}),", ",(0,a.jsx)(t.strong,{children:"bit string"}),", or ",(0,a.jsx)(t.strong,{children:"bit vector"}),") is an ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Array_data_structure",children:"array data structure"})," that compactly stores ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bit",children:"bits"}),". It can be used to implement a simple ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Set_data_structure",children:"set data structure"}),". A bit array is effective at exploiting bit-level parallelism in hardware to perform operations quickly. A typical bit array stores ",(0,a.jsx)(t.em,{children:"kw"})," bits, where ",(0,a.jsx)(t.em,{children:"w"})," is the number of bits in the unit of storage, such as a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Byte",children:"byte"})," or ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Word_(computer_architecture)",children:"word"}),", and ",(0,a.jsx)(t.em,{children:"k"})," is some nonnegative integer. If ",(0,a.jsx)(t.em,{children:"w"})," does not divide the number of bits to be stored, some space is wasted due to ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Fragmentation_(computing)",children:"internal fragmentation"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computing",children:"computing"}),", abitmapis a mapping from some domain (for example, a range of integers) to ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bit",children:"bits"}),". It is also called a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bit_array",children:"bit array"})," or ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bitmap_index",children:"bitmap index"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The more general termpix-maprefers to a map of ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Pixel",children:"pixels"}),", where each one may store more than two colors, thus using more than one bit per pixel. Oftenbitmapis used for this as well. In some contexts, the termbitmapimplies one bit per pixel, whilepixmapis used for images with multiple bits per pixel."]}),"\n",(0,a.jsxs)(t.p,{children:["A bitmap is a type of ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_storage",children:"memory"})," organization or ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Image_file_format",children:"image file format"})," used to store ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Digital_image",children:"digital images"}),". The termbitmapcomes from the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_programming",children:"computer programming"})," terminology, meaning just amap of bits, a spatially mapped ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bit_array",children:"array of bits"}),". Now, along withpixmap, it commonly refers to the similar concept of a spatially mapped array of pixels.",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Raster_graphics",children:"Raster"})," images in general may be referred to as bitmaps or pixmaps, whether synthetic or photographic, in files or memory."]}),"\n",(0,a.jsx)(t.h2,{id:"when-should-you-use-a-bitmap",children:"When should you use a bitmap?"}),"\n",(0,a.jsx)(t.p,{children:"Sets are a fundamental abstraction in software. They can be implemented in various ways, as hash sets, as trees, and so forth. In databases and search engines, sets are often an integral part of indexes. For example, we may need to maintain a set of all documents or rows (represented by numerical identifier) that satisfy some property. Besides adding or removing elements from the set, we need fast functions to compute the intersection, the union, the difference between sets, and so on."}),"\n",(0,a.jsx)(t.p,{children:"To implement a set of integers, a particularly appealing strategy is the bitmap (also called bitset or bit vector). Using n bits, we can represent any set made of the integers from the range [0, n): the ith bit is set to one if integer i is present in the set. Commodity processors use words of W=32 or W=64 bits. By combining many such words, we can support large values of n. Intersections, unions and differences can then be implemented as bitwise AND, OR and ANDNOT operations. More complicated set functions can also be implemented as bitwise operations."}),"\n",(0,a.jsx)(t.p,{children:"When the bitset approach is applicable, it can be orders of magnitude faster than other possible implementation of a set (e.g., as a hash set) while using several times less memory."}),"\n",(0,a.jsx)(t.p,{children:'However, a bitset, even a compressed one is not always applicable. For example, if the you have 1000 random-looking integers, then a simple array might be the best representation. We refer to this case as the "sparse" scenario.'}),"\n",(0,a.jsx)(t.h2,{id:"when-should-you-use-compressed-bitmaps",children:"When should you use compressed bitmaps?"}),"\n",(0,a.jsx)(t.p,{children:"An uncompressed BitSet can use a lot of memory. For example, if you take a BitSet and set the bit at position 1,000,000 to true and you have just over 100kB. That's over 100kB to store the position of one bit. This is wasteful even if you do not care about memory: suppose that you need to compute the intersection between this BitSet and another one that has a bit at position 1,000,001 to true, then you need to go through all these zeroes, whether you like it or not. That can become very wasteful."}),"\n",(0,a.jsx)(t.p,{children:"This being said, there are definitively cases where attempting to use compressed bitmaps is wasteful. For example, if you have a small universe size. E.g., your bitmaps represent sets of integers from [0, n) where n is small (e.g., n=64 or n=128). If you are able to uncompressed BitSet and it does not blow up your memory usage, then compressed bitmaps are probably not useful to you. In fact, if you do not need compression, then a BitSet offers remarkable speed."}),"\n",(0,a.jsx)(t.p,{children:"The sparse scenario is another use case where compressed bitmaps should not be used. Keep in mind that random-looking data is usually not compressible. E.g., if you have a small set of 32-bit random integers, it is not mathematically possible to use far less than 32 bits per integer, and attempts at compression can be counterproductive."}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bitmap",children:"https://en.wikipedia.org/wiki/Bitmap"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bit_array",children:"https://en.wikipedia.org/wiki/Bit_array"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/RoaringBitmap/RoaringBitmap",children:"https://github.com/RoaringBitmap/RoaringBitmap"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"http://paulbourke.net/dataformats/bitmaps",children:"http://paulbourke.net/dataformats/bitmaps"})})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>n,x:()=>o});var s=i(296540);const a={},r=s.createContext(a);function n(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);