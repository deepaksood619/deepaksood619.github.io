"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[20894],{21197:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"languages/sql/dql-data-query-language/analytical-queries","title":"Analytical Queries","description":"Aggregate functions perform calculations based on sets of rows","source":"@site/docs/languages/sql/dql-data-query-language/analytical-queries.md","sourceDirName":"languages/sql/dql-data-query-language","slug":"/languages/sql/dql-data-query-language/analytical-queries","permalink":"/languages/sql/dql-data-query-language/analytical-queries","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/sql/dql-data-query-language/analytical-queries.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Aggregation Queries","permalink":"/languages/sql/dql-data-query-language/aggregation-queries"},"next":{"title":"Window Functions","permalink":"/languages/sql/dql-data-query-language/window-functions"}}');var s=a(474848),r=a(28453);const i={},l="Analytical Queries",o={},c=[{value:"Examples",id:"examples",level:2},{value:"Links",id:"links",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"analytical-queries",children:"Analytical Queries"})}),"\n",(0,s.jsx)(n.p,{children:"Aggregate functions perform calculations based on sets of rows"}),"\n",(0,s.jsxs)(n.p,{children:["Unlike aggregate functions, ",(0,s.jsx)(n.strong,{children:"analytic functions"})," return a (potentially different) value for each row in the original table."]}),"\n",(0,s.jsxs)(n.p,{children:["All analytic functions have an ",(0,s.jsx)(n.strong,{children:"OVER"})," clause, which defines the sets of rows used in each calculation."]}),"\n",(0,s.jsx)(n.p,{children:"The OVER clause has three (optional) parts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"PARTITION BY"})," clause divides the rows of the table into different groups"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"ORDER BY"})," clause defines an ordering within each partition."]}),"\n",(0,s.jsxs)(n.li,{children:["The final clause (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) is known as a",(0,s.jsx)(n.strong,{children:"window frame"})," clause. It identifies the set of rows used in each calculation. We can refer to this group of rows as a ",(0,s.jsx)(n.strong,{children:"window"}),". (Actually, analytic functions are sometimes referred to as ",(0,s.jsx)(n.strong,{children:"analytic window functions"})," or simply ",(0,s.jsx)(n.strong,{children:"window functions"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image",src:a(868875).A+"",width:"1000",height:"371"})}),"\n",(0,s.jsx)(n.p,{children:"There are many ways to write window frame clauses:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROWS BETWEEN 1 PRECEDING AND CURRENT ROW"})," - the previous row and the current row."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING"})," - the 3 previous rows, the current row, and the following row."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING"})," - all rows in the partition."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"})," - a window frame that spans from the start of the partition to the current row, inclusive."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The lowest possible bound  is UNBOUNDED PRECEDING (the first row), the current row is CURRENT ROW and the highest possible row is UNBOUNDED FOLLOWING (the last row)."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT time, buy,\n  avg(buy) OVER (ORDER BY time rows between 1 preceding and current row) as average_2,\n  avg(buy) OVER (ORDER BY time rows between 2 preceding and current row) as average_3\nFROM my_table;\n\n-- https://stackoverflow.com/questions/56063397/how-to-understand-the-results-of-rows-between-2-preceding-and-current-row\n\nSELECT sale_day, sale_time, branch, article, quantity, revenue,\nSUM(quantity) OVER (PARTITION BY article) AS total_units_sold\nFROM sales;\n\nSELECT DISTINCT article,\n EXTRACT('month' FROM sale_day) AS month,\n SUM(quantity) OVER (PARTITION BY article, sale_month) AS units_sold_month,\n SUM(quantity) OVER (PARTITION BY article) AS units_sold_year,\n ((SUM(quantity) OVER (PARTITION BY article, sale_month)::decimal / SUM(quantity) OVER (PARTITION BY article)::decimal ) * 100) AS month_percentage\nFROM sales\nWHERE EXTRACT('YEAR' FROM sale_day) = 2021\nORDER BY article, month\n\nWITH branch_month_sales AS (\n SELECT DISTINCT\n branch,\n EXTRACT('MONTH' FROM sale_day) AS month,\n SUM(revenue) OVER (PARTITION BY branch, sale_month ) AS revenue\n FROM sales\n)\nSELECT branch,\n month,\n revenue AS revenue_current_month,\n LAG(revenue) OVER (PARTITION BY branch ORDER BY month) AS revenue_prev_month,\n revenue - LAG(revenue) OVER (PARTITION BY branch ORDER BY month) AS revenue_delta\nFROM branch_month_sales\nORDER BY branch, month\n\n-- using ANY_VALUE and IF to transpose rows in columns based on rank\nWITH ranked_transactions AS (\nSELECT\natr.userId,\natr.operation,\natr.confirmedAt,\nROW_NUMBER() OVER (PARTITION BY atr.userId\nORDER BY\natr.confirmedAt ASC) AS rn\nFROM\nall_transactions atr\n)\nSELECT\nrt.UserId,\nANY_VALUE(IF(rt.rn = 1, rt.operation, NULL), TRUE) AS firstEntryProduct,\nANY_VALUE(IF(rt.rn = 2, rt.operation, NULL), TRUE) AS secondEntryProduct,\nFROM ranked_transactions rt GROUP BY userId\n"})}),"\n",(0,s.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/languages/sql/dql-data-query-language/window-functions",children:"Window Functions"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/languages/sql/dql-data-query-language/aggregation-queries",children:"Aggregation Queries"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://learnsql.com/blog/sql-over-clause/",children:"What Is the OVER() Clause in SQL? | LearnSQL.com"})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://stevestedman.com/2012/03/rows-preceding-and-following-in-tsql-2012/",children:"ROWS PRECEDING and FOLLOWING in TSQL 2012 - Steve Stedman"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},868875:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/DQL-Data-Query-Language_Aggregation-Analytical-Queries-SQL-Analytics-image1-7eaea3d946421917491eef0a60b23ea5.jpg"},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var t=a(296540);const s={},r=t.createContext(s);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);