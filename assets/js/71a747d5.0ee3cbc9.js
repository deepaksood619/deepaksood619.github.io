"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[45097],{601269:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"devops/kubernetes/reference/readme","title":"Reference","description":"Admission Controllers","source":"@site/docs/devops/kubernetes/reference/readme.md","sourceDirName":"devops/kubernetes/reference","slug":"/devops/kubernetes/reference/","permalink":"/devops/kubernetes/reference/","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/kubernetes/reference/readme.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1720119349000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Outline Documentation","permalink":"/devops/kubernetes/outline-documentation"},"next":{"title":"Quality of Service (QoS)","permalink":"/devops/kubernetes/reference/quality-of-service-qos"}}');var o=t(474848),i=t(28453);const r={},a="Reference",c={},d=[{value:"Admission Controllers",id:"admission-controllers",level:2},{value:"Dynamic Admission Control",id:"dynamic-admission-control",level:2},{value:"Admission Webhooks",id:"admission-webhooks",level:2}];function l(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"reference",children:"Reference"})}),"\n",(0,o.jsx)(s.h2,{id:"admission-controllers",children:"Admission Controllers"}),"\n",(0,o.jsxs)(s.p,{children:["An admission controller is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object, but after the request is authenticated and authorized. The controllers consist of the",(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do",children:"list"})," below, are compiled into thekube-apiserverbinary, and may only be configured by the cluster administrator. In that list, there are two special controllers: MutatingAdmissionWebhook and ValidatingAdmissionWebhook. These execute the mutating and validating (respectively)",(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks",children:"admission control webhooks"})," which are configured in the API."]}),"\n",(0,o.jsx)(s.p,{children:'Admission controllers may be "validating", "mutating", or both. Mutating controllers may modify the objects they admit; validating controllers may not.'}),"\n",(0,o.jsx)(s.p,{children:"The admission control process proceeds in two phases. In the first phase, mutating admission controllers are run. In the second phase, validating admission controllers are run. Note again that some of the controllers are both."}),"\n",(0,o.jsx)(s.p,{children:"If any of the controllers in either phase reject the request, the entire request is rejected immediately and an error is returned to the end-user."}),"\n",(0,o.jsx)(s.p,{children:"Finally, in addition to sometimes mutating the object in question, admission controllers may sometimes have side effects, that is, mutate related resources as part of request processing. Incrementing quota usage is the canonical example of why this is necessary. Any such side-effect needs a corresponding reclamation or reconciliation process, as a given admission controller does not know for sure that a given request will pass all of the other admission controllers."}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers",children:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers"})}),"\n",(0,o.jsx)(s.h2,{id:"dynamic-admission-control",children:"Dynamic Admission Control"}),"\n",(0,o.jsx)(s.h2,{id:"admission-webhooks",children:"Admission Webhooks"}),"\n",(0,o.jsxs)(s.p,{children:["Admission webhooks are HTTP callbacks that receive admission requests and do something with them. You can define two types of admission webhooks, ",(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook",children:"validating admission Webhook"})," and ",(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook",children:"mutating admission webhook"}),". Mutating admission Webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults. After all object modifications are complete, and after the incoming object is validated by the API server, validating admission webhooks are invoked and can reject requests to enforce custom policies."]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers",children:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>a});var n=t(296540);const o={},i=n.createContext(o);function r(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);