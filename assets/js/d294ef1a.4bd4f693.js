"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[47605],{930166:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"algorithms/dynamic-programming/how-to-find-dp","title":"How to find DP","description":"Steps to solve a DP","source":"@site/docs/algorithms/dynamic-programming/how-to-find-dp.md","sourceDirName":"algorithms/dynamic-programming","slug":"/algorithms/dynamic-programming/how-to-find-dp","permalink":"/algorithms/dynamic-programming/how-to-find-dp","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/dynamic-programming/how-to-find-dp.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"General","permalink":"/algorithms/dynamic-programming/greedy-algorithms"},"next":{"title":"Intro","permalink":"/algorithms/dynamic-programming/intro"}}');var i=a(474848),o=a(28453);const s={},r="How to find DP",l={},d=[{value:"Steps to solve a DP",id:"steps-to-solve-a-dp",level:2},{value:"Step 1 : How to classify a problem as a Dynamic Programming Problem?",id:"step-1--how-to-classify-a-problem-as-a-dynamic-programming-problem",level:2},{value:"Step 2 : Deciding the state",id:"step-2--deciding-the-state",level:2},{value:"Step 3 : Formulating a relation among the states",id:"step-3--formulating-a-relation-among-the-states",level:2},{value:"Step 4 : Adding memoization or tabulation for the state",id:"step-4--adding-memoization-or-tabulation-for-the-state",level:2},{value:"References",id:"references",level:2}];function m(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"how-to-find-dp",children:"How to find DP"})}),"\n",(0,i.jsx)(t.h2,{id:"steps-to-solve-a-dp",children:"Steps to solve a DP"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Identify if it is a DP problem"}),"\n",(0,i.jsx)(t.li,{children:"Decide a state expression with least parameters"}),"\n",(0,i.jsx)(t.li,{children:"Formulate state relationship"}),"\n",(0,i.jsx)(t.li,{children:"Do tabulation (or add memoization)"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"step-1--how-to-classify-a-problem-as-a-dynamic-programming-problem",children:"Step 1 : How to classify a problem as a Dynamic Programming Problem?"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Typically, all the problems that require to maximize or minimize certain quantity or counting problems that say to count the arrangements under certain condition or certain probability problems can be solved by using Dynamic Programming."}),"\n",(0,i.jsx)(t.li,{children:"All dynamic programming problems satisfy the overlapping subproblems property and most of the classic dynamic problems also satisfy the optimal substructure property. Once, we observe these properties in a given problem, be sure that it can be solved using DP."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"step-2--deciding-the-state",children:"Step 2 : Deciding the state"}),"\n",(0,i.jsx)(t.p,{children:'DP problems are all about state and their transition. This is the most basic step which must be done very carefully because the state transition depends on the choice of state definition you make. So, let\'s see what do we mean by the term "state".'}),"\n",(0,i.jsx)(t.p,{children:"StateA state can be defined as the set of parameters that can uniquely identify a certain position or standing in the given problem. This set of parameters should be as small as possible to reduce state space"}),"\n",(0,i.jsx)(t.p,{children:"As we know DP is all about using calculated results to formulate the final result."}),"\n",(0,i.jsx)(t.p,{children:"So, our next step will be to find a relation between previous states to reach the current state."}),"\n",(0,i.jsx)(t.h2,{id:"step-3--formulating-a-relation-among-the-states",children:"Step 3 : Formulating a relation among the states"}),"\n",(0,i.jsxs)(t.p,{children:["Let's think dynamically for this problem. So, first of all, we decide a state for the given problem. We will take a parameter n to decide state as it can uniquely identify any subproblem. So, our state dp will look like state(n). Here, state(n) means the total number of arrangements to form n by using ",5," as elements."]}),"\n",(0,i.jsx)(t.p,{children:"Now, we need to compute state(n)."}),"\n",(0,i.jsx)(t.h2,{id:"step-4--adding-memoization-or-tabulation-for-the-state",children:"Step 4 : Adding memoization or tabulation for the state"}),"\n",(0,i.jsx)(t.p,{children:"This is the easiest part of a dynamic programming solution. We just need to store the state answer so that next time that state is required, we can directly use it from our memory"}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/solve-dynamic-programming-problem",children:"https://www.geeksforgeeks.org/solve-dynamic-programming-problem"})})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>r});var n=a(296540);const i={},o=n.createContext(i);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);