"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[76148],{602498:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"databases/nosql-databases/aws-dynamodb/cheatsheet","title":"Cheatsheet","description":"The Basics of DynamoDB","source":"@site/docs/databases/nosql-databases/aws-dynamodb/cheatsheet.md","sourceDirName":"databases/nosql-databases/aws-dynamodb","slug":"/databases/nosql-databases/aws-dynamodb/cheatsheet","permalink":"/databases/nosql-databases/aws-dynamodb/cheatsheet","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/nosql-databases/aws-dynamodb/cheatsheet.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1719081324000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Capacity Modes","permalink":"/databases/nosql-databases/aws-dynamodb/capacity-modes"},"next":{"title":"Core components","permalink":"/databases/nosql-databases/aws-dynamodb/core-components"}}');var t=a(474848),i=a(28453);const d={},r="Cheatsheet",o={},l=[{value:"The Basics of DynamoDB",id:"the-basics-of-dynamodb",level:2},{value:"Reads and Writes Consistency",id:"reads-and-writes-consistency",level:2},{value:"Partitions",id:"partitions",level:2},{value:"Primary Key Design",id:"primary-key-design",level:2},{value:"Secondary Indexes",id:"secondary-indexes",level:2},{value:"LSI - Local Secondary index",id:"lsi---local-secondary-index",level:2},{value:"GSI - Global Secondary Index",id:"gsi---global-secondary-index",level:2},{value:"Scan",id:"scan",level:2},{value:"Query",id:"query",level:2},{value:"DynamoDB Accelerator",id:"dynamodb-accelerator",level:2},{value:"DynamoDB Transactions",id:"dynamodb-transactions",level:2},{value:"Global tables",id:"global-tables",level:2},{value:"Streams",id:"streams",level:2},{value:"DynamoDB API",id:"dynamodb-api",level:2},{value:"aws dynamodb get-item",id:"aws-dynamodb-get-item",level:3},{value:"aws dynamodb put-item",id:"aws-dynamodb-put-item",level:3},{value:"aws dynamodb update-item",id:"aws-dynamodb-update-item",level:3},{value:"aws dynamodb batch-get-item",id:"aws-dynamodb-batch-get-item",level:3},{value:"aws dynamodb batch-write-item",id:"aws-dynamodb-batch-write-item",level:3},{value:"aws dynamodb create-table",id:"aws-dynamodb-create-table",level:3},{value:"aws dynamodb update-table",id:"aws-dynamodb-update-table",level:3},{value:"aws dynamodb delete-table",id:"aws-dynamodb-delete-table",level:3},{value:"aws dynamodb transact-get-items",id:"aws-dynamodb-transact-get-items",level:3},{value:"aws dynamodb transact-write-items",id:"aws-dynamodb-transact-write-items",level:3},{value:"aws dynamodb query",id:"aws-dynamodb-query",level:3},{value:"aws dynamodb scan",id:"aws-dynamodb-scan",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"cheatsheet",children:"Cheatsheet"})}),"\n",(0,t.jsx)(n.h2,{id:"the-basics-of-dynamodb",children:"The Basics of DynamoDB"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB is a fully managed NoSQL key/value and document database.\nDynamoDB is suited for workloads with any amount of data that require predictable read and write performance and automatic scaling from large to small and everywhere in between."}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB scales up and down to support what ever read and write capacity you specify per second in provisioned capacity mode. Or you can set it to On-Demand mode and there is little to no capacity planning."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["DynamoDB stores ",(0,t.jsx)(n.strong,{children:"3 copies"})," of data on SSD drives across 3 AZs in a region."]}),"\n",(0,t.jsx)(n.li,{children:"DynamoDB's most common datatypes areB(Binary),N(Number), andS(String)"}),"\n",(0,t.jsx)(n.li,{children:"Tables consist ofItems(rows) and Items consist ofAttributes(columns)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"reads-and-writes-consistency",children:"Reads and Writes Consistency"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB can be set to supportEventually Consistent Reads(default) andStrongly Consistent Reads on a per-call basis."}),"\n",(0,t.jsx)(n.p,{children:"Eventually consistent reads data is returned immediately but data can be inconsistent. Copies of data will be generally consistent in 1 second."}),"\n",(0,t.jsx)(n.p,{children:"Strongly Consistent Readswill always read from the leader partition since it always has an up-to-date copy. Data will never be inconsistent but latency may be higher. Copies of data will be consistent with a guarantee of 1 second."}),"\n",(0,t.jsx)(n.h2,{id:"partitions",children:"Partitions"}),"\n",(0,t.jsx)(n.p,{children:"A Partition is when DynamoDB slices your table up into smaller chunks of data. This speeds up reads for very large tables."}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB automatically creates Partitions for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Every 10 GB of Data or"}),"\n",(0,t.jsx)(n.li,{children:"When you exceed RCUs (3000) or WCUs (1000) limits for a single partition"}),"\n",(0,t.jsx)(n.li,{children:"When DynamoDB sees a pattern of a hot partition, it will split that partition in an attempt to fix the issue."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB will try to evenly split the RCUs and WCUs across Partitions"}),"\n",(0,t.jsx)(n.h2,{id:"primary-key-design",children:"Primary Key Design"}),"\n",(0,t.jsx)(n.p,{children:"Primary keys define where and how your data will be stored in partitions"}),"\n",(0,t.jsx)(n.p,{children:"The Key schema can be made up of two keys:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Partition Key (PK) is also known asHASH"}),"\n",(0,t.jsx)(n.li,{children:"TheSort Key (SK) is also known asRANGE"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When using the AWS DynamoDB API eg. CLI, SDK they refer to the PK and SK by their alternative names due to legacy reasons."}),"\n",(0,t.jsx)(n.p,{children:"Primary key comes in two types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SimplePrimary Key (Using only a Partition Key)"}),"\n",(0,t.jsx)(n.li,{children:"CompositePrimary Key (Using both a Partition and Sort Key)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Key Uniqueness is as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When creating a Simple Primary Key the PKvalue may be unique"}),"\n",(0,t.jsx)(n.li,{children:"When creating a Composite Primary Keythe combined PK and SK must be unique"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When using a Sort key, records on the partition are logically grouped together in Ascending order."}),"\n",(0,t.jsx)(n.h2,{id:"secondary-indexes",children:"Secondary Indexes"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB has two types of Indexes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"LSI- Local Secondary index"}),"\n",(0,t.jsx)(n.li,{children:"GSI- Global Secondary Index"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.youtube.com/watch?v=eQ3eNd5WbH8&ab_channel=ArpitBhayani",children:"How indexes work in Distributed Databases, their trade-offs, and challenges - YouTube"})}),"\n",(0,t.jsx)(n.h2,{id:"lsi---local-secondary-index",children:"LSI - Local Secondary index"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Supports strongly or eventual consistency reads"}),"\n",(0,t.jsx)(n.li,{children:"Can only be created with initial table (cannot be modified or and cannot deleted unless also deleting the table)"}),"\n",(0,t.jsx)(n.li,{children:"Only Composite"}),"\n",(0,t.jsx)(n.li,{children:"10GB or less per partition"}),"\n",(0,t.jsx)(n.li,{children:"Share capacity units with base table"}),"\n",(0,t.jsx)(n.li,{children:"Must share Partition Key (PK) with base table."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"gsi---global-secondary-index",children:"GSI - Global Secondary Index"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Only eventual consistency reads (cannot provide strong consistency)"}),"\n",(0,t.jsx)(n.li,{children:"Can create, modify, or delete at anytime"}),"\n",(0,t.jsx)(n.li,{children:"Simple and Composite"}),"\n",(0,t.jsx)(n.li,{children:"Can have whatever attributes as Primary Key (PK) or Secondary Key (SK)"}),"\n",(0,t.jsx)(n.li,{children:"No size restriction per partition"}),"\n",(0,t.jsx)(n.li,{children:"Has its own capacity settings (does not share with base table)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"scan",children:"Scan"}),"\n",(0,t.jsx)(n.p,{children:"Your table(s) should be designed in such a way that your workload primary access patterns do not use Scans. Overall, scans should be needed sparingly, for example for an infrequent report."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Scans through all items in a table and then returns one or more items through filters"}),"\n",(0,t.jsx)(n.li,{children:"By default returns all attributes for every item (use Project Expression to limit)"}),"\n",(0,t.jsx)(n.li,{children:"Scans are sequential, and you can speed up a scan through parallel scans using Segments and Total Segments"}),"\n",(0,t.jsx)(n.li,{children:"Scans can be slow, especially with very large tables and can easily consume your provisioned throughput."}),"\n",(0,t.jsx)(n.li,{children:"Scans are one of the most expensive ways to access data in DynamoDB."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"query",children:"Query"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Find items based on primary key values"}),"\n",(0,t.jsx)(n.li,{children:"Table must have a composite key in order to be able to query"}),"\n",(0,t.jsx)(n.li,{children:"By default queries are Eventually Consistent (use ConsistentRead True to change Strongly Consistent)"}),"\n",(0,t.jsx)(n.li,{children:"By default returns all attributes for each item found by a query (useProjectExpression to limit)"}),"\n",(0,t.jsx)(n.li,{children:"By default is sorted ascending (use ScanIndexForward to False to reverse order to descending)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dynamodb-accelerator",children:"DynamoDB Accelerator"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB Accelerator(DAX) is a fully managed in-memory write through cache for DynamoDB that runs in a cluster"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reads are eventually consistent"}),"\n",(0,t.jsx)(n.li,{children:"Incoming requests are evenly distributed across all of the nodes in the cluster."}),"\n",(0,t.jsx)(n.li,{children:"DAX can reduce read response times to microseconds"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"DAX is ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"fastest response times possible"}),"\n",(0,t.jsx)(n.li,{children:"apps that read a small number of items more frequently"}),"\n",(0,t.jsx)(n.li,{children:"apps that are read intensive"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"DAX is not ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Apps that require strongly consistent reads"}),"\n",(0,t.jsx)(n.li,{children:"Apps that do not require microsecond read response times"}),"\n",(0,t.jsx)(n.li,{children:"Apps that are write intensive, or that do not perform much read activity"}),"\n",(0,t.jsx)(n.li,{children:"If you don't need DAX consider using ElastiCache"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dynamodb-transactions",children:"DynamoDB Transactions"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB supports transactions via the TransactWriteItems and TransactGetItemsAPI calls."}),"\n",(0,t.jsx)(n.p,{children:"Transactions let you query multiple tables at once and are an all-or-nothing approach (all API calls must succeed)."}),"\n",(0,t.jsx)(n.h2,{id:"global-tables",children:"Global tables"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB Global tables provide a fully managed solution for deploying multi-region, multi-master databases."}),"\n",(0,t.jsx)(n.h2,{id:"streams",children:"Streams"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB Streams allows you to set up a Lambda function triggered every time data is modified in a table to react to changes.Streams do not consume RCUs."}),"\n",(0,t.jsx)(n.h2,{id:"dynamodb-api",children:"DynamoDB API"}),"\n",(0,t.jsx)(n.p,{children:"DynamoDB API's most notable commands via CLI"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"aws dynamodb < command >"})}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-get-item",children:"aws dynamodb get-item"}),"\n",(0,t.jsx)(n.p,{children:"returns a set of attributes for the item with the given primary key. If no matching item, then it does not return any data and there will be no Item element in the response."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-put-item",children:"aws dynamodb put-item"}),"\n",(0,t.jsx)(n.p,{children:"Creates a new item, or replaces an old item with a new item. If an item that has the same primary key as the new item already exists in the specified table, the new item completely replaces the existing item."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-update-item",children:"aws dynamodb update-item"}),"\n",(0,t.jsx)(n.p,{children:"Edits an existing item's attributes, or adds a new item to the table if it does not already exist."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-batch-get-item",children:"aws dynamodb batch-get-item"}),"\n",(0,t.jsx)(n.p,{children:"returns the attributes of one or more items from one or more tables. You identify requested items by primary key. A single operation can retrieve up to 16 MB of data, which can contain as many as 100 items."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-batch-write-item",children:"aws dynamodb batch-write-item"}),"\n",(0,t.jsx)(n.p,{children:"puts or deletes multiple items in one or more tables. Can write up to 16 MB of data, which can comprise as many as25 put or delete requests. Individual items to be written can beas large as 400 KB."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-create-table",children:"aws dynamodb create-table"}),"\n",(0,t.jsx)(n.p,{children:"adds a new table to your account. Table names must be unique within each Region."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-update-table",children:"aws dynamodb update-table"}),"\n",(0,t.jsx)(n.p,{children:"Modifies the provisioned throughput settings, global secondary indexes, or DynamoDB Streams settings for a given table."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-delete-table",children:"aws dynamodb delete-table"}),"\n",(0,t.jsx)(n.p,{children:"operation deletes a table and all of its items."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-transact-get-items",children:"aws dynamodb transact-get-items"}),"\n",(0,t.jsx)(n.p,{children:"is a synchronous operation that atomically retrieves multiple items from one or more tables (but not from indexes) in a single account and Region. Call can contain up to 25 objects. The aggregate size of the items in the transaction cannot exceed 4 MB."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-transact-write-items",children:"aws dynamodb transact-write-items"}),"\n",(0,t.jsx)(n.p,{children:"a synchronous write operation that groups up to25 action requests. These actions can target items in different tables, but not in different AWS accounts or Regions, and no two actions can target the same item."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-query",children:"aws dynamodb query"}),"\n",(0,t.jsx)(n.p,{children:"finds items based on primary key values. You can query table or secondary index that has a composite primary key."}),"\n",(0,t.jsx)(n.h3,{id:"aws-dynamodb-scan",children:"aws dynamodb scan"}),"\n",(0,t.jsx)(n.p,{children:"returns one or more items and item attributes by accessing every item in a table or a secondary index."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.freecodecamp.org/news/ultimate-dynamodb-2020-cheatsheet",children:"https://www.freecodecamp.org/news/ultimate-dynamodb-2020-cheatsheet"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>d,x:()=>r});var s=a(296540);const t={},i=s.createContext(t);function d(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);