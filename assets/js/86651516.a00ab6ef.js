"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[54149],{807119:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"databases-sql/postgres/replication","title":"Replication","description":"Types","source":"@site/docs/databases-sql/postgres/replication.md","sourceDirName":"databases-sql/postgres","slug":"/databases-sql/postgres/replication","permalink":"/databases-sql/postgres/replication","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases-sql/postgres/replication.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1749575438000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Parameters / Configurations / Optimizations","permalink":"/databases-sql/postgres/parameters-configuration-optimization"},"next":{"title":"Table Partitioning","permalink":"/databases-sql/postgres/table-partitioning"}}');var t=s(474848),r=s(28453);const a={},o="Replication",l={},c=[{value:"Types",id:"types",level:3},{value:"Streaming Replication",id:"streaming-replication",level:4},{value:"Physical Replication",id:"physical-replication",level:4},{value:"Logical Replication",id:"logical-replication",level:4},{value:"Bi-Directional Replication (BDR)",id:"bi-directional-replication-bdr",level:4},{value:"Bi-directional Replication (BDR)",id:"bi-directional-replication-bdr-1",level:3},{value:"Multiple Masters to Single Slave (Multi-Source Replication)",id:"multiple-masters-to-single-slave-multi-source-replication",level:2},{value:"Dump and Restore",id:"dump-and-restore",level:2},{value:"Replication Slot",id:"replication-slot",level:2},{value:"1. Physical PostgreSQL Replication Slots",id:"1-physical-postgresql-replication-slots",level:3},{value:"2. Logical PostgreSQL Replication Slots",id:"2-logical-postgresql-replication-slots",level:3},{value:"Links",id:"links",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"replication",children:"Replication"})}),"\n",(0,t.jsx)(i.h3,{id:"types",children:"Types"}),"\n",(0,t.jsx)(i.h4,{id:"streaming-replication",children:"Streaming Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Uses a continuous stream of write-ahead logs (WAL) from the primary server to the standby server(s)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates entire database clusters at the block level."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Generally used for read-only failover. Failover to a standby server in case the primary server fails."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Synchronous replication can be achieved by waiting for acknowledgments from the standby, ensuring transaction durability."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Commonly used for high availability and disaster recovery."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"physical-replication",children:"Physical Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Synchronous or Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates physical blocks of data, similar to streaming replication, but allows for more flexibility in configuration."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates entire data pages at the storage level."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Primarily used for read-only failover, similar to streaming replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Can be synchronous, ensuring that a transaction is committed on both the primary and standby servers before returning to the client."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Suitable for high availability, disaster recovery, and load balancing."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"logical-replication",children:"Logical Replication"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates changes in the database on a logical level, such as tables, rows, or columns."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Replicates changes made to the data, providing more flexibility in what is replicated."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Often used for upgrading databases with minimal downtime or for data distribution across different systems."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Typically asynchronous, so there might be some delay in data replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Useful for selective data replication, upgrades, and data distribution."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"bi-directional-replication-bdr",children:"Bi-Directional Replication (BDR)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type:"})," Asynchronous"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method:"})," Replicates changes bidirectionally between nodes."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Transfer:"})," Allows for bidirectional replication of changes made to the data."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Failover:"})," Can be used for read and write failover, allowing writes on multiple nodes."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consistency:"})," Asynchronous replication, so there might be some delay in data replication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Usage:"})," Useful for multi-master setups where multiple nodes can accept both read and write operations. It enables data consistency across multiple nodes."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Streaming replication and physical replication are more focused on providing high availability and disaster recovery, while logical replication allows for more selective data replication. Bi-Directional Replication (BDR) is a specific implementation of multi-master replication, allowing for bidirectional data synchronization between nodes."}),"\n",(0,t.jsx)(i.h3,{id:"bi-directional-replication-bdr-1",children:"Bi-directional Replication (BDR)"}),"\n",(0,t.jsxs)(i.p,{children:["PostgreSQL supports block-based (physical) replication as well as the row-based (logical) replication. ",(0,t.jsx)(i.strong,{children:"Physical replication is traditionally used to create read-only replicas of a primary instance"}),", and utilized in both self-managed and managed deployments of PostgreSQL. Uses for physical read replicas can include high availability, disaster recovery, and scaling out the reader nodes. Although there is flexibility in the use cases for physical replicas, consider that all data in the database must be replicated from the write instance to its readers."]}),"\n",(0,t.jsxs)(i.p,{children:["In contrast, ",(0,t.jsx)(i.strong,{children:"logical replication allows you to choose a subset of the data to replicate"}),". Additionally, when using logical replication, there is no requirement for the secondary nodes to be read-only. You can configure logical replication to get data for some tables and at the same time, the application can directly write to the same or different tables in the database."]}),"\n",(0,t.jsxs)(i.p,{children:["The publisher- and subscriber-based ",(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/current/logical-replication.html",children:"logical replication feature"})," was introduced into core PostgreSQL starting with version 10, but prior to that, PostgreSQL started supporting the ",(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/current/logicaldecoding-explanation.html",children:"logical decoding feature"})," from version 9.4. Much of the logical replication capability in core PostgreSQL was based on the work done for the open-source PostgreSQL logical replication extension called ",(0,t.jsx)(i.a,{href:"https://github.com/2ndQuadrant/pglogical",children:"pglogical"}),"."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://aws.amazon.com/blogs/database/postgresql-bi-directional-replication-using-pglogical/",children:"PostgreSQL bi-directional replication using pglogical | AWS Database Blog"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"PostgreSQL\u2019s bidirectional replication"})," (Postgres-BDR or BDR) is PostgreSQL\u2019s first open-source multi-master replication system to achieve full production status. BDR was developed by 2ndQuadrant, specially designed for ",(0,t.jsx)(i.strong,{children:"distribution"})," in different geographical clusters, using efficient asynchronous logical replication, and ",(0,t.jsx)(i.strong,{children:"supporting"})," any node with more than 2 to 48 nodes in the distributed database."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.enterprisedb.com/docs/pgd/4/bdr/",children:"EDB Docs - EDB Postgres Distributed (PGD) v4 - BDR (Bi-Directional Replication)"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/database-blog/converting-asynchronous-synchronous-replication-postgresql",children:"Converting from Asynchronous to Synchronous Replication in PostgreSQL | Severalnines"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/download/products/3-clusteringreplication/",children:"PostgreSQL: Software Catalogue - Clustering/replication"})}),"\n",(0,t.jsx)(i.h2,{id:"multiple-masters-to-single-slave-multi-source-replication",children:"Multiple Masters to Single Slave (Multi-Source Replication)"}),"\n",(0,t.jsx)(i.p,{children:"Multi-Source Replication enables a replication slave to receive transactions from multiple sources simultaneously. Multi-source replication can be used to backup multiple servers to a single server, to merge table shards, and consolidate data from multiple servers to a single server."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{src:"https://severalnines.com/wp-content/uploads/2022/05/07-mysql-rep-wp.jpeg",alt:"image"})}),"\n",(0,t.jsx)(i.p,{children:"MySQL and MariaDB have different implementations of multi-source replication, where MariaDB must have GTID with gtid-domain-id configured to distinguish the originating transactions while MySQL uses a separate replication channel for each master the slave replicates from. In MySQL, masters in a multi-source replication topology can be configured to use either global transaction identifier (GTID) based replication, or binary log position-based replication."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/resources/whitepapers/mysql-replication-high-availability/",children:"MySQL replication for high availability | Severalnines"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://dev.mysql.com/doc/refman/8.0/en/replication-multi-source.html",children:"MySQL 8.0 Reference Manual - 19.1.5 MySQL Multi-Source Replication"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://severalnines.com/blog/difference-between-mysql-multi-master-and-multi-source-replication/",children:"The Difference Between MySQL Multi-Master and Multi-Source Replication | Severalnines"})}),"\n",(0,t.jsx)(i.h2,{id:"dump-and-restore",children:"Dump and Restore"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://stackoverflow.com/questions/2094963/postgresql-improving-pg-dump-pg-restore-performance",children:"PostgreSQL: improving pg_dump, pg_restore performance - Stack Overflow"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://serverfault.com/questions/1081642/postgresql-13-speed-up-pg-dump-to-5-minutes-instead-of-70-minutes",children:"pg dump - Postgresql 13 - Speed up pg_dump to 5 minutes instead of 70 minutes - Server Fault"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://www.iseatz.com/blog/speeding-up-postgres-data-dumps",children:"Speeding up Postgres Data Dumps"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsxs)(i.a,{href:"https://www.postgresql.org/docs/current/continuous-archiving.html",children:["PostgreSQL: Documentation: 17: 25.3. ",(0,t.jsx)(i.strong,{children:"Continuous Archiving and Point-in-Time Recovery (PITR)"})]})}),"\n",(0,t.jsx)(i.h2,{id:"replication-slot",children:"Replication Slot"}),"\n",(0,t.jsx)(i.p,{children:"A PostgreSQL replication slot is a vital feature ensuring the master server retains necessary Write-Ahead Log (WAL) files, even when replicas are temporarily disconnected. In streaming replication scenarios with hot or archiving standbys, replication slots preserve WAL files, allowing the master to track standby lag. When a standby reconnects, preserved WAL files are decoded and applied."}),"\n",(0,t.jsx)(i.p,{children:"PostgreSQL Replication slots are of two types:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Physical PostgreSQL Replication Slots"}),"\n",(0,t.jsx)(i.li,{children:"Logical PostgreSQL Replication Slots"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"1-physical-postgresql-replication-slots",children:"1. Physical PostgreSQL Replication Slots"}),"\n",(0,t.jsx)(i.p,{children:"The changes that take place on the main server via streaming replication are recorded in the WAL segments. These WAL files are sent to the standby server and then replayed."}),"\n",(0,t.jsx)(i.p,{children:"So, a physical replication slot can be created on the primary server, and the location to which the transactions are sent is stored on the standby. Now, if the standby loses connection, the primary server will keep those WAL files."}),"\n",(0,t.jsx)(i.h3,{id:"2-logical-postgresql-replication-slots",children:"2. Logical PostgreSQL Replication Slots"}),"\n",(0,t.jsxs)(i.p,{children:["Logical replication was introduced in\xa0",(0,t.jsx)(i.a,{href:"https://docs.hevodata.com/sources/databases/postgresql/",children:"PostgreSQL"}),"\xa010. Logical replication brings over only the SQL-like changes. It does not work without replication slots. Logical replication data has to be decoded using a\xa0",(0,t.jsx)(i.a,{href:"https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins",children:"plugin"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"-- Monitor Postgres Replication Slots\nselect * from pg_replication_slots;\n\n-- Drop Replication Slot\nselect pg_drop_replication_slot(\u2018ocean\u2019);\n"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://hevodata.com/learn/postgresql-replication-slots/",children:"Working with PostgreSQL Replication Slots: Simplified Guide"})}),"\n",(0,t.jsx)(i.h2,{id:"links",children:"Links"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/high-availability.html",children:"26. High Availability, Load Balancing, and Replication"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/logical-replication.html",children:"30. Logical Replication"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.postgresql.org/docs/12/replication-origins.html",children:"49. Replication Progress Tracking"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://dbaclass.com/article/edb-failover-managerefm-for-managing-streaming-replication/",children:"EDB failover manager (EFM) for managing streaming replication - DBACLASS DBACLASS"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.interdb.jp/blog/pgsql/pg_vs_my_01/",children:"Difference between PostgreSQL and MySQL: (1) Replication \xb7 Hironobu SUZUKI @ InterDB"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://aws.amazon.com/blogs/database/replicate-data-between-partitioned-and-non-partitioned-tables-using-trigger-functions-in-amazon-rds-for-postgresql-or-amazon-aurora-postgresql/",children:"Replicate data between partitioned and non-partitioned tables using trigger functions in Amazon RDS for PostgreSQL or Amazon Aurora PostgreSQL | AWS Database Blog"})}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,s)=>{s.d(i,{R:()=>a,x:()=>o});var n=s(296540);const t={},r=n.createContext(t);function a(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);