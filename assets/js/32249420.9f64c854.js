"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[89715],{41611:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"computer-science/distributed-system/others","title":"Others","description":"CRDTs (Conflict-free Replicated Data Types)","source":"@site/docs/computer-science/distributed-system/others.md","sourceDirName":"computer-science/distributed-system","slug":"/computer-science/distributed-system/others","permalink":"/computer-science/distributed-system/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/distributed-system/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/computer-science/distributed-system/intro"},"next":{"title":"Vocabulary","permalink":"/computer-science/distributed-system/vocabulary"}}');var a=i(474848),n=i(28453);const r={},o="Others",c={},d=[{value:"CRDTs (Conflict-free Replicated Data Types)",id:"crdts-conflict-free-replicated-data-types",level:2},{value:"Types of CRDTs",id:"types-of-crdts",level:3},{value:"Operation-based CRDTs",id:"operation-based-crdts",level:3},{value:"State-based CRDTs",id:"state-based-crdts",level:3},{value:"Comparison",id:"comparison",level:3},{value:"Actor Model",id:"actor-model",level:2},{value:"Multi-Tenancy",id:"multi-tenancy",level:2},{value:"Failure Modes",id:"failure-modes",level:2},{value:"Shared-Nothing architecture (SN)",id:"shared-nothing-architecture-sn",level:2},{value:"Redundancy, Replication, Transparency",id:"redundancy-replication-transparency",level:2},{value:"Designing Distributed Systems",id:"designing-distributed-systems",level:2},{value:"<em>Patterns and Paradigms for Scalable, Reliable Services by Brendon Burns (cofounder of Kubernetes)</em>",id:"patterns-and-paradigms-for-scalable-reliable-services-by-brendon-burns-cofounder-of-kubernetes",level:4}];function h(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"others",children:"Others"})}),"\n",(0,a.jsx)(t.h2,{id:"crdts-conflict-free-replicated-data-types",children:"CRDTs (Conflict-free Replicated Data Types)"}),"\n",(0,a.jsx)(t.p,{children:"A conflict-free replicated data type (CRDT) is an abstract data type, with a well defined interface, designed to be replicated at multiple processes and exhibiting the following properties"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Any replica can be modified without coordinating with another replicas;"}),"\n",(0,a.jsx)(t.li,{children:"When any two replicas have received the same set of updates, they reach the same state, deterministically, by adopting mathematically sound rules to guarantee state convergence."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Riak is the most popular open source library of CRDT's and is used by Bet365 and League of Legends."}),"\n",(0,a.jsx)(t.h3,{id:"types-of-crdts",children:"Types of CRDTs"}),"\n",(0,a.jsxs)(t.p,{children:["There are two approaches to CRDTs, both of which can provide ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Strong_consistency",children:"strong"}),(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Eventual_consistency",children:"eventual consistency"}),": ",(0,a.jsx)(t.strong,{children:"operation-based CRDTs and state-based CRDTs."})]}),"\n",(0,a.jsxs)(t.p,{children:["The two alternatives are equivalent, as one can emulate the other.Operation-based CRDTs require additional guarantees from the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Communications_protocol",children:"communication middleware"}),";namely that the operations not be dropped or duplicated when transmitted to the other replicas, though they can be delivered in any order. State-based CRDTs also have a disadvantage, which is that the entire state must be transmitted to the other replicas, which may be costly."]}),"\n",(0,a.jsx)(t.h3,{id:"operation-based-crdts",children:"Operation-based CRDTs"}),"\n",(0,a.jsxs)(t.p,{children:["Operation-based CRDTs are referred to as ",(0,a.jsx)(t.strong,{children:"commutative replicated data types, or CmRDTs."})," CmRDT replicas propagate state by transmitting only the update operation. For example, a CmRDT of a single integer might broadcast the operations (+10) or (\u221220). Replicas receive the updates and apply them locally. The operations are ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Commutative",children:"commutative"}),". However, they are not ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Idempotent",children:"idempotent"}),". The communications infrastructure must therefore ensure that all operations on a replica are delivered to the other replicas, without duplication, but in any order."]}),"\n",(0,a.jsx)(t.p,{children:"Pure operation-based CRDTs are a variant of operation-based CRDTs that reduces the metadata size."}),"\n",(0,a.jsx)(t.h3,{id:"state-based-crdts",children:"State-based CRDTs"}),"\n",(0,a.jsxs)(t.p,{children:["State-based CRDTs are called",(0,a.jsx)(t.strong,{children:"convergent replicated data types, orCvRDTs"}),". In contrast to CmRDTs, CvRDTs send their full local state to other replicas, where the states are merged by a function which must be ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Commutative",children:"commutative"}),", ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Associative",children:"associative"}),", and ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Idempotent",children:"idempotent"}),". Themergefunction provides a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Join_(mathematics)",children:"join"})," for any pair of replica states, so the set of all states forms a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Semilattice",children:"semilattice"}),". Theupdatefunction must ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Monotonic_function",children:"monotonically increase"})," the internal state, according to the same ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Partial_order",children:"partial order"})," rules as the semilattice."]}),"\n",(0,a.jsx)(t.p,{children:"Delta state CRDTs(or simply Delta CRDTs) are optimized state-based CRDTs where only recently applied changes to a state are disseminated instead of the entire state."}),"\n",(0,a.jsx)(t.h3,{id:"comparison",children:"Comparison"}),"\n",(0,a.jsxs)(t.p,{children:["While CmRDTs place more requirements on the protocol for transmitting operations between replicas, they use less bandwidth than CvRDTs when the number of transactions is small in comparison to the size of internal state. However, since the CvRDT merge function is associative, merging with the state of some replica yields all previous updates to that replica.",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Gossip_protocol",children:"Gossip protocols"})," work well for propagating CvRDT state to other replicas while reducing network use and handling topology changes."]}),"\n",(0,a.jsx)(t.p,{children:"Some lower bounds on the storage complexity of state-based CRDTs are known."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://arxiv.org/abs/1805.06358",children:"https://arxiv.org/abs/1805.06358"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type",children:"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"http://christophermeiklejohn.com/crdt/2014/07/22/readings-in-crdts.html",children:"http://christophermeiklejohn.com/crdt/2014/07/22/readings-in-crdts.html"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=Paau_t0aZKw&ab_channel=AsliEngineeringbyArpitBhayani",children:"Ep 2 - Introduction to CRDTs - Conflict-free Replicated Data Types - with @VipulVaibhaw - YouTube"})}),"\n",(0,a.jsx)(t.h2,{id:"actor-model",children:"Actor Model"}),"\n",(0,a.jsx)(t.p,{children:"The actor model provides a higher level of abstaction for writing concurrent and distributed systems, which shields the developer from explicit locking and thread management. It provides the core functionality of reactive systems, defined in the Reactive Manifesto as responsive, resilient, elastic, and message-driven. Akka is an actor-based framework that is easy to implement with full Java 8 Lambda support. Actors enable developers to design and implement systems in ways that help focus more on the core functionality and less on the plumbing. Actor-based systems are the perfect foundation for quickly evoling microservices architectures."}),"\n",(0,a.jsx)(t.p,{children:"Actor (encapsulate 3 things)"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Processing"}),"\n",(0,a.jsx)(t.li,{children:"Storage"}),"\n",(0,a.jsx)(t.li,{children:"Communication"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"If an actor receive a message it can do 3 things"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Create more actors"}),"\n",(0,a.jsx)(t.li,{children:"Send messages to actors it knows"}),"\n",(0,a.jsx)(t.li,{children:"Designate what to do with the next message"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.brianstorti.com/the-actor-model",children:"https://www.brianstorti.com/the-actor-model"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=7erJ1DV_Tlo",children:"https://www.youtube.com/watch?v=7erJ1DV_Tlo"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=ELwEdb_pD0k&ab_channel=Finematics",children:"Actor Model Explained - YouTube"})}),"\n",(0,a.jsx)(t.h2,{id:"multi-tenancy",children:"Multi-Tenancy"}),"\n",(0,a.jsxs)(t.p,{children:["Multi-tenancy is an architecture in which a single instance of a software application serves multiple customers. Each customer is called a tenant. Tenants may be given the ability to customize some parts of the application, such as color of the user interface (",(0,a.jsx)(t.a,{href:"http://searchsoa.techtarget.com/definition/user-interface",children:"UI"}),") or ",(0,a.jsx)(t.a,{href:"http://whatis.techtarget.com/definition/business-rule",children:"business rules"}),", but they cannot customize the application's ",(0,a.jsx)(t.a,{href:"http://whatis.techtarget.com/definition/code",children:"code"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Multi-tenancy can be economical because software development and maintenance costs are shared. It can be contrasted with single-tenancy, an architecture in which each customer has their own software instance and may be given access to code. With a multi-tenancy architecture, the provider only has to make updates once. With a single-tenancy architecture, the provider has to touch multiple instances of the software in order to make updates."}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"http://searchcloudcomputing.techtarget.com/definition/cloud-computing",children:"cloud computing"}),", the meaning of multi-tenancy architecture has broadened because of new service models that take advantage of ",(0,a.jsx)(t.a,{href:"http://searchservervirtualization.techtarget.com/definition/virtualization",children:"virtualization"})," and ",(0,a.jsx)(t.a,{href:"http://searchmidmarketsecurity.techtarget.com/definition/remote-access",children:"remote access"}),". A software-as-a-service (",(0,a.jsx)(t.a,{href:"http://whatis.techtarget.com/definition/SaaS",children:"SaaS"}),") provider, for example, can run one instance of its application on one instance of a database and provide web access to multiple customers. In such a scenario, each tenant's data is isolated and remains invisible to other tenants."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://whatis.techtarget.com/definition/multi-tenancy",children:"https://whatis.techtarget.com/definition/multi-tenancy"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.computerworld.com/article/2517005/data-center/multi-tenancy-in-the-cloud--why-it-matters.html",children:"https://www.computerworld.com/article/2517005/data-center/multi-tenancy-in-the-cloud--why-it-matters.html"})}),"\n",(0,a.jsx)(t.h2,{id:"failure-modes",children:"Failure Modes"}),"\n",(0,a.jsx)(t.p,{children:"This brings us to an important subject of Failure Detectors, which are widely used in practical consensus algorithms and help to solve consensus problem in a partial synchronous or synchronous system.Failure Detectoris an abstraction that helps to reason about liveness in the system, detect and mark participants as active or failed."}),"\n",(0,a.jsx)(t.p,{children:"If processes A and B communicate through perfect link and all process B stops receiving messages from A and A does not receive any messages from B, most of the time from the process perspective it's impossible to know whetherBhas crashed, B is simply running very slow or there's a network partition. If two processes are separated by the network partition, for both of them it will seem as if the other process just crashed."}),"\n",(0,a.jsx)(t.p,{children:"The simplest way for a process to fail is Crash-Failure, where the process stops executing steps required by the algorithm. Here, the assumption is that processes are executing algorithm correctly, but stop at some point and never recover. In real-life system, this type of failure occurs less often than, say, Crash-Recovery, where the process stops executing steps required by the algorithm, but recovers at the later point and tries to execute further steps. For correctness, some algorithms still assume crashed and recovered process as failed and further steps do not influence the outcome of the algorithm."}),"\n",(0,a.jsx)(t.p,{children:"This means that the algorithm should be designed in a way that does not rely for on process recovery for correctness, since it may never recover or recover too late."}),"\n",(0,a.jsx)(t.p,{children:"Another type of failure is Omission Fault. This failure model assumes that the process omits some of the algorithm steps, is not able to execute algorithm steps or this execution is not visible for other participants."}),"\n",(0,a.jsx)(t.p,{children:"The hardest failures to overcome are Arbitrary or Byzantine Failures, where the process continues executing algorithm steps, but in a way that contradicts the algorithm in some way (for example, by deciding on a value that was never proposed)."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://medium.com/databasss/on-ways-to-agree-part-1-links-and-flp-impossibility-f6bd8a6a0980",children:"https://medium.com/databasss/on-ways-to-agree-part-1-links-and-flp-impossibility-f6bd8a6a0980"})}),"\n",(0,a.jsx)(t.h2,{id:"shared-nothing-architecture-sn",children:"Shared-Nothing architecture (SN)"}),"\n",(0,a.jsxs)(t.p,{children:["A shared-nothing architecture (SN) is a ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Distributed_computing",children:"distributed-computing"})," architecture in which each update request is satisfied by a single node (processor/memory/storage unit). The intent is to eliminate contention among nodes. Nodes do not share (independently access) memory or storage. One alternative architecture is shared everything, in which requests are satisfied by arbitrary combinations of nodes. This may introduce contention, as multiple nodes may seek to update the same data at the same time."]}),"\n",(0,a.jsxs)(t.p,{children:["SN eliminates ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Single_point_of_failure",children:"single points of failure"}),", allowing the overall system to continue operating despite failures in individual nodes and allowing individual nodes to upgrade without a system-wide shutdown."]}),"\n",(0,a.jsxs)(t.p,{children:["A SN system can scale simply by adding nodes, since no central resource bottlenecks the system.Another term for SN is ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Sharding",children:"sharding"}),". A SN system typically partitions its data among many nodes. A refinement is to replicate commonly used but infrequently modified data across many nodes, allowing more requests to be resolved on a single node."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Shared-nothing_architecture",children:"https://en.wikipedia.org/wiki/Shared-nothing_architecture"})}),"\n",(0,a.jsx)(t.h2,{id:"redundancy-replication-transparency",children:"Redundancy, Replication, Transparency"}),"\n",(0,a.jsx)(t.p,{children:"Replication takes a redundant node one step further; it ensures that the redundant node (a replica) is identical to all of its other copies."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://medium.com/baseds/transparency-illusions-of-a-single-system-part-1-b01c25f7dddd",children:"Transparency"})," in ",(0,a.jsx)(t.a,{href:"https://medium.com/baseds/transparency-illusions-of-a-single-system-part-2-2b21c5047774",children:"a system"})," means that all the replicas and the original node must behave similarly, which means that a consumer of the system (like an end user or another node) could potentially write to one replica, while another consumer of the system could read from another replica!"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://medium.com/baseds/redundancy-and-replication-duplicating-in-a-distributed-system-7ab4322d7378",children:"https://medium.com/baseds/redundancy-and-replication-duplicating-in-a-distributed-system-7ab4322d7378"})}),"\n",(0,a.jsx)(t.h2,{id:"designing-distributed-systems",children:"Designing Distributed Systems"}),"\n",(0,a.jsx)(t.h4,{id:"patterns-and-paradigms-for-scalable-reliable-services-by-brendon-burns-cofounder-of-kubernetes",children:(0,a.jsx)(t.em,{children:"Patterns and Paradigms for Scalable, Reliable Services by Brendon Burns (cofounder of Kubernetes)"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Both an object and interface for expressing core distributed system patterns"}),"\n",(0,a.jsx)(t.li,{children:"side-car, adapter and ambassador patterns to split application into a group of containers on a single machine"}),"\n",(0,a.jsx)(t.li,{children:"Loosely coupled multi-node distributed patterns for replication, scaling, and communication between the components"}),"\n",(0,a.jsx)(t.li,{children:"Work queues, event-based processing and coordinated workflows# Event-Driven Batch Processing"}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var s=i(296540);const a={},n=s.createContext(a);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);