"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[49333],{905512:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"computer-science/programming-paradigms/behavioral-memento","title":"Behavioral - Memento","description":"Memento is a behavioral design pattern that allows you to save and restore the past states of the objects without revealing the details of their implementation","source":"@site/docs/computer-science/programming-paradigms/behavioral-memento.md","sourceDirName":"computer-science/programming-paradigms","slug":"/computer-science/programming-paradigms/behavioral-memento","permalink":"/computer-science/programming-paradigms/behavioral-memento","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-paradigms/behavioral-memento.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Behavioral - Mediator","permalink":"/computer-science/programming-paradigms/behavioral-mediator"},"next":{"title":"Behavioral - Observer","permalink":"/computer-science/programming-paradigms/behavioral-observer"}}');var s=o(474848),n=o(28453);const i={},r="Behavioral - Memento",h={},l=[{value:"Situations in which it&#39;s appropriate to use the pattern",id:"situations-in-which-its-appropriate-to-use-the-pattern",level:2},{value:"When you need to save snapshots of the object&#39;s state (or a part of it), so that the object could later be restored in the same state",id:"when-you-need-to-save-snapshots-of-the-objects-state-or-a-part-of-it-so-that-the-object-could-later-be-restored-in-the-same-state",level:4},{value:"When the direct interface for obtaining the state of the object reveals details of the implementation and violates the encapsulation of the object",id:"when-the-direct-interface-for-obtaining-the-state-of-the-object-reveals-details-of-the-implementation-and-violates-the-encapsulation-of-the-object",level:4},{value:"Pros",id:"pros",level:2},{value:"Cons",id:"cons",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"behavioral---memento",children:"Behavioral - Memento"})}),"\n",(0,s.jsx)(t.p,{children:"Memento is a behavioral design pattern that allows you to save and restore the past states of the objects without revealing the details of their implementation"}),"\n",(0,s.jsx)(t.p,{children:"Let's say that you are writing a text editor program. Apart from the usual addition and removal of the text, your editor allows you to change the text formatting, insert pictures and other. At some point, you've decided to make all of these actions cancelable. To do this, you need to save the current state of the text before performing any actions. If you then decide to cancel your action, you'll get a copy of the state from the history and restore the old state of the text."}),"\n",(0,s.jsx)(t.p,{children:"Let's now take a look at the copies of the editor's state. It should have several fields for storing the current text and all of its properties (font, color, etc.), cursor and scroll position of the screen, inserted images and much more. To make a copy of the state, you need to write the values \u200b\u200bof all these fields in a certain \"container\". Most likely, you'll need to store a lot of such containers as a history of operations, so the most convenient thing is to make them the objects of the same class. This class must have many fields, but almost no methods."}),"\n",(0,s.jsx)(t.p,{children:"The Memento pattern perfectly handles all of these requirements. It suggests holding a copy of the state in a special image object with a limited interface, which allows, for example, to find out the date/time of storage or the name of the snapshot. But, on the other hand, the snapshot should be open to its creator, allowing you to read and restore its internal state."}),"\n",(0,s.jsx)(t.p,{children:'Such a scheme allows the creators to take snapshots and give them away for storage to other objects called guardians. The guardians will only have access to a limited image interface, so they won\'t be able to affect the "insides" of the image itself. At the right time, the guardian can ask the creator to restore its state, providing it with the appropriate snapshot.'}),"\n",(0,s.jsx)(t.p,{children:"In the example with the editor, you can choose a separate class to be the guardian that will store the list of completed operations. The limited interface of images will show the user a beautiful list with names and dates of the performed operations. And when the user decides to roll back the operation, the history class takes the last snapshot from the stack and sends it to the editor to restore it."}),"\n",(0,s.jsx)(t.h2,{id:"situations-in-which-its-appropriate-to-use-the-pattern",children:"Situations in which it's appropriate to use the pattern"}),"\n",(0,s.jsx)(t.h4,{id:"when-you-need-to-save-snapshots-of-the-objects-state-or-a-part-of-it-so-that-the-object-could-later-be-restored-in-the-same-state",children:"When you need to save snapshots of the object's state (or a part of it), so that the object could later be restored in the same state"}),"\n",(0,s.jsx)(t.p,{children:"The Memento pattern allows you to create any number of the object's snapshots and store them, regardless of the object from which they've been taken. Snapshots are often used not only to implement a cancellation operation, but also for transactions when the state of the object needs to be \"rolled back\" if the operation failed."}),"\n",(0,s.jsx)(t.h4,{id:"when-the-direct-interface-for-obtaining-the-state-of-the-object-reveals-details-of-the-implementation-and-violates-the-encapsulation-of-the-object",children:"When the direct interface for obtaining the state of the object reveals details of the implementation and violates the encapsulation of the object"}),"\n",(0,s.jsx)(t.h2,{id:"pros",children:"Pros"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Doesn't violate the encapsulation of the input object."}),"\n",(0,s.jsx)(t.li,{children:"Simplifies the structure of the input object. It doesn't need to keep a history of its state versions."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"cons",children:"Cons"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Requires a lot of memory if clients create images too often."}),"\n",(0,s.jsx)(t.li,{children:"It can entail additional memory costs, if the objects storing the history don't release the resources occupied by the outdated images."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://py.checkio.org/blog/design-patterns-part-3",children:"https://py.checkio.org/blog/design-patterns-part-3"})})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>r});var a=o(296540);const s={},n=a.createContext(s);function i(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);