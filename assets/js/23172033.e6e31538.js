"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[6408],{121384:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>l});var s=r(785893),i=r(511151);const o={},a="Graph Search",n={id:"algorithms/graphtheory/graph-search",title:"Graph Search",description:"Graph search algorithms like A* are often used to find the shortest path from one point to another point. You can use this for each enemy to find a path to the goal. There are lots of different graph search algorithms we could use in this type of game. These are the classics:",source:"@site/docs/algorithms/graphtheory/graph-search.md",sourceDirName:"algorithms/graphtheory",slug:"/algorithms/graphtheory/graph-search",permalink:"/algorithms/graphtheory/graph-search",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/graphtheory/graph-search.md",tags:[],version:"current",lastUpdatedAt:1692586856,formattedLastUpdatedAt:"Aug 21, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Ford-Fulkerson Algorithm",permalink:"/algorithms/graphtheory/ford-fulkerson-algorithm"},next:{title:"Intro",permalink:"/algorithms/graphtheory/intro"}},h={},l=[{value:"One source, one destination",id:"one-source-one-destination",level:3},{value:"One source, all destinations, or all sources, one destination",id:"one-source-all-destinations-or-all-sources-one-destination",level:3},{value:"3. All sources, all destinations",id:"3-all-sources-all-destinations",level:3},{value:"Example Algorithms",id:"example-algorithms",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"graph-search",children:"Graph Search"}),"\n",(0,s.jsx)(t.p,{children:"Graph search algorithms like A* are often used to find the shortest path from one point to another point. You can use this for each enemy to find a path to the goal. There are lots of different graph search algorithms we could use in this type of game. These are the classics:"}),"\n",(0,s.jsx)(t.h3,{id:"one-source-one-destination",children:"One source, one destination"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Best_first_search",children:"Greedy Best First Search"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/A*_search_algorithm",children:"A*"})," Use A* Search Algorithm (For Unweighted as well as Weighted Graphs) - commonly used in games"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"one-source-all-destinations-or-all-sources-one-destination",children:"One source, all destinations, or all sources, one destination"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Breadth_first_search",children:"Breadth First Search"}),"- (For Unweighted Graphs)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm",children:"Dijkstra's Algorithm"}),"- (For Weighted Graphs without negative weights)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",children:"Bellman-Ford"}),"- (For Weighted Graphs with negative weights)"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"3-all-sources-all-destinations",children:"3. All sources, all destinations"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",children:"Floyd-Warshall"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Johnson%27s_algorithm",children:"Johnson's Algorithm"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"example-algorithms",children:"Example Algorithms"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Breadth First Search"})," explores equally in all directions. This is an incredibly useful algorithm, not only for regular path finding, but also for procedural map generation, flow field pathfinding, distance maps, and other types of map analysis"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Dijkstra's Algorithm"})," (also called Uniform Cost Search) lets us prioritize which paths to explore. Instead of exploring all possible paths equally, it favors lower cost paths. We can assign lower costs to encourage moving on roads, higher costs to avoid forests, higher costs to discourage going near enemies, and more. When movement costs vary, we use this instead of Breadth First Search."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"A*"})," is a modification of Dijkstra's Algorithm that is optimized for a single destination. Dijkstra's Algorithm can find paths to all locations; A* finds paths to one location. It prioritizes paths that seem to be leading closer to the goal."]})]})}function c(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},511151:(e,t,r)=>{r.d(t,{Z:()=>n,a:()=>a});var s=r(667294);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);