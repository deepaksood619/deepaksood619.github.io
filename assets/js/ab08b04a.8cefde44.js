"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[29125],{326271:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"computer-science/system-design/others","title":"Others","description":"Grid FTP","source":"@site/docs/computer-science/system-design/others.md","sourceDirName":"computer-science/system-design","slug":"/computer-science/system-design/others","permalink":"/computer-science/system-design/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/system-design/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1728296318000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"N-Tier Application Architecture","permalink":"/computer-science/system-design/n-tier-application-architecture"},"next":{"title":"Rate Limiting","permalink":"/computer-science/system-design/rate-limiting"}}');var a=i(474848),n=i(28453);const r={},o="Others",l={},d=[{value:"Grid FTP",id:"grid-ftp",level:2},{value:"Real-Time Analytics",id:"real-time-analytics",level:2},{value:"ALT (Aggregator Leaf Tailer) - Real-Time Analytics Without Pipelines",id:"alt-aggregator-leaf-tailer---real-time-analytics-without-pipelines",level:2},{value:"The ALT architecture described",id:"the-alt-architecture-described",level:3},{value:"Advantages of ALT",id:"advantages-of-alt",level:3},{value:"Dead Letter Queues",id:"dead-letter-queues",level:2},{value:"Systemantics",id:"systemantics",level:2},{value:"Notification System",id:"notification-system",level:2},{value:"Callbacks and Webhooks",id:"callbacks-and-webhooks",level:2},{value:"Callbacks",id:"callbacks",level:3},{value:"Webhooks",id:"webhooks",level:3},{value:"Updates",id:"updates",level:2},{value:"Hard updates",id:"hard-updates",level:3},{value:"Soft updates",id:"soft-updates",level:3},{value:"Distributed Locks",id:"distributed-locks",level:2},{value:"Top 6 Use Cases for Distributed Locks",id:"top-6-use-cases-for-distributed-locks",level:3}];function c(e){const s={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"others",children:"Others"})}),"\n",(0,a.jsx)(s.h2,{id:"grid-ftp",children:"Grid FTP"}),"\n",(0,a.jsxs)(s.p,{children:["GridFTPis an extension of the ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/File_Transfer_Protocol",children:"File Transfer Protocol (FTP)"})," for ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Grid_computing",children:"grid computing"}),".The protocol was defined within the GridFTP working group of the ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Open_Grid_Forum",children:"Open Grid Forum"}),". There are multiple implementations of the protocol; the most widely used is that provided by the ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Globus_Toolkit",children:"Globus Toolkit"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["The aim of GridFTP is to provide a more reliable and high performance file transfer, for example to enable the transmission of very large files. GridFTP is used extensively within large science projects such as the ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/LHC",children:"Large Hadron Collider"})," and by many supercomputer centers and other scientific facilities."]}),"\n",(0,a.jsx)(s.p,{children:"GridFTP also addresses the problem of incompatibility between storage and access systems. Previously, each data provider would make their data available in their own specific way, providing a library of access functions. This made it difficult to obtain data from multiple sources, requiring a different access method for each, and thus dividing the total available data into partitions. GridFTP provides a uniform way of accessing the data, encompassing functions from all the different modes of access, building on and extending the universally accepted FTP standard. FTP was chosen as a basis for it because of its widespread use, and because it has a well defined architecture for extensions to the protocol (which may be dynamically discovered)."}),"\n",(0,a.jsx)(s.p,{children:"Globus Toolkit - GSIFTP"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/GridFTP",children:"https://en.wikipedia.org/wiki/GridFTP"})}),"\n",(0,a.jsx)(s.h2,{id:"real-time-analytics",children:"Real-Time Analytics"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsx)(s.li,{children:"Ingestion"}),"\n",(0,a.jsx)(s.li,{children:"Store"}),"\n",(0,a.jsx)(s.li,{children:"Visualize"}),"\n",(0,a.jsx)(s.li,{children:"Act"}),"\n",(0,a.jsx)(s.li,{children:"Predict"}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"alt-aggregator-leaf-tailer---real-time-analytics-without-pipelines",children:"ALT (Aggregator Leaf Tailer) - Real-Time Analytics Without Pipelines"}),"\n",(0,a.jsx)(s.p,{children:"Aggregator Leaf Tailer (ALT)is the data architecture favored by web-scale companies, like Facebook, LinkedIn, and Google, for its efficiency and scalability."}),"\n",(0,a.jsx)(s.p,{children:"The ALT architecture addresses these shortcomings of Lambda architectures. The key component of ALT is a high-performance serving layer that serves complex queries, and not just key-value lookups. The existence of this serving layer obviates the need for complex data pipelines."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"image",src:i(424646).A+"",width:"960",height:"540"})}),"\n",(0,a.jsx)(s.h3,{id:"the-alt-architecture-described",children:"The ALT architecture described"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"The Tailer pulls new incoming data from a static or streaming source into an indexing engine. Its job is to fetch from all data sources, be it a data lake, like S3, or a dynamic source, like Kafka or Kinesis."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"The Leaf is a powerful indexing engine. It indexes all data as and when it arrives via the Tailer. The indexing component builds multiple types of indexes - inverted, columnar, document, geo, and many others - on the fields of a data set. The goal of indexing is to make any query on any data field fast."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"The scalable Aggregator tier is designed to deliver low-latency aggregations, be it columnar aggregations, joins, relevance sorting, or grouping. The Aggregators leverage indexing so efficiently that complex logic typically executed by pipeline software in other architectures can be executed on the fly as part of the query."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"advantages-of-alt",children:"Advantages of ALT"}),"\n",(0,a.jsx)(s.p,{children:"The ALT architecture enables the app developer or data scientist to run low-latency queries on raw data sets without any prior transformation. A large portion of the data transformation process can occur as part of the query itself. How is this possible in the ALT architecture?"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"Indexing is critical to making queries fast.The Leaves maintain a variety of indexes concurrently, so that data can be quickly accessed regardless of the type of query - aggregation, key-value, time series, or search. Every document and field is indexed, including both value and type of each field, resulting in fast query performance that allows significantly more complex data processing to be inserted into queries."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"Queries are distributed across a scalable Aggregator tier.The ability to scale the number of Aggregators, which provide compute and memory resources, allows compute power to be concentrated on any complex processing executed on the fly."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"The Tailer, Leaf, and Aggregator run as discrete microservices in disaggregated fashion.Each Tailer, Leaf, or Aggregator tier can be independently scaled up and down as needed. The system scales Tailers when there is more data to ingest, scales Leaves when data size grows, and scales Aggregators when the number or complexity of queries increases. This independent scalability allows the system to bring significant resources to bear on complex queries when needed, while making it cost-effective to do so."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"The most significant difference is that the Lambda architecture performs data transformations up front so that results are pre-materialized, while the ALT architecture allows for query on demand with on-the-fly transformations."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://rockset.com/blog/aggregator-leaf-tailer-an-architecture-for-live-analytics-on-event-streams",children:"https://rockset.com/blog/aggregator-leaf-tailer-an-architecture-for-live-analytics-on-event-streams"})}),"\n",(0,a.jsx)(s.h2,{id:"dead-letter-queues",children:"Dead Letter Queues"}),"\n",(0,a.jsxs)(s.p,{children:["In ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Message_queue",children:"message queueing"})," the dead letter queue is a service implementation to store messages that meet one or more of the following criteria:"]}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsx)(s.li,{children:"Message that is sent to a queue that does not exist."}),"\n",(0,a.jsx)(s.li,{children:"Queue length limit exceeded."}),"\n",(0,a.jsx)(s.li,{children:"Message length limit exceeded."}),"\n",(0,a.jsx)(s.li,{children:"Message is rejected by another queue exchange."}),"\n",(0,a.jsx)(s.li,{children:'Message reaches a threshold read counter number, because it is not consumed. Sometimes this is called a "back out queue".'}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"Dead letter queue storing of these messages allows developers to look for common patterns and potential software problems."}),"\n",(0,a.jsxs)(s.p,{children:["Queueing systems that incorporate dead letter queues include ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service",children:"Amazon Simple Queue Service"}),", ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Apache_ActiveMQ",children:"Apache ActiveMQ"}),", ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/HornetQ",children:"HornetQ"}),", ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Microsoft_Message_Queuing",children:"Microsoft Message Queuing"}),", ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/WebSphere_MQ",children:"WebSphere MQ"}),", ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Rabbit_MQ",children:"Rabbit MQ"})," and Apache Pulsar"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Dead_letter_queue",children:"https://en.wikipedia.org/wiki/Dead_letter_queue"})}),"\n",(0,a.jsxs)(s.p,{children:["Amazon SQS supports ",(0,a.jsx)(s.em,{children:"dead-letter queues"}),", which other queues (",(0,a.jsx)(s.em,{children:"source queues"}),") can target for messages that can't be processed (consumed) successfully. Dead-letter queues are useful for debugging your application or messaging system because they let you isolate problematic messages to determine why their processing doesn't succeed."]}),"\n",(0,a.jsxs)(s.p,{children:["Do use dead-letter queues to decrease the number of messages and to reduce the possibility of exposing your system to ",(0,a.jsx)(s.em,{children:"poison-pill messages"})," (messages that can be received but can't be processed)."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html",children:"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://aws.amazon.com/blogs/compute/designing-durable-serverless-apps-with-dlqs-for-amazon-sns-amazon-sqs-aws-lambda",children:"https://aws.amazon.com/blogs/compute/designing-durable-serverless-apps-with-dlqs-for-amazon-sns-amazon-sqs-aws-lambda"})}),"\n",(0,a.jsx)(s.h2,{id:"systemantics",children:"Systemantics"}),"\n",(0,a.jsxs)(s.p,{children:["General Systemantics(retitled toSystemanticsin its second edition andThe Systems Biblein its third) is a ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Systems_engineering",children:"systems engineering"})," treatise by ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/John_Gall_(author)",children:"John Gall"})," in which he offers practical principles of systems design based on experience and anecdotes.\nIt is offered from the perspective of hownotto design systems, based on system engineering failures. The primary precept of treatise is that large ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Complex_system",children:"complex systems"})," are extremely difficult to design correctly despite best intentions, so care must be taken to design smaller, less-complex systems and to do so with incremental functionality based on close and continual touch with user needs and measures of effectiveness."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Systemantics",children:"https://en.wikipedia.org/wiki/Systemantics"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://www.freecodecamp.org/news/have-an-idea-want-to-build-a-product-from-scratch-heres-a-checklist-of-things-you-should-go-through-in-your-backend-software-architecture",children:"https://www.freecodecamp.org/news/have-an-idea-want-to-build-a-product-from-scratch-heres-a-checklist-of-things-you-should-go-through-in-your-backend-software-architecture"})}),"\n",(0,a.jsx)(s.h2,{id:"notification-system",children:"Notification System"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["APNS - Apple Push Notification System - ",(0,a.jsx)(s.a,{href:"https://github.com/samuraisam/pyapns",children:"GitHub - samuraisam/pyapns: An APNS provider with multi-app support."})]}),"\n",(0,a.jsx)(s.li,{children:"FCM - Firebase Cloud Messaging"}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"callbacks-and-webhooks",children:"Callbacks and Webhooks"}),"\n",(0,a.jsx)(s.h3,{id:"callbacks",children:"Callbacks"}),"\n",(0,a.jsx)(s.p,{children:"Handoff from an external page back to your page, you can send a callback url, that System B will use to redirect back to when it's operation is finished."}),"\n",(0,a.jsx)(s.p,{children:"Ex - Swiggy -> Razorpay -> Back to swiggy after payment finishes"}),"\n",(0,a.jsx)(s.p,{children:"So swiggy will pass a callback url to razorpay, which razorpay will call after payment success/failure, so that user is directed back to swiggy, with status of payment, which swiggy can use to show appropriate page to users."}),"\n",(0,a.jsx)(s.h3,{id:"webhooks",children:"Webhooks"}),"\n",(0,a.jsx)(s.p,{children:"A webhook is a hook in the web. Typically used to make two distinct systems communicate and typically to go away from polling towards a publisher-subscriber model."}),"\n",(0,a.jsx)(s.h2,{id:"updates",children:"Updates"}),"\n",(0,a.jsx)(s.h3,{id:"hard-updates",children:"Hard updates"}),"\n",(0,a.jsx)(s.p,{children:"refer to when the user is forced to update the client version to a higher version number than what is installed on their mobile."}),"\n",(0,a.jsx)(s.h3,{id:"soft-updates",children:"Soft updates"}),"\n",(0,a.jsx)(s.p,{children:"refer to when the user is shown a prompt that a new version is available and they can update their app to the new version if they want to.\nHard updates are not encouraged, but there are times when you need to enforce them. Whatever the case you should definitely consider how you are going to implement this for your applications.\nYou can do this by implementing or configuring it in the Play Store or App Store. Another way is to create an API in your backend application that will be hit every time the mobile app is launched. This will send two keys: hard_update -> true/false and soft_update -> true/false, depending upon the user's version and the hard and soft update versions set in your backend system.\nA good place to store these versions is in your cache (Redis/Memcache), which you can change on the fly without needing to deploy your application."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://kentcdodds.com/blog/stop-using-client-side-route-redirects",children:"Stop using client-side route redirects"})}),"\n",(0,a.jsx)(s.h2,{id:"distributed-locks",children:"Distributed Locks"}),"\n",(0,a.jsx)(s.p,{children:"A distributed lock is a mechanism that ensures mutual exclusion across a distributed system."}),"\n",(0,a.jsx)(s.h3,{id:"top-6-use-cases-for-distributed-locks",children:"Top 6 Use Cases for Distributed Locks"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Leader Election -"})," Distributed locks can be used to ensure that only one node becomes the leader at any given time."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Task Scheduling -"})," In a distributed task scheduler, distributed locks ensure that a scheduled task is executed by only one worker node, preventing duplicate execution."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Resource Allocation -"})," When managing shared resources like file systems, network sockets, or hardware devices, distributed locks ensure that only one process can access the resource at a time."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Microservices Coordination -"})," When multiple microservices need to perform coordinated operations, such as updating related data in different databases, distributed locks ensure that these operations are performed in a controlled and orderly manner."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Inventory Management -"})," In e-commerce platforms, distributed locks can manage inventory updates to ensure that stock levels are accurately maintained when multiple users attempt to purchase the same item simultaneously."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Session Management -"})," When handling user sessions in a distributed environment, distributed locks can ensure that a user session is only modified by one server at a time, preventing inconsistencies."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"Distributed lock use cases",src:i(831950).A+"",width:"1000",height:"1156"})})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},831950:(e,s,i)=>{i.d(s,{A:()=>t});const t=i.p+"assets/images/Pasted image 20240924221049-2d06c1150100f533806fe9fb24f6ba29.jpg"},424646:(e,s,i)=>{i.d(s,{A:()=>t});const t=i.p+"assets/images/system-design-alt-Others-image1-cdfff464c5c151c9fb594758b656b6af.jpg"},28453:(e,s,i)=>{i.d(s,{R:()=>r,x:()=>o});var t=i(296540);const a={},n=t.createContext(a);function r(e){const s=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);