"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[2679],{666460:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"databases/indexing/indexing-questions","title":"Indexing Questions","description":"https://use-the-index-luke.com/3-minute-test/mysql","source":"@site/docs/databases/indexing/indexing-questions.md","sourceDirName":"databases/indexing","slug":"/databases/indexing/indexing-questions","permalink":"/databases/indexing/indexing-questions","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/databases/indexing/indexing-questions.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1739572825000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Heaped storage","permalink":"/databases/indexing/heaped-storage"},"next":{"title":"Indexing","permalink":"/databases/indexing/intro"}}');var i=s(474848),r=s(28453);const l={},d="Indexing Questions",a={},o=[{value:"Question 1",id:"question-1",level:2},{value:"Answer",id:"answer",level:3},{value:"Question 2",id:"question-2",level:2},{value:"Answer",id:"answer-1",level:3},{value:"Question 3",id:"question-3",level:2},{value:"Answer",id:"answer-2",level:3},{value:"Question 4",id:"question-4",level:2},{value:"Answer",id:"answer-3",level:3},{value:"Question 5",id:"question-5",level:2},{value:"Answer",id:"answer-4",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"indexing-questions",children:"Indexing Questions"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://use-the-index-luke.com/3-minute-test/mysql",children:(0,i.jsx)(n.strong,{children:"https://use-the-index-luke.com/3-minute-test/mysql"})})}),"\n",(0,i.jsx)(n.h2,{id:"question-1",children:"Question 1"}),"\n",(0,i.jsx)(n.p,{children:"Is the following index a good fit for the query?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (date_column)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT COUNT(*)\n  FROM tbl\n WHERE EXTRACT(YEAR FROM date_column) = 2017\n"})}),"\n",(0,i.jsx)(n.p,{children:"Your answer:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or query could improve performance"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"answer",children:"Answer"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or query could improve performance"]}),"\n",(0,i.jsx)(n.p,{children:"Wrapping the table column in a function renders this index mostly useless for this query."}),"\n",(0,i.jsx)(n.p,{children:"Note that the database could still read the full index end to end. Although this can be faster than reading the full table end to end, it is still not very efficient and considered not solution to this problem."}),"\n",(0,i.jsx)(n.h2,{id:"question-2",children:"Question 2"}),"\n",(0,i.jsx)(n.p,{children:"Is the following index a good fit for the query?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (a, date_column)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\n  FROM tbl\n WHERE a = 12\n ORDER BY date_column DESC\n LIMIT 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"Your answer:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or query could improve performance"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"answer-1",children:"Answer"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.p,{children:["The statement can run as an ",(0,i.jsx)(n.a,{href:"https://use-the-index-luke.com/sql/partial-results/top-n-queries",children:"indexed top-N query"}),". It performs just a ",(0,i.jsxs)(n.a,{href:"https://use-the-index-luke.com/sql/anatomy/the-tree",children:["B-tree traversal (",(0,i.jsx)(n.em,{children:"log(n)"}),")"]})," and a single table access."]}),"\n",(0,i.jsxs)(n.p,{children:["The trick is that the index supports the ",(0,i.jsx)(n.code,{children:"where"})," clause as well as the ",(0,i.jsx)(n.code,{children:"order by"})," clause. The database uses the index to find the last entry that matches the ",(0,i.jsx)(n.code,{children:"where"})," clause and takes it as result. Even though there is an ",(0,i.jsx)(n.code,{children:"order by"})," clause, there is no need to sort any rows."]}),"\n",(0,i.jsx)(n.h2,{id:"question-3",children:"Question 3"}),"\n",(0,i.jsxs)(n.p,{children:["Is the following index a good fit for ",(0,i.jsx)(n.strong,{children:"both queries"}),"?"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (a, b)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\n  FROM tbl\n WHERE a = 38\n   AND b = 1\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\n  FROM tbl\n WHERE b = 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"Your answer:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or a query could improve performance"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"answer-2",children:"Answer"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or a query could improve performance"]}),"\n",(0,i.jsx)(n.p,{children:"The index covers the first query only, the second query cannot use the index efficiently."}),"\n",(0,i.jsx)(n.p,{children:"Note that the database could still read the full index end to end. Although this can be faster than reading the full table end to end, it is still not very efficient and considered not solution to this problem."}),"\n",(0,i.jsx)(n.p,{children:"Changing the index column order makes the index suitable for both queries\u2014without additional overhead. The index should therefore look like this (columns exchanged):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (b, a)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"question-4",children:"Question 4"}),"\n",(0,i.jsx)(n.p,{children:"Is the following index a good fit for the query?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (text)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\n  FROM tbl\n WHERE text LIKE 'TJ%'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Your answer:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bad fit"}),": Changing the index or query could improve performance"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"answer-3",children:"Answer"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Good fit"}),": No need to change anything"]}),"\n",(0,i.jsxs)(n.p,{children:["Although ",(0,i.jsx)(n.code,{children:"like"})," expressions starting with a wild card character (",(0,i.jsx)(n.code,{children:"%"})," or ",(0,i.jsx)(n.code,{children:"_"}),") cannot use this index efficiently, a pattern that has the wild card character at the very end can! Even if the wild card character is in the middle, the index is still useful."]}),"\n",(0,i.jsx)(n.h2,{id:"question-5",children:"Question 5"}),"\n",(0,i.jsx)(n.p,{children:"This question is different. First consider the following index and query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX tbl_idx ON tbl (a, date_column)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT date_column, count(*)\n  FROM tbl\n WHERE a = 38\n GROUP BY date_column\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s say this query returns at least a few rows and that there is no other index on this table."}),"\n",(0,i.jsxs)(n.p,{children:["To implement a new functional requirement, another condition (",(0,i.jsx)(n.code,{children:"b = 1"}),") is added to the ",(0,i.jsx)(n.code,{children:"where"})," clause:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT date_column, count(*)\n  FROM tbl\n WHERE a = 38\n   AND b = 1\n GROUP BY date_column\n"})}),"\n",(0,i.jsx)(n.p,{children:"How will the change affect performance:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Same"}),": Query performance stays about the same"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Not enough information"}),": Definite answer cannot be given"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slower"}),": Query takes more time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster"}),": Query take less time"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"answer-4",children:"Answer"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Same"}),": Query performance stays about the same"]}),"\n",(0,i.jsx)(n.p,{children:"Wrong! The query will be slower."}),"\n",(0,i.jsxs)(n.p,{children:["The index happened to have all required data (columns) for the original query. It can run as so-called ",(0,i.jsx)(n.a,{href:"https://use-the-index-luke.com/sql/clustering/index-only-scan-covering-index",children:"index-only scan"}),", which doesn\u2019t need to access the actual table at all."]}),"\n",(0,i.jsxs)(n.p,{children:["Accessing any column that is not part of the index prevents this optimization so that the database must look into the actual table for each row that qualifies the original ",(0,i.jsx)(n.code,{children:"where"})," clause to see if it also satisfies the new filter. Even if the new filter removes ",(0,i.jsx)(n.em,{children:"all"})," rows, it does so after incurring additional work. Although the grouping has fewer rows to aggregate, this cannot compensate for the additional table look-ups."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var t=s(296540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);