"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[12600],{742904:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"data-structures/hashtable/dht-distributed-hash-tables","title":"DHT - Distributed Hash Tables","description":"A distributed hash table(DHT) is a class of a decentralized distributed system that provides a lookup service similar to a hash table: (key, value) pairs are stored in a DHT, and any participating node) can efficiently retrieve the value associated with a given key.Keysare unique identifiers which map to particularvalues, which in turn can be anything from addresses, to documents, to arbitrary data). Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to scale) to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures.","source":"@site/docs/data-structures/hashtable/dht-distributed-hash-tables.md","sourceDirName":"data-structures/hashtable","slug":"/data-structures/hashtable/dht-distributed-hash-tables","permalink":"/data-structures/hashtable/dht-distributed-hash-tables","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hashtable/dht-distributed-hash-tables.md","tags":[],"version":"current","lastUpdatedBy":"Deeapak Sood","lastUpdatedAt":1765917138000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Count-min Sketch","permalink":"/data-structures/hashtable/count-min-sketch"},"next":{"title":"Dictionaries","permalink":"/data-structures/hashtable/dictionaries"}}');var n=t(474848),a=t(28453);const r={},o="DHT - Distributed Hash Tables",h={},d=[{value:"Properties",id:"properties",level:2},{value:"Structure",id:"structure",level:2},{value:"Keyspace partitioning",id:"keyspace-partitioning",level:2},{value:"Overlay network",id:"overlay-network",level:2},{value:"References",id:"references",level:2}];function l(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"dht---distributed-hash-tables",children:"DHT - Distributed Hash Tables"})}),"\n",(0,n.jsxs)(i.p,{children:["A distributed hash table(DHT) is a class of a decentralized ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Distributed_computing",children:"distributed system"})," that provides a lookup service similar to a ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hash_table",children:"hash table"}),": (key, value) pairs are stored in a DHT, and any participating ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Node_(networking)",children:"node"})," can efficiently retrieve the value associated with a given key.Keysare unique identifiers which map to particularvalues, which in turn can be anything from addresses, to ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Electronic_document",children:"documents"}),", to arbitrary ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_(computing)",children:"data"}),". Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Scale_(computing)",children:"scale"})," to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures."]}),"\n",(0,n.jsxs)(i.p,{children:["DHTs form an infrastructure that can be used to build more complex services, such as ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Anycast",children:"anycast"}),", cooperative ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Web_cache",children:"Web caching"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Distributed_file_system",children:"distributed file systems"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Domain_name_system",children:"domain name services"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Instant_messaging",children:"instant messaging"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Multicast",children:"multicast"}),", and also ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Peer-to-peer",children:"peer-to-peer"}),(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/File_sharing",children:"file sharing"})," and ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Content_distribution",children:"content distribution"})," systems. Notable distributed networks that use DHTs include ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/BitTorrent_(protocol)",children:"BitTorrent"}),"'s distributed tracker, the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Coral_Content_Distribution_Network",children:"Coral Content Distribution Network"}),", the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Kad_network",children:"Kad network"}),", the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Storm_botnet",children:"Storm botnet"}),", the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tox_(protocol)",children:"Tox instant messenger"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Freenet",children:"Freenet"}),", the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/YaCy",children:"YaCy"})," search engine, and the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/InterPlanetary_File_System",children:"InterPlanetary File System"}),"."]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"image",src:t(762605).A+"",width:"500",height:"210"})}),"\n",(0,n.jsx)(i.h2,{id:"properties",children:"Properties"}),"\n",(0,n.jsx)(i.p,{children:"DHTs characteristically emphasize the following properties:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Decentralized_computing",children:"Autonomy and decentralization"}),": the nodes collectively form the system without any central coordination."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Fault_tolerance",children:"Fault tolerance"}),": the system should be reliable (in some sense) even with nodes continuously joining, leaving, and failing."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Scale_(computing)",children:"Scalability"}),": the system should function efficiently even with thousands or millions of nodes."]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["A key technique used to achieve these goals is that any one node needs to coordinate with only a few other nodes in the system -- most commonly, ",(0,n.jsx)(i.code,{children:"O(logn)"})," of then participants -- so that only a limited amount of work needs to be done for each change in membership."]}),"\n",(0,n.jsx)(i.h2,{id:"structure",children:"Structure"}),"\n",(0,n.jsxs)(i.p,{children:["The structure of a DHT can be decomposed into several main components.The foundation is an abstract keyspace, such as the set of 160-bit ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/String_(computer_science)",children:"strings"}),". A keyspace partitioning scheme splits ownership of this keyspace among the participating nodes. An overlay network then connects the nodes, allowing them to find the owner of any given key in the keyspace."]}),"\n",(0,n.jsx)(i.h2,{id:"keyspace-partitioning",children:"Keyspace partitioning"}),"\n",(0,n.jsxs)(i.p,{children:["Most DHTs use some variant of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Consistent_hashing",children:"consistent hashing"})," or ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Rendezvous_hashing",children:"rendezvous hashing"})," to map keys to nodes. The two algorithms appear to have been devised independently and simultaneously to solve the distributed hash table problem."]}),"\n",(0,n.jsxs)(i.p,{children:["Both consistent hashing and rendezvous hashing have the essential property that removal or addition of one node changes only the set of keys owned by the nodes with adjacent IDs, and leaves all other nodes unaffected. Contrast this with a traditional ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hash_table",children:"hash table"})," in which addition or removal of one bucket causes nearly the entire keyspace to be remapped. Since any change in ownership typically corresponds to ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bandwidth_(computing)",children:"bandwidth"}),"-intensive movement of objects stored in the DHT from one node to another, minimizing such reorganization is required to efficiently support high rates of churn (node arrival and failure)."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Consistent Hashing"}),"\n",(0,n.jsx)(i.li,{children:"Rendezvous Hashing"}),"\n",(0,n.jsx)(i.li,{children:"Locality-preserving Hashing"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"overlay-network",children:"Overlay network"}),"\n",(0,n.jsxs)(i.p,{children:["Each node maintains a set of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Data_link",children:"links"})," to other nodes (itsneighborsor ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Routing_table",children:"routing table"}),"). Together, these links form the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Overlay_network",children:"overlay network"}),". A node picks its neighbors according to a certain structure, called the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Network_topology",children:"network's topology"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["All DHT topologies share some variant of the most essential property: for any keyk, each node either has a node ID that ownskor has a link to a node whose node ID isclosertok, in terms of the keyspace distance defined above. It is then easy to route a message to the owner of any keykusing the following ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Greedy_algorithm",children:"greedy algorithm"}),"(that is not necessarily globally optimal): at each step, forward the message to the neighbor whose ID is closest tok. When there is no such neighbor, then we must have arrived at the closest node, which is the owner ofkas defined above. This style of routing is sometimes called ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Key-based_routing",children:"key-based routing"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Beyond basic routing correctness, two important constraints on the topology are to guarantee that the maximum number of ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hop_(networking)",children:"hops"})," in any route (route length) is low, so that requests complete quickly; and that the maximum number of neighbors of any node (maximum node ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Degree_(graph_theory)",children:"degree"}),") is low, so that maintenance overhead is not excessive. Of course, having shorter routes requires higher ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Maximum_degree",children:"maximum degree"}),". Some common choices for maximum degree and route length are as follows, wherenis the number of nodes in the DHT, using ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Big_O_notation",children:"Big O notation"}),":"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:(0,n.jsx)(i.strong,{children:"Max. degree"})}),(0,n.jsx)(i.th,{children:(0,n.jsx)(i.strong,{children:"Max route length"})}),(0,n.jsx)(i.th,{children:(0,n.jsx)(i.strong,{children:"Used in"})}),(0,n.jsx)(i.th,{children:(0,n.jsx)(i.strong,{children:"Note"})})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"O(1)"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"O(n)"})}),(0,n.jsx)(i.td,{children:"Worst lookup lengths, with likely much slower lookups times"}),(0,n.jsx)(i.td,{})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"O(log n)"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"O(log n)"})}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Chord_(peer-to-peer)",children:"Chord"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Kademlia",children:"Kademlia"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Pastry_(DHT)",children:"Pastry"}),", ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Tapestry_(DHT)",children:"Tapestry"})]}),(0,n.jsx)(i.td,{children:"Most common, but not optimal (degree/route length). Chord is the most basic version, with Kademlia seeming the most popular optimized variant (should have improved average lookup)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"O(log n)"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"O(log n / log(log(n))"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Koorde",children:"Koorde"})}),(0,n.jsx)(i.td,{children:"Likely would be more complex to implement, but lookups might be faster (have a lower worst case bound)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"O(sqrt(x))"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"O(1)"})}),(0,n.jsx)(i.td,{children:"Worst local storage needs, with lots of communication after any node connects or disconnects"}),(0,n.jsx)(i.td,{})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Distributed_hash_table",children:"https://en.wikipedia.org/wiki/Distributed_hash_table"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"/data-structures/hashtable/kademlia",children:"Kademlia"})})]})}function c(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},762605:(e,i,t)=>{t.d(i,{A:()=>s});const s=t.p+"assets/images/DHT-Distributed-Hash-Tables-image1-a7740ab326a8a2eb1341d4442f6ffa17.jpg"},28453:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>o});var s=t(296540);const n={},a=s.createContext(n);function r(e){const i=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(a.Provider,{value:i},e.children)}}}]);