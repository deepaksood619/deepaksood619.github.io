"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[32890],{173666:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>h,default:()=>c,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var i=s(785893),a=s(511151);const t={},h="Hashing",l={id:"data-structures/hashtable/hashing",title:"Hashing",description:"https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial",source:"@site/docs/data-structures/hashtable/hashing.md",sourceDirName:"data-structures/hashtable",slug:"/data-structures/hashtable/hashing",permalink:"/data-structures/hashtable/hashing",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hashtable/hashing.md",tags:[],version:"current",lastUpdatedAt:1732812944,formattedLastUpdatedAt:"Nov 28, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hashing Techniques",permalink:"/data-structures/hashtable/hashing-techniques"},next:{title:"HyperLogLog",permalink:"/data-structures/hashtable/hyperloglog"}},r={},o=[{value:"Hash Function",id:"hash-function",level:2},{value:"Consistent Hashing",id:"consistent-hashing",level:2},{value:"How Consistent Hashing Works",id:"how-consistent-hashing-works",level:3},{value:"1. Hash Ring",id:"1-hash-ring",level:4},{value:"2. Data Assignment",id:"2-data-assignment",level:4},{value:"3. Node Addition/Removal",id:"3-node-additionremoval",level:4},{value:"Implementation",id:"implementation",level:3},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Algorithms",id:"algorithms",level:3},{value:"1. Classic Consistent Hashing",id:"1-classic-consistent-hashing",level:4},{value:"2. Maglev Hashing",id:"2-maglev-hashing",level:4},{value:"3. Jump Consistent Hashing",id:"3-jump-consistent-hashing",level:4},{value:"4. Rendezvous Hashing (Highest Random Weight Hashing)",id:"4-rendezvous-hashing-highest-random-weight-hashing",level:4},{value:"5. Consistent Hashing with Virtual Nodes",id:"5-consistent-hashing-with-virtual-nodes",level:4},{value:"6. Weighted Consistent Hashing",id:"6-weighted-consistent-hashing",level:4},{value:"Modular based hashing",id:"modular-based-hashing",level:2},{value:"Applications",id:"applications",level:3},{value:"Solution to pathological data set",id:"solution-to-pathological-data-set",level:3},{value:"Universal Hashing",id:"universal-hashing",level:2},{value:"Perfect Hash Function",id:"perfect-hash-function",level:2},{value:"Hashing Integer Data Types",id:"hashing-integer-data-types",level:2},{value:"Hashing Variable Length Data",id:"hashing-variable-length-data",level:2},{value:"2-choice Hashing",id:"2-choice-hashing",level:2},{value:"2-left Hashing",id:"2-left-hashing",level:2},{value:"Hash Table Implementations",id:"hash-table-implementations",level:2},{value:"Locality Sensitive Hashing (LSH)",id:"locality-sensitive-hashing-lsh",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"hashing",children:"Hashing"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial",children:"https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial"})}),"\n",(0,i.jsx)(n.h2,{id:"hash-function",children:"Hash Function"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"hash function"})," is any ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Function_(mathematics)",children:"function"})," that can be used to map ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Data_(computing)",children:"data"})," of arbitrary size to data of fixed size. The values returned by a hash function are called ",(0,i.jsx)(n.em,{children:"hash values"}),",",(0,i.jsx)(n.em,{children:"hash codes"}),", ",(0,i.jsx)(n.em,{children:"digests"}),", or simply ",(0,i.jsx)(n.em,{children:"hashes"}),". The values are used to index a fixed-size table called a ",(0,i.jsx)(n.em,{children:"hash table"}),". Use of a hash function to index a hash table is called ",(0,i.jsx)(n.em,{children:"hashing"})," or ",(0,i.jsx)(n.em,{children:"scatter storage addressing"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"consistent-hashing",children:"Consistent Hashing"}),"\n",(0,i.jsx)(n.p,{children:"Consistent Hashing is a special kind of hashing such that when a hash table is resized, only K/n keys need to be remapped on average, where K is the number of the keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and slots are defined by a modular operation."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Consistent hashing"})," is a key concept in distributed systems, especially for load balancing, distributed caching, and data partitioning. Unlike standard hashing techniques that can cause significant reorganization when nodes are added or removed, consistent hashing minimizes disruption by redistributing only a fraction of the data."]}),"\n",(0,i.jsx)(n.h3,{id:"how-consistent-hashing-works",children:"How Consistent Hashing Works"}),"\n",(0,i.jsx)(n.h4,{id:"1-hash-ring",children:"1. Hash Ring"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keys and nodes are hashed into the same numeric space (often visualized as a circle or ring)."}),"\n",(0,i.jsx)(n.li,{children:"The hash function maps both nodes (e.g., servers) and keys (e.g., data items) onto this ring."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"2-data-assignment",children:"2. Data Assignment"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A key is assigned to the first node that is encountered in a clockwise direction on the ring."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"3-node-additionremoval",children:"3. Node Addition/Removal"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When a node is added, it only affects the keys that fall between it and the previous node in the ring."}),"\n",(0,i.jsx)(n.li,{children:"When a node is removed, only the keys that were assigned to it need reassignment."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import hashlib\n\nclass ConsistentHashing:\n    def __init__(self, nodes=None, replicas=3):\n        self.replicas = replicas\n        self.ring = {}\n        self.sorted_keys = []\n        if nodes:\n            for node in nodes:\n                self.add_node(node)\n\n    def hash(self, key):\n        return int(hashlib.md5(key.encode('utf-8')).hexdigest(), 16)\n\n    def add_node(self, node):\n        for i in range(self.replicas):\n            hash_val = self.hash(f\"{node}:{i}\")\n            self.ring[hash_val] = node\n            self.sorted_keys.append(hash_val)\n        self.sorted_keys.sort()\n\n    def remove_node(self, node):\n        for i in range(self.replicas):\n            hash_val = self.hash(f\"{node}:{i}\")\n            del self.ring[hash_val]\n            self.sorted_keys.remove(hash_val)\n\n    def get_node(self, key):\n        if not self.ring:\n            return None\n        hash_val = self.hash(key)\n        for h in self.sorted_keys:\n            if hash_val <= h:\n                return self.ring[h]\n        return self.ring[self.sorted_keys[0]]\n\n# Example Usage\nnodes = ['Node1', 'Node2', 'Node3']\nch = ConsistentHashing(nodes)\nprint(ch.get_node('my_data_key'))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces data movement during scaling"}),"\n",(0,i.jsx)(n.li,{children:"Provides a fair and balanced distribution"}),"\n",(0,i.jsx)(n.li,{children:"Supports redundancy with ease for high availability"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Requires a reliable hash function to minimize hotspots"}),"\n",(0,i.jsx)(n.li,{children:"Managing virtual nodes adds complexity"}),"\n",(0,i.jsx)(n.li,{children:"May require additional mechanisms for replication and failure handling"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"algorithms",children:"Algorithms"}),"\n",(0,i.jsx)(n.h4,{id:"1-classic-consistent-hashing",children:"1. Classic Consistent Hashing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": Maps both keys and nodes onto a circular hash ring. Each key is assigned to the closest node in the ring (moving clockwise)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Distributed caching (e.g., Memcached), load balancing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimal data movement when nodes are added or removed."}),"\n",(0,i.jsx)(n.li,{children:"Balances data across nodes based on their position on the ring."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example Libraries"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Python: ",(0,i.jsx)(n.code,{children:"hash_ring"})]}),"\n",(0,i.jsxs)(n.li,{children:["Java: ",(0,i.jsx)(n.code,{children:"Ketama"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"2-maglev-hashing",children:"2. Maglev Hashing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": Developed by Google, Maglev hashing creates a consistent, precomputed lookup table for faster key-to-node mapping."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": High-performance load balancing in network services."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simple implementation."}),"\n",(0,i.jsx)(n.li,{children:"Ensures minimal disruption and balanced loads when adding or removing nodes."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Used in Google\u2019s load balancers."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"3-jump-consistent-hashing",children:"3. Jump Consistent Hashing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": A non-ring-based hashing technique that directly maps keys to a fixed set of buckets."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Scenarios with a known, fixed number of buckets."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High performance (O(1) operations)."}),"\n",(0,i.jsx)(n.li,{children:"Minimal movement of keys."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Popular in cloud storage systems and databases."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"4-rendezvous-hashing-highest-random-weight-hashing",children:"4. Rendezvous Hashing (Highest Random Weight Hashing)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": Keys are mapped to nodes by calculating a weight for each key-node pair and assigning the key to the node with the highest weight."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Distributed databases, consistent key-to-node mapping."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Provides optimal load balancing."}),"\n",(0,i.jsx)(n.li,{children:"Resilient to node failures."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Used in distributed systems like Amazon DynamoDB."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"5-consistent-hashing-with-virtual-nodes",children:"5. Consistent Hashing with Virtual Nodes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": Adds virtual nodes (or replicas) for each physical node on the hash ring to ensure even data distribution."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Systems with unevenly loaded or heterogeneous nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces the risk of hotspots."}),"\n",(0,i.jsx)(n.li,{children:"Improves load distribution for systems with varying node capacities."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Used in Apache Cassandra and Amazon Dynamo."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"6-weighted-consistent-hashing",children:"6. Weighted Consistent Hashing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overview"}),": Assigns weights to nodes, ensuring that higher-capacity nodes are responsible for more keys."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Heterogeneous systems with nodes of varying capabilities."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Balances the load according to node capacity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Used in CDN services and distributed storage systems."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf",children:"https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.toptal.com/big-data/consistent-hashing",children:"The Ultimate Guide to Consistent Hashing | Toptal"})}),"\n",(0,i.jsx)(n.h2,{id:"modular-based-hashing",children:"Modular based hashing"}),"\n",(0,i.jsx)(n.h3,{id:"applications",children:"Applications"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Associative arrays:"})," Hash tables are commonly used to implement many types of in-memory tables. They are used to implement associative arrays (arrays whose indices are arbitrary strings or other complicated objects)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database indexing:"})," Hash tables may also be used as disk-based data structures and database indices (such as in dbm)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Caches:"})," Hash tables can be used to implement caches i.e. auxiliary data tables that are used to speed up the access to data, which is primarily stored in slower media."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Object representation:"})," Several dynamic languages, such as Perl, Python, JavaScript, and Ruby use hash tables to implement objects."]}),"\n",(0,i.jsx)(n.li,{children:"Hash Functions are used in various algorithms to make their computing faster"}),"\n",(0,i.jsxs)(n.li,{children:["De-Duplication","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Remove duplicates","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Report unique visitors to web site"}),"\n",(0,i.jsx)(n.li,{children:"avoid duplicates in search results"}),"\n",(0,i.jsx)(n.li,{children:"Do not crawl same page twice"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Symbol tables in compilers"}),"\n",(0,i.jsx)(n.li,{children:"Blocking network traffic"}),"\n",(0,i.jsxs)(n.li,{children:["Search algorithms (e.g. game tree exploration)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"use hash table to avoid exploring any configuration (e.g. arrangement of chess pieces) more than once"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"How to choose n = # of buckets (When using modulus to hash values to buckets)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Choose n to be prime (should be few factors, within constant factor of # of objects in table)"}),"\n",(0,i.jsx)(n.li,{children:"not too close to a power of 2"}),"\n",(0,i.jsx)(n.li,{children:"not too close to a power of 10"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The load of a hash table"}),"\n",(0,i.jsx)(n.p,{children:"alpha = # of objects in hash table / # of buckets of hash table"}),"\n",(0,i.jsx)(n.p,{children:"Question - which hash table implementation strategy is feasible for load factors larger than 1 (Answer - Only chaining, because # of objects are greater than # of buckets, so only using linked list for collision can be used)"}),"\n",(0,i.jsxs)(n.p,{children:["Therefore load factor for a hash table must be ",(0,i.jsx)(n.code,{children:"<< 1"}),", for constant time operations, since if chaining is used, than we have to use exhaustive search for getting values whose key hash to same place"]}),"\n",(0,i.jsx)(n.p,{children:"So if load factor increases, we increase the number of buckets."}),"\n",(0,i.jsxs)(n.p,{children:["A super hash function, that can handle all types of data ",(0,i.jsx)(n.strong,{children:"does not exists"})," (for every hash function there exists a pathological data set)"]}),"\n",(0,i.jsx)(n.h3,{id:"solution-to-pathological-data-set",children:"Solution to pathological data set"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use a cryptographic hash function (e.g. SHA-2)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This works because it's infeasible to reverse engineer a pathological data set"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use randomization"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'Deisgn a family of hash function, and choose randomly. Such that, for all data sets S, "almost all" functions spread out "pretty evenly"'}),"\n",(0,i.jsx)(n.h2,{id:"universal-hashing",children:"Universal Hashing"}),"\n",(0,i.jsx)(n.h2,{id:"perfect-hash-function",children:"Perfect Hash Function"}),"\n",(0,i.jsx)(n.p,{children:"A hash function that maps each item into a unique slot is referred to as a perfect hash function."}),"\n",(0,i.jsx)(n.h2,{id:"hashing-integer-data-types",children:"Hashing Integer Data Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Identity Hash Function"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Trivial Hash Function"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Folding Method"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The folding method for constructing the hash functions begins by dividing the item into equal-size pieces (the last piece may not be of equal size)"}),"\n",(0,i.jsxs)(n.li,{children:["These pieces are then added together to give the resulting hash value.- ",(0,i.jsx)(n.strong,{children:"Mid-square method"})]}),"\n",(0,i.jsx)(n.li,{children:"We first square the item, and then extract some portion of the resulting digits."}),"\n",(0,i.jsx)(n.li,{children:"For example, if the item were 44, we would first compute 44^2^ = 1936"}),"\n",(0,i.jsxs)(n.li,{children:["By extracting the middle two digits, 93, and performing the remainder step, we get 93 % 11 = 5- ",(0,i.jsx)(n.strong,{children:"Division hashing"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Algebraic coding"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Unique permuatation hashing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Multiplicative hashing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Fibonacci hashing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Zobrist hashing"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"hashing-variable-length-data",children:"Hashing Variable Length Data"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Middle and ends"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Character folding"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Word length folding"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Radix conversion hashing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Rolling hash"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"2-choice-hashing",children:"2-choice Hashing"}),"\n",(0,i.jsx)(n.p,{children:"Explain the 2-choice hashing algorithm for exact-match hash tables."}),"\n",(0,i.jsx)(n.p,{children:"In the 2-choice hashing algorithm, we use two independent hash functions to compute two separate indices into the hash table. Then, we look at both indices and find whichever one has lower occupancy.We insert a new element at this index. To lookup an element, we again hash the element using both hash functons to find 2 indices, and compare the element against the elements stored at each of the 2 indices."}),"\n",(0,i.jsx)(n.p,{children:"On what metric is the 2-choice algorithm better than the standard hashing algorithm? Why?"}),"\n",(0,i.jsx)(n.p,{children:"The 2-choice algorithm is better on the metric of likelihood of overflowing the hash tables given a certain number of inserts into the hash table (equivalently, given a certain occupancy ratio). This is because the 2-choice algorithm explicitly favors the hash table location that has lower occupancy, which means that it is less likely to overflow an already full location in the hash table. The standard hashing algorithm, on the other hand, pays no attention to how occupied a location is."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/2-choice_hashing",children:"https://en.wikipedia.org/wiki/2-choice_hashing"})}),"\n",(0,i.jsx)(n.h2,{id:"2-left-hashing",children:"2-left Hashing"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"https://xlinux.nist.gov/dads/HTML/dictionary.html",children:"dictionary"})," implemented with two ",(0,i.jsx)(n.a,{href:"https://xlinux.nist.gov/dads/HTML/hashtab.html",children:"hash tables"})," of equal size, T1and T2, and two different ",(0,i.jsx)(n.a,{href:"https://xlinux.nist.gov/dads/HTML/hash.html",children:"hash functions"}),", h1and h2. A new ",(0,i.jsx)(n.a,{href:"https://xlinux.nist.gov/dads/HTML/key.html",children:"key"})," is put in table 2 only if there are fewer (colliding) keys at T2 [h2(key)] than at T1 [h1(key)], otherwise it is put in table 1. With n keys and two tables of size n/2, the most collisions is 0.69... log2ln n +",(0,i.jsx)(n.a,{href:"https://xlinux.nist.gov/dads/HTML/bigOnotation.html",children:"O"}),"(1) with high probability."]}),"\n",(0,i.jsx)(n.h2,{id:"hash-table-implementations",children:"Hash Table Implementations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Using Array"}),"\n",(0,i.jsx)(n.li,{children:"Alternatively, we can implement the hash table with a binary search tree. We can then guarantee an 0(log n) lookup time, since we can keep the tree balanced. Additionally, we may use less space, since a large array no longer needs to be allocated in the very beginning."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"locality-sensitive-hashing-lsh",children:"Locality Sensitive Hashing (LSH)"}),"\n",(0,i.jsxs)(n.p,{children:['In computer science, locality-sensitive hashing(LSH) is an algorithmic technique that hashes similar input items into the same "buckets" with high probability.(The number of buckets are much smaller than the universe of possible input items.)Since similar items end up in the same buckets, this technique can be used for ',(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cluster_analysis",children:"data clustering"})," and ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Nearest_neighbor_search",children:"nearest neighbor search"}),". It differs from ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hash_function",children:"conventional hashing techniques"})," in that hash collisions are maximized, not minimized. Alternatively, the technique can be seen as a way to ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dimension_reduction",children:"reduce the dimensionality"})," of high-dimensional data; high-dimensional input items can be reduced to low-dimensional versions while preserving relative distances between items."]}),"\n",(0,i.jsxs)(n.p,{children:["Hashing-based approximate ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Nearest_neighbor_search",children:"nearest neighbor search"})," algorithms generally use one of two main categories of hashing methods: either data-independent methods, such as locality-sensitive hashing (LSH); or data-dependent methods, such as ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Locality-preserving_hashing",children:"Locality-preserving hashing"}),"(LPH)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Locality-sensitive_hashing",children:"https://en.wikipedia.org/wiki/Locality-sensitive_hashing"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134",children:"https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134"})}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Birthday Paradox"}),"\n",(0,i.jsx)(n.li,{children:"Pigeonhole Principle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hash_function",children:"https://en.wikipedia.org/wiki/Hash_function"})})]})}function c(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},511151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>h});var i=s(667294);const a={},t=i.createContext(a);function h(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:h(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);