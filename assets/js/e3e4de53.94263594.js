"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[29690],{807849:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var n=i(785893),s=i(511151);const r={},o="Quick Sort",a={id:"algorithms/searching-sorting/quick-sort",title:"Quick Sort",description:"Quicksortis performed by taking the first (leftmost) element of the array as a pivot point. We then compare it to each following element. When we find one that is smaller, we move it to the left. The moving is performed quickly by swapping that element with the first element after the pivot point, and then swapping the pivot point with the element after it. After going through the whole array, we take all points on the left of the pivot and call quicksort on that subarray, and we do the same to all points on the right of the pivot. The recursion is performed until we reach subarrays of 0-1 elements in length.",source:"@site/docs/algorithms/searching-sorting/quick-sort.md",sourceDirName:"algorithms/searching-sorting",slug:"/algorithms/searching-sorting/quick-sort",permalink:"/algorithms/searching-sorting/quick-sort",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/searching-sorting/quick-sort.md",tags:[],version:"current",lastUpdatedAt:1707138374,formattedLastUpdatedAt:"Feb 5, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Others",permalink:"/algorithms/searching-sorting/others"},next:{title:"Selection Sort",permalink:"/algorithms/searching-sorting/selection-sort"}},l={},h=[{value:"Properties",id:"properties",level:2},{value:"Basic Plan",id:"basic-plan",level:2},{value:"Pivot element",id:"pivot-element",level:2},{value:"When does the worst case of Quicksort occur?",id:"when-does-the-worst-case-of-quicksort-occur",level:2},{value:"Further Readings",id:"further-readings",level:2}];function c(e){const t={h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,n.jsx)(t.p,{children:"Quicksortis performed by taking the first (leftmost) element of the array as a pivot point. We then compare it to each following element. When we find one that is smaller, we move it to the left. The moving is performed quickly by swapping that element with the first element after the pivot point, and then swapping the pivot point with the element after it. After going through the whole array, we take all points on the left of the pivot and call quicksort on that subarray, and we do the same to all points on the right of the pivot. The recursion is performed until we reach subarrays of 0-1 elements in length."}),"\n",(0,n.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"In-place"}),"\n",(0,n.jsx)(t.li,{children:"Not stable"}),"\n",(0,n.jsx)(t.li,{children:"Best Case - N lg N ( N lg N compares)"}),"\n",(0,n.jsx)(t.li,{children:"Worst Case - Quadratic - N^2 (1/2 N^2 compares)"}),"\n",(0,n.jsxs)(t.li,{children:["Average Case ~ 1.39 N lg N","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"39% more compares than mergesort"}),"\n",(0,n.jsx)(t.li,{children:"But faster than mergesort in practice because less data movement"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"basic-plan",children:"Basic Plan"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Shuffle the array"}),"\n",(0,n.jsxs)(t.li,{children:["Partition so that, for some j","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Entry a[j] is in place"}),"\n",(0,n.jsx)(t.li,{children:"No larger entry to the left of j"}),"\n",(0,n.jsx)(t.li,{children:"No smaller entry to the right of j"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"Sort each piece recursively"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"pivot-element",children:"Pivot element"}),"\n",(0,n.jsx)(t.p,{children:"Code -"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Partitioning"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(830281).Z+"",width:"1099",height:"700"})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Sort"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:i(733776).Z+"",width:"1099",height:"594"})}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Improvements"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Insertion sort small subarrays","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Too much overhead for tiny subarrays"}),"\n",(0,n.jsx)(t.li,{children:"Cutoff to insertion sort for ~ 10 items"}),"\n",(0,n.jsx)(t.li,{children:"Note: delay insertion sort until one pass at end"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["Median of sample","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Best choice of pivot item = median"}),"\n",(0,n.jsx)(t.li,{children:"Estimate true median by taking median of sample"}),"\n",(0,n.jsx)(t.li,{children:"Median-of-3 (random) items"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Why QuickSort is faster than MergeSort -"}),"\n",(0,n.jsx)(t.p,{children:"Because QuickSort doesn't do a lot of data movements (MergeSort moves data in and out of the auxiliary array)"}),"\n",(0,n.jsx)(t.h2,{id:"when-does-the-worst-case-of-quicksort-occur",children:"When does the worst case of Quicksort occur?"}),"\n",(0,n.jsx)(t.p,{children:"The answer depends on strategy for choosing pivot. In early versions of Quick Sort where leftmost (or rightmost) element is chosen as pivot, the worst occurs in following cases."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Array is already sorted in same order."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Array is already sorted in reverse order."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"All elements are same (special case of case 1 and 2)"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Since these cases are very common use cases, the problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the median of the first, middle and last element of the partition for the pivot. With these modifications, the worst case of Quick sort has less chances to occur, but worst case can still occur if the input array is such that the maximum (or minimum) element is always chosen as pivot."}),"\n",(0,n.jsx)(t.h2,{id:"further-readings",children:"Further Readings"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Quick Select - A quicksort variant which finds the kth smallest item in linear time"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},830281:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/Quick-Sort-image1-edc4247d5a8d003977900a797b0d9228.jpg"},733776:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/Quick-Sort-image2-f7ccea0f109067a0c45ee30d8e45c1f2.jpg"},511151:(e,t,i)=>{i.d(t,{Z:()=>a,a:()=>o});var n=i(667294);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);