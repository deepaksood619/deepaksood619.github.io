"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[60691],{776297:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>o,toc:()=>u});var a=s(785893),r=s(511151);const n={},i="Questions",o={id:"data-structures/hashtable/questions",title:"Questions",description:"Hash Table",source:"@site/docs/data-structures/hashtable/questions.md",sourceDirName:"data-structures/hashtable",slug:"/data-structures/hashtable/questions",permalink:"/data-structures/hashtable/questions",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hashtable/questions.md",tags:[],version:"current",lastUpdatedAt:1701793554,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Probabilistic Data Structure",permalink:"/data-structures/hashtable/probabilistic-data-structure"},next:{title:"Verkle Trees",permalink:"/data-structures/hashtable/verkle-trees"}},d={},u=[{value:"Hash Table",id:"hash-table",level:2},{value:"Why databases use ordered indexes but programming uses hash tables",id:"why-databases-use-ordered-indexes-but-programming-uses-hash-tables",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"questions",children:"Questions"}),"\n",(0,a.jsx)(t.h2,{id:"hash-table",children:"Hash Table"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Find symmetric pairs in an array"}),"\n",(0,a.jsx)(t.li,{children:"Trace complete path of a journey"}),"\n",(0,a.jsx)(t.li,{children:"Find if an array is a subset of another array"}),"\n",(0,a.jsx)(t.li,{children:"Check if given arrays are disjoint"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"why-databases-use-ordered-indexes-but-programming-uses-hash-tables",children:"Why databases use ordered indexes but programming uses hash tables"}),"\n",(0,a.jsx)(t.p,{children:'B-Trees are more "general purpose," which results in lower "total cost" for very large persistent data. In other words, even though they are slower for single value accesses that make up the majority of the workload, they are better when you consider rare operations and the cost of multiple indexes.'}),"\n",(0,a.jsx)(t.p,{children:"And also range queries are better in B-Trees than in Hash Tables"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.evanjones.ca/ordered-vs-unordered-indexes.html",children:"https://www.evanjones.ca/ordered-vs-unordered-indexes.html"})})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},511151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>i});var a=s(667294);const r={},n=a.createContext(r);function i(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);