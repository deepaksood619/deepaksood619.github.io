"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[60890],{632336:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var a=s(785893),n=s(511151);const o={},i="Others",r={id:"technologies/kafka/others",title:"Others",description:"Message Processing Guarantees",source:"@site/docs/technologies/kafka/others.md",sourceDirName:"technologies/kafka",slug:"/technologies/kafka/others",permalink:"/technologies/kafka/others",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/others.md",tags:[],version:"current",lastUpdatedAt:1708929300,formattedLastUpdatedAt:"Feb 26, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Monitoring",permalink:"/technologies/kafka/monitoring"},next:{title:"Security",permalink:"/technologies/kafka/security"}},c={},l=[{value:"Message Processing Guarantees",id:"message-processing-guarantees",level:2},{value:"Storage formats: Serialization and deserialization of events",id:"storage-formats-serialization-and-deserialization-of-events",level:2},{value:"Data contracts, schema on read, and schema on write",id:"data-contracts-schema-on-read-and-schema-on-write",level:2},{value:"Other Stream Processing Brokers",id:"other-stream-processing-brokers",level:2},{value:"Kafka Connect Dead Letter Queues",id:"kafka-connect-dead-letter-queues",level:2},{value:"Kafka Edge Computing",id:"kafka-edge-computing",level:2},{value:"Kafka Gotchas",id:"kafka-gotchas",level:2},{value:"Compression",id:"compression",level:2},{value:"Secor",id:"secor",level:2},{value:"Others",id:"others-1",level:2}];function h(e){const t={a:"a",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"others",children:"Others"}),"\n",(0,a.jsx)(t.h2,{id:"message-processing-guarantees",children:"Message Processing Guarantees"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No guarantee-"})," No explicit guarantee is provided, so consumers may process messages once, multiple times or never at all."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"At most once-"}),' This is "best effort" delivery semantics. Consumers will receive and process messages exactly once or not at all.']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"At least once-"})," Consumers will receive and process every message, but they may process the same message more than once."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Effectively once-"})," Also ",(0,a.jsx)(t.a,{href:"https://streaml.io/blog/exactly-once",children:"contentiously"}),(0,a.jsx)(t.a,{href:"https://medium.com/@jaykreps/exactly-once-support-in-apache-kafka-55e1fdd0a35f",children:"known"})," as exactly once, this promises consumers will process every message once."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:s(814026).Z+"",width:"525",height:"409"})}),"\n",(0,a.jsx)(t.h2,{id:"storage-formats-serialization-and-deserialization-of-events",children:"Storage formats: Serialization and deserialization of events"}),"\n",(0,a.jsxs)(t.p,{children:['Events areserializedwhen they are written to a topic anddeserializedwhen they are read. These operations turn binary data into the forms you and I understand, and vice versa. Importantly, these operations are done solely by the Kafkaclients, i.e., producing and consuming applications such as ksqlDB, Kafka Streams, or a microservice using the Go client for Kafka, for example. As such, there is no single "storage format" in Kafka. Common serialization formats used by Kafka clients include Apache Avro\u2122 (with the ',(0,a.jsx)(t.a,{href:"https://docs.confluent.io/current/schema-registry/index.html",children:"Confluent Schema Registry"}),"), Protobuf, and JSON."]}),"\n",(0,a.jsx)(t.p,{children:'Kafka brokers, on the other hand, are agnostic to the serialization format or "type" of a stored event. All they see is a pair of raw bytes for event key and event value coming in when being written, and going out when being read. Brokers thus have no idea what\'s in the data they serve - it\'s a black box to them. Being this "dumb" is actually pretty smart, because this design decision allows brokers to scale much better than traditional messaging systems.'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.confluent.io/blog/avro-kafka-data",children:"https://www.confluent.io/blog/avro-kafka-data"})}),"\n",(0,a.jsx)(t.h2,{id:"data-contracts-schema-on-read-and-schema-on-write",children:"Data contracts, schema on read, and schema on write"}),"\n",(0,a.jsx)(t.p,{children:"As already mentioned, it is the responsibility of the consuming client (whether it's ksqlDB, Kafka Connect, a custom Kafka consumer, etc.) to deserialize the raw bytes of a Kafka message into the original event by applying some kind of schema, be it a formalized schema in Avro or Protobuf, or an informal JSON format scribbled on the back of a napkin in the company canteen. This means it is, generally speaking, a schema-on-read setup."}),"\n",(0,a.jsxs)(t.p,{children:["But how does a consuming client know how to deserialize stored events, given that most likely a different client produced them? The answer is that producers and consumers must agree on a data contract in some way. Gwen Shapira covered the important subject of ",(0,a.jsx)(t.a,{href:"https://www.confluent.io/blog/schemas-contracts-compatibility",children:"data contracts and schema management"})," in an earlier blog post, so I'll skip over the details here. But in summary, the easiest option is to use Avro and ",(0,a.jsx)(t.a,{href:"https://www.confluent.io/confluent-schema-registry/",children:"Confluent Schema Registry"}),". With a schema registry and a formalized schema (including but not limited to Avro), we are moving from schema on read into ",(0,a.jsx)(t.a,{href:"https://www.oreilly.com/ideas/data-governance-and-the-death-of-schema-on-read",children:"schema-on-write territory"}),', which is a boon for pretty much everyone who is working with data, not just the few poor souls of us tasked to "go and do data governance."']}),"\n",(0,a.jsxs)(t.p,{children:["And with Confluent Platform 5.4 or newer, you have the additional option to ",(0,a.jsx)(t.a,{href:"https://www.confluent.io/blog/data-governance-with-schema-validation",children:"centrally enforce broker-side Schema Validation"})," so that no misbehaving client can violate the data contract: incoming events are validated server side before they are stored in Kafka topics. This feature is a huge benefit for any Kafka user and especially for larger, regulated organizations."]}),"\n",(0,a.jsx)(t.h2,{id:"other-stream-processing-brokers",children:"Other Stream Processing Brokers"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Apache Pulsar"}),"\n",(0,a.jsx)(t.li,{children:"AWS Kinesis"}),"\n",(0,a.jsx)(t.li,{children:"AWS SQS"}),"\n",(0,a.jsx)(t.li,{children:"Google Cloud Pub/Sub"}),"\n",(0,a.jsx)(t.li,{children:"Azure Event Hubs"}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"redpanda"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Redpanda is the real-time engine for modern apps. Kafka API Compatible; 10x faster"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://youtu.be/kz7R1mGrN9Q",children:"Co-Designing Raft + Thread-per-Core Execution Model for the Kafka-API"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://redpanda.com",children:"https://redpanda.com"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/vectorizedio/redpanda",children:"https://github.com/vectorizedio/redpanda"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://bravenewgeek.com/benchmarking-message-queue-latency",children:"https://bravenewgeek.com/benchmarking-message-queue-latency"})}),"\n",(0,a.jsx)(t.h2,{id:"kafka-connect-dead-letter-queues",children:"Kafka Connect Dead Letter Queues"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.confluent.io/blog/kafka-connect-deep-dive-error-handling-dead-letter-queues",children:"https://www.confluent.io/blog/kafka-connect-deep-dive-error-handling-dead-letter-queues"})}),"\n",(0,a.jsx)(t.h2,{id:"kafka-edge-computing",children:"Kafka Edge Computing"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.kai-waehner.de/blog/2020/01/01/apache-kafka-edge-computing-industrial-iot-retailing-logistics",children:"https://www.kai-waehner.de/blog/2020/01/01/apache-kafka-edge-computing-industrial-iot-retailing-logistics"})}),"\n",(0,a.jsx)(t.h2,{id:"kafka-gotchas",children:"Kafka Gotchas"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Too many tunable knobs"}),"\n",(0,a.jsx)(t.li,{children:"Unsafe defaults"}),"\n",(0,a.jsx)(t.li,{children:"enable.auto.commit"}),"\n",(0,a.jsx)(t.li,{children:"max.in.flight.requests.per.connection"}),"\n",(0,a.jsx)(t.li,{children:"Appalling tooling"}),"\n",(0,a.jsx)(t.li,{children:"Complicated bootstrapping process"}),"\n",(0,a.jsx)(t.li,{children:"Shaky client libraries"}),"\n",(0,a.jsx)(t.li,{children:"Lack of true multitenancy"}),"\n",(0,a.jsx)(t.li,{children:"Lack of geo-awareness"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://itnext.io/kafka-gotchas-24b51cc8d44e",children:"https://itnext.io/kafka-gotchas-24b51cc8d44e"})}),"\n",(0,a.jsx)(t.h2,{id:"compression",children:"Compression"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/KAFKA/Compression#app-switcher",children:"https://cwiki.apache.org/confluence/display/KAFKA/Compression#app-switcher"})}),"\n",(0,a.jsx)(t.p,{children:"When the broker receives a compressed batch of messages from a producer:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"it always decompresses the data in order to validate it"}),"\n",(0,a.jsxs)(t.li,{children:["it considers the compression codec of the destination topic","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"if the compression codec of the destination topic isproducer, or if the codecs of the batch and destination topic are the same, the broker takes the compressed batch from the client and writes it directly to the topic's log file without recompressing the data."}),"\n",(0,a.jsx)(t.li,{children:"Otherwise, the broker needs to re-compress the data to match the codec of the destination topic."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Decompression and re-compression can also happen if producers are running a version prior to 0.10 because offsets need to be overwritten, or if any other message format conversion is required."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://stackoverflow.com/questions/59902385/if-i-set-compression-type-at-topic-level-and-producer-level-which-takes-prece",children:"https://stackoverflow.com/questions/59902385/if-i-set-compression-type-at-topic-level-and-producer-level-which-takes-prece"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://stackoverflow.com/questions/48670584/kafka-set-compression-type-at-producer-vs-topic",children:"https://stackoverflow.com/questions/48670584/kafka-set-compression-type-at-producer-vs-topic"})}),"\n",(0,a.jsx)(t.h2,{id:"secor",children:"Secor"}),"\n",(0,a.jsxs)(t.p,{children:["Secor is a service persisting ",(0,a.jsx)(t.a,{href:"http://kafka.apache.org/",children:"Kafka"})," logs to ",(0,a.jsx)(t.a,{href:"http://aws.amazon.com/s3/",children:"Amazon S3"}),", ",(0,a.jsx)(t.a,{href:"https://cloud.google.com/storage/",children:"Google Cloud Storage"}),", ",(0,a.jsx)(t.a,{href:"https://azure.microsoft.com/en-us/services/storage/blobs/",children:"Microsoft Azure Blob Storage"})," and ",(0,a.jsx)(t.a,{href:"http://swift.openstack.org/",children:"Openstack Swift"}),"."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/pinterest/secor",children:"https://github.com/pinterest/secor"})}),"\n",(0,a.jsx)(t.h2,{id:"others-1",children:"Others"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://kafka-tutorials.confluent.io",children:"https://kafka-tutorials.confluent.io"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.confluent.io/blog/kafka-streams-tables-part-4-elasticity-fault-tolerance-advanced-concepts",children:"https://www.confluent.io/blog/kafka-streams-tables-part-4-elasticity-fault-tolerance-advanced-concepts"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},814026:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/Technologies-Kafka-Others-image1-222764531f3afc98c9149375ae83669d.jpg"},511151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>i});var a=s(667294);const n={},o=a.createContext(n);function i(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);