"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[69133],{101785:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"languages/golang/concepts","title":"Concepts","description":"Goroutines & Channels","source":"@site/docs/languages/golang/concepts.md","sourceDirName":"languages/golang","slug":"/languages/golang/concepts","permalink":"/languages/golang/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/languages/golang/concepts.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1707138374000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"golang","permalink":"/languages/golang/"},"next":{"title":"Data Types","permalink":"/languages/golang/data-types"}}');var o=t(474848),a=t(28453);const s={},r="Concepts",l={},c=[{value:"Goroutines &amp; Channels",id:"goroutines--channels",level:2},{value:"Start from the bottom",id:"start-from-the-bottom",level:3},{value:"Blocking is fine",id:"blocking-is-fine",level:3},{value:"Don&#39;t interrupt",id:"dont-interrupt",level:3},{value:"What is a Goroutine leak, and how can it be avoided in a Go program?",id:"what-is-a-goroutine-leak-and-how-can-it-be-avoided-in-a-go-program",level:3},{value:"Explain the concept of context in Go. How is it useful in managing cancellations and deadlines in a program?",id:"explain-the-concept-of-context-in-go-how-is-it-useful-in-managing-cancellations-and-deadlines-in-a-program",level:3},{value:"Channels",id:"channels",level:2},{value:"Goroutine vs Thread",id:"goroutine-vs-thread",level:2},{value:"Pointers in Go",id:"pointers-in-go",level:2}];function h(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,o.jsx)(n.h2,{id:"goroutines--channels",children:"Goroutines & Channels"}),"\n",(0,o.jsx)(n.p,{children:"The native support for concurrency and parallelism. This makes Go an ideal candidate for applications that require heavy concurrent and/or parallel processing, networking and so on. Goroutines makes it so easy to start lightweight threads and channels provide a way to communicate between these threads acting like a message bus."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Goroutines"})," represent concurrent tasks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Channels"})," are used to communicate between tasks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Select"})," enables task synchronization"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Goroutines exists only in the virtual space of go runtime and not in the OS."}),"\n",(0,o.jsx)(n.p,{children:"Hence, a Go Runtime scheduler is needed which manages their lifecycle."}),"\n",(0,o.jsx)(n.p,{children:"Go Runtime maintains three C structs for this purpose:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The G Struct:"})," This represents a single go routine with it's properties such as stack pointer, base of stack, it's ID, it's cache and it's status"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The M Struct:"})," This represents an OS thread. It also contains a pointer to the global queue of runnable goroutines, the current running goroutine and the reference to the scheduler"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The Sched Struct:"})," It is a global struct and contains the queues free and waiting goroutines as well as threads."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"So, on startup, go runtime starts a number of goroutines for GC, scheduler and user code. An OS Thread is created to handle these goroutines. These threads can be at most equal to GOMAXPROCS."}),"\n",(0,o.jsx)(n.h3,{id:"start-from-the-bottom",children:"Start from the bottom"}),"\n",(0,o.jsx)(n.p,{children:"A goroutine is created with initial only 2KB of stack size. Each function in go already has a check if more stack is needed or not and the stack can be copied to another region in memory with twice the original size. This makes goroutine very light on resources."}),"\n",(0,o.jsx)(n.h3,{id:"blocking-is-fine",children:"Blocking is fine"}),"\n",(0,o.jsx)(n.p,{children:"If a goroutine blocks on system call, it blocks it's running thread. But another thread is taken from the waiting queue of Scheduler (the Sched struct) and used for other runnable goroutines."}),"\n",(0,o.jsx)(n.p,{children:"However, if you communicate using channels in go which exists only in virtual space, the OS doesn't block the thread.Such goroutines simply go in the waiting state and other runnable goroutine (from the M struct) is scheduled in it's place."}),"\n",(0,o.jsx)(n.h3,{id:"dont-interrupt",children:"Don't interrupt"}),"\n",(0,o.jsx)(n.p,{children:"The go runtime scheduler does cooperative scheduling, which means another goroutine will only be scheduled if the current one is blocking or done. Some of these cases are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Channel send and receive operations, if those operations would block."}),"\n",(0,o.jsx)(n.li,{children:"The Go statement, although there is no guarantee that new goroutine will be scheduled immediately."}),"\n",(0,o.jsx)(n.li,{children:"Blocking syscalls like file and network operations."}),"\n",(0,o.jsx)(n.li,{children:"After being stopped for a garbage collection cycle."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This is better than pre-emptive scheduling which uses timely system interrupts (e.g. every 10 ms) to block and schedule a new thread which may lead a task to take longer than needed to finish when number of threads increases or when a higher priority tasks need to be scheduled while a lower priority task is running."}),"\n",(0,o.jsx)(n.p,{children:"Another advantage is that, since it is invoked implicitly in the code e.g. during sleep or channel wait, the compile only needs to safe/restore the registers which are alive at these points. In Go, this means only 3 registers i.e. PC, SP and DX (Data Registers) being updated during context switch rather than all registers (e.g. AVX, Floating Point, MMX)."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f",children:"https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f"})}),"\n",(0,o.jsx)(n.h3,{id:"what-is-a-goroutine-leak-and-how-can-it-be-avoided-in-a-go-program",children:"What is a Goroutine leak, and how can it be avoided in a Go program?"}),"\n",(0,o.jsx)(n.p,{children:"A Goroutine leak occurs when Goroutines are created but not properly managed, leading to excessive resource usage. To avoid leaks, it's essential to ensure that Goroutines are appropriately closed when they are no longer needed, typically using defer statements or sync.WaitGroup."}),"\n",(0,o.jsx)(n.h3,{id:"explain-the-concept-of-context-in-go-how-is-it-useful-in-managing-cancellations-and-deadlines-in-a-program",children:"Explain the concept of context in Go. How is it useful in managing cancellations and deadlines in a program?"}),"\n",(0,o.jsx)(n.p,{children:"Context in Go is a package that provides a way to carry deadlines, cancellations, and other request-scoped values across API boundaries. It is useful for managing the lifecycle of operations, handling timeouts, and propagating cancellation signals in a clean and consistent manner."}),"\n",(0,o.jsx)(n.h2,{id:"channels",children:"Channels"}),"\n",(0,o.jsx)(n.p,{children:"Channels are communication primitives in Go for synchronizing and communicating between Goroutines. They provide a safe way for Goroutines to communicate by sending and receiving data. Channels help prevent race conditions and facilitate proper synchronization in concurrent programming."}),"\n",(0,o.jsx)(n.h2,{id:"goroutine-vs-thread",children:"Goroutine vs Thread"}),"\n",(0,o.jsx)(n.p,{children:"Goroutines are lightweight, managed by the Go runtime, and use a smaller stack size compared to traditional threads. Goroutines are multiplexed onto a smaller number of OS threads, making them more efficient for concurrent programming."}),"\n",(0,o.jsx)(n.h2,{id:"pointers-in-go",children:"Pointers in Go"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://www.digitalocean.com/community/conceptual_articles/understanding-pointers-in-go",children:"https://www.digitalocean.com/community/conceptual_articles/understanding-pointers-in-go"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(296540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);