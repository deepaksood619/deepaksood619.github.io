"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[45410],{321919:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"computer-science/programming-concepts/cohesion-and-coupling","title":"Cohesion and Coupling","description":"COUPLING - An indication of the strength of interconnections between program units","source":"@site/docs/computer-science/programming-concepts/cohesion-and-coupling.md","sourceDirName":"computer-science/programming-concepts","slug":"/computer-science/programming-concepts/cohesion-and-coupling","permalink":"/computer-science/programming-concepts/cohesion-and-coupling","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/computer-science/programming-concepts/cohesion-and-coupling.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1678191863000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Programming Concepts","permalink":"/computer-science/programming-concepts/"},"next":{"title":"Dependency Injection","permalink":"/computer-science/programming-concepts/dependency-injection"}}');var i=o(474848),s=o(28453);const a={},r="Cohesion and Coupling",l={},c=[{value:"COUPLING - An indication of the strength of interconnections between program units",id:"coupling---an-indication-of-the-strength-of-interconnections-between-program-units",level:2},{value:"COHESION - Measure of how well module fits together",id:"cohesion---measure-of-how-well-module-fits-together",level:2},{value:"Many levels of cohesion",id:"many-levels-of-cohesion",level:3}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cohesion-and-coupling",children:"Cohesion and Coupling"})}),"\n",(0,i.jsx)(n.h2,{id:"coupling---an-indication-of-the-strength-of-interconnections-between-program-units",children:"COUPLING - An indication of the strength of interconnections between program units"}),"\n",(0,i.jsx)(n.p,{children:"Highly coupled have program units dependent on each other. Loosely coupled are made up of units that are independent or almost independent.\nModules are independent if they can function completely without the presence of the other. Obviously, can't have modules completely independent of each other. Must interact so that can produce desired outputs. The more connections between modules, the more dependent they are in the sense that more info about one modules is required to understand the other module.\nThree factors: number of interfaces, complexity of interfaces, type of info flow along interfaces."}),"\n",(0,i.jsx)(n.p,{children:"Want to minimize number of interfaces between modules, minimize the complexity of each interface, and control the type of info flow. An interface of a module is used to pass information to and from other modules.\nIn general, modules tightly coupled if they use shared variables or if they exchange control info."}),"\n",(0,i.jsx)(n.p,{children:"Loose coupling if info held within a unit and interface with other units via parameter lists. Tight coupling if shared global data.\nIf need only one field of a record, don't pass entire record. Keep interface as simple and small as possible.\nTwo types of info flow: data or control."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Passing or receiving back control info means that the action of the module will depend on this control info, which makes it difficult to understand the module."}),"\n",(0,i.jsx)(n.li,{children:"Interfaces with only data communication result in lowest degree of coupling, followed by interfaces that only transfer control data. Highest if data is hybrid.\nRanked highest to lowest:"}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Content coupling: if one directly references the contents of the other.\nWhen one module modifies local data values or instructions in another module. (can happen in assembly language)\nif one refers to local data in another module.\nif one branches into a local label of another."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Common coupling: access to global data.\nmodules bound together by global data structures."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Control coupling: passing control flags (as parameters or globals) so that one module controls the sequence of processing steps in another module."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Stamp coupling: similar to common coupling except that global variables are shared selectively among routines that require the data. E.g., packages in Ada. More desirable than common coupling because fewer modules will have to be modified if a shared data structure is modified. Pass entire data structure but need only parts of it."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Data coupling: use of parameter lists to pass data items between routines."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cohesion---measure-of-how-well-module-fits-together",children:"COHESION - Measure of how well module fits together"}),"\n",(0,i.jsx)(n.p,{children:"A component should implement a single logical function or single logical entity. All the parts should contribute to the implementation."}),"\n",(0,i.jsx)(n.p,{children:"Coupling, in the computer science lingo, means to link two parts of a system, so that changes in one of them directly affect the other one, and is usually avoided as much as possible."}),"\n",(0,i.jsx)(n.h3,{id:"many-levels-of-cohesion",children:"Many levels of cohesion"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Coincidental cohesion: the parts of a component are not related but simply bundled into a single component.\nharder to understand and not reusable."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Logical association: similar functions such as input, error handling, etc. put together. Functions fall in same logical class. May pass a flag to determine which ones executed.\ninterface difficult to understand. Code for more than one function may be intertwined, leading to severe maintenance problems. Difficult to reuse"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Temporal cohesion: all of statements activated at a single time, such as start up or shut down, are brought together. Initialization, clean up.\nFunctions weakly related to one another, but more strongly related to functions in other modules so may need to change lots of modules when do maintenance."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Procedural cohesion: a single control sequence, e.g., a loop or sequence of decision statements. Often cuts across functional lines. May contain only part of a complete function or parts of several functions.\nFunctions still weakly connected, and again unlikely to be reusable in another product."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Communicational cohesion: operate on same input data or produce same output data. May be performing more than one function. Generally acceptable if alternate structures with higher cohesion cannot be easily identified.\nstill problems with reusability."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Sequential cohesion: output from one part serves as input for another part. May contain several functions or parts of different functions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Informational cohesion: performs a number of functions, each with its own entry point, with independent code for each function, all performed on same data structure. Different than logical cohesion because functions not intertwined."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Functional cohesion: each part necessary for execution of a single function. e.g., compute square root or sort the array.\nUsually reusable in other contexts. Maintenance easier."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Type cohesion: modules that support a data abstraction.\nNot strictly a linear scale. Functional much stronger than rest while first two much weaker than others. Often many levels may be applicable when considering two elements of a module. Cohesion of module considered as highest level of cohesion that is applicable to all elements in the module."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>r});var t=o(296540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);