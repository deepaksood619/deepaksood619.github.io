"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[52152],{887818:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>h,default:()=>d,frontMatter:()=>n,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"data-structures/hashtable/merkle-trees","title":"Merkle Trees","description":"A merkle tree, also known as a binary hash tree, is a data structure used for efficiently summarizing and verifying the integrity of large sets of data.","source":"@site/docs/data-structures/hashtable/merkle-trees.md","sourceDirName":"data-structures/hashtable","slug":"/data-structures/hashtable/merkle-trees","permalink":"/data-structures/hashtable/merkle-trees","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hashtable/merkle-trees.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"List of Hash Functions","permalink":"/data-structures/hashtable/list-of-hash-functions"},"next":{"title":"Probabilistic Data Structure","permalink":"/data-structures/hashtable/probabilistic-data-structure"}}');var r=s(474848),i=s(28453);const n={},h="Merkle Trees",o={},l=[{value:"Links",id:"links",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"merkle-trees",children:"Merkle Trees"})}),"\n",(0,r.jsx)(t.p,{children:"A merkle tree, also known as a binary hash tree, is a data structure used for efficiently summarizing and verifying the integrity of large sets of data."}),"\n",(0,r.jsxs)(t.p,{children:["A Merkle tree is a ",(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/hash-based-data-structure/",children:"hash-based data structure"})," that is a generalization of the ",(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/hash-list/",children:"hash list"}),". It is a ",(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/trees-basic/",children:"tree"})," structure in which each leaf node is a hash of a block of data, and each non-leaf node is a hash of its children. Typically, Merkle trees have a branching factor of 2, meaning that each node has up to 2 children."]}),"\n",(0,r.jsxs)(t.p,{children:["Merkle trees are used in distributed systems for efficient data verification. They are efficient because they use hashes instead of full files. Hashes are ways of encoding files that are much smaller than the actual file itself. Currently, their main uses are in ",(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/peer-to-peer-networks/?wiki_title=peer-to-peer%20networks",children:"peer-to-peer networks"})," such as Tor, ",(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/bitcoin/",children:"Bitcoin"}),", and Git."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"image",src:s(773100).A+"",width:"561",height:"451"})}),"\n",(0,r.jsx)(t.p,{children:"Image - A basic Merkle Tree. I've abbreviated the middle nodes as H(cd) and H(ab) respectively, but without this shorthand the root hash could also be called H(H(H(a) + H(b)) + H(H(c) +H(d)))"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://brilliant.org/wiki/merkle-tree",children:"https://brilliant.org/wiki/merkle-tree"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://hackernoon.com/merkle-tree-introduction-4c44250e2da7",children:"https://hackernoon.com/merkle-tree-introduction-4c44250e2da7"})}),"\n",(0,r.jsx)(t.p,{children:"A Merkle tree is a type of binary tree composed of a set of nodes with lots of leaf nodes at the bottom of the tree that contains data. Intermediate nodes in a Merkle tree consist of nodes that have a hash of its two child nodes, and the root node is made up of the hash of its two child nodes, representing the top of the tree."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"image",src:s(896116).A+"",width:"975",height:"606"})}),"\n",(0,r.jsx)(t.p,{children:"Data at the bottom of the Merkle tree is generated by splitting it into chunks, splitting chunks into buckets, and repeating the process using bucket hashes until there is only a single hash remaining (the root hash)."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"image",src:s(697923).A+"",width:"975",height:"452"})}),"\n",(0,r.jsx)(t.p,{children:"Each node of the tree has a key with an associated value; the key tells us which child node to follow to get to the corresponding value, which is stored in the leaf nodes. In the case of ethereum, the key/value mapping for the state tree is between the addresses and their accounts."}),"\n",(0,r.jsx)(t.p,{children:"Every blocks header stores the hash of the root node of what are essentially three different Merkle tree structures for the state, transactions, and receipts."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"image",src:s(316870).A+"",width:"975",height:"483"})}),"\n",(0,r.jsx)(t.p,{children:"Merkle trees are supremely useful because its a very efficient way to store all this information, especially for light nodes. Ethereum uses light nodes and full nodes; full nodes must download the full blockchain, executing all the transactions contained in it. Light nodes must download only the chain of headers, without needing to execute any transactions or retrieving any associated state. This allows them to easily generate and receive verifiable answers about balances, events, etc."}),"\n",(0,r.jsx)(t.p,{children:"Merkle trees serve to help secure the blockchain because hashes in the Merkle tree propagate upward. If a bad actor tries to swap a fraudulent transaction into the bottom of the Merkle tree, it will cause a chain reaction in all the hashes in all the nodes above it."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"image",src:s(810221).A+"",width:"772",height:"473"})}),"\n",(0,r.jsx)(t.p,{children:"A node that wants to verify some data can use whats called a 'Merkle proof\". This contains some data to be verified, the root hash of the tree, and the tree branch (partner hashes going up along the path from the data chunk to the root hash). People who read the proof can verify that branch hashing is consistent throughout the tree."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=gcpW7cfmFeE",children:"CakeDefi | Youtube | Why Merkle trees are the best way to verify your crypto accounts"})}),"\n",(0,r.jsx)(t.h2,{id:"links",children:"Links"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"/data-structures/hashtable/verkle-trees",children:"Verkle Trees"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://www.geeksforgeeks.org/introduction-to-merkle-tree/",children:"Introduction to Merkle Tree - GeeksforGeeks"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Merkle_tree",children:"Merkle tree - Wikipedia"})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},896116:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Blockchain-image1-6465a34dac266493aa098175126b9160.jpg"},697923:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Blockchain-image2-bf8e4c250b08c295f64fffcf1fbec1eb.jpg"},316870:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Blockchain-image3-e0bd545157e23d4f663dcfb6ca6ef8e7.jpg"},810221:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Blockchain-image4-8091a53d1dd084068c64d72795a37e97.jpg"},773100:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Merkle-Trees-image1-351fdd334eb86c9635d3b83b7f139897.jpg"},28453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>h});var a=s(296540);const r={},i=a.createContext(r);function n(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);