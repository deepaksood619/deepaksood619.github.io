"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[7311],{536034:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"ai/move-37/3-monte-carlo-methods","title":"3. Monte Carlo Methods","description":"Internet of Things Optimization","source":"@site/docs/ai/move-37/3-monte-carlo-methods.md","sourceDirName":"ai/move-37","slug":"/ai/move-37/3-monte-carlo-methods","permalink":"/ai/move-37/3-monte-carlo-methods","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/ai/move-37/3-monte-carlo-methods.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1707138374000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"2. Dynamic Programming","permalink":"/ai/move-37/2-dynamic-programming"},"next":{"title":"4. Model Free Learning","permalink":"/ai/move-37/4-model-free-learning"}}');var o=n(474848),r=n(28453);const a={},s="3. Monte Carlo Methods",l={},d=[{value:"Internet of Things Optimization",id:"internet-of-things-optimization",level:2},{value:"Exploration vs Exploitation",id:"exploration-vs-exploitation",level:2},{value:"Thompson Sampling",id:"thompson-sampling",level:3},{value:"Multi-armed bandit problem",id:"multi-armed-bandit-problem",level:3},{value:"MC Control and MC Prediction",id:"mc-control-and-mc-prediction",level:2},{value:"Model Free Learning",id:"model-free-learning",level:3},{value:"MC Method - Monte Carlo Method for model free learning",id:"mc-method---monte-carlo-method-for-model-free-learning",level:2},{value:"First-visit MC: average returns only for first time s is visited in an episode",id:"first-visit-mc-average-returns-only-for-first-time-s-is-visited-in-an-episode",level:3},{value:"Every-Visit MC: average returns for every time s is visited in an episode",id:"every-visit-mc-average-returns-for-every-time-s-is-visited-in-an-episode",level:3},{value:"Epsilon-greedy policy",id:"epsilon-greedy-policy",level:2},{value:"GLIE Monte Carlo Method (Greedy in the Limit of Infinite Exploration)",id:"glie-monte-carlo-method-greedy-in-the-limit-of-infinite-exploration",level:2},{value:"Temporal Difference Learning",id:"temporal-difference-learning",level:2},{value:"Q-Learning for Trading",id:"q-learning-for-trading",level:2}];function h(e){const i={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"3-monte-carlo-methods",children:"3. Monte Carlo Methods"})}),"\n",(0,o.jsx)(i.h2,{id:"internet-of-things-optimization",children:"Internet of Things Optimization"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Monte Carlo vs Dynamic Programming","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"No need for a complete Markov Decision Process"}),"\n",(0,o.jsx)(i.li,{children:"Computationally more efficient"}),"\n",(0,o.jsx)(i.li,{children:"Can be used with stochastic simulations"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.li,{children:"In model-free reinforcement learning, as opposed to model based, we don't know the reward function and the transition function beforehand we have to learn them though experience."}),"\n",(0,o.jsx)(i.li,{children:"A model-free learning technique called monte carlo uses repeated random sampling to obtain numerical results"}),"\n",(0,o.jsx)(i.li,{children:"In first visite monte carlo the state value function is defined as the average of the returns following the agents first visit to S in a set of episodes"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"exploration-vs-exploitation",children:"Exploration vs Exploitation"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Example - In the context of a restaurant, we can order the same meal that we have already eaten, so ",(0,o.jsx)(i.strong,{children:"exploit"})," our previous knowledge to get already tested meal, vs we can ",(0,o.jsx)(i.strong,{children:"explore"})," new items in the hope of eating more tastier meal."]}),"\n",(0,o.jsx)(i.li,{children:"We can do this in RL by adjusting \u03f5 (epsilon), to balance between exploration vs exploitation to get the maximum reward possible."}),"\n",(0,o.jsx)(i.li,{children:"Exploration vs Exploitation tradeoff"}),"\n",(0,o.jsx)(i.li,{children:"Epsilon Greedy"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"epsilon is the fraction of times we sample a lever randomly and1- epsilonis the fraction of times we choose optimally."}),"\n",(0,o.jsx)(i.h3,{id:"thompson-sampling",children:"Thompson Sampling"}),"\n",(0,o.jsx)(i.p,{children:"The basic idea is toassume a simple prior distributionon the underlying parameters of the reward distribution of every lever, and at every time step, play a lever according to itsposterior probabilityof being the best arm."}),"\n",(0,o.jsx)(i.h3,{id:"multi-armed-bandit-problem",children:"Multi-armed bandit problem"}),"\n",(0,o.jsxs)(i.p,{children:["In ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Probability_theory",children:"probability theory"}),", the ",(0,o.jsx)(i.strong,{children:"multi-armed bandit problem"}),"(sometimes called the ",(0,o.jsxs)(i.strong,{children:[(0,o.jsx)(i.em,{children:"K"}),"- or ",(0,o.jsx)(i.em,{children:"N"}),"-armed bandit problem"]}),") is a problem in which a fixed limited set of resources must be allocated between competing (alternative) choices in a way that maximizes their expected gain, when each choice's properties are only partially known at the time of allocation, and may become better understood as time passes or by allocating resources to the choice."]}),"\n",(0,o.jsxs)(i.p,{children:["The name comes from imagining a ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Gambler",children:"gambler"})," at a row of ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Slot_machines",children:"slot machines"}),'(sometimes known as "one-armed bandits"), who has to decide which machines to play, how many times to play each machine and in which order to play them, and whether to continue with the current machine or try a different machine.The multi-armed bandit problem also falls into the broad category of ',(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Stochastic_scheduling",children:"stochastic scheduling"}),"."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Multi-armed_bandit",children:"https://en.wikipedia.org/wiki/Multi-armed_bandit"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"We must strike a balance between explore/exploit"}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Epsilon Greedy - epsilon (a hyperparameter) is the probability that our agent will choose a random action instead of following policy"}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Algorithm"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"generate a random number p, between 0 and 1"}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"if p < (1-\u03b5) take the action dictated by policy"}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Otherwise take a random action"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"First visit optimization"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"What happens if we visit the same state more than once"}),"\n",(0,o.jsx)(i.li,{children:"It's been proven the subsequent visits doesn't change the answer"}),"\n",(0,o.jsx)(i.li,{children:"All we need is the first visit"}),"\n",(0,o.jsx)(i.li,{children:"We throw rest of the data away"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Monte Carlo Q Learning Algorithm"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"image",src:n(581870).A+"",width:"999",height:"626"})}),"\n",(0,o.jsx)(i.h2,{id:"mc-control-and-mc-prediction",children:"MC Control and MC Prediction"}),"\n",(0,o.jsx)(i.p,{children:"There are two types of tasks in reinforcement learning -- Prediction and Control."}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Prediction"})}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"A task that can predict expected total reward from any given state assuming the function\u03c0(a|s)is given. Prediction calculates the value functionV\u03c0"}),"\n",(0,o.jsxs)(i.p,{children:["e.g.",":Policyevaluation"," (Estimate)."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Control"})}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"A task that can findpolicy\u03c0(a|s)that maximizes the expected total reward from any given state. Simply if given a policy\u03c0control finds an optimal policy\u03c0*."}),"\n",(0,o.jsxs)(i.p,{children:["e.g.",":Policy"," Improvement (Optimize)."]}),"\n",(0,o.jsx)(i.p,{children:"Policy Iteration is a combination of prediction and control to find optimal policy."}),"\n",(0,o.jsx)(i.p,{children:"There are two types of policy learning methods -"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"On policy learning"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"This methodlearns on the job, it evaluates or improves the policy that used to make the decisions."}),"\n",(0,o.jsx)(i.li,{children:"We must act based on our current policy"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Off policy learning"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"This method evaluates one policy while following another policy. The earlier is called target policy which may be deterministic and thelatterbehaviorpolicy is stochastic."}),"\n",(0,o.jsx)(i.li,{children:"Any action is okay"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"model-free-learning",children:"Model Free Learning"}),"\n",(0,o.jsx)(i.p,{children:"Learn a problem when not all the components are available. In model free learning we just focus on calculating the value functions directly from the interactions with the environment. Our aim here is to figureout Vfor unknown MDP assuming that we have a policy."}),"\n",(0,o.jsx)(i.h2,{id:"mc-method---monte-carlo-method-for-model-free-learning",children:"MC Method - Monte Carlo Method for model free learning"}),"\n",(0,o.jsx)(i.p,{children:"There are two different types of MC."}),"\n",(0,o.jsx)(i.h3,{id:"first-visit-mc-average-returns-only-for-first-time-s-is-visited-in-an-episode",children:"First-visit MC: average returns only for first time s is visited in an episode"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Incremental Mean"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"every-visit-mc-average-returns-for-every-time-s-is-visited-in-an-episode",children:"Every-Visit MC: average returns for every time s is visited in an episode"}),"\n",(0,o.jsx)(i.p,{children:"Both converge asymptotically."}),"\n",(0,o.jsx)(i.p,{children:"Monte Carlo methods for control task (Policy iteration is the base of control task)"}),"\n",(0,o.jsx)(i.p,{children:"In model-free RL, we need to interact with the environment to find out the best strategy so we need to explore the entire the state space while figuring out best actions."}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Exploration",":is"," about finding more information about the environment. In other words exploring a lot of states and actions in the environment."]}),"\n",(0,o.jsxs)(i.li,{children:["Exploitation",":is"," about exploiting the known information to maximize the reward."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Example for exploration vs exploitation (in context of Roomba, floor cleaning robot) - When the state is in charged up mode It needs to cover maximum area in a grid world for cleaning which falls under exploration. When the state of the machine changes to low battery it needs to find the charging dock as soon as possible to avoid getting stuck here the robot needs to exploit rather than explore to maximize the reward.So due to the exploration problem, we cannot expect Roomba to act greedily in MC to improve policy instead we use the epsilon-greedy policy."}),"\n",(0,o.jsx)(i.h2,{id:"epsilon-greedy-policy",children:"Epsilon-greedy policy"}),"\n",(0,o.jsx)(i.p,{children:"The best-known action based on our experience is selected with (1-epsilon) probability and the rest of the time i.e. with epsilon probability any action is selected randomly. Initially, epsilon is 1 so we can explore more but as we do many iterations we slowly decrease the epsilon to 0( which is exploitation \u2192 choosing the best-known action) this get us to have the value of epsilon between 0 and 1."}),"\n",(0,o.jsx)(i.h2,{id:"glie-monte-carlo-method-greedy-in-the-limit-of-infinite-exploration",children:"GLIE Monte Carlo Method (Greedy in the Limit of Infinite Exploration)"}),"\n",(0,o.jsx)(i.p,{children:"GLIE Monte-Carlo is an on-policy learning method that learns from complete episodes. For each state-action pair, we keep track of how many times the pair has been visited with a simple counter function."}),"\n",(0,o.jsx)(i.p,{children:"N(St,At) \u2190 N(St,At) + 1"}),"\n",(0,o.jsx)(i.p,{children:"For each episode, we can update our estimated value function using an incremental mean."}),"\n",(0,o.jsx)(i.p,{children:"Q(St,At) \u2190 Q(St,At) + (1 / N(St,At)) (Gt--Q(St,At))"}),"\n",(0,o.jsx)(i.p,{children:"Here, Gt either represents the return from time t when the agent first visited the state-action pair, or the sum of returns from each time t that the agent visited the state-action pair, depending on whether you are using first-visit or every-visit Monte Carlo."}),"\n",(0,o.jsx)(i.p,{children:"We'll adopt a \u03f5-greedy policy with \u03f5=1/k where k represents the number of episodes our agent has learned from."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"image",src:n(862137).A+"",width:"999",height:"617"})}),"\n",(0,o.jsx)(i.h2,{id:"temporal-difference-learning",children:"Temporal Difference Learning"}),"\n",(0,o.jsx)(i.p,{children:"The temporal difference approach approximates the value of a state-action pair by comparing estimates at two points in time (thus the name, temporal difference). The intuition behind this method is that we can formulate a better estimate for the value of a state-action pair after having observed some of the reward that our agent accumulates after having visited a state and performing a given action."}),"\n",(0,o.jsx)(i.h2,{id:"q-learning-for-trading",children:"Q-Learning for Trading"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"A partially observable markov decision process is one where we don't know what the true state looks like, but we can observe a part of it."}),"\n",(0,o.jsx)(i.li,{children:"A Q table is one where the states and rows and actions are columns, it helps us find the best action to take for each state"}),"\n",(0,o.jsx)(i.li,{children:"Q learning is the process of learning what this Q table is directly, without needing to learn either the transition probability or reward function"}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},581870:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/3.-Monte-Carlo-Methods-image1-92f4f6d1dc56000c37f54c5b82808541.jpg"},862137:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/3.-Monte-Carlo-Methods-image2-5844575c4be2f2d8372a969cf468f4b0.jpg"},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>s});var t=n(296540);const o={},r=t.createContext(o);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);