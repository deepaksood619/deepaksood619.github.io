"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[43566],{784650:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"algorithms/advanced-algorithms/travelling-salesman-problem","title":"Travelling Salesman Problem","description":"The Traveling Salesman Problem is a well known challenge in Computer Science: it consists on finding the shortest route possible that traverses all cities in a given map only once. Although its simple explanation, this problem is, indeed, NP-Complete. This implies that the difficulty to solve it increases rapidly with the number of cities, and we do not know in fact a general solution that solves the problem. For that reason, we currently consider that any method able to find a sub-optimal solution is generally good enough (we cannot verify if the solution returned is the optimal one most of the times).","source":"@site/docs/algorithms/advanced-algorithms/travelling-salesman-problem.md","sourceDirName":"algorithms/advanced-algorithms","slug":"/algorithms/advanced-algorithms/travelling-salesman-problem","permalink":"/algorithms/advanced-algorithms/travelling-salesman-problem","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/advanced-algorithms/travelling-salesman-problem.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701846168000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Regular Expressions","permalink":"/algorithms/advanced-algorithms/regular-expressions"},"next":{"title":"Algorithmic Complexity","permalink":"/algorithms/algorithmic-complexity/"}}');var a=o(474848),i=o(28453);const s={},l="Travelling Salesman Problem",r={},h=[{value:"Arora PTAS for Euclidean TSP",id:"arora-ptas-for-euclidean-tsp",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"travelling-salesman-problem",children:"Travelling Salesman Problem"})}),"\n",(0,a.jsx)(t.p,{children:"The Traveling Salesman Problem is a well known challenge in Computer Science: it consists on finding the shortest route possible that traverses all cities in a given map only once. Although its simple explanation, this problem is, indeed, NP-Complete. This implies that the difficulty to solve it increases rapidly with the number of cities, and we do not know in fact a general solution that solves the problem. For that reason, we currently consider that any method able to find a sub-optimal solution is generally good enough (we cannot verify if the solution returned is the optimal one most of the times)."}),"\n",(0,a.jsx)(t.p,{children:"To solve it, we can try to apply a modification of the Self-Organizing Map (SOM) technique."}),"\n",(0,a.jsx)(t.h2,{id:"arora-ptas-for-euclidean-tsp",children:"Arora PTAS for Euclidean TSP"}),"\n",(0,a.jsxs)(t.p,{children:["The Travelling Salesman Problem (TSP) is one of the most famous problems in Computer Science, but it turns out to be NP-Hard. It's even NP-hard to approximate it to any polynomial factor in the general case! Thankfully we can do a constant (around 1.5) approximation when the distances for which we are solving the problem come from a metric. While exactly what this constant is remains open, we know we cannot have a PTAS in the general case. What's a PTAS? It's a Polynomial Time Approximation Scheme. The idea is that you give me an epsilon, I will give you a (1+epsilon) approximation algorithm whose runtime depends on epsilon but is polynomial in n. So we have runtimes like poly(n) ",(0,a.jsx)(t.code,{children:"2^{1/epsilon}"})," and others."]}),"\n",(0,a.jsx)(t.p,{children:"Sanjeev Arora discovered a PTAS for TSP when the distances come from a Euclidean space a couple of decades ago. This is very good news for Uber and the like, since their distances usually come from the plane! The idea is not hard to understand, and I plan to make the talk accessible to anyone who is comfortable with Dynamic Programming."}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://diego.codes/post/som-tsp",children:"https://diego.codes/post/som-tsp"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/DiegoVicen/som-tsp",children:"https://github.com/DiegoVicen/som-tsp"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>l});var n=o(296540);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);