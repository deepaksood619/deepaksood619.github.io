"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[97022],{742400:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"technologies/kafka/security/06-encryption","title":"Encryption","description":"Encryption uses mathematical techniques to scramble data so that it is unreadable by those who don\u2019t have the right key, and it also protects the data\u2019s integrity so that you can determine if it was tampered with during its journey.","source":"@site/docs/technologies/kafka/security/06-encryption.md","sourceDirName":"technologies/kafka/security","slug":"/technologies/kafka/security/06-encryption","permalink":"/technologies/kafka/security/06-encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/technologies/kafka/security/06-encryption.md","tags":[],"version":"current","lastUpdatedBy":"Deepak Sood","lastUpdatedAt":1769339984000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authorization","permalink":"/technologies/kafka/security/05-authorization"},"next":{"title":"Hands On: Setting Up Encryption","permalink":"/technologies/kafka/security/07-hands-on-setting-up-encryption"}}');var i=n(474848),s=n(28453);const o={},a="Encryption",c={},d=[{value:"Client/Cluster",id:"clientcluster",level:2},{value:"Client/Cluster \u2013 Inter-Broker \u2013 Broker/ZooKeeper",id:"clientcluster--inter-broker--brokerzookeeper",level:2},{value:"Client/Cluster \u2013 Inter-Broker \u2013 Broker/ZooKeeper \u2013 Data at Rest",id:"clientcluster--inter-broker--brokerzookeeper--data-at-rest",level:2},{value:"Other Data Leaks",id:"other-data-leaks",level:2},{value:"Encryption Strategies",id:"encryption-strategies",level:2},{value:"Encrypting Data in Transit with SSL",id:"encrypting-data-in-transit-with-ssl",level:3},{value:"Encrypting Data at Rest",id:"encrypting-data-at-rest",level:3},{value:"End-to-End Encryption",id:"end-to-end-encryption",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"encryption",children:"Encryption"})}),"\n",(0,i.jsx)(t.p,{children:"Encryption uses mathematical techniques to scramble data so that it is unreadable by those who don\u2019t have the right key, and it also protects the data\u2019s integrity so that you can determine if it was tampered with during its journey."}),"\n",(0,i.jsx)(t.h2,{id:"clientcluster",children:"Client/Cluster"}),"\n",(0,i.jsx)(t.p,{children:"The simplest encryption setup consists of encrypted traffic between clients and the cluster, which is important if clients access the cluster through an unsecured network such as the public internet:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://images.ctfassets.net/gt6dp23g0g38/6rPRkMApd6TiC6sik2WLdq/86ef2c77ca7dc20dee89d6e710f735df/client-cluster-encryption.jpg",alt:"client-cluster-encryption"})}),"\n",(0,i.jsx)(t.h2,{id:"clientcluster--inter-broker--brokerzookeeper",children:"Client/Cluster \u2013 Inter-Broker \u2013 Broker/ZooKeeper"}),"\n",(0,i.jsx)(t.p,{children:"The next thing to consider is encrypting traffic between brokers, and between brokers and ZooKeeper. Even private networks can be breached, so you want to be sure the traffic on your private network is resistant to eavesdroppers or anyone who wishes to tamper with it while it is in motion."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://images.ctfassets.net/gt6dp23g0g38/5Luln4g06rJrrAcg7mz8Vg/3154ce1a91c49cfce5600ffd29d51373/inter-broker-zookeeper.jpg",alt:"inter-broker-zookeeper"})}),"\n",(0,i.jsx)(t.h2,{id:"clientcluster--inter-broker--brokerzookeeper--data-at-rest",children:"Client/Cluster \u2013 Inter-Broker \u2013 Broker/ZooKeeper \u2013 Data at Rest"}),"\n",(0,i.jsx)(t.p,{children:"Another thing to consider is your data at rest, which will be extensive as Kafka makes data durable by writing to disk. So you need to think about encrypting your static data, to protect it from anyone who gains unauthorized access to your filesystem."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://images.ctfassets.net/gt6dp23g0g38/4DKr2o2rHRzoCpm9l1CGww/ef593b94bfb394ea126a2ee9093a3c7c/data-at-rest.jpg",alt:"data-at-rest"})}),"\n",(0,i.jsx)(t.h2,{id:"other-data-leaks",children:"Other Data Leaks"}),"\n",(0,i.jsx)(t.p,{children:"Finally, there are other ways users could gain unauthorized access to your data, including data residing in memory that could appear in a heap dump, as well as data in logs."}),"\n",(0,i.jsx)(t.h2,{id:"encryption-strategies",children:"Encryption Strategies"}),"\n",(0,i.jsx)(t.p,{children:"Next, we will cover the three encryption strategies, in turn, beginning with data in transit, the only type for which Kafka provides direct support."}),"\n",(0,i.jsx)(t.h3,{id:"encrypting-data-in-transit-with-ssl",children:"Encrypting Data in Transit with SSL"}),"\n",(0,i.jsx)(t.p,{children:"An out-of-the-box Kafka installation doesn\u2019t use encryption, but rather sends everything in the easily intercepted plaintext. Fortunately, as we discussed in the Authentication Basics module, it\u2019s relatively simple to implement SSL or SASL_SSL in order to TLS encrypt data in transit. For this, you'll need a self-signed certificate (primarily for internal environments) or one signed by a certificate authority (a must for production environments)."}),"\n",(0,i.jsxs)(t.p,{children:["In the Authentication with SSL and SASL_SSL module, we demonstrated how, in addition to brokers providing certificates to clients, you can also require that clients provide certificates to brokers. This is accomplished by enabling the SSL security protocol and setting\xa0",(0,i.jsx)(t.code,{children:"ssl.client.auth=required"}),"\xa0in the broker config, and it is sometimes referred to as mutual TLS or mTLS. Conversely, if all you want to do is encrypt and you don\u2019t want to check client certificates (which will reduce the scope of your certificate management duties), you can set set\xa0",(0,i.jsx)(t.code,{children:"ssl.client.auth=none"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["TLS uses private-key certificate pairs, and each broker needs its own. Each client does too\u2014if client authentication is enabled. Note that if you want to enable TLS for inter-broker communication, add\xa0",(0,i.jsx)(t.code,{children:"security.inter.broker.protocol=SSL"}),"\xa0to your broker properties file."]}),"\n",(0,i.jsx)(t.p,{children:"You should keep in mind, that enabling TLS can have a performance impact on your system, because of the CPU overhead needed to encrypt and decrypt data."}),"\n",(0,i.jsx)(t.h3,{id:"encrypting-data-at-rest",children:"Encrypting Data at Rest"}),"\n",(0,i.jsx)(t.p,{children:"Apache Kafka doesn't provide support for encrypting data at rest, so you'll have to use the whole disk or volume encryption that is part of your infrastructure. Public cloud providers generally provide this, for example, AWS EBS volumes can be encrypted with keys from AWS Key Management Service. For on-premises solutions, you might consider platforms like Vormetric or Gemalto (Thales)."}),"\n",(0,i.jsx)(t.h3,{id:"end-to-end-encryption",children:"End-to-End Encryption"}),"\n",(0,i.jsx)(t.p,{children:"By this point in the course, you\u2019ve likely set up some certificates, encrypted your data at rest, and set strict filesystem permissions. However, you may wish to go even further and encrypt your data from start to finish, so that it will show as encrypted even in places like heap dumps and logs. For this, you'll need end-to-end encryption, which in the context of Kafka, uses a key management system that encrypts/decrypts when serialization/deserialization happens. End-to-end encryption provides the greatest amount of security since brokers never see the unencrypted contents of messages:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://images.ctfassets.net/gt6dp23g0g38/3k9GOOQfEkf4wxqbkZOuCH/cc216e8d58666a4ea8dc671516591b3d/key-management-service.jpg",alt:"key-management-service"})}),"\n",(0,i.jsxs)(t.p,{children:["In addition to end-to-end encryption, you should add a ",(0,i.jsx)(t.strong,{children:"key rotation policy"}),", since clients will come and go and changes will be made to your system. This ensures that in any security breach the number of compromised messages will be limited to those from the time since your keys were rotated."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(296540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);