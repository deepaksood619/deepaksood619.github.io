"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[96237],{279840:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var n=s(785893),i=s(511151);const a={},o="Load Balancing Algorithms",l={id:"devops/devops-intro/load-balancing-algorithms",title:"Load Balancing Algorithms",description:"Round Robin",source:"@site/docs/devops/devops-intro/load-balancing-algorithms.md",sourceDirName:"devops/devops-intro",slug:"/devops/devops-intro/load-balancing-algorithms",permalink:"/devops/devops-intro/load-balancing-algorithms",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/devops/devops-intro/load-balancing-algorithms.md",tags:[],version:"current",lastUpdatedAt:1705642844,formattedLastUpdatedAt:"Jan 19, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Load Balancer",permalink:"/devops/devops-intro/load-balancer"},next:{title:"Others",permalink:"/devops/devops-intro/others"}},r={},h=[{value:"Round Robin",id:"round-robin",level:3},{value:"Weighted Round Robin",id:"weighted-round-robin",level:3},{value:"Least Connections",id:"least-connections",level:3},{value:"Weighted Least Request",id:"weighted-least-request",level:3},{value:"all weights equal",id:"all-weights-equal",level:4},{value:"all weights not equal",id:"all-weights-not-equal",level:4},{value:"IP Hash",id:"ip-hash",level:3},{value:"Least Response Time",id:"least-response-time",level:3},{value:"Least Bandwidth",id:"least-bandwidth",level:3},{value:"Others",id:"others",level:3}];function d(e){const t={a:"a",h1:"h1",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"load-balancing-algorithms",children:"Load Balancing Algorithms"}),"\n",(0,n.jsx)(t.h3,{id:"round-robin",children:"Round Robin"}),"\n",(0,n.jsx)(t.p,{children:"Requests are distributed across all the instances sequentially"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Sticky Round Robin"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"weighted-round-robin",children:"Weighted Round Robin"}),"\n",(0,n.jsx)(t.p,{children:"This algorithm assigns a weight to each instance in the pool, and new connections are forwarded in proportion to the assigned weight"}),"\n",(0,n.jsx)(t.h3,{id:"least-connections",children:"Least Connections"}),"\n",(0,n.jsx)(t.p,{children:"A request goes to the instance that is processing the least number of connections at the current time"}),"\n",(0,n.jsx)(t.h3,{id:"weighted-least-request",children:"Weighted Least Request"}),"\n",(0,n.jsx)(t.p,{children:"The least request load balancer uses different algorithms depending on whether hosts have the same or different weights."}),"\n",(0,n.jsx)(t.h4,{id:"all-weights-equal",children:"all weights equal"}),"\n",(0,n.jsxs)(t.p,{children:["An O(1) algorithm which selects N random available hosts as specified in the ",(0,n.jsx)(t.a,{href:"https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-msg-config-cluster-v3-cluster-leastrequestlbconfig",children:"configuration"}),"(2 by default) and picks the host which has the fewest active requests (",(0,n.jsx)(t.a,{href:"https://www.eecs.harvard.edu/~michaelm/postscripts/handbook2001.pdf",children:"Mitzenmacher et al."})," has shown that this approach is nearly as good as an O(N) full scan). This is also known as ",(0,n.jsx)(t.strong,{children:"P2C (power of two choices)"}),". The P2C load balancer has the property that a host with the highest number of active requests in the cluster will never receive new requests. It will be allowed to drain until it is less than or equal to all of the other hosts."]}),"\n",(0,n.jsx)(t.h4,{id:"all-weights-not-equal",children:"all weights not equal"}),"\n",(0,n.jsx)(t.p,{children:"If two or more hosts in the cluster have different load balancing weights, the load balancer shifts into a mode where it uses a weighted round robin schedule in which weights are dynamically adjusted based on the host's request load at the time of selection (weight is divided by the current active request count. For example, a host with weight 2 and an active request count of 4 will have a synthetic weight of 2 / 4 = 0.5). This algorithm provides good balance at steady state but may not adapt to load imbalance as quickly. Additionally, unlike P2C, a host will never truly drain, though it will receive fewer requests over time."}),"\n",(0,n.jsx)(t.h3,{id:"ip-hash",children:"IP Hash"}),"\n",(0,n.jsx)(t.p,{children:"This method generates a unique hash key from the source IP address and determines which instance receives the request (good for session management, where each client must be routed to same server)"}),"\n",(0,n.jsx)(t.p,{children:"Maintaining stateful connections"}),"\n",(0,n.jsx)(t.p,{children:"See at the source IP of the request and it builds a hash out of the source ip."}),"\n",(0,n.jsx)(t.p,{children:"This is called Source Algorithm - Memorize IP address of the user."}),"\n",(0,n.jsx)(t.p,{children:"But what if the server goes down, then all the hashes must be mapped to a new server. Here consistent hashing is used (for stable remapping)"}),"\n",(0,n.jsx)(t.h3,{id:"least-response-time",children:"Least Response Time"}),"\n",(0,n.jsx)(t.p,{children:"The least response time method directs traffic to the server with the least amount of active connections and lowest average response time."}),"\n",(0,n.jsx)(t.h3,{id:"least-bandwidth",children:"Least Bandwidth"}),"\n",(0,n.jsx)(t.p,{children:"This application load balancer method measures traffic in megabits (Mbps) per second, sending client requests to the server with the least Mbps of traffic"}),"\n",(0,n.jsx)(t.h3,{id:"others",children:"Others"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Grpc > Client-side > ",(0,n.jsx)(t.strong,{children:"Pick-First"})]}),"\n",(0,n.jsx)(t.li,{children:"Ring Hash"}),"\n",(0,n.jsx)(t.li,{children:"Maglev"}),"\n",(0,n.jsx)(t.li,{children:"Random"}),"\n",(0,n.jsx)(t.li,{children:"Original destination"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers",children:"https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:s(952178).Z+"",width:"1605",height:"1536"})})]})}function c(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},952178:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/load-balancing-algorithms-aa250c4f1a9c260dd1da589a436c948c.jpg"},511151:(e,t,s)=>{s.d(t,{Z:()=>l,a:()=>o});var n=s(667294);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);