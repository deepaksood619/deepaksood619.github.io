"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[92074],{124494:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>o});var n=a(785893),t=a(511151);const i={},l="Hash Tables",r={id:"data-structures/hashtable/hash-tables",title:"Hash Tables",description:"hash tables, a data structure that achieves constant-time performance for core symbol table operations, provided that search keys are standard data types or simply defined.",source:"@site/docs/data-structures/hashtable/hash-tables.md",sourceDirName:"data-structures/hashtable",slug:"/data-structures/hashtable/hash-tables",permalink:"/data-structures/hashtable/hash-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/data-structures/hashtable/hash-tables.md",tags:[],version:"current",lastUpdatedAt:1732812944,formattedLastUpdatedAt:"Nov 28, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hash Functions",permalink:"/data-structures/hashtable/hash-functions"},next:{title:"Hashing Techniques",permalink:"/data-structures/hashtable/hashing-techniques"}},h={},o=[{value:"Issues",id:"issues",level:2},{value:"Classic space-time tradeoff",id:"classic-space-time-tradeoff",level:2},{value:"Computing the hash function",id:"computing-the-hash-function",level:2},{value:"Modular Hashing",id:"modular-hashing",level:2},{value:"Uniform hashing assumption",id:"uniform-hashing-assumption",level:2},{value:"Collisions - Two distinct keys hashing to same index",id:"collisions---two-distinct-keys-hashing-to-same-index",level:2},{value:"Collision Resolution methods",id:"collision-resolution-methods",level:2},{value:"1. Separate Chaining symbol table",id:"1-separate-chaining-symbol-table",level:3},{value:"2. Linear Probing (Open addressing)",id:"2-linear-probing-open-addressing",level:3},{value:"Problems",id:"problems",level:2},{value:"Optimization",id:"optimization",level:2},{value:"Hash Table Context",id:"hash-table-context",level:2},{value:"Implementation",id:"implementation",level:2}];function d(e){const s={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"hash-tables",children:"Hash Tables"}),"\n",(0,n.jsx)(s.p,{children:"hash tables, a data structure that achieves constant-time performance for core symbol table operations, provided that search keys are standard data types or simply defined."}),"\n",(0,n.jsx)(s.p,{children:"Hash tables utilize hashing to form a data structure."}),"\n",(0,n.jsx)(s.p,{children:"Hash tables use an associative method to store data by using what is known as a key-value lookup system. All that means is that, in a hash table, keys are mapped to unique values."}),"\n",(0,n.jsx)(s.p,{children:"This system of organizing data results in a very fast way to find data efficiently. This is because since each key is mapped to a unique value -- once we know a key then we can find the associated value instantly."}),"\n",(0,n.jsx)(s.p,{children:"Hash tables are extremely fast, having a time complexity that is in the order of O(1).\nA function that takes a key and reduces it to an integer (array index) to be mapped to an array."}),"\n",(0,n.jsx)(s.h2,{id:"issues",children:"Issues"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Computing the hash function"}),"\n",(0,n.jsx)(s.li,{children:"Equality test"}),"\n",(0,n.jsx)(s.li,{children:"Collision resolution: Algorithm and data structure to handle two keys that hash to the same array index"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"classic-space-time-tradeoff",children:"Classic space-time tradeoff"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"No space limitation: trivial has function with key as index"}),"\n",(0,n.jsx)(s.li,{children:"No time limitation: trivial collision resolution with sequential search"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"computing-the-hash-function",children:"Computing the hash function"}),"\n",(0,n.jsx)(s.p,{children:"Scramble the keys uniformly to produce a table index"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Efficiently computable"}),"\n",(0,n.jsx)(s.li,{children:"Each table index equally likely for each key"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"NOTE: Always try to use all the data for calculating hash (try to involve all the bits for computing the hash function)"})}),"\n",(0,n.jsx)(s.h2,{id:"modular-hashing",children:"Modular Hashing"}),"\n",(0,n.jsx)(s.p,{children:"Hash code - An int between -2^31 and 2^31 - 1"}),"\n",(0,n.jsx)(s.p,{children:"Hash function - An int between 0 to M-1 (for use as array index)"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"First convert from negative to positive and then use modulus to get it to the size."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(731857).Z+"",width:"950",height:"176"})}),"\n",(0,n.jsx)(s.h2,{id:"uniform-hashing-assumption",children:"Uniform hashing assumption"}),"\n",(0,n.jsx)(s.p,{children:"Each key is equally likely to hash to an integer between 0 to M - 1."}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"Bins and balls Model: Throw balls uniformly at random into M bins"}),"\n",(0,n.jsx)(s.li,{children:"Birthday problem: Expect two balls in the same bin after ~ sqrt(pie M / 2) tosses."}),"\n",(0,n.jsx)(s.li,{children:"Coupon collector problem: Expect every bin has >= 1 ball after ~ M ln M tosses."}),"\n",(0,n.jsx)(s.li,{children:"Load balancing: After M tosses, expect most loaded bin has theta(log M / log log M) balls."}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"collisions---two-distinct-keys-hashing-to-same-index",children:"Collisions - Two distinct keys hashing to same index"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Birthday problem: can't avoid collisions unless you have a ridiculous (quadratic) amount of memory."}),"\n",(0,n.jsx)(s.li,{children:"Coupon collector + load balancing: collisions are evenly distributed"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"collision-resolution-methods",children:"Collision Resolution methods"}),"\n",(0,n.jsx)(s.h3,{id:"1-separate-chaining-symbol-table",children:"1. Separate Chaining symbol table"}),"\n",(0,n.jsx)(s.p,{children:"Use linked list for storing the values that hash to the same value."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(645260).Z+"",width:"832",height:"774"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Easier to implement delete"}),"\n",(0,n.jsx)(s.li,{children:"Performance degrades gracefully"}),"\n",(0,n.jsx)(s.li,{children:"Clustering less sensitive to poorly-designed hash function"}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"2-linear-probing-open-addressing",children:"2. Linear Probing (Open addressing)"}),"\n",(0,n.jsx)(s.p,{children:"When a new key collides, find next empty slot, and put it there"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(489016).Z+"",width:"1054",height:"638"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Less wasted space"}),"\n",(0,n.jsx)(s.li,{children:"Better cache performance"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(911725).Z+"",width:"1020",height:"642"})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"image",src:a(988637).Z+"",width:"1036",height:"812"})}),"\n",(0,n.jsx)(s.h2,{id:"problems",children:"Problems"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Clustering"}),"\n",(0,n.jsx)(s.li,{children:"Hash functions are often publically available (like java) so if some client has implemented back-end in java, then an adversary can send some data that can make the Hashing perform poorly and can make the system crash"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"optimization",children:"Optimization"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"Create a bigger hash table when older hash table gets full and rehash all old values to new hash table"}),"\n",(0,n.jsx)(s.li,{children:"Can use Consistent Hashing Functions"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"hash-table-context",children:"Hash Table Context"}),"\n",(0,n.jsx)(s.p,{children:'One-way hash function - "Hard" to find a key that will hash to a desired value (or two keys that hash to same value)'}),"\n",(0,n.jsx)(s.p,{children:"Ex - MD4, MD5, SHA-0, SHA-1, SHA-2, WHIRLPOOL, RIPEMD-160"}),"\n",(0,n.jsx)(s.p,{children:"Applications - Digital fingerprint, message digest, storing passwords.\nHash tables vs. balanced search trees"}),"\n",(0,n.jsx)(s.p,{children:"Hash tables"}),"\n",(0,n.jsxs)(s.p,{children:["\u30fbSimpler to code.\n\u30fbNo effective alternative for unordered keys.\n\u30fbFaster for simple keys (a few arithmetic ops versus log ",(0,n.jsx)(s.em,{children:"N"})," compares).\n\u30fbBetter system support in Java for strings (e.g., cached hash code)."]}),"\n",(0,n.jsx)(s.p,{children:"Balanced search trees"}),"\n",(0,n.jsx)(s.p,{children:"\u30fbStronger performance guarantee.\n\u30fbSupport for ordered ST operations.\n\u30fbEasier to implement compareTo() correctly than equals() and hashCode()."}),"\n",(0,n.jsx)(s.p,{children:"Java system includes both"}),"\n",(0,n.jsx)(s.p,{children:"\u30fbRed-black BSTs: java.util.TreeMap, java.util.TreeSet.\n\u30fbHash tables: java.util.HashMap, java.util.IdentityHashMap."}),"\n",(0,n.jsx)(s.h2,{id:"implementation",children:"Implementation"}),"\n",(0,n.jsx)(s.p,{children:"All java classes inherit a method hashCode(), which returns a 32 bit int"}),"\n",(0,n.jsx)(s.p,{children:"Integer - return value"}),"\n",(0,n.jsx)(s.p,{children:"Double - convert 64 bit to 32 bit by XOR(^) MSB 32 bot LSB 32"}),"\n",(0,n.jsx)(s.p,{children:"Boolean - return fixed numbers"}),"\n",(0,n.jsx)(s.p,{children:"Strings - Use Horner's method to hash string and cache the hash value in an instance variable for better performance, since strings are immutable"}),"\n",(0,n.jsx)(s.p,{children:"User-defined types - Include all method variables in the hash code evaluation. Use hashCode implementation for each data type with some small prime number and multiply by 31"}),"\n",(0,n.jsxs)(s.p,{children:["\u30fbCombine each significant field using the 31",(0,n.jsx)(s.em,{children:"x"})," + ",(0,n.jsx)(s.em,{children:"y"})," rule.\n\u30fbIf field is a primitive type, use wrapper type hashCode().\n\u30fbIf field is null, return 0.\n\u30fbIf field is a reference type, use hashCode().\n\u30fbIf field is an array, apply to each entry. or use Arrays.deepHashCode()"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"http://blog.chapagain.com.np/hash-table-implementation-in-python-data-structures-algorithms",children:"http://blog.chapagain.com.np/hash-table-implementation-in-python-data-structures-algorithms"})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://www.youtube.com/watch?v=kuxBOGB_FlM",children:"Faster than Rust and C++ : the PERFECT Hash Table - YouTube"})})]})}function c(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},731857:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image1-544e3ac2328790d0ca1200275d58a5b9.jpg"},645260:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image2-a50ded56993991503458c634a371b7a7.jpg"},489016:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image3-04f78e7b11af27d954aa68e6b7ebf1c9.jpg"},911725:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image4-0df0a747062b3b81233ac4ce4e7b4fe2.jpg"},988637:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/Hash-Tables-image5-a5a3f499bb6e4ca2d93fc6741d31e236.jpg"},511151:(e,s,a)=>{a.d(s,{Z:()=>r,a:()=>l});var n=a(667294);const t={},i=n.createContext(t);function l(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);