"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[50937],{558724:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"algorithms/data-compression/others","title":"Others","description":"image","source":"@site/docs/algorithms/data-compression/others.md","sourceDirName":"algorithms/data-compression","slug":"/algorithms/data-compression/others","permalink":"/algorithms/data-compression/others","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/data-compression/others.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1716554631000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LZW Compression","permalink":"/algorithms/data-compression/lzw-compression"},"next":{"title":"Run Length Encoding","permalink":"/algorithms/data-compression/run-length-encoding"}}');var a=o(474848),n=o(28453);const t={},r="Others",c={},d=[{value:"Zstd (by facebook)",id:"zstd-by-facebook",level:2},{value:"WebP (for images)",id:"webp-for-images",level:2},{value:"cwebp (for image compression)",id:"cwebp-for-image-compression",level:2},{value:"Brotli",id:"brotli",level:2},{value:"Snappy Compression",id:"snappy-compression",level:2},{value:"Performance",id:"performance",level:3},{value:"Working",id:"working",level:3},{value:"Phase 1: Dictionary Creation",id:"phase-1-dictionary-creation",level:4},{value:"Phase 2: Blocks",id:"phase-2-blocks",level:4},{value:"Phase 3: Huffman coding",id:"phase-3-huffman-coding",level:4},{value:"Phase 4: Compressed output",id:"phase-4-compressed-output",level:4},{value:"Phase 5: Decompression",id:"phase-5-decompression",level:4},{value:"Roaring Bitmaps",id:"roaring-bitmaps",level:2},{value:"Message Pack",id:"message-pack",level:2},{value:"Digital Video",id:"digital-video",level:2}];function p(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"others",children:"Others"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"image",src:o(836887).A+"",width:"1466",height:"707"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{src:"https://raw.githubusercontent.com/facebook/zstd/master/doc/images/DCspeed5.png",alt:"Compression Speed vs Ratio"})}),"\n",(0,a.jsx)(s.h2,{id:"zstd-by-facebook",children:"Zstd (by facebook)"}),"\n",(0,a.jsxs)(s.p,{children:["Zstandard, or zstd as short version, is a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression ratios. It's backed by a very fast entropy stage, provided by ",(0,a.jsx)(s.a,{href:"https://github.com/Cyan4973/FiniteStateEntropy",children:"Huff0 and FSE library"}),"."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://github.com/facebook/zstd",children:"https://github.com/facebook/zstd"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://facebook.github.io/zstd",children:"https://facebook.github.io/zstd"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"tar --use-compress-program=unzstd -xvf archive.tar.zst\ntar --zstd -xvf archive.tar.zst\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://engineering.fb.com/2016/08/31/core-infra/smaller-and-faster-data-compression-with-zstandard/",children:"Smaller and faster data compression with Zstandard - Engineering at Meta"})}),"\n",(0,a.jsx)(s.h2,{id:"webp-for-images",children:"WebP (for images)"}),"\n",(0,a.jsx)(s.p,{children:"See > Image Formats"}),"\n",(0,a.jsx)(s.h2,{id:"cwebp-for-image-compression",children:"cwebp (for image compression)"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.code,{children:'for file in *.jpg; do cwebp -q 50 "$file" -o "${file%.jpg}.webp"; done'})}),"\n",(0,a.jsx)(s.h2,{id:"brotli",children:"Brotli"}),"\n",(0,a.jsx)(s.p,{children:"Brotli is a generic-purpose lossless compression algorithm that compresses data using a combination of a modern variant of the LZ77 algorithm, Huffman coding and 2nd order context modeling, with a compression ratio comparable to the best currently available general-purpose compression methods. It is similar in speed with deflate but offers more dense compression."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://github.com/google/brotli",children:"https://github.com/google/brotli"})}),"\n",(0,a.jsx)(s.h2,{id:"snappy-compression",children:"Snappy Compression"}),"\n",(0,a.jsx)(s.p,{children:"Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression. For instance, compared to the fastest mode of zlib, Snappy is an order of magnitude faster for most inputs, but the resulting compressed files are anywhere from 20% to 100% bigger."}),"\n",(0,a.jsx)(s.p,{children:"Snappy has the following properties:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:'Fast: Compression speeds at 250 MB/sec and beyond, with no assembler code. See "Performance" below.'}),"\n",(0,a.jsx)(s.li,{children:"Stable: Over the last few years, Snappy has compressed and decompressed petabytes of data in Google's production environment. The Snappy bitstream format is stable and will not change between versions."}),"\n",(0,a.jsx)(s.li,{children:"Robust: The Snappy decompressor is designed not to crash in the face of corrupted or malicious input."}),"\n",(0,a.jsx)(s.li,{children:"Free and open source software: Snappy is licensed under a BSD-type license. For more information, see the included COPYING file."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"performance",children:"Performance"}),"\n",(0,a.jsx)(s.p,{children:"Snappy is intended to be fast. On a single core of a Core i7 processor in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more. (These numbers are for the slowest inputs in our benchmark suite; others are much faster.) In our tests, Snappy usually is faster than algorithms in the same class (e.g. LZO, LZF, QuickLZ, etc.) while achieving comparable compression ratios."}),"\n",(0,a.jsx)(s.p,{children:"Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data. Similar numbers for zlib in its fastest mode are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are capable of achieving yet higher compression rates, although usually at the expense of speed. Of course, compression ratio will vary significantly with the input."}),"\n",(0,a.jsx)(s.p,{children:"Although Snappy should be fairly portable, it is primarily optimized for 64-bit x86-compatible processors, and may run slower in other environments. In particular:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Snappy uses 64-bit operations in several places to process more data at once than would otherwise be possible."}),"\n",(0,a.jsx)(s.li,{children:"Snappy assumes unaligned 32 and 64-bit loads and stores are cheap. On some platforms, these must be emulated with single-byte loads and stores, which is much slower."}),"\n",(0,a.jsx)(s.li,{children:"Snappy assumes little-endian throughout, and needs to byte-swap data in several places if running on a big-endian platform."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://github.com/andrix/python-snappy",children:"https://github.com/andrix/python-snappy"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'python -m snappy -c uncompressed_file compressed_file.snappy\n\nr = snappy.compress("hola mundo cruel!")\nsnappy.uncompress(r)\n'})}),"\n",(0,a.jsx)(s.h3,{id:"working",children:"Working"}),"\n",(0,a.jsx)(s.h4,{id:"phase-1-dictionary-creation",children:"Phase 1: Dictionary Creation"}),"\n",(0,a.jsx)(s.p,{children:"Before compressing the data, Snappy creates a dictionary based on a sample of the input data. This dictionary consists of sequences of bytes that occur frequently in the input data. The dictionary is used to replace these sequences with shorter codes during compression, which improves the compression ratio."}),"\n",(0,a.jsx)(s.h4,{id:"phase-2-blocks",children:"Phase 2: Blocks"}),"\n",(0,a.jsx)(s.p,{children:"Snappy divides the input data into blocks of up to 64 KB in size. Each block is compressed separately, which makes it possible to decompress individual parts of the data without having to decompress the entire file."}),"\n",(0,a.jsx)(s.h4,{id:"phase-3-huffman-coding",children:"Phase 3: Huffman coding"}),"\n",(0,a.jsx)(s.p,{children:"Snappy uses Huffman coding to compress the data within each block. Huffman coding assigns shorter codes to more frequently occuring symbols. Snappy uses a pre-defined set of Huffman codes that is optimized for the type of data being compressed"}),"\n",(0,a.jsx)(s.h4,{id:"phase-4-compressed-output",children:"Phase 4: Compressed output"}),"\n",(0,a.jsx)(s.p,{children:"The compressed data is output in a block-based format that includes information about the size of each block, the length of the uncompressed data, and the contents of the dictionary"}),"\n",(0,a.jsx)(s.h4,{id:"phase-5-decompression",children:"Phase 5: Decompression"}),"\n",(0,a.jsx)(s.p,{children:"Snappy reverses the compression process. It reads the block headers, decompresses each block using the Huffman codes and dictionary, and concatenates the decompressed blocks to produce the original data."}),"\n",(0,a.jsx)(s.h2,{id:"roaring-bitmaps",children:"Roaring Bitmaps"}),"\n",(0,a.jsx)(s.p,{children:"Roaring bitmaps are compressed bitmaps. They can be hundreds of times faster."}),"\n",(0,a.jsx)(s.p,{children:"Bitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory. To compensate, we often use compressed bitmaps."}),"\n",(0,a.jsx)(s.p,{children:"Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. In some instances, roaring bitmaps can be hundreds of times faster and they often offer significantly better compression. They can even be faster than uncompressed bitmaps."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://roaringbitmap.org",children:"https://roaringbitmap.org"})}),"\n",(0,a.jsx)(s.h2,{id:"message-pack",children:"Message Pack"}),"\n",(0,a.jsx)(s.p,{children:"MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://msgpack.org/index.html",children:"https://msgpack.org/index.html"})}),"\n",(0,a.jsx)(s.h2,{id:"digital-video",children:"Digital Video"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://github.com/leandromoreira/digital_video_introduction",children:"https://github.com/leandromoreira/digital_video_introduction"})})]})}function l(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},836887:(e,s,o)=>{o.d(s,{A:()=>i});const i=o.p+"assets/images/data-compression-Others-image1-7f868a11a1ca560c2fc40cd8c418ee91.jpg"},28453:(e,s,o)=>{o.d(s,{R:()=>t,x:()=>r});var i=o(296540);const a={},n=i.createContext(a);function t(e){const s=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(n.Provider,{value:s},e.children)}}}]);