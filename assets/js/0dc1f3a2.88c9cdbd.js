"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[75847],{211183:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"algorithms/graphtheory/problems","title":"Problems","description":"Knight\'s Tour Problem","source":"@site/docs/algorithms/graphtheory/problems.md","sourceDirName":"algorithms/graphtheory","slug":"/algorithms/graphtheory/problems","permalink":"/algorithms/graphtheory/problems","draft":false,"unlisted":false,"editUrl":"https://github.com/deepaksood619/deepaksood619.github.io/tree/master/docs/algorithms/graphtheory/problems.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Prim\'s Algorithm for MST","permalink":"/algorithms/graphtheory/prim-algorithm-for-mst"},"next":{"title":"Resources","permalink":"/algorithms/graphtheory/resources"}}');var s=t(474848),n=t(28453);const i={},a="Problems",l={},h=[{value:"Knight&#39;s Tour Problem",id:"knights-tour-problem",level:2},{value:"Inorder Successor of BST",id:"inorder-successor-of-bst",level:2},{value:"Word Ladder Problem",id:"word-ladder-problem",level:2}];function c(e){const r={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"problems",children:"Problems"})}),"\n",(0,s.jsx)(r.h2,{id:"knights-tour-problem",children:"Knight's Tour Problem"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.em,{children:"The knight is placed on the first block of an empty board and, moving according to the rules of chess, must visit each square exactly once."})}),"\n",(0,s.jsx)(r.p,{children:"This is an example of Hamiltonian Path Problem. If the path's starting point and ending point must be the same, then this problem is Hamiltonian cycle problem."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"The knight's tour puzzle is played on a chess board with a single chess piece, the knight."}),"\n",(0,s.jsx)(r.li,{children:"The object of the puzzle is to find a sequence of moves that allow the knight to visit every square on the board exactly once."}),"\n",(0,s.jsx)(r.li,{children:"Can be solved in linear time"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"inorder-successor-of-bst",children:"Inorder Successor of BST"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.a,{href:"https://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree",children:"https://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree"})}),"\n",(0,s.jsx)(r.h2,{id:"word-ladder-problem",children:"Word Ladder Problem"}),"\n",(0,s.jsx)(r.p,{children:"Problem - Given two words transform one word to another by changing only one letter at a time from the given list of words"}),"\n",(0,s.jsx)(r.p,{children:"Solution - Have a bucket for each class of words, in each bucket every word is connected to each other"}),"\n",(0,s.jsx)(r.p,{children:"Ex - POP_ which will match both POPE and POPS"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.a,{href:"https://www.freecodecamp.org/news/8-essential-graph-algorithms-in-javascript",children:"https://www.freecodecamp.org/news/8-essential-graph-algorithms-in-javascript"})})]})}function d(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>a});var o=t(296540);const s={},n=o.createContext(s);function i(e){const r=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(n.Provider,{value:r},e.children)}}}]);